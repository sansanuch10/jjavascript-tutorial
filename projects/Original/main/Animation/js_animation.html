<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="160">AJAX и COMET</a></nav-up><h1>JS-Анимация</h1><p>JavaScript-анимация применяется там, где не подходит CSS.</p><p>Например, по сложной траектории, с временной функцией, выходящей за рамки кривых Безье, на canvas. Иногда её используют для анимации в старых IE.</p><h2><a name="0" href="#0">setInterval</a></h2><p>С точки зрения HTML/CSS, анимация – это постепенное изменение стиля DOM-элемента. Например, увеличение координаты <code>style.left</code> от <code>0px</code> до <code>100px</code> сдвигает элемент.</p><p>Если увеличивать <code>left</code> от <code>0</code> до <code>100</code> при помощи <code>setInterval</code>, делая по 50 изменений в секунду, то это будет выглядеть как плавное перемещение. Тот же принцип, что и в кино: для непрерывной анимации достаточно 24 или больше вызовов <code>setInterval</code> в секунду.</p><p>Псевдо-код для анимации выглядит так:</p><code-example><script>`var fps = 50; // 50 кадров в секунду\nvar timer = setInterval(function() {\n  if (время вышло) clearInterval(timer);\n  else немного увеличить left\n}, 1000 / fps)`</script></code-example><p>Более полный пример кода анимации:</p><code-example><script>`var start = Date.now(); // сохранить время начала\n\nvar timer = setInterval(function() {\n  // вычислить сколько времени прошло с начала анимации\n  var timePassed = Date.now() - start;\n\n  if (timePassed >= 2000) {\n    clearInterval(timer); // конец через 2 секунды\n    return;\n  }\n\n  // рисует состояние анимации, соответствующее времени timePassed\n  draw(timePassed);\n\n}, 20);\n\n// в то время как timePassed идёт от 0 до 2000\n// left принимает значения от 0 до 400px\nfunction draw(timePassed) {\n  train.style.left = timePassed / 5 + 'px';\n}`</script></code-example><p>Кликните для демонстрации:</p><code-example style="display: block;"><script>`<!DOCTYPE HTML>\n<html>\n\n<head>\n  <style>\n    GOLD_#train_GOLD {\n      position: relative;\n      cursor: pointer;\n    }\n  </style>\n</head>\n\n<body>\n\n  <img id="train" src="train.gif">\n\n  <script>\n    train.onclick = function() {\n      var start = Date.now(); // сохранить время начала\n\n      var timer = setInterval(function() {\n        // вычислить сколько времени прошло из opts.duration\n        var timePassed = Date.now() - start;\n\n        train.style.left = timePassed / 5 + 'px';\n\n        if (timePassed > 2000) clearInterval(timer);\n\n      }, 20);\n    }\n  <\/script>\n\n</body>\n\n</html>`</script><code-toolbar- iframe="200"><a title="показать" data-code_run="0"></a><a title="открыть в новом окне" data-new_window="code"></a><a title="открыть в песочнице" data-code_edit_run=""></a></code-toolbar-></code-example><h2><a name="1" href="#1">requestAnimationFrame</a></h2><p>Если у нас не один такой <code>setInterval</code>, а несколько в разных местах кода, то браузеру нужно в те же 20 мс работать со страницей уже несколько раз. А ведь кроме <code>setInterval</code> есть ещё другие действия, к примеру, прокрутка страницы, которую тоже надо нарисовать.</p><p>Если все действия по перерисовке производить независимо, то будет выполняться много двойной работы.</p><p>Гораздо выгоднее с точки зрения производительности – сгруппировать все перерисовки в одну и запускать их централизованно, все вместе.</p><p>Для этого в JavaScript-фреймворках, которые поддерживают анимацию, есть единый таймер:</p><code-example><script>`setInterval(function() {\n  /* отрисовать все анимации */\n}, 20);`</script></code-example><p>…Все анимации, которые запускает такой фреймворк, добавляются в общий список, и раз в 20 мс единый таймер проверяет его, запускает текущие, удаляет завершившиеся.</p><p>Современные браузеры, кроме IE9-, поддерживают стандарт <a href="http://www.w3.org/TR/animation-timing/">Animation timing</a>, который представляет собой дальнейший шаг в этом направлении. Он позволяет синхронизировать наши анимации со встроенными механизмами обновления страницы. То есть, сгруппированы будут не только наши, но и CSS-анимации и другие браузерные перерисовки.</p><p>При этом графический ускоритель будет использован максимально эффективно, и исключена повторная обработка одних и тех же участков страницы. А значит – меньше будет загрузка CPU, да и сама анимация станет более плавной.</p><p>Для этого используется функция <a href="http://www.w3.org/TR/animation-timing/#dom-windowanimationtiming-requestanimationframe">requestAnimationFrame</a>.</p><p>Синтаксис:</p><code-example><script>`var requestId = requestAnimationFrame(callback)`</script></code-example><p>Такой вызов планирует запуск <code>callback</code> в ближайшее время, когда браузер сочтёт возможным осуществить анимацию.</p><p>Если запланировать в <code>callback</code> какое-то рисование, то оно будет сгруппировано с другими <code>requestAnimationFrame</code> и с внутренними перерисовками браузера.</p><p>Возвращаемое значение <code>requestId</code> служит для отмены запуска:</p><code-example><script>`// отменить запланированное выше выполнение callback\ncancelAnimationFrame(requestId);`</script></code-example><p>Функция <code>callback</code> получает один аргумент – время, прошедшее с начала загрузки страницы, результат вызова <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now">performance.now()</a>.</p><p>Как правило, запуск <code>callback</code> происходит очень скоро. Если у процессора большая загрузка или батарея у ноутбука почти разряжена – то пореже.</p><p>Если вы запустите этот код, то увидите промежутки между первыми 20 запусками <code>requestAnimationFrame</code>. Как правило, это 10-20 мс, но бывает и больше и меньше. Это оптимальная частота анимации с точки зрения браузера.</p><code-example><script>`<script>\n  var prev = performance.now();\n  var times = 0;\n\n  requestAnimationFrame(function measure(time) {\n    document.body.insertAdjacentHTML("beforeEnd", Math.floor(time - prev) + " ");\n    prev = time;\n\n    if (times++ < 10) requestAnimationFrame(measure);\n  })\n<\/script>`</script><code-toolbar iframe="40"></code-toolbar></code-example><p>Функция анимации на основе <code>requestAnimationFrame</code>:</p><code-example><script>`// Рисует функция draw\n// Продолжительность анимации duration\nfunction animate(draw, duration) {\n  var start = performance.now();\n\n  requestAnimationFrame(function animate(time) {\n    // определить, сколько прошло времени с начала анимации\n    var timePassed = time - start;\n\n    // возможно небольшое превышение времени, в этом случае зафиксировать конец\n    if (timePassed > duration) timePassed = duration;\n\n    // нарисовать состояние анимации в момент timePassed\n    draw(timePassed);\n\n    // если время анимации не закончилось - запланировать ещё кадр\n    if (timePassed < duration) {\n      requestAnimationFrame(animate);\n    }\n\n  });\n}`</script></code-example><p>Использование для поезда:</p><code-example><script>`animate(function(timePassed) {\n  train.style.left = timePassed / 5 + 'px';\n}, 2000);`</script></code-example><p>В действии:</p><code-example style="display: block;"><script>`<!DOCTYPE HTML>\n<html>\n\n<head>\n  <style>\n    GOLD_#train_GOLD {\n      position: relative;\n      cursor: pointer;\n    }\n  </style>\n</head>\n\n<body>\n\n  <img id="train" src="train.gif">\n\n  <script>\n    train.onclick = function() {\n      animate(function(timePassed) {\n        train.style.left = timePassed / 5 + 'px';\n      }, 2000);\n    };\n\n    // Рисует функция draw\n    // Продолжительность анимации duration\n    function animate(draw, duration) {\n      var start = performance.now();\n\n      requestAnimationFrame(function animate(time) {\n        // определить, сколько прошло времени с начала анимации\n        var timePassed = time - start;\n\n        console.log(time, start)\n          // возможно небольшое превышение времени, в этом случае зафиксировать конец\n        if (timePassed > duration) timePassed = duration;\n\n        // нарисовать состояние анимации в момент timePassed\n        draw(timePassed);\n\n        // если время анимации не закончилось - запланировать ещё кадр\n        if (timePassed < duration) {\n          requestAnimationFrame(animate);\n        }\n      });\n    }\n  <\/script>\n\n</body>\n\n</html>`</script><code-toolbar- iframe="200"><a title="показать" data-code_run="0"></a><a title="открыть в новом окне" data-new_window="code"></a><a title="открыть в песочнице" data-code_edit_run=""></a></code-toolbar-></code-example><h2><a name="2" href="#2">Структура анимации</a></h2><p>На основе <code>requestAnimationFrame</code> можно соорудить и гораздо более мощную, но в то же время простую функцию анимации.</p><p>У анимации есть три основных параметра:</p><dl><dt><code>duration</code></dt><dd><p>Общее время, которое должна длиться анимация, в мс. Например, <code>1000</code>.</p></dd><dt><code>timing(timeFraction)</code></dt><dd><p>Временная функция, которая, по аналогии с CSS-свойством <code>transition-timing-function</code>, будет по текущему времени вычислять состояние анимации.</p><p>Она получает на вход непрерывно возрастающее число <code>timeFraction</code> – от <code>0</code> до <code>1</code>, где <code>0</code> означает самое начало анимации, а <code>1</code> – её конец.</p><p>Её результатом должно быть значение завершённости анимации, которому в CSS transitions на кривых Безье соответствует координата <code>y</code>.</p><p>Также по аналогии с <code>transition-timing-function</code> должны соблюдаться условия:</p></dd></dl><ul><li><p>timing(0) = 0</p></li><li><p>timing(1) = 1</p><p>…То есть, анимация начинается в точке <code>(0,0)</code> – нулевое время и нулевой прогресс и заканчивается в <code>(1, 1)</code> – прошло полное время, и процесс завершён.</p><p>Например, функция-прямая означает равномерное развитие процесса:</p><code-example><script>`function linear(timeFraction) {  return timeFraction;}`</script></code-example><p>Её график:<img src="/article/js-animation/linear.png" alt="" width="234" height="240"></p><p>Как видно, её график полностью совпадает с <code>transition-timing-function: linear</code>, и эффект абсолютно такой же.</p><p>Есть и другие, более интересные варианты, мы рассмотрим их чуть позже.</p></li></ul><dl><dt><code>draw(progress)</code></dt><dd><p>Функция, которая получает состояние завершённости анимации и рисует его. Значению <code>progress=0</code> соответствует начальная точка анимации, <code>progress=1</code> – конечная.</p><p>Именно эта функция и осуществляет, собственно, анимацию.</p><p>Например, может двигать элемент:</p><code-example><script>`function draw(progress) {\n  train.style.left = progress + 'px';\n}`</script></code-example><p>Возможны любые варианты, анимировать можно что угодно и как угодно.</p></dd></dl><p>Анимируем ширину элемента <code>width</code> от <code>0</code> до <code>100%</code>, используя нашу функцию.</p><p>Кликните для демонстрации:</p><code-example style="display: block;"><script>`<!DOCTYPE HTML>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <style>\n    GOLD_progress_GOLD {\n      width: 5%;\n    }\n  </style>\n  <script>\n    function animate(options) {\n\n      var start = performance.now();\n\n      requestAnimationFrame(function animate(time) {\n        // timeFraction от 0 до 1\n        var timeFraction = (time - start) / options.duration;\n        if (timeFraction > 1) timeFraction = 1;\n\n        // текущее состояние анимации\n        var progress = options.timing(timeFraction)\n\n        options.draw(progress);\n\n        if (timeFraction < 1) {\n          requestAnimationFrame(animate);\n        }\n      });\n    }\n  <\/script>\n</head>\n\n<body>\n\n  <pRED_rogress_RED id="elem"></pRED_rogress_RED>\n\n  <script>\n    elem.onclick = function() {\n      animate({\n        duration: 1000,\n        timing: function(timeFraction) {\n          return timeFraction;\n        },\n        draw: function(progress) {\n          elem.style.width = progress * 100 + '%';\n        }\n      });\n    };\n  <\/script>\n\n</body>\n\n</html>`</script><code-toolbar- iframe="60"><a title="показать" data-code_run="250"></a><a title="открыть в новом окне" data-new_window="code"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><p>Код для запуска анимации:</p><code-example><script>`animate({\n  duration: 1000,\n  timing: function(timeFraction) {\n    return timeFraction;\n  },\n  draw: function(progress) {\n    elem.style.width = progress * 100 + '%';\n  }\n});`</script></code-example><h2><a name="3" href="#3">Временные функции</a></h2><p>Выше мы видели самую простую, линейную временную функцию.</p><p>Рассмотрим примеры анимации движения с использованием различных <code>timing</code>.</p><h3><a name="10" href="#10">В степени n</a></h3><p>Вот еще один простой случай – <code>progress</code> в степени <code>n</code>. Частные случаи – квадратичная, кубическая функции и т.д.</p><p>Для квадратичной функции:</p><code-example><script>`function quad(progress) {\n  return Math.pow(progress, 2)\n}`</script></code-example><p><strong>График квадратичной функции:</strong></p><figure><img src="quad.png" alt="" width="100%" style="max-width:233px"></figure><p>Пример для квадратичной функции (клик для просмотра):</p><figure- style="overflow: auto;"><code-toolbar-><a title="reset" onclick="this.parentElement.nextElementSibling.src='left.html'"></a><a data-new_window="" title="открыть в новом окне"></a><a-></a-></code-toolbar-><iframe style="height:70px" src="left.html"></iframe></figure-><p>Увеличение степени влияет на ускорение. Например, график для 5-й степени:</p><figure><img src="quint.png" alt="" width="100%" style="max-width:233px"></figure><p>В действии:</p><code-result><code-toolbar-><a title="reset" onclick="this.parentElement.nextElementSibling.src='left_1.html'"></a><a data-new_window="" title="открыть в новом окне"></a><a-></a-></code-toolbar-><iframe style="height:70px" src="left_1.html"></iframe></code-result><h3><a name="11" href="#11">Дуга</a></h3><p>Функция:</p><code-example><script>`function circ(timeFraction) {\n  return 1 - Math.sin(Math.acos(timeFraction))\n}`</script></code-example><p><strong>График:</strong></p><figure><img src="circ.png" alt="" width="100%" style="max-width:233px"></figure><figure-><code-toolbar-><a title="reset" onclick="this.parentElement.nextElementSibling.src='left_2.html'"></a><a data-new_window="" title="открыть в новом окне"></a><a-></a-></code-toolbar-><iframe style="height:70px" src="left_2.html"></iframe></figure-><h3><a name="12" href="#12">Back: стреляем из лука</a></h3><p>Эта функция работает по принципу лука: сначала мы «натягиваем тетиву», а затем «стреляем».</p><p>В отличие от предыдущих функций, эта зависит от дополнительного параметра <code>x</code>, который является «коэффициентом упругости». Он определяет расстояние, на которое «оттягивается тетива».</p><p>Её код:</p><code-example><script>`function back(x, timeFraction) {\n  return Math.pow(timeFraction, 2) * ((x + 1) * timeFraction - x)\n}`</script></code-example><p><strong>График для <code>x = 1.5</code>:</strong></p><figure><img src="back.png" alt="" width="100%" style="max-width:233px"></figure><p>Пример для <code>x = 1.5</code>:</p><code-result><code-toolbar-><a title="reset" onclick="this.parentElement.nextElementSibling.src='left_3.html'"></a><a data-new_window="" title="открыть в новом окне"></a><a-></a-></code-toolbar-><iframe style="height:70px" src="left_3.html"></iframe></code-result><h3><a name="13" href="#13">Отскок bounce</a></h3><p>Представьте, что мы отпускаем мяч, он падает на пол, несколько раз отскакивает и останавливается.</p><p>Функция <code>bounce</code> делает то же самое, только наоборот: «подпрыгивание» начинается сразу.</p><p>Эта функция немного сложнее предыдущих и использует специальные коэффициенты:</p><code-example><script>`function bounce(timeFraction) {\n  for (var a = 0, b = 1, result; 1; a += b, b /= 2) {\n    if (timeFraction >= (7 - 4 * a) / 11) {\n      return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2)\n    }\n  }\n}`</script></code-example><p>Код взят из MooTools.FX.Transitions. Конечно же, есть и другие реализации <code>bounce</code>.</p><p>Пример:</p><code-result><code-toolbar-><a title="reset" onclick="this.parentElement.nextElementSibling.src='left_4.html'"></a><a data-new_window="" title="открыть в новом окне"></a><a-></a-></code-toolbar-><iframe style="height:70px" src="left_4.html"></iframe></code-result><h3><a name="14" href="#14">Упругая анимация</a></h3><p>Эта функция зависит от дополнительного параметра <code>x</code>, который определяет начальный диапазон.</p><code-example><script>`function elastic(x, timeFraction) {\n  return Math.pow(2, 10 * (timeFraction - 1)) * Math.cos(20 * Math.PI * x / 3 * timeFraction)\n}`</script></code-example><p><strong>График для <code>x=1.5</code>:</strong><img src="/article/js-animation/elastic.png" alt="" width="233" height="388"></p><p>Пример для <code>x=1.5</code>:</p><code-result><code-toolbar-><a title="reset" onclick="this.parentElement.nextElementSibling.src='left_5.html'"></a><a data-new_window="" title="открыть в новом окне"></a><a-></a-></code-toolbar-><iframe style="height:70px" src="left_5.html"></iframe></code-result><h2><a name="4" href="#4">Реверсивные функции ease*</a></h2><p>Итак, у нас есть коллекция временных функций.</p><p>Их прямое использование называется «easeIn».</p><p><strong>Иногда нужно показать анимацию в обратном режиме. Преобразование функции, которое даёт такой эффект, называется «easeOut»</strong>.</p><h3><a name="15" href="#15">easeOut</a></h3><p>В режиме «easeOut», значение timing вычисляется по формуле: <code>timingEaseOut(timeFraction) = 1 - timing(1 - timeFraction)</code></p><p>Например, функция <code>bounce</code> в режиме «easeOut»:</p><code-example><script>`// обычный вариант\nfunction bounce(timeFraction) {\n  for (var a = 0, b = 1, result; 1; a += b, b /= 2) {\n    if (timeFraction >= (7 - 4 * a) / 11) {\n      return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2);\n    }\n  }\n}\n\n// преобразователь в easeOut\nfunction makeEaseOut(timing) {\n  return function(timeFraction) {\n    return 1 - timing(1 - timeFraction);\n  }\n}\n\nMARKvar bounceEaseOut = makeEaseOut(bounce);`</script></code-example><p>Полный пример – отскок в <code>bounceEaseOut</code> теперь не в начале, а в конце (и это куда красивее):</p><code-tabs data-code_switch=""><tools-><button-0 class="current">index.html</button-0><button-1>style.css</button-1><button-2>animate.js</button-2></tools-><code-example style="display: block;"><script>`<!DOCTYPE HTML>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="style_left.css">\n  <script src="animate.js"><\/script>\n</head>\n\n<body>\n\n  <div id="path">\n    <div id="brick"></div>\n  </div>\n\n  <script>\n    function makeEaseOut(timing) {\n      return function(timeFraction) {\n        return 1 - timing(1 - timeFraction);\n      }\n    }\n\n    function bounce(timeFraction) {\n      for (var a = 0, b = 1, result; 1; a += b, b /= 2) {\n        if (timeFraction >= (7 - 4 * a) / 11) {\n          return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2)\n        }\n      }\n    }\n\n    var bounceEaseOut = makeEaseOut(bounce);\n\n    brick.onclick = function() {\n      animate({\n        duration: 3000,\n        timing: bounceEaseOut,\n        draw: function(progress) {\n          brick.style.left = progress * 500 + 'px';\n        }\n      });\n    };\n  <\/script>\n\n</body>\n\n</html>`</script><code-toolbar- iframe="100"><a title="показать" data-code_run="40"></a><a title="открыть в новом окне" data-new_window="code"></a><a title="открыть в песочнице" data-code_edit_run=""></a></code-toolbar-></code-example><code-example><script>`GOLD_#brick_GOLD {\n  width: 40px;\n  height: 20px;\n  background: #EE6B47;\n  position: relative;\n  cursor: pointer;\n}\n\nGOLD_#path_GOLD {\n  outline: 1px solid #E8C48E;\n  width: 540px;\n  height: 20px;\n}`</script></code-example><code-example><script>`function animate({timing, draw, duration}) {\n\n  let start = performance.now();\n\n  requestAnimationFrame(function animate(time) {\n    // timeFraction goes from 0 to 1\n    let timeFraction = (time - start) / duration;\n    if (timeFraction > 1) timeFraction = 1;\n\n    // calculate the current animation state\n    let progress = timing(timeFraction);\n\n    draw(progress); // draw it\n\n    if (timeFraction < 1) {\n      requestAnimationFrame(animate);\n    }\n  });\n}`</script><code-toolbar- iframe="100"><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example></code-tabs><p>На этом графике видно, как преобразование <code>easeOut</code> изменяет поведение функции:</p><figure><img src="bounce-inout.png" alt="" width="100%" style="max-width:233px"></figure><p>Если есть анимационный эффект, такой как подпрыгивание – он будет показан в конце, а не в начале (или наоборот, в начале, а не в конце).</p><p>Красным цветом обозначен <span style="color:#EE6B47">обычный вариант</span>, а <span style="color:#62C0DC">синим</span> – <code>easeOut</code>.</p><ul><li>Обычно анимируемый объект сначала медленно скачет внизу, а затем, в конце, резко достигает верха…</li><li>А после <code>easeOut</code> – он сначала прыгает наверх, а затем медленно скачет внизу.</li></ul><h3><a name="16" href="#16">easeInOut</a></h3><p>А еще можно сделать так, чтобы показать эффект <em>и в начале и в конце</em> анимации. Соответствующее преобразование называется «easeInOut».</p><p>Его код выглядит так:</p><code-example><script>`if (timeFraction <= 0.5) { // первая половина анимации)\n  return timing(2 * timeFraction) / 2;\n} else { // вторая половина\n  return (2 - timing(2 * (1 - timeFraction))) / 2;\n}`</script></code-example><p>Код, который трансформирует <code>timing</code>:</p><code-example><script>`function makeEaseInOut(timing) {\n  return function(timeFraction) {\n    if (timeFraction < .5)\n      return timing(2 * timeFraction) / 2;\n    else\n      return (2 - timing(2 * (1 - timeFraction))) / 2;\n  }\n}\n\nbounceEaseInOut = makeEaseInOut(bounce);`</script></code-example><p>Пример с <code>bounceEaseInOut</code>:</p><code-example style="display: block;"><script>`<!DOCTYPE HTML>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="style_left.css">\n  <script src="animate.js"><\/script>\n</head>\n\n<body>\n\n  <div id="path">\n    <div id="brick"></div>\n  </div>\n\n  <script>\n    function makeEaseInOut(timing) {\n      return function(timeFraction) {\n        if (timeFraction < .5)\n          return timing(2 * timeFraction) / 2;\n        else\n          return (2 - timing(2 * (1 - timeFraction))) / 2;\n      }\n    }\n\n    function bounce(timeFraction) {\n      for (var a = 0, b = 1, result; 1; a += b, b /= 2) {\n        if (timeFraction >= (7 - 4 * a) / 11) {\n          return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2)\n        }\n      }\n    }\n\n    var bounceEaseInOut = makeEaseInOut(bounce);\n\n    brick.onclick = function() {\n      animate({\n        duration: 3000,\n        timing: bounceEaseInOut,\n        draw: function(progress) {\n          brick.style.left = progress * 500 + 'px';\n        }\n      });\n    };\n  <\/script>\n\n</body>\n\n</html>`</script><code-toolbar- iframe="100"><a title="показать" data-code_run="40"></a><a title="открыть в новом окне" data-new_window="code"></a><a title="открыть в песочнице" data-code_edit_run=""></a></code-toolbar-></code-example><p>Трансформация «easeInOut» объединяет в себе два графика в один: <code>easeIn</code> для первой половины анимации и <code>easeOut</code> – для второй.</p><p>Это отлично видно, если посмотреть графики <code>easeIn</code>, <code>easeOut</code> и <code>easeInOut</code> на примере функции <code>circ</code>:</p><figure><img src="circ-ease.png" alt="" width="100%" style="max-width:233px"></figure><ul><li><span style="color:#EE6B47">Красным</span> цветом обозначен обычный вариант функции <code>circ</code>.</li><li><span style="color:#8DB173">Зелёным</span> – <code>easeOut</code>.</li><li><span style="color:#62C0DC">Синим</span> – <code>easeInOut</code>.</li></ul><p>Как видно, график первой половины анимации представляет собой уменьшенный «easeIn», а второй – уменьшенный «easeOut». В результате, анимация начинается и заканчивается одинаковым эффектом.</p><div class="summary"><div class="summary__content"><p>Процесс анимации полностью в ваших руках благодаря <code>timing</code>. Её можно сделать настолько реалистичной, насколько захочется.</p><p>Впрочем, исходя из практики, можно сказать, что варианты <code>timing</code>, описанные выше, покрывают 95% потребностей в анимации.</p></div></div><h2><a name="5" href="#5">Сложные варианты step</a></h2><p>Анимировать можно все, что угодно. Вместо движения, как во всех предыдущих примерах, можно изменять любые CSS свойства… И не только!</p><p>Достаточно лишь написать соответствующий <code>draw</code>.</p><h3><a name="17" href="#17">Набор текста</a></h3><p>Можно, к примеру, анимировать набор текста в «скачущем» режиме:</p><code-tabs data-code_switch=""><tools-><button-0 class="current">index.html</button-0><button-1>style.css</button-1></tools-><code-example style="display: block;"><script src="text.html">`<!DOCTYPE HTML>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="style_text.css">\n  <script src="animate.js"><\/script>\n</head>\n\n<body>\n\n  <textarea id="textExample" rows="4" cols="60">Он стал под дерево и ждет. И вдруг граахнул гром — Летит ужасный Бармаглот И пылкает огнем!\n  </textarea>\n\n  <button onclick="animateText(textExample)">Запустить анимированную печать!</button>\n\n  <script>\n    function animateText(textArea) {\n      var text = textArea.value;\n      var to = text.length,\n        from = 0;\n\n      animate({\n        duration: 5000,\n        timing: bounce,\n        draw: function(progress) {\n          var result = (to - from) * progress + from;\n          textArea.value = text.substr(0, Math.ceil(result))\n        }\n      });\n    }\n\n    function bounce(timeFraction) {\n      for (var a = 0, b = 1, result; 1; a += b, b /= 2) {\n        if (timeFraction >= (7 - 4 * a) / 11) {\n          return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2)\n        }\n      }\n    }\n  <\/script>\n\n</body>\n\n</html>`</script><code-toolbar- iframe="200"><a title="показать" data-code_run="40"></a><a title="открыть в новом окне" data-new_window="code"></a><a title="открыть в песочнице" data-code_edit_run=""></a></code-toolbar-></code-example><code-example><script>`GOLD_textarea_GOLD {\n  display: block;\n  border: 1px solid #BBB;\n  color: #444;\n  font-size: 110%;\n}\n\nGOLD_button_GOLD {\n  margin: 10px 0 0 0\n}`</script></code-example></code-tabs><h2><a name="6" href="#6">Итого</a></h2><p>Анимация выполняется путём вызовов <code>requestAnimationFrame</code>. Для поддержки IE9- желательно подключить полифилл, который будет внутри использовать <code>setTimeout</code>. Это будет всё равно лучше, чем независимые <code>setInterval</code>.</p><p>Реализация анимации – очень простая и вместе с тем гибкая:</p><code-example><script>`function animate(options) {\n\n  var start = performance.now();\n\n  requestAnimationFrame(function animate(time) {\n    // timeFraction от 0 до 1\n    var timeFraction = (time - start) / options.duration;\n    if (timeFraction > 1) timeFraction = 1;\n\n    // текущее состояние анимации\n    var progress = options.timing(timeFraction)\n\n    options.draw(progress);\n\n    if (timeFraction < 1) {\n      requestAnimationFrame(animate);\n    }\n  });\n}`</script></code-example><p>Основные параметры:</p><ul><li><code>duration</code> – длительность анимации в мс.</li><li><code>timing</code> – функция, которая определяет состояние анимации каждый кадр. Получает часть времени от 0 до 1, возвращает завершенность анимации от 0 до 1.</li><li><code>draw</code> – функция, которая отрисовывает состояние анимации от 0 до 1.</li></ul><p>Эту функцию можно улучшить, например добавить коллбэк <code>complete</code> для вызова в конце анимации.</p><p>Мы рассмотрели ряд примеров для <code>timing</code> и трансформации <code>easeOut</code>, <code>easeInOut</code>, которые позволяют их разнообразить. В отличие от CSS мы не ограничены кривыми Безье, можно реализовать всё, что угодно.</p><p>Это же относится и к функции <code>draw</code>.</p><p>Такая реализация анимации имеет три основных области применения:</p><ul><li>Нестандартные задачи и требования, не укладывающиеся в рамки CSS.</li><li>Поддержка IE9-.</li><li>Графика, рисование на canvas.</li></ul><h2 id="tasks"><a href="#7" name="7">Задачи (2)</a></h2><task-content><h3><a href="#18" name="18">Анимируйте мяч</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Сделайте так, чтобы мяч подпрыгивал. Кликните по мячу, чтобы увидеть, как это должно выглядеть.</p><script>+ function(){frameAddScript('ball',on);function on(){function makeEaseOut(timing){return function(timeFraction){return 1-timing(1-timeFraction);}} function bounce(timeFraction){for (var a=0,b=1,result;1;a += b,b /= 2){if (timeFraction >= (7-4 * a)/11){return -Math.pow((11-6 * a-11 * timeFraction)/4,2)+Math.pow(b,2)}}}ball.onclick=function(){var to=field.clientHeight-ball.clientHeight;animate({duration:2000,timing:makeEaseOut(bounce),draw:function(progress){ball.style.top=to * progress+'px'}});};}}()</script><figure><code-toolbar-><a title="reset" data-reset=""></a><a title="открыть в новом окне" data-new_window=""></a><a id="answer_1" style="display:none" title="открыть в песочнице" data-code_edit=""></a><a id="task_1" title="открыть в песочнице" data-code_edit="?"></a></code-toolbar-><iframe id="ball" style="height:250px" src="ball.html"></iframe><script>+ function(){frameAddScript('ball',on);function on(){function makeEaseOut(timing){return function(timeFraction){return 1-timing(1-timeFraction);}} function bounce(timeFraction){for (var a=0,b=1,result;1;a += b,b /= 2){if (timeFraction >= (7-4 * a)/11){return -Math.pow((11-6 * a-11 * timeFraction)/4,2)+Math.pow(b,2)}}}ball.onclick=function(){var to=field.clientHeight-ball.clientHeight;animate({duration:2000,timing:makeEaseOut(bounce),draw:function(progress){ball.style.top=to * progress+'px'}});};}}();</script></figure><p><a data-click="task_1">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>В HTML/CSS, падение мяча можно отобразить изменением свойства <code>ball.style.top</code> от 0 и до значения, соответствующего нижнему положению.</p><p>Нижняя граница элемента <code>field</code>, в котором находится мяч, имеет значение <code>field.clientHeight</code>. Но свойство <code>top</code> относится к верху мяча, поэтому оно меняется до <code>field.clientHeight - ball.clientHeight</code>.</p><p>Для создания анимационного эффекта лучше всего подойдет функция <code>bounce</code> в режиме <code>easeOut</code>.</p><p>Следующий код даст нам нужный результат:</p><code-example><script>`var to = field.clientHeight - ball.clientHeight;\n\nanimate({\n  duration: 2000,\n  timing: makeEaseOut(bounce),\n  draw: function(progress) {\n    ball.style.top = to * progress + 'px'\n  }\n});`</script></code-example><p><a data-click="answer_1">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#19" name="19">Анимируйте падение мяча с отскоками вправо</a><task-open hover-style="" data-show_task="" title="Закрыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Заставьте мяч падать вправо. Кликните, чтобы увидеть в действии.</p><figure><code-toolbar-><a title="reset" data-reset=""></a><a title="открыть в новом окне" data-new_window=""></a><a id="answer_2" style="display:none" data-code_edit=""></a><a title="открыть в песочнице" data-code_edit="?"></a></code-toolbar-><iframe id="ball_1" style="height:250px" src="ball.html"></iframe><script>+ function(){frameAddScript('ball_1',on);function on(){function makeEaseOut(timing){return function(timeFraction){return 1-timing(1-timeFraction);}} function bounce(timeFraction){for (var a=0,b=1,result;1;a += b,b /= 2){if (timeFraction >= (7-4 * a)/11){return -Math.pow((11-6 * a-11 * timeFraction)/4,2)+Math.pow(b,2)}}}function quad(timeFraction){return Math.pow(timeFraction,2);}ball.onclick=function(){var height=field.clientHeight-ball.clientHeight;var width=100;animate({duration:2000,timing:makeEaseOut(bounce),draw:function(progress){ball.style.top=height * progress+'px'}});animate({duration:2000,timing:makeEaseOut(quad),draw:function(progress){ball.style.left=width * progress+"px"}});}}}();</script></figure><p>Напишите код, который будет анимировать мяч. Дистанция вправо составляет <code>100px</code>.</p><p>В качестве исходного кода возьмите решение предыдущей задачи <a data-load_page="179-1">Анимируйте мяч</a>.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>В задаче <a data-load_page="179-1">Анимируйте мяч</a> создаётся подпрыгивающий мяч. Нам нужно всего лишь добавить еще одну анимацию для <code>elem.style.left</code>.</p><p>Горизонтальная координата меняется по другому закону, нежели вертикальная. Она не «подпрыгивает», а постоянно увеличивается, постепенно сдвигая мяч вправо.</p><p>Поэтому мы не можем добавить её в тот же <code>animate</code>, нужно делать отдельный.</p><p>В качестве временной функции для перемещения вправо мы могли бы применить для неё <code>linear</code>, но тогда горизонтальное движение будет отставать от скачков мяча. Более красиво будет что-то типа <code>makeEaseOut(quad)</code>.</p><p>Код:</p><code-example><script>`var height = field.clientHeight - ball.clientHeight;\nvar width = 100;\n\nanimate({\n  duration: 2000,\n  timing: makeEaseOut(bounce),\n  draw: function(progress) {\n    ball.style.top = height * progress + 'px'\n  }\n});\n\nanimate({\n  duration: 2000,\n  timing: makeEaseOut(quad),\n  draw: function(progress) {\n    ball.style.left = width * progress + "px"\n  }\n});`</script></code-example><p><a data-click="answer_2">Открыть решение в песочнице.</a></p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="CSS-анимации; Оптимизация"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/js-animation",disqus_identifier="js-animation",disqus_title="JS-\u0410\u043d\u0438\u043c\u0430\u0446\u0438\u044f";</script></page-content></main>