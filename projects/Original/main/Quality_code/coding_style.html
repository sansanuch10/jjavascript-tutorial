<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="29">Качество кода</a></nav-up><h1>Советы по стилю кода</h1><p>Код должен быть максимально читаемым и понятным. Для этого нужен <em>хороший стиль</em> написания кода. В этой главе мы рассмотрим компоненты такого стиля.</p><h2><a name="0" href="#0">Синтаксис</a></h2><p>Шпаргалка с правилами синтаксиса (детально их варианты разобраны далее):</p><figure><img src="code-style.png" style="width:100%;max-width:723px"></figure><p>Не всё здесь однозначно, так что разберём эти правила подробнее.</p><h3><a name="12" href="#12">Фигурные скобки</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><p>Пишутся на той же строке, так называемый «египетский» стиль. Перед скобкой – пробел.</p><figure><img src="figure-bracket-style.png" style="width:100%;max-width:489px"></figure><p>Если у вас уже есть опыт в разработке, и вы привыкли делать скобку на отдельной строке – это тоже вариант. В конце концов, решать вам. Но в большинстве JavaScript-фреймворков стиль именно такой.</p><p>Если условие и код достаточно короткие, например <code>if (cond) return null</code>, то запись в одну строку вполне читаема… Но, как правило, отдельная строка всё равно воспринимается лучше.</p><h3><a name="13" href="#13">Длина строки</a></h3><p>Максимальную длину строки согласовывают в команде. Как правило, это либо <code>80</code>, либо <code>120</code> символов, в зависимости от того, какие мониторы у разработчиков.</p><p>Более длинные строки необходимо разбивать для улучшения читаемости.</p><h3><a name="14" href="#14">Отступы</a></h3><p>Отступы нужны двух типов:</p><ul><li><p><strong>Горизонтальный отступ, при вложенности – два(или четыре) пробела.</strong></p><p>Как правило, используются именно пробелы, т.к. они позволяют сделать более гибкие «конфигурации отступов», чем символ «Tab».</p><p>Например, выровнять аргументы относительно открывающей скобки:</p><code-example><script>`show("Строки" +\n  &nbsp  " выровнены" +\n  &nbsp  " строго" +\n  &nbsp  " одна под другой");`</script></code-example></li><li><p><strong>Вертикальный отступ, для лучшей разбивки кода – перевод строки.</strong></p><p>Используется, чтобы разделить логические блоки внутри одной функции. В примере разделены инициализация переменных, главный цикл и возвращение результата:</p><code-example><script>`function pow(x, n) {\n  var result = 1;\n  //   <--\n  for (var i = 0; i < n; i++) {\n result *= x;\n  }\n  //   <--\n  return result;\n}`</script></code-example><p>Вставляйте дополнительный перевод строки туда, где это сделает код более читаемым. Не должно быть более 9 строк кода подряд без вертикального отступа.</p></li></ul><h3><a name="15" href="#15">Точка с запятой</a></h3><p>Точки с запятой нужно ставить, даже если их, казалось бы, можно пропустить.</p><p>Есть языки, в которых точка с запятой не обязательна, и её там никто не ставит. В JavaScript перевод строки её заменяет, но лишь частично, поэтому лучше её ставить, как обсуждалось <a data-load_page="10#1">ранее</a>.</p><h2><a name="1" href="#1">Именование</a></h2><p>Общее правило:</p><ul><li>Имя переменной – существительное.</li><li>Имя функции – глагол или начинается с глагола. Бывает, что имена для краткости делают существительными, но глаголы понятнее.</li></ul><p>Для имён используется английский язык (не транслит) и верблюжья нотация.</p><p>Более подробно – читайте про <a data-load_page="24#6">имена функций</a> и <a data-load_page="12#1">имена переменных</a>.</p><h2><a name="2" href="#2">Уровни вложенности</a></h2><p>Уровней вложенности должно быть немного.</p><p>Например, <a data-load_page="22#5">проверки в циклах можно делать через «continue»</a>, чтобы не было дополнительного уровня <code>if(..) { ... }</code>:</p><p>Вместо:</p><code-example><script>`for (var i = 0; i < 10; i++) {\n  if (i подходит) {\n    ... // <- уровень вложенности 2\n  }\n}`</script></code-example><p>Используйте:</p><code-example><script>`for (var i = 0; i < 10; i++) {\n  if (i не подходит) continue;\n  ...  // <- уровень вложенности 1\n}`</script></code-example><p>Аналогичная ситуация – с <code>if/else</code> и <code>return</code>. Следующие две конструкции идентичны.</p><p>Первая:</p><code-example><script>`function isEven(n) { // проверка чётности\n  if (n % 2 == 0) {\n    return true;\nMARK  } else {\nMARK    return false;\nMARK  }\n}`</script></code-example><p>Вторая:</p><code-example><script>`function isEven(n) { // проверка чётности\n  if (n % 2 == 0) {\n    return true;\n  }\n\nMARK  return false;\n}`</script></code-example><p>Если в блоке <code>if</code> идёт <code>return</code>, то <code>else</code> за ним не нужен.</p><p><strong>Лучше быстро обработать простые случаи, вернуть результат, а дальше разбираться со сложным, без дополнительного уровня вложенности.</strong></p><p>В случае с функцией <code>isEven</code> можно было бы поступить и проще:</p><code-example><script>`function isEven(n) { // проверка чётности\n  return !(n % 2);\n}`</script></code-example><p>…Однако, если код <code>!(n % 2)</code> для вас менее очевиден чем предыдущий вариант, то стоит использовать предыдущий.</p><p>Главное для нас – не краткость кода, а его простота и читаемость. Совсем не всегда более короткий код проще для понимания, чем более развёрнутый.</p><h2><a name="3" href="#3">Функции = Комментарии</a></h2><p>Функции должны быть небольшими. Если функция большая – желательно разбить её на несколько.</p><p>Этому правилу бывает сложно следовать, но оно стоит того. При чем же здесь комментарии?</p><p>Вызов отдельной небольшой функции не только легче отлаживать и тестировать – сам факт его наличия является <em>отличным комментарием</em>.</p><p>Сравните, например, две функции <code>showPrimes(n)</code> для вывода простых чисел до <code>n</code>.</p><p>Первый вариант использует метку:</p><code-example><script>`function showPrimes(n) {\n  nextPrime: for (var i = 2; i < n; i++) {\n\n    for (var j = 2; j < i; j++) {\n      if (i % j == 0) continue nextPrime;\n    }\n\n    alert( i ); // простое\n  }\n}`</script></code-example><p>Второй вариант – дополнительную функцию <code>isPrime(n)</code> для проверки на простоту:</p><code-example><script>`function showPrimes(n) {\n\n  for (var i = 2; i < n; i++) {\n    HIGHif (!isPrime(i)) continue;LIGHT\n\n    alert(i);  // простое\n  }\n}\n\nfunction isPrime(n) {\n  for (var i = 2; i < n; i++) {\n    if ( n % i == 0) return false;\n  }\n  return true;\n}`</script></code-example><p>Второй вариант проще и понятнее, не правда ли? Вместо участка кода мы видим описание действия, которое там совершается (проверка <code>isPrime</code>).</p><h2><a name="4" href="#4">Функции – под кодом</a></h2><p>Есть два способа расположить функции, необходимые для выполнения кода.</p><ol><li><p>Функции над кодом, который их использует:</p><code-example><script>`// HIGHобъявить функцииLIGHT\nfunction createElement() {\n  ...\n}\n\nfunction setHandler(elem) {\n  ...\n}\n\nfunction walkAround() {\n  ...\n}\n\n// HIGHкод, использующий функцииLIGHT\nvar elem = createElement();\nsetHandler(elem);\nwalkAround();`</script></code-example></li><li><p>Сначала код, а функции внизу:</p><code-example><script>`// HIGHкод, использующий функцииLIGHT\nvar elem = createElement();\nsetHandler(elem);\nwalkAround();\n\n// --- HIGHфункцииLIGHT ---n\nfunction createElement() {\n  ...\n}\n\nfunction setHandler(elem) {\n  ...\n}\n\nfunction walkAround() {\n  ...\n}`</script></code-example></li></ol><p>…На самом деле существует еще третий «стиль», при котором функции хаотично разбросаны по коду, но это ведь не наш метод, да?</p><p><strong>Как правило, лучше располагать функции под кодом, который их использует.</strong></p><p>То есть, предпочтителен 2-й способ.</p><p>Дело в том, что при чтении такого кода мы хотим знать в первую очередь, <em>что он делает</em>, а уже затем <em>какие функции ему помогают.</em> Если первым идёт код, то это как раз дает необходимую информацию. Что же касается функций, то вполне возможно нам и не понадобится их читать, особенно если они названы адекватно и то, что они делают, понятно из названия.</p><h2><a name="5" href="#5">Плохие комментарии</a></h2><p>В коде нужны комментарии.</p><p>Сразу начну с того, каких комментариев быть почти не должно.</p><p><strong>Должен быть минимум комментариев, которые отвечают на вопрос "что происходит в коде?"</strong></p><p>Что интересно, в коде начинающих разработчиков обычно комментариев либо нет, либо они как раз такого типа: «что делается в этих строках».</p><p>Серьёзно, хороший код и так понятен.</p><p>Об этом замечательно выразился Р.Мартин в книге <a href="http://www.ozon.ru/context/detail/id/21916535/">«Чистый код»</a>: «Если вам кажется, что нужно добавить комментарий для улучшения понимания, это значит, что ваш код недостаточно прост, и, может, стоит переписать его».</p><p>Если у вас образовалась длинная «простыня», то, возможно, стоит разбить её на отдельные функции, и тогда из их названий будет понятно, что делает тот или иной фрагмент.</p><p>Да, конечно, бывают сложные алгоритмы, хитрые решения для оптимизации, поэтому нельзя такие комментарии просто запретить. Но перед тем, как писать подобное – подумайте: «Нельзя ли сделать код понятным и без них?»</p><h2><a name="6" href="#6">Хорошие комментарии</a></h2><p>А какие комментарии полезны и приветствуются?</p><ul><li><p><strong>Архитектурный комментарий – «как оно, вообще, устроено».</strong></p><p>Какие компоненты есть, какие технологии использованы, поток взаимодействия. О чём и зачем этот скрипт. Взгляд с высоты птичьего полёта. Эти комментарии особенно нужны, если вы не один, а проект большой.</p><p>Для описания архитектуры, кстати, создан специальный язык <a href="http://ru.wikipedia.org/wiki/Unified_Modeling_Language">UML</a>, красивые диаграммы, но можно и без этого. Главное – чтобы понятно.</p></li><li><p><strong>Справочный комментарий перед функцией – о том, что именно она делает, какие параметры принимает и что возвращает.</strong></p><p>Для таких комментариев существует синтаксис <a href="http://en.wikipedia.org/wiki/JSDoc">JSDoc</a>.</p><code-example><script>`/**\nCOMMENT * Возвращает x в степени n, только для натуральных n\nCOMMENT *\nCOMMENT * @param {number} x Число для возведения в степень.\nCOMMENT * @param {number} n Показатель степени, натуральное число.\nCOMMENT * @return {number} x в степени n.\n */\nfunction pow(x, n) {\n  ...\n}`</script></code-example><p>Такие комментарии позволяют сразу понять, что принимает и что делает функция, не вникая в код.</p><p>Кстати, они автоматически обрабатываются многими редакторами, например <a href="http://aptana.com">Aptana</a> и редакторами от <a href="http://www.jetbrains.com/">JetBrains</a>, которые учитывают их при автодополнении, а также выводят их в автоподсказках при наборе кода.</p><p>Кроме того, есть инструменты, например <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3</a>, которые умеют генерировать по таким комментариям документацию в формате HTML. Более подробную информацию об этом можно также найти на сайте <a href="http://usejsdoc.org/">http://usejsdoc.org/</a>.</p></li></ul><p><strong>…Но куда более важными могут быть комментарии, которые объясняют не <em>что</em>, а <em>почему</em> в коде происходит именно это!</strong></p><p>Как правило, из кода можно понять, что он делает. Бывает, конечно, всякое, но, в конце концов, вы этот код <em>видите</em>. Однако гораздо важнее может быть то, чего вы <em>не видите</em>!</p><p><em>Почему</em> это сделано именно так? На это сам код ответа не даёт.</p><p>Например:</p><dl><dt>Есть несколько способов решения задачи. Почему выбран именно этот?</dt><dd><p>Например, пробовали решить задачу по-другому, но не получилось – напишите об этом. Почему вы выбрали именно этот способ решения? Особенно это важно в тех случаях, когда используется не первый приходящий в голову способ, а какой-то другой.</p><p>Без этого возможна, например, такая ситуация:</p></dd></dl><ul><li><p>Вы открываете код, который был написан какое-то время назад, и видите, что он «неоптимален».</p></li><li><p>Думаете: «Какой я был дурак», и переписываете под «более очевидный и правильный» вариант.</p></li><li><p>…Порыв, конечно, хороший, да только этот вариант вы уже обдумали раньше. И отказались, а почему – забыли. В процессе переписывания вспомнили, конечно (к счастью), но результат – потеря времени на повторное обдумывание.</p><p>Комментарии, которые объясняют выбор решения, очень важны. Они помогают понять происходящее и предпринять правильные шаги при развитии кода.</p></li></ul><dl><dt>Какие неочевидные возможности обеспечивает этот код? Где ещё они используются?</dt><dd>В хорошем коде должно быть минимум неочевидного. Но там, где это есть – пожалуйста, комментируйте.</dd></dl><important-><h3>Комментарии – это важно</h3><p>Один из показателей хорошего разработчика – качество комментариев, которые позволяют эффективно поддерживать код, возвращаться к нему после любой паузы и легко вносить изменения.</p></important-><h2><a name="7" href="#7">Руководства по стилю</a></h2><p>Когда написанием проекта занимается целая команда, то должен существовать один стандарт кода, описывающий где и когда ставить пробелы, запятые, переносы строк и т.п.</p><p>Сейчас, когда есть столько готовых проектов, нет смысла придумывать целиком своё руководство по стилю. Можно взять уже готовое, к которому, по желанию, всегда можно что-то добавить.</p><p>Большинство есть на английском, сообщите мне, если найдёте хороший перевод:</p><ul><li><a href="https://google.github.io/styleguide/javascriptguide.xml">Google JavaScript Style Guide</a></li><li><a href="http://contribute.jquery.org/style-guide/js/">jQuery JavaScript Style Guide</a></li><li><a href="https://github.com/airbnb/javascript">Airbnb JavaScript Style Guide</a></li><li><a href="https://github.com/rwaldron/idiomatic.js">Idiomatic.JS</a> (есть <a href="https://github.com/rwaldron/idiomatic.js/tree/master/translations/ru_RU">перевод</a>)</li><li><a href="https://dojotoolkit.org/reference-guide/1.10/developer/styleguide.html">Dojo Style Guide</a></li></ul><p>Для того, чтобы начать разработку, вполне хватит элементов стилей, обозначенных в этой главе. В дальнейшем, посмотрев эти руководства, вы можете выработать и свой стиль, но лучше не делать его особенно «уникальным и неповторимым», себе дороже потом будет с людьми сотрудничать.</p><h2><a name="8" href="#8">Автоматизированные средства проверки</a></h2><p>Существуют средства, проверяющие стиль кода.</p><p>Самые известные – это:</p><ul><li><a href="http://www.jslint.com/">JSLint</a> – проверяет код на соответствие <a href="http://www.jslint.com/lint.html">стилю JSLint</a>, в онлайн-интерфейсе вверху можно ввести код, а внизу различные настройки проверки, чтобы сделать её более мягкой.</li><li><a href="http://www.jshint.com/">JSHint</a> – вариант JSLint с большим количеством настроек.</li><li><a href="https://developers.google.com/closure/utilities/">Closure Linter</a> – проверка на соответствие <a href="https://google.github.io/styleguide/jsguide.html">Google JavaScript Style Guide</a>.</li></ul><p>В частности, JSLint и JSHint интегрированы с большинством редакторов, они гибко настраиваются под нужный стиль и совершенно незаметно улучшают разработку, подсказывая, где и что поправить.</p><p>Побочный эффект – они видят некоторые ошибки, например необъявленные переменные. У меня это обычно результат опечатки, которые таким образом сразу отлавливаются. Очень рекомендую поставить что-то из этого. Я использую <a href="http://www.jshint.com/">JSHint</a>.</p><h2><a name="9" href="#9">Итого</a></h2><p>Описанные принципы оформления кода уместны в большинстве проектов. Есть и другие полезные соглашения.</p><p>Следуя (или не следуя) им, необходимо помнить, что любые советы по стилю хороши лишь тогда, когда делают код читаемее, понятнее, проще в поддержке.</p><h2 id="tasks"><a href="#10" name="10">Задачи</a></h2><task-content><h3><a href="#17" name="17">Ошибки в стиле</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>Какие недостатки вы видите в стиле этого примера?</p><code-example><script>`function pow(x,n)\n{\n  var result=1;\n  for(var i=0;i<n;i++) {result*=x;}\n  return result;\n}\n\nx=prompt('x?','')\nn=prompt('n?','')\nif (n<0)\n{\n  alert('Степень&nbsp'+n+ 'не поддерживается, введите целую степень, большую 0');\n}\nelse\n{\n  alert(pow(x,n))\n}`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="" style="">Ответ</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Ответ</h4><p>Вы могли заметить следующие недостатки, сверху-вниз:</p><code-example><script>`function pow(x,n)  // <- отсутствует пробел между аргументами\n{  // <- фигурная скобка на отдельной строке\n  var result=1;   // <- нет пробелов вокруг знака =\n  for(var i=0;i<n;i++) {result*=x;}   // <- нет пробелов\n  // содержимое скобок { ... } лучше вынести на отдельную строку\n  return result;\n}\n\nx=prompt('x?','')  // <- не объявлена переменная, нет пробелов, ;\nn=prompt('n?','')\nif (n<0)  // <- нет пробелов, стоит добавить вертикальную отбивку\n{   // <- фигурная скобка на отдельной строке\n  // ниже - слишком длинная строка, нет пробелов\n  alert('Степень&nbsp'+n+ 'не поддерживается, введите целую степень, большую 0');\n}\nelse // - можно на одной строке } else {\n{\n  alert(pow(x,n))  // вложенный вызов функции, нет точки с запятой\n}`</script></code-example><p>Исправленный вариант:</p><code-example><script>`function pow(x, n) {\n  var result = 1;\n\n  for (var i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n\nvar x = prompt('x?', '');\nvar n = prompt('n?', '');\n\nif (n < 0) {\n  alert('Степень&nbsp' + n +\n    'не поддерживается, введите целую степень, большую 0');\n} else {\n  alert( pow(x, n) );\n}`</script></code-example></task-answer></task-answer-ext></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Отладка в браузере Chrome; Как писать неподдерживаемый код?"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/coding-style",disqus_identifier="coding-style",disqus_title="\u0421\u043e\u0432\u0435\u0442\u044b \u043f\u043e \u0441\u0442\u0438\u043b\u044e \u043a\u043e\u0434\u0430";</script></page-content></main>