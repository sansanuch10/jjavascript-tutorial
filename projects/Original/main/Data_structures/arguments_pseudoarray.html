<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="34">Структуры данных</a></nav-up><h1>Псевдомассив аргументов "arguments"</h1><p>В JavaScript любая функция может быть вызвана с произвольным количеством аргументов.</p><p>Например:</p><code-example><script>`function go(a,b) {\n  alert("a =&nbsp" + a + ", b =&nbsp" + b);\n}\n\ngo(1);     // a=1, b=undefined\ngo(1,2);   // a=1, b=2\ngo(1,2,3); // a=1, b=2, третий аргумент не вызовет ошибку`</script><code-toolbar></code-toolbar></code-example><important-><h3>В JavaScript нет «перегрузки» функций</h3><p>В некоторых языках программист может создать две функции с одинаковым именем, но разным набором аргументов, а при вызове интерпретатор сам выберет нужную:</p><code-example><script>`function log(a) {\n  ...\n}\n\nfunction log(a, b, c) {\n  ...\n}\n\nMARKlog(a); // вызовется первая функция\nMARKlog(a, b, c); // вызовется вторая функция`</script></code-example><p>Это называется «полиморфизмом функций» или «перегрузкой функций». В JavaScript ничего подобного нет.</p><p><strong>Может быть только одна функция с именем <code>log</code>, которая вызывается с любыми аргументами.</strong></p><p>А уже внутри она может посмотреть, с чем вызвана и по-разному отработать.</p><p>В примере выше второе объявление <code>log</code> просто переопределит первое.</p></important-><h2><a name="0" href="#0">Доступ к «лишним» аргументам</a></h2><p>Как получить значения аргументов, которых нет в списке параметров?</p><p>Доступ к ним осуществляется через «псевдо-массив» <a href="https://developer.mozilla.org/en/JavaScript/Reference/functions_and_function_scope/arguments">arguments</a>.</p><p>Он содержит список аргументов по номерам: <code>arguments[0]</code>, <code>arguments[1]</code>…, а также свойство <code>length</code>.</p><p>Например, выведем список всех аргументов:</p><code-example><script>`function sayHi() {\n  for (var i = 0; i < arguments.length; i++) {\n    alert( "Привет,&nbsp" + arguments[i] );\n  }\n}\n\nsayHi("Винни", "Пятачок"); // \'Привет, Винни\', \'Привет, Пятачок\'`</script><code-toolbar></code-toolbar></code-example><p>Все параметры находятся в <code>arguments</code>, даже если они есть в списке. Код выше сработал бы также, будь функция объявлена <code>sayHi(a,b,c)</code>.</p><important-warn><h3>Связь между <code>arguments</code> и параметрами</h3><p><strong>В старом стандарте JavaScript псевдо-массив <code>arguments</code> и переменные-параметры ссылаются на одни и те же значения.</strong></p><p>В результате изменения <code>arguments</code> влияют на параметры и наоборот.</p><p>Например:</p><code-example><script>`function f(x) {\n  arguments[0] = 5; // меняет переменную x\n  alert( x ); // 5\n}\n\nf(1);`</script><code-toolbar></code-toolbar></code-example><p>Наоборот:</p><code-example><script>`function f(x) {\n  x = 5;\n  alert( arguments[0] ); // 5, обновленный x\n}\n\nf(1);`</script><code-toolbar></code-toolbar></code-example><p>В современной редакции стандарта это поведение изменено. Аргументы отделены от локальных переменных:</p><code-example><script>`function f(x) {\n  "use strict"; // для браузеров с поддержкой строгого режима\n\n  arguments[0] = 5;\n  alert( x ); // не 5, а 1! Переменная "отвязана" от arguments\n}\n\nf(1);`</script><code-toolbar></code-toolbar></code-example><p><strong>Если вы не используете строгий режим, то чтобы переменные не менялись «неожиданно», рекомендуется никогда не изменять <code>arguments</code>.</strong></p></important-warn><h3><a name="9" href="#9">arguments – это не массив</a></h3><p>Частая ошибка новичков – попытка применить методы <code>Array</code> к <code>arguments</code>. Это невозможно:</p><code-example><script>`function sayHi() {\n  var a = arguments.shift(); // ошибка! нет такого метода!\n}\n\nsayHi(1);`</script><code-toolbar></code-toolbar></code-example><p>Дело в том, что <code>arguments</code> – это не массив <code>Array</code>.</p><p>В действительности, это обычный объект, просто ключи числовые и есть <code>length</code>. На этом сходство заканчивается. Никаких особых методов у него нет, и методы массивов он тоже не поддерживает.</p><p>Впрочем, никто не мешает сделать обычный массив из <code>arguments</code>, например так:</p><code-example><script>`var args = [];\nfor (var i = 0; i < arguments.length; i++) {\n  args[i] = arguments[i];\n}`</script><code-toolbar></code-toolbar></code-example><p>Такие объекты иногда называют <em>«коллекциями»</em> или <em>«псевдомассивами»</em>.</p><h2><a name="1" href="#1">Пример: копирование свойств copy(dst, src1, src2...)</a></h2><p>Иногда встаёт задача – скопировать в существующий объект свойства из одного или нескольких других.</p><p>Напишем для этого функцию <code>copy</code>. Она будет работать с любым числом аргументов, благодаря использованию <code>arguments</code>.</p><p>Синтаксис:</p><dl><dt>copy(dst, src1, src2…)</dt><dd>Копирует свойства из объектов <code>src1, src2,...</code> в объект <code>dst</code>. Возвращает получившийся объект.</dd></dl><p>Использование:</p><ul><li><p>Для объединения нескольких объектов в один:</p><code-example><script>`var vasya = {\n  age: 21,\n  name: 'Вася',\n  surname: 'Петров'\n};\n\nvar user = {\n  isAdmin: false,\n  isEmailConfirmed: true\n};\n\nvar student = {\n  university: 'My university'\n};\n\n// добавить к vasya свойства из user и student\nMARKcopy(vasya, user, student);\n\nalert( vasya.isAdmin ); // false\nalert( vasya.university ); // My university`</script><code-toolbar></code-toolbar></code-example></li><li><p>Для создания копии объекта <code>user</code>:</p><code-example><script>`// скопирует все свойства в пустой объект\nvar userClone = copy({}, user);`</script></code-example><p>Такой «клон» объекта может пригодиться там, где мы хотим изменять его свойства, при этом не трогая исходный объект <code>user</code>.</p><p>В нашей реализации мы будем копировать только свойства первого уровня, то есть вложенные объекты как-то особым образом не обрабатываются. Впрочем, её можно расширить.</p></li></ul><p>А вот и реализация:</p><code-example><script>`function copy() {\n  var dst = arguments[0];\n\n  for (var i = 1; i < arguments.length; i++) {\n    var arg = arguments[i];\n    for (var key in arg) {\n      dst[key] = arg[key];\n    }\n  }\n\n  return dst;\n}`</script></code-example><p>Здесь первый аргумент <code>copy</code> – это объект, в который нужно копировать, он назван <code>dst</code>. Для упрощения доступа к нему можно указать его прямо в объявлении функции:</p><code-example><script>`MARKfunction copy(dst) {\n  // остальные аргументы остаются безымянными\n  for (var i = 1; i < arguments.length; i++) {\n    var arg = arguments[i];\n    for (var key in arg) {\n      dst[key] = arg[key];\n    }\n  }\n\n  return dst;\n}`</script></code-example><h3><a name="10" href="#10">Аргументы по умолчанию через ||</a></h3><p>Если функция вызвана с меньшим количеством аргументов, чем указано, то отсутствующие аргументы считаются равными <code>undefined</code>.</p><p>Зачастую в случае отсутствия аргумента мы хотим присвоить ему некоторое «стандартное» значение или, иначе говоря, значение «по умолчанию». Это можно удобно сделать при помощи оператора логическое ИЛИ <code>||</code>.</p><p>Например, функция <code>showWarning</code>, описанная ниже, должна показывать предупреждение. Для этого она принимает ширину <code>width</code>, высоту <code>height</code>, заголовок <code>title</code> и содержимое <code>contents</code>, но большая часть этих аргументов необязательна:</p><code-example><script>`function showWarning(width, height, title, contents) {\n  width = width || 200; // если не указана width, то width = 200\n  height = height || 100; // если нет height, то height = 100\n  title = title || "Предупреждение";\n\n  //...\n}`</script></code-example><p>Это отлично работает в тех ситуациях, когда «нормальное» значение параметра в логическом контексте отлично от <code>false</code>. В коде выше, при передаче <code>width = 0</code> или <code>width = null</code>, оператор ИЛИ заменит его на значение по умолчанию.</p><p>А что, если мы хотим использовать значение по умолчанию только если <code>width === undefined</code>? В этом случае оператор ИЛИ уже не подойдёт, нужно поставить явную проверку:</p><code-example><script>`function showWarning(width, height, title, contents) {\n  if (width === undefined) width = 200;\n  if (height === undefined) height = 100;\n  if (title === undefined) title = "Предупреждение";\n\n  //...\n}`</script></code-example><h2><a name="2" href="#2">Устаревшее свойство arguments.callee</a></h2><important-warn><h3>Используйте NFE вместо <code>arguments.callee</code></h3><p>Это свойство устарело, при <code>use strict</code> оно не работает.</p><p>Единственная причина, по которой оно тут – это то, что его можно встретить в старом коде, поэтому о нём желательно знать.</p><p>Современная спецификация рекомендует использовать <a data-load_page="27">именованные функциональные выражения (NFE)</a>.</p></important-warn><p>В старом стандарте JavaScript объект <code>arguments</code> не только хранил список аргументов, но и содержал в свойстве <code>arguments.callee</code> ссылку на функцию, которая выполняется в данный момент.</p><p>Например:</p><code-example><script>`function f() {\n  alert( arguments.callee === f ); // true\n}\n\nf();`</script><code-toolbar></code-toolbar></code-example><p>Эти два примера будут работать одинаково:</p><code-example><script>`// подвызов через NFE\nvar factorial = function f(n) {\n  return n==1 ? 1 : n*f(n-1);\n};\n\n// подвызов через arguments.callee\nvar factorial = function(n) {\n  return n==1 ? 1 : n*arguments.callee(n-1);\n};`</script></code-example><p>В учебнике мы его использовать не будем, оно приведено для общего ознакомления.</p><h3><a name="12" href="#12">arguments.callee.caller</a></h3><p>Устаревшее свойство <code>arguments.callee.caller</code> хранит ссылку на <em>функцию, которая вызвала данную</em>.</p><important-warn><h3>Это свойство тоже устарело</h3><p>Это свойство было в старом стандарте, при <code>use strict</code> оно не работает, как и <code>arguments.callee</code>.</p><p>Также ранее существовало более короткое свойство <code>arguments.caller</code>. Но это уже раритет, оно даже не кросс-браузерное. А вот свойство <code>arguments.callee.caller</code> поддерживается везде, если не использован <code>use strict</code>, поэтому в старом коде оно встречается.</p></important-warn><p>Пример работы:</p><code-example><script>`f1();\n\nfunction f1() {\n  alert( arguments.callee.caller ); // null, меня вызвали из глобального кода\n  f2();\n}\n\nfunction f2() {\n  alert( arguments.callee.caller ); // f1, функция, из которой меня вызвали\n  f3();\n}\n\nfunction f3() {\n  alert( arguments.callee.caller ); // f2, функция, из которой меня вызвали\n}`</script><code-toolbar></code-toolbar></code-example><p>В учебнике мы это свойство также не будем использовать.</p><h2><a name="3" href="#3">«Именованные аргументы»</a></h2><p><em>Именованные аргументы</em> – альтернативная техника работы с аргументами, которая вообще не использует <code>arguments</code>.</p><p>Некоторые языки программирования позволяют передать параметры как-то так: <code>f(width=100, height=200)</code>, то есть по именам, а что не передано, тех аргументов нет. Это очень удобно в тех случаях, когда аргументов много, сложно запомнить их порядок и большинство вообще не надо передавать, по умолчанию подойдёт.</p><p>Такая ситуация часто встречается в компонентах интерфейса. Например, у «меню» может быть масса настроек отображения, которые можно «подкрутить» но обычно нужно передать всего один-два главных параметра, а остальные возьмутся по умолчанию.</p><p>В JavaScript для этих целей используется передача аргументов в виде объекта, а в его свойствах мы передаём параметры.</p><p>Получается так:</p><code-example><script>`function showWarning(options) {\n  var width = options.width || 200; // по умолчанию\n  var height = options.height || 100;\n\n  var contents = options.contents || "Предупреждение";\n\n  // ...\n}`</script></code-example><p>Вызвать такую функцию очень легко. Достаточно передать объект аргументов, указав в нем только нужные:</p><code-example><script>`showWarning({\n  contents: "Вы вызвали функцию" // и всё понятно!\n});`</script></code-example><p>Сравним это с передачей аргументов через список:</p><code-example><script>`showWarning(null, null, "Предупреждение!");\n// мысль программиста "а что это за null, null в начале? ох, надо глядеть описание функции"`</script></code-example><p>Не правда ли, объект – гораздо проще и понятнее?</p><p>Еще один бонус кроме красивой записи – возможность повторного использования объекта аргументов:</p><code-example><script>`var opts = {\n  width: 400,\n  height: 200,\n  BLUE_contents: "Текст"\n};\n\nshowWarning(opts);\n\nopts.contents_BLUE = "Другой текст";\n\nMARKshowWarning(opts); // вызвать с новым текстом, без копирования других аргументов`</script></code-example><p>Именованные аргументы применяются во многих JavaScript-фреймворках.</p><h2><a name="4" href="#4">Итого</a></h2><ul><li>Полный список аргументов, с которыми вызвана функция, доступен через <code>arguments</code>.</li><li>Это псевдомассив, то есть объект, который похож на массив, в нём есть нумерованные свойства и <code>length</code>, но методов массива у него нет.</li><li>В старом стандарте было свойство <code>arguments.callee</code> со ссылкой на текущую функцию, а также свойство <code>arguments.callee.caller</code>, содержащее ссылку на функцию, которая вызвала данную. Эти свойства устарели, при <code>use strict</code> обращение к ним приведёт к ошибке.</li><li>Для указания аргументов по умолчанию, в тех случаях, когда они заведомо не <code>false</code>, удобен оператор <code>||</code>.</li></ul><p>В тех случаях, когда возможных аргументов много и, в особенности, когда большинство их имеют значения по умолчанию, вместо работы с <code>arguments</code> организуют передачу данных через объект, который как правило называют <code>options</code>.</p><p>Возможен и гибридный подход, при котором первый аргумент обязателен, а второй – <code>options</code>, который содержит всевозможные дополнительные параметры:</p><code-example><script>`function showMessage(text, options) {\n  // показать сообщение text, настройки показа указаны в options\n}`</script></code-example><h2 id="tasks"><a href="#5" name="5">Задачи (2)</a></h2><task-content><h3><a href="#14" name="14">Проверка на аргумент-undefined</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Как в функции отличить отсутствующий аргумент от <code>undefined</code>?</p><code-example><script>`function f(x) {\n  // ..ваш код..\n  // выведите 1, если первый аргумент есть, и 0 - если нет\n}\n\nf(undefined); // 1\nf(); // 0`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer style=""><close- title="закрыть" data-close_answer=""></close-><p>Узнать количество реально переданных аргументов можно по значению <code>arguments.length</code>:</p><code-example><script>`function f(x) {\n  alert( arguments.length ? 1 : 0 );\n}\n\nf(undefined);\nf();`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#15" name="15">Сумма аргументов</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Напишите функцию <code>sum(...)</code>, которая возвращает сумму всех своих аргументов:</p><code-example><script>`sum() = 0\nsum(1) = 1\nsum(1, 2) = 3\nsum(1, 2, 3) = 6\nsum(1, 2, 3, 4) = 10`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`function sum() {\n  var result = 0;\n\n  for (var i = 0; i < arguments.length; i++) {\n    result += arguments[i];\n  }\n\n  return result;\n}\n\nalert( sum() ); // 0\nalert( sum(1) ); // 1\nalert( sum(1, 2) ); // 3\nalert( sum(1, 2, 3) ); // 6\nalert( sum(1, 2, 3, 4) ); // 10`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Массив: перебирающие методы; Дата и Время"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/arguments-pseudoarray",disqus_identifier="arguments-pseudoarray",disqus_title="\u041f\u0441\u0435\u0432\u0434\u043e\u043c\u0430\u0441\u0441\u0438\u0432 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \"arguments\"";function copy(dst){for (var i=1;i<arguments.length;i++){var arg=arguments[i];for (var key in arg){dst[key]=arg[key];}} return dst}</script></page-content></main>