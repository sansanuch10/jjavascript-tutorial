<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="34">Структуры данных</a></nav-up><h1>Строки</h1><p>В JavaScript любые текстовые данные являются строками. Не существует отдельного типа «символ», который есть в ряде других языков.</p><p>Внутренним форматом строк, вне зависимости от кодировки страницы, является <a href="http://ru.wikipedia.org/wiki/%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4">Юникод (Unicode)</a>.</p><h2><a name="0" href="#0">Создание строк</a></h2><p>Строки создаются при помощи двойных или одинарных кавычек:</p><code-example><script>`var text = "моя строка";\n\nvar anotherText = \'еще строка\';\n\nvar str = "012345";`</script></code-example><p>В JavaScript нет разницы между двойными и одинарными кавычками.</p><h3><a name="8" href="#8">Специальные символы</a></h3><p>Строки могут содержать специальные символы. Самый часто используемый из таких символов – это «перевод строки».</p><p>Он обозначается как <code>\n</code>, например:</p><code-example><script>`alert( 'Привет\\nМир' ); // выведет \"Мир\" на новой строке`</script><code-toolbar></code-toolbar></code-example><p>Есть и более редкие символы, вот их список:</p><table><caption>Специальные символы</caption><thead><tr><th>Символ</th><th>Описание</th></tr></thead><tbody><tr><td>\b</td><td>Backspace</td></tr><tr><td>\f</td><td>Form feed</td></tr><tr><td>\n</td><td>New line</td></tr><tr><td>\r</td><td>Carriage return</td></tr><tr><td>\t</td><td>Tab</td></tr><tr><td>\uNNNN</td><td>Символ в кодировке Юникод с шестнадцатеричным кодом `NNNN`. Например, `\u00A9` -- юникодное представление символа копирайт ©</td></tr></tbody></table><h3><a name="9" href="#9">Экранирование специальных символов</a></h3><p>Если строка в одинарных кавычках, то внутренние одинарные кавычки внутри должны быть <em>экранированы</em>, то есть снабжены обратным слешем <code>\'</code>, вот так:</p><code-example><script>`var str = 'HIGHI\\'mLIGHT a JavaScript programmer';`</script></code-example><p>В двойных кавычках – экранируются внутренние двойные:</p><code-example><script>`var str = "I\'m a JavaScript \\"programmer\\" ";\nalert( str ); // I\'m a JavaScript \"programmer\"`</script><code-toolbar></code-toolbar></code-example><p>Экранирование служит исключительно для правильного восприятия строки JavaScript. В памяти строка будет содержать сам символ без <code>'\'</code>. Вы можете увидеть это, запустив пример выше.</p><p>Сам символ обратного слэша <code>'\'</code> является служебным, поэтому всегда экранируется, т.е пишется как <code>\\</code>:</p><code-example><script>`var str = ' символ \\\\ ';\n\nalert( str ); // символ \\ `</script><code-toolbar></code-toolbar></code-example><p>Заэкранировать можно любой символ. Если он не специальный, то ничего не произойдёт:</p><code-example><script>`alert( "\\a" ); // a\n// идентично alert(  "a"  );`</script><code-toolbar></code-toolbar></code-example><h2><a name="1" href="#1">Методы и свойства</a></h2><p>Здесь мы рассмотрим методы и свойства строк, с некоторыми из которых мы знакомились ранее, в главе <a data-load_page="35">Введение в методы и свойства</a>.</p><h3><a name="10" href="#10">Длина length</a></h3><p>Одно из самых частых действий со строкой – это получение ее длины:</p><code-example><script>`var str = "My\\n"; // 3 символа. Третий - перевод строки\n\nalert( str.length ); // 3`</script><code-toolbar></code-toolbar></code-example><h3><a name="11" href="#11">Доступ к символам</a></h3><p>Чтобы получить символ, используйте вызов <code>charAt(позиция)</code>. Первый символ имеет позицию <code>0</code>:</p><code-example><script>`var str = "jQuery";\nalert( str.charAt(0) ); // "j"`</script><code-toolbar></code-toolbar></code-example><p>В JavaScript <strong>нет отдельного типа «символ»</strong>, так что <code>charAt</code> возвращает строку, состоящую из выбранного символа.</p><p>Также для доступа к символу можно использовать квадратные скобки:</p><code-example><script>`var str = "Я - современный браузер!";\nalert( str[0] ); // "Я"`</script><code-toolbar></code-toolbar></code-example><p>Разница между этим способом и <code>charAt</code> заключается в том, что если символа нет – <code>charAt</code> выдает пустую строку, а скобки – <code>undefined</code>:</p><code-example><script>`alert( "".charAt(0) ); // пустая строка\nalert( "" [0] ); // undefined`</script><code-toolbar></code-toolbar></code-example><p>Вообще же метод <code>charAt</code> существует по историческим причинам, ведь квадратные скобки – проще и короче.</p><important-warn><h3>Вызов метода – всегда со скобками</h3><p>Обратите внимание, <code>str.length</code> – это <em>свойство</em> строки, а <code>str.charAt(pos)</code> – <em>метод</em>, т.е. функция.</p><p>Обращение к методу всегда идет со скобками, а к свойству – без скобок.</p></important-warn><h3><a name="13" href="#13">Изменения строк</a></h3><p>Содержимое строки в JavaScript нельзя изменять. Нельзя взять символ посередине и заменить его. Как только строка создана – она такая навсегда.</p><p>Можно лишь создать целиком новую строку и присвоить в переменную вместо старой, например:</p><code-example><script>`var str = "строка";\n\nstr = str[3] + str[4] + str[5];\n\nalert( str ); // ока`</script><code-toolbar></code-toolbar></code-example><h3><a name="14" href="#14">Смена регистра</a></h3><p>Методы <code>toLowerCase()</code> и <code>toUpperCase()</code> меняют регистр строки на нижний/верхний:</p><code-example><script>`alert( "Интерфейс".toUpperCase() ); // ИНТЕРФЕЙС`</script><code-toolbar></code-toolbar></code-example><p>Пример ниже получает первый символ и приводит его к нижнему регистру:</p><code-example><script>`alert( "Интерфейс" [0].toLowerCase() ); // \'и\'`</script><code-toolbar></code-toolbar></code-example><h3><a name="15" href="#15">Поиск подстроки</a></h3><p>Для поиска подстроки есть метод <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String/indexOf">indexOf(подстрока[, начальная_позиция])</a>.</p><p>Он возвращает позицию, на которой находится <code>подстрока</code> или <code>-1</code>, если ничего не найдено. Например:</p><code-example><script>`var str = "Widget with id";\n\nalert( str.indexOf("Widget") ); // 0, т.к. "Widget" найден прямо в начале str\nalert( str.indexOf("id") ); // 1, т.к. "id" найден, начиная с позиции 1\nalert( str.indexOf("widget") ); // -1, не найдено, так как поиск учитывает регистр`</script><code-toolbar></code-toolbar></code-example><p>Необязательный второй аргумент позволяет искать, начиная с указанной позиции. Например, первый раз <code>"id"</code> появляется на позиции <code>1</code>. Чтобы найти его следующее появление – запустим поиск с позиции <code>2</code>:</p><code-example><script>`var str = "Widget with id";\n\nalert(str.indexOf("id", 2)) // 12, поиск начат с позиции 2`</script><code-toolbar></code-toolbar></code-example><p>Также существует аналогичный метод <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String/lastIndexOf">lastIndexOf</a>, который ищет не с начала, а с конца строки.</p><important-><h3>На заметку:</h3><p>Для красивого вызова <code>indexOf</code> применяется побитовый оператор НЕ <code>'~'</code>.</p><p>Дело в том, что вызов <code>~n</code> эквивалентен выражению <code>-(n+1)</code>, например:</p><code-example><script>`alert( ~2 ); // -(2+1) = -3\nalert( ~1 ); // -(1+1) = -2\nalert( ~0 ); // -(0+1) = -1\nMARKalert( ~-1 ); // -(-1+1) = 0`</script><code-toolbar></code-toolbar></code-example><p>Как видно, <code>~n</code> – ноль только в случае, когда <code>n == -1</code>.</p><p>То есть, проверка <code>if ( ~str.indexOf(...) )</code> означает, что результат <code>indexOf</code> отличен от <code>-1</code>, т.е. совпадение есть.</p><p>Вот так:</p><code-example><script>`var str = "Widget";\n\nif (~str.indexOf("get")) {\n  alert( \'совпадение есть!\' );\n}`</script><code-toolbar></code-toolbar></code-example><p>Вообще, использовать возможности языка неочевидным образом не рекомендуется, поскольку ухудшает читаемость кода.</p><p>Однако, в данном случае, все в порядке. Просто запомните: <code>'~'</code> читается как «не минус один», а <code>"if ~str.indexOf"</code> читается как <code>"если найдено"</code>.</p></important-><h3><a name="17" href="#17">Поиск всех вхождений</a></h3><p>Чтобы найти все вхождения подстроки, нужно запустить <code>indexOf</code> в цикле. Как только получаем очередную позицию – начинаем следующий поиск со следующей.</p><p>Пример такого цикла:</p><code-example><script>`var str = "Ослик Иа-Иа посмотрел на виадук"; // ищем в этой строке\nvar target = "Иа"; // цель поиска\n\nvar pos = 0;\nwhile (true) {\n  var foundPos = str.indexOf(target, pos);\n  if (foundPos == -1) break;\n\n  alert( foundPos ); // нашли на этой позиции\n  pos = foundPos + 1; // продолжить поиск со следующей\n}`</script><code-toolbar></code-toolbar></code-example><p>Такой цикл начинает поиск с позиции <code>0</code>, затем найдя подстроку на позиции <code>foundPos</code>, следующий поиск продолжит с позиции <code>pos = foundPos+1</code>, и так далее, пока что-то находит.</p><p>Впрочем, тот же алгоритм можно записать и короче:</p><code-example><script>`var str = "Ослик Иа-Иа посмотрел на виадук"; // ищем в этой строке\nvar target = "Иа"; // цель поиска\n\nMARKvar pos = -1;\nMARKwhile ((pos = str.indexOf(target, pos + 1)) != -1) {\nMARK  alert( pos );\nMARK}`</script><code-toolbar></code-toolbar></code-example><h3><a name="18" href="#18">Взятие подстроки: substring, substr, slice</a></h3><p>В JavaScript существуют целых 3 (!) метода для взятия подстроки, с небольшими отличиями между ними.</p><dl><dt><code>substring(start [, end])</code></dt><dd><p>Метод <code>substring(start, end)</code> возвращает подстроку с позиции <code>start</code> до, но не включая <code>end</code>.</p><code-example><script>`var str = "HIGHsLIGHTtringify";\nalert(str.substring(0,1)); // "s", символы с позиции 0 по 1 не включая 1.`</script><code-toolbar></code-toolbar></code-example><p>Если аргумент <code>end</code> отсутствует, то идет до конца строки:</p><code-example><script>`var str = "stHIGHringifyLIGHT";\nalert(str.substring(2)); // ringify, символы с позиции 2 до конца`</script><code-toolbar></code-toolbar></code-example></dd><dt></dt><dt><code>substr(start [, length])</code></dt><dd><p>Первый аргумент имеет такой же смысл, как и в <code>substring</code>, а второй содержит не конечную позицию, а количество символов.</p><code-example><script>`var str = "stHIGHringLIGHTify";\nstr = str.substr(2,4); // ring, со 2-й позиции 4 символа\nalert(str)`</script><code-toolbar></code-toolbar></code-example><p>Если второго аргумента нет – подразумевается «до конца строки».</p></dd><dt><code>slice(start [, end])</code></dt><dd><p>Возвращает часть строки от позиции <code>start</code> до, но не включая, позиции <code>end</code>. Смысл параметров – такой же как в <code>substring</code>.</p></dd></dl><h3><a name="19" href="#19">Отрицательные аргументы</a></h3><p>Различие между <code>substring</code> и <code>slice</code> – в том, как они работают с отрицательными и выходящими за границу строки аргументами:</p><dl><dt><code>substring(start, end)</code></dt><dd><p>Отрицательные аргументы интерпретируются как равные нулю. Слишком большие значения усекаются до длины строки:</p><code-example><script>`alert( "testme".substring(-2) ); // "testme", -2 становится 0`</script><code-toolbar></code-toolbar></code-example><p>Кроме того, если <code>start &gt; end</code>, то аргументы меняются местами, т.е. возвращается участок строки <em>между</em><code>start</code> и <code>end</code>:</p><code-example><script>`alert( "testme".substring(4, -1) ); // "test"\n// -1 становится 0 -> получили substring(4, 0)\n// 4 > 0, так что аргументы меняются местами -> substring(0, 4) = "test"`</script><code-toolbar></code-toolbar></code-example></dd><dt><code>slice</code></dt><dd><p>Отрицательные значения отсчитываются от конца строки:</p><code-example><script>`alert( "testme".slice(-2) ); // "me", от 2 позиции с конца`</script><code-toolbar></code-toolbar></code-example><code-example><script>`alert( "testme".slice(1, -1) ); // "estm", от 1 позиции до первой с конца.`</script><code-toolbar></code-toolbar></code-example><p>Это гораздо более удобно, чем странная логика <code>substring</code>.</p></dd></dl><p>Отрицательное значение первого параметра поддерживается в <code>substr</code> во всех браузерах, кроме IE8-.</p><p>Если выбирать из этих трёх методов один, для использования в большинстве ситуаций – то это будет <code>slice</code>: он и отрицательные аргументы поддерживает и работает наиболее очевидно.</p><h2><a name="2" href="#2">Кодировка Юникод</a></h2><p>Как мы знаем, символы сравниваются в алфавитном порядке <code>'А' &lt; 'Б' &lt; 'В' &lt; ... &lt; 'Я'</code>.</p><p>Но есть несколько странностей…</p><ol><li><p>Почему буква <code>'а'</code> маленькая больше буквы <code>'Я'</code> большой?</p><code-example><script>`alert( 'а' > 'Я' ); // true`</script><code-toolbar></code-toolbar></code-example></li><li><p>Буква <code>'ё'</code> находится в алфавите между <code>е</code> и <code>ж</code>: <code>абвгде<strong>ё</strong>жз…</code>. Но почему тогда <code>'ё'</code> больше <code>'я'</code>?</p><code-example><script>`alert( 'ё' > 'я' ); // true`</script><code-toolbar></code-toolbar></code-example></li></ol><p>Чтобы разобраться с этим, обратимся к внутреннему представлению строк в JavaScript.</p><p><strong>Все строки имеют внутреннюю кодировку <a href="http://ru.wikipedia.org/wiki/%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4">Юникод</a>.</strong></p><p>Неважно, на каком языке написана страница, находится ли она в windows-1251 или utf-8. Внутри JavaScript-интерпретатора все строки приводятся к единому «юникодному» виду. Каждому символу соответствует свой код.</p><p>Есть метод для получения символа по его коду:</p><dl><dt>String.fromCharCode(code)</dt><dd><p>Возвращает символ по коду <code>code</code>:</p><code-example><script>`alert( String.fromCharCode(1072) ); // 'а'`</script><code-toolbar></code-toolbar></code-example></dd></dl><p>…И метод для получения цифрового кода из символа:</p><dl><dt>str.charCodeAt(pos)</dt><dd><p>Возвращает код символа на позиции <code>pos</code>. Отсчет позиции начинается с нуля.</p><code-example><script>`alert( \"абрикос\".charCodeAt(0) ); // 1072, код 'а'`</script><code-toolbar></code-toolbar></code-example></dd></dl><p>Теперь вернемся к примерам выше. Почему сравнения <code>'ё' &gt; 'я'</code> и <code>'а' &gt; 'Я'</code> дают такой странный результат?</p><p>Дело в том, что <strong>символы сравниваются не по алфавиту, а по коду</strong>. У кого код больше – тот и больше. В юникоде есть много разных символов. Кириллическим буквам соответствует только небольшая часть из них, подробнее – <a href="http://ru.wikipedia.org/wiki/%D0%9A%D0%B8%D1%80%D0%B8%D0%BB%D0%BB%D0%B8%D1%86%D0%B0_%D0%B2_%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4%D0%B5">Кириллица в Юникоде</a>.</p><p>Выведем отрезок символов юникода с кодами от <code>1034</code> до <code>1113</code>:</p><code-example><script>`var str = '';\nfor (var i = 1034; i <= 1113; i++) {\n  str += String.fromCharCode(i);\n}\nalert( str );`</script><code-toolbar></code-toolbar></code-example><p>Результат:</p><div style="overflow: auto"><code>ЊЋЌЍЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюяѐёђѓєѕіїјљ</code></div><p>Мы можем увидеть из этого отрезка две важных вещи:</p><ol><li><p><strong>Строчные буквы идут после заглавных, поэтому они всегда больше.</strong></p><p>В частности, <code>'а'(код 1072) &gt; 'Я'(код 1071)</code>.</p><p>То же самое происходит и в английском алфавите, там <code>'a' &gt; 'Z'</code>.</p></li><li><p><strong>Ряд букв, например <code>ё</code>, находятся вне основного алфавита.</strong></p><p>В частности, маленькая буква <code>ё</code> имеет код, больший чем <code>я</code>, поэтому <strong><code>'ё'(код 1105) &gt; 'я'(код 1103)</code></strong>.</p><p>Кстати, большая буква <code>Ё</code> располагается в Unicode до <code>А</code>, поэтому <strong><code>'Ё'</code>(код 1025) &lt; <code>'А'</code>(код 1040)</strong>. Удивительно: есть буква меньше чем <code>А</code> :)</p></li></ol><p><strong>Буква <code>ё</code> не уникальна, точки над буквой используются и в других языках, приводя к тому же результату.</strong></p><p>Например, при работе с немецкими названиями:</p><code-example><script>`alert( "ö" > "z" ); // true`</script><code-toolbar></code-toolbar></code-example><important-><h3>Юникод в HTML</h3><p>Кстати, если мы знаем код символа в кодировке юникод, то можем добавить его в HTML, используя «числовую ссылку» (numeric character reference).</p><p>Для этого нужно написать сначала <code>&amp;#</code>, затем код, и завершить точкой с запятой <code>';'</code>. Например, символ <code>'а'</code> в виде числовой ссылки: <code>&amp;#1072;</code>.</p><p>Если код хотят дать в 16-ричной системе счисления, то начинают с <code>&amp;#x</code>.</p><p>В юникоде есть много забавных и полезных символов, например, символ ножниц: ✂ (<code>&amp;#x2702;</code>), дроби: ½ (<code>&amp;#xBD;</code>) ¾ (<code>&amp;#xBE;</code>) и другие. Их можно использовать вместо картинок в дизайне.</p></important-><h2><a name="3" href="#3">Посимвольное сравнение</a></h2><p>Сравнение строк работает <em>лексикографически</em>, иначе говоря, посимвольно.</p><p>Сравнение строк <code>s1</code> и <code>s2</code> обрабатывается по следующему алгоритму:</p><ol><li>Сравниваются первые символы: <code>s1[0]</code> и <code>s2[0]</code>. Если они разные, то сравниваем их и, в зависимости от результата их сравнения, возвратить <code>true</code> или <code>false</code>. Если же они одинаковые, то…</li><li>Сравниваются вторые символы <code>s1[1]</code> и <code>s2[1]</code></li><li>Затем третьи <code>s1[2]</code> и <code>s2[2]</code> и так далее, пока символы не будут наконец разными, и тогда какой символ больше – та строка и больше. Если же в какой-либо строке закончились символы, то считаем, что она меньше, а если закончились в обеих – они равны.</li></ol><p>Спецификация языка определяет этот алгоритм более детально. Если же говорить простыми словами, смысл алгоритма в точности соответствует порядку, по которому имена заносятся в орфографический словарь.</p><code-example><script>`"Вася" > "Ваня" // true, т.к. начальные символы совпадают, а потом \'с\' > \'н\'\n"Дома" > "До" // true, т.к. начало совпадает, но в 1-й строке больше символов`</script></code-example><important-warn><h3>Числа в виде строк сравниваются как строки</h3><p>Бывает, что числа приходят в скрипт в виде строк, например как результат <code>prompt</code>. В этом случае результат их сравнения будет неверным:</p><code-example><script>`alert( "2" > "14" ); // true, так как это строки, и для первых символов верно "2" > "1"`</script><code-toolbar></code-toolbar></code-example><p>Если хотя бы один аргумент – не строка, то другой будет преобразован к числу:</p><code-example><script>`alert( 2 > "14" ); // false`</script><code-toolbar></code-toolbar></code-example></important-warn><h2><a name="4" href="#4">Правильное сравнение</a></h2><p>Все современные браузеры, кроме IE10- (для которых нужно подключить библиотеку <a href="https://github.com/andyearnshaw/Intl.js/">Intl.JS</a>) поддерживают стандарт <a href="http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf">ECMA 402</a>, поддерживающий сравнение строк на разных языках, с учётом их правил.</p><p>Способ использования:</p><code-example><script>`var str = "Ёлки";\n\nalert( str.localeCompare("Яблони") ); // -1`</script><code-toolbar></code-toolbar></code-example><p>Метод <code>str1.localeCompare(str2)</code> возвращает <code>-1</code>, если <code>str1 &lt; str2</code>, <code>1</code>, если <code>str1 &gt; str2</code> и <code>0</code>, если они равны.</p><p>Более подробно про устройство этого метода можно будет узнать в статье <a data-load_page="242">Intl: интернационализация в JavaScript</a>, когда это вам понадобится.</p><h2><a name="5" href="#5">Итого</a></h2><ul><li>Строки в JavaScript имеют внутреннюю кодировку Юникод. При написании строки можно использовать специальные символы, например <code>\n</code> и вставлять юникодные символы по коду.</li><li>Мы познакомились со свойством <code>length</code> и методами <code>charAt</code>, <code>toLowerCase/toUpperCase</code>, <code>substring/substr/slice</code> (предпочтителен <code>slice</code>). Есть и другие методы, например <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim">trim</a> обрезает пробелы с начала и конца строки.</li><li>Строки сравниваются побуквенно. Поэтому если число получено в виде строки, то такие числа могут сравниваться некорректно, нужно преобразовать его к типу <em>number</em>.</li><li>При сравнении строк следует иметь в виду, что буквы сравниваются по их кодам. Поэтому большая буква меньше маленькой, а буква <code>ё</code> вообще вне основного алфавита.</li><li>Для правильного сравнения существует целый стандарт ECMA 402. Это не такое простое дело, много языков и много правил. Он поддерживается во всех современных браузерах, кроме IE10-, в которых нужна библиотека <a href="https://github.com/andyearnshaw/Intl.js/">https://github.com/andyearnshaw/Intl.js/</a>. Такое сравнение работает через вызов <code>str1.localeCompare(str2)</code>.</li></ul><p>Больше информации о методах для строк можно получить в справочнике: <a href="http://javascript.ru/String">http://javascript.ru/String</a>.</p><h2 id="tasks"><a href="#6" name="6">Задачи (4)</a></h2><task-content><h3><a href="#22" name="22">Сделать первый символ заглавным</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Напишите функцию <code>ucFirst(str)</code>, которая возвращает строку <code>str</code> с заглавным первым символом, например:</p><code-example><script>`ucFirst("вася") == "Вася";\nucFirst("") == ""; // нет ошибок при пустой строке`</script></code-example><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\nMARK    function ucFirst(str) {\nMARK       // ...Ваш код...\nMARK    }\n  <\/script>\n  <script>\n    describe("ucFirst", function() {\n      it('делает первый символ заглавным', function() {\n        assert.strictEqual(ucFirst("вася"), "Вася");\n      });\n\n      it('для пустой строки возвращает пустую строку', function() {\n        assert.strictEqual(ucFirst(""), "");\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="task_1" data-code_edit=""></a></code-toolbar-></code-example><p>P.S. В JavaScript нет встроенного метода для этого. Создайте функцию, используя <code>toUpperCase()</code> и <code>charAt()</code>.</p><p><a data-click="task_1">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Мы не можем просто заменить первый символ, т.к. строки в JavaScript неизменяемы.</p><p>Но можно пересоздать строку на основе существующей, с заглавным первым символом:</p><code-example><script>`var newStr = str[0].toUpperCase() + str.slice(1);`</script></code-example><p>Однако, есть небольшая проблемка – в случае, когда строка пуста, будет ошибка.</p><p>Ведь <code>str[0] == undefined</code>, а у <code>undefined</code> нет метода <code>toUpperCase()</code>.</p><p>Выхода два. Первый – использовать <code>str.charAt(0)</code>, он всегда возвращает строку, для пустой строки – пустую, но не <code>undefined</code>. Второй – отдельно проверить на пустую строку, вот так:</p><code-example><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\nMARK    function ucFirst(str) {\n      if (!str) return str;\n    \n      return str[0].toUpperCase() + str.slice(1);\nMARK    }\n  <\/script>\n  <script>\n    describe("ucFirst", function() {\n      it('делает первый символ заглавным', function() {\n        assert.strictEqual(ucFirst("вася"), "Вася");\n      });\n\n      it('для пустой строки возвращает пустую строку', function() {\n        assert.strictEqual(ucFirst(""), "");\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar- iframe="650"><a title="показать" data-code_run="0"></a><a title="открыть в новом окне" data-new_window="code"></a><a id="answer_1" title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><p>P.S. Возможны и более короткие решения, использующие методы для работы со строками, которые мы пройдём далее.</p><p><a data-click="answer_1">Открыть решение с тестами в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#23" name="23">Проверьте спам</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Напишите функцию <code>checkSpam(str)</code>, которая возвращает <code>true</code>, если строка <code>str</code> содержит „viagra“ или „XXX“, а иначе <code>false</code>.</p><p>Функция должна быть нечувствительна к регистру:</p><code-example><script>`checkSpam('buy ViAgRA now') == true\ncheckSpam('free xxxxx') == true\ncheckSpam(\"innocent rabbit\") == false`</script></code-example><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    // ...Ваш код...\n\n  <\/script>\n  <script>\n    describe("checkSpam", function() {\n      it('считает спамом "buy ViAgRA now"', function() {\n        assert.isTrue(checkSpam('buy ViAgRA now'));\n      });\n\n      it('считает спамом "free xxxxx"', function() {\n        assert.isTrue(checkSpam('free xxxxx'));\n      });\n\n      it('не считает спамом "innocent rabbit"', function() {\n        assert.isFalse(checkSpam('innocent rabbit'));\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="task_2" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="task_2">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Метод <code>indexOf</code> ищет совпадение с учетом регистра. То есть, в строке <code>'xXx'</code> он не найдет <code>'XXX'</code>.</p><p>Для проверки, сначала приведем строку <code>str</code> к нижнему регистру, а затем уже будем искать.</p><code-example><script>`function checkSpam(str) {\n  var lowerStr = str.toLowerCase();\n\n  return !!(~lowerStr.indexOf('viagra') || ~lowerStr.indexOf('xxx'));\n}\n\nalert( checkSpam('buy ViAgRA now') );\nalert( checkSpam('free xxxxx') );\nalert( checkSpam(\"innocent rabbit\") );`</script><code-toolbar></code-toolbar></code-example><code-example><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    function checkSpam(str) {\n      var lowerStr = str.toLowerCase();\n    \n      return !!(~lowerStr.indexOf('viagra') || ~lowerStr.indexOf('xxx'));\n    }\n\n  <\/script>\n  <script>\n    describe("checkSpam", function() {\n      it('считает спамом "buy ViAgRA now"', function() {\n        assert.isTrue(checkSpam('buy ViAgRA now'));\n      });\n\n      it('считает спамом "free xxxxx"', function() {\n        assert.isTrue(checkSpam('free xxxxx'));\n      });\n\n      it('не считает спамом "innocent rabbit"', function() {\n        assert.isFalse(checkSpam('innocent rabbit'));\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar- iframe="650"><a title="показать" data-code_run="0"></a><a title="открыть в новом окне" data-new_window="code"></a><a id="answer_2" title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="answer_2">Открыть решение с тестами в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#24" name="24">Усечение строки</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Создайте функцию <code>truncate(str, maxlength)</code>, которая проверяет длину строки <code>str</code>, и если она превосходит <code>maxlength</code> – заменяет конец <code>str</code> на <code>"..."</code>, так чтобы ее длина стала равна <code>maxlength</code>.</p><p>Результатом функции должна быть (при необходимости) усечённая строка.</p><p>Например:</p><code-example><script>`truncate("Вот, что мне хотелось бы сказать на эту тему:", 20) = "Вот, что мне хоте..."\n\ntruncate("Всем привет!", 20) = "Всем привет!"`</script></code-example><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    // ...Ваш код...\n\n  <\/script>\n  <script>\n    describe("truncate", function() {\n      it("обрезает строку до указанной длины (включая троеточие)", function() {\n        assert.equal(\n          truncate("Вот, что мне хотелось бы сказать на эту тему:", 20),\n          "Вот, что мне хоте..."\n        );\n      });\n\n      it("не меняет короткие строки", function() {\n        assert.equal(\n          truncate("Всем привет!", 20),\n          "Всем привет!"\n        );\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="task_3" data-code_edit=""></a></code-toolbar-></code-example><p>Эта функция имеет применение в жизни. Она используется, чтобы усекать слишком длинные темы сообщений.</p><p>P.S. В кодировке Unicode существует специальный символ «троеточие»: <code>…</code> (HTML: <code>&amp;hellip;</code>), но в этой задаче подразумеваются именно три точки подряд.</p><p><a data-click="task_3">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Так как окончательная длина строки должна быть <code>maxlength</code>, то нужно её обрезать немного короче, чтобы дать место для троеточия.</p><code-example><script>`function truncate(str, maxlength) {\n  if (str.length > maxlength) {\n    return str.slice(0, maxlength - 3) + \'...\';\n    // итоговая длина равна maxlength\n  }\n\n  return str;\n}\n\nalert( truncate("Вот, что мне хотелось бы сказать на эту тему:&nbsp", 20) );\nalert( truncate("Всем привет!", 20) );`</script><code-toolbar></code-toolbar></code-example><p>Можно было бы написать этот код ещё короче:</p><code-example><script>`function truncate(str, maxlength) {\n  return (str.length > maxlength) ?\n    str.slice(0, maxlength - 3) + '...' : str;\n}`</script><code-toolbar></code-toolbar></code-example><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    function truncate(str, maxlength) {\n      return (str.length > maxlength) ?\n        str.slice(0, maxlength - 3) + '...' : str;\n    }\n\n  <\/script>\n  <script>\n    describe("truncate", function() {\n      it("обрезает строку до указанной длины (включая троеточие)", function() {\n        assert.equal(\n          truncate("Вот, что мне хотелось бы сказать на эту тему:", 20),\n          "Вот, что мне хоте..."\n        );\n      });\n\n      it("не меняет короткие строки", function() {\n        assert.equal(\n          truncate("Всем привет!", 20),\n          "Всем привет!"\n        );\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="answer_3" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="answer_3">Открыть решение с тестами в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#25" name="25">Выделить число</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>Есть стоимость в виде строки: <code>"$120"</code>. То есть, первым идёт знак валюты, а затем – число.</p><p>Создайте функцию <code>extractCurrencyValue(str)</code>, которая будет из такой строки выделять число-значение, в данном случае 120.</p><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    // ...Ваш код...\n\n  <\/script>\n  <script>\n    describe("extractCurrencyValue", function() {\n      it("выделяет из строки $120 число 120", function() {\n        assert.strictEqual(extractCurrencyValue('$120'), 120);\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="task_4" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="task_4">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Возьмём часть строки после первого символа и приведём к числу: <code>+str.slice(1)</code>.</p><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    function extractCurrencyValue(str) {\n      return +str.slice(1);\n    }\n\n  <\/script>\n  <script>\n    describe("extractCurrencyValue", function() {\n      it("выделяет из строки $120 число 120", function() {\n        assert.strictEqual(extractCurrencyValue('$120'), 120);\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="answer_4" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="answer_4">Открыть решение с тестами в песочнице.</a></p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Числа; Объекты как ассоциативные массивы"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/string",disqus_identifier="string",disqus_title="\u0421\u0442\u0440\u043e\u043a\u0438";</script></page-content></main>