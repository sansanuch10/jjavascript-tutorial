<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="34">Структуры данных</a></nav-up><h1>Объекты как ассоциативные массивы</h1><p>Объекты в JavaScript сочетают в себе два важных функционала.</p><p>Первый – это ассоциативный массив: структура, пригодная для хранения любых данных. В этой главе мы рассмотрим использование объектов именно как массивов.</p><p>Второй – языковые возможности для объектно-ориентированного программирования. Эти возможности мы изучим в последующих разделах учебника.</p><h2><a name="0" href="#0">Ассоциативные массивы</a></h2><p><a href="http://ru.wikipedia.org/wiki/%D0%90%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2">Ассоциативный массив</a> – структура данных, в которой можно хранить любые данные в формате ключ-значение.</p><p>Её можно легко представить как шкаф с подписанными ящиками. Все данные хранятся в ящичках. По имени можно легко найти ящик и взять то значение, которое в нём лежит.</p><figure><img src="object.png" alt="" width="100%" height="168" style="
    max-width: 134px;
"></figure><p>В отличие от реальных шкафов, в ассоциативный массив можно в любой момент добавить новые именованные «ящики» или удалить существующие. Далее мы увидим примеры, как это делается.</p><p>Кстати, в других языках программирования такую структуру данных также называют <em>«словарь»</em> и <em>«хэш»</em>.</p><h2><a name="1" href="#1">Создание объектов</a></h2><p>Пустой объект («пустой шкаф») может быть создан одним из двух синтаксисов:</p><code-example><script>`1. o = new Object();\n2. o = {}; // пустые фигурные скобки`</script></code-example><p>Обычно все пользуются синтаксисом <code>(2)</code>, т.к. он короче.</p><h2><a name="2" href="#2">Операции с объектом</a></h2><p>Объект может содержать в себе любые значения, которые называются <em>свойствами объекта</em>. Доступ к свойствам осуществляется по <em>имени свойства</em> (иногда говорят <em>«по ключу»</em>).</p><p>Например, создадим объект <code>person</code> для хранения информации о человеке:</p><code-example><script>`var person = {}; // пока пустой`</script></code-example><figure><img src="object-person-empty.png" style="max-width: 128px;
" width="100%" height="207"></figure><p>Основные операции с объектами – это создание, получение и удаление свойств.</p><p>Для обращения к свойствам используется запись «через точку», вида <code>объект.свойство</code>, например:</p><code-example><script>`// при присвоении свойства в объекте автоматически создаётся \"ящик\"\n// с именем \"name\" и в него записывается содержимое 'Вася'\nperson.name = 'Вася';\n\nperson.age = 25; // запишем ещё одно свойство: с именем 'age' и значением 25`</script></code-example><figure><img src="object-person-1.png" style="max-width: 125px;
" width="100%" height="165"></figure><p>Значения хранятся «внутри» ящиков. Обратим внимание – любые значения, любых типов: число, строка – не важно.</p><p>Чтобы прочитать их – также обратимся через точку:</p><code-example><script>`alert( person.name + ': ' + person.age ); // \"Вася: 25\"`</script></code-example><p>Удаление осуществляется оператором <code>delete</code>:</p><code-example><script>`delete person.age;`</script></code-example><p>Осталось только свойство <code>name</code>:</p><figure><img src="object-person-2.png" style="max-width: 134px;
" width="100%" height="165"></figure><p>Иногда бывает нужно проверить, есть ли в объекте свойство с определенным ключом.</p><p>Для этого есть особый оператор: <code>"in"</code>.</p><p>Его синтаксис: <code>"prop" in obj</code>, причем имя свойства – в виде строки, например:</p><code-example><script>`if ("name" in person) {\n  alert( "Свойство name существует!" );\n}`</script></code-example><p>Впрочем, чаще используется другой способ – сравнение значения с <code>undefined</code>.</p><p><strong>Дело в том, что в JavaScript можно обратиться к любому свойству объекта, даже если его нет</strong>.</p><p>Ошибки не будет.</p><p>Но если свойство не существует, то вернется специальное значение <code>undefined</code>:</p><code-example><script>`var person = {};\n\nalert( person.lalala ); // undefined, нет свойства с ключом lalala`</script><code-toolbar></code-toolbar></code-example><p>Таким образом мы можем легко проверить существование свойства – получив его и сравнив с <code>undefined</code>:</p><code-example><script>`var person = {\n  name: "Василий"\n};\n\nalert( person.lalala === undefined ); // true, свойства нет\nalert( person.name === undefined ); // false, свойство есть.`</script><code-toolbar></code-toolbar></code-example><important-><h3>Разница между проверками <code>in</code> и <code>=== undefined</code></h3><p>Есть два средства для проверки наличия свойства в объекте: первое – оператор <code>in</code>, второе – получить его и сравнить с <code>undefined</code>.</p><p>Они почти идентичны, но есть одна небольшая разница.</p><p>Дело в том, что технически возможно, что <em>свойство есть, а его значением является <code>undefined</code></em>:</p><code-example><script>`var obj = {};\nobj.test = undefined; // добавили свойство со значением undefined\n\nMARK// проверим наличие свойств test и заведомо отсутствующего blabla\nMARKalert( obj.test === undefined ); // true\nMARKalert( obj.blabla === undefined ); // true`</script><code-toolbar></code-toolbar></code-example><p>…При этом, как видно из кода, при простом сравнении наличие такого свойства будет неотличимо от его отсутствия.</p><p>Но оператор <code>in</code> гарантирует правильный результат:</p><code-example><script>`var obj = {};\nobj.test = undefined;\n\nMARKalert( "test" in obj ); // true\nMARKalert( "blabla" in obj ); // false`</script><code-toolbar></code-toolbar></code-example><p>Как правило, в коде мы не будем присваивать <code>undefined</code>, чтобы корректно работали обе проверки. А в качестве значения, обозначающего неизвестность и неопределенность, будем использовать <code>null</code>.</p></important-><h3><a name="8" href="#8">Доступ через квадратные скобки</a></h3><p>Существует альтернативный синтаксис работы со свойствами, использующий квадратные скобки <code>объект['свойство']</code>:</p><code-example><script>`var person = {};\n\nperson['name'] = 'Вася'; // то же что и person.name = 'Вася'`</script><code-toolbar></code-toolbar></code-example><p>Записи <code>person['name']</code> и <code>person.name</code> идентичны, но квадратные скобки позволяют использовать в качестве имени свойства любую строку:</p><code-example><script>`var person = {};\n\nperson['любимый стиль музыки'] = 'Джаз';`</script><code-toolbar></code-toolbar></code-example><p>Такое присвоение было бы невозможно «через точку», так интерпретатор после первого пробела подумает, что свойство закончилось, и далее выдаст ошибку:</p><code-example><script>`person.любимый стиль музыки = 'Джаз'; // ??? ошибка`</script><code-toolbar></code-toolbar></code-example><p>В обоих случаях, <strong>имя свойства обязано быть строкой</strong>. Если использовано значение другого типа – JavaScript приведет его к строке автоматически.</p><h3><a name="9" href="#9">Доступ к свойству через переменную</a></h3><p>Квадратные скобки также позволяют обратиться к свойству, имя которого хранится в переменной:</p><code-example><script>`var person = {};\nperson.age = 25;\nvar key = 'age';\n\nalert( person[key] ); // 25; person['age']`</script><code-toolbar></code-toolbar></code-example><p>Вообще, если имя свойства хранится в переменной (<code>var key = "age"</code>), то единственный способ к нему обратиться – это квадратные скобки <code>person[key]</code>.</p><p>Доступ через точку используется, если мы на этапе написания программы уже знаем название свойства. А если оно будет определено по ходу выполнения, например, введено посетителем и записано в переменную, то единственный выбор – квадратные скобки.</p><h3><a name="10" href="#10">Объявление со свойствами</a></h3><p>Объект можно заполнить значениями при создании, указав их в фигурных скобках: <code>{ ключ1: значение1, ключ2: значение2, ... }</code>.</p><p>Такой синтаксис называется <em>литеральным</em> (англ. literal).</p><p>Следующие два фрагмента кода создают одинаковый объект:</p><code-example><script>`var menuSetup = {\n  width: 300,\n  height: 200,\n  title: \"Menu\"\n};\n\n// то же самое, что:\n\nvar menuSetup = {};\nmenuSetup.width = 300;\nmenuSetup.height = 200;\nmenuSetup.title = 'Menu';`</script></code-example><p>Названия свойств можно перечислять как в кавычках, так и без, если они удовлетворяют ограничениям для имён переменных.</p><p>Например:</p><code-example><script>`var menuSetup = {\n  width: 300,\n  'height': 200,\n  \"мама мыла раму\": true\n};`</script></code-example><p>В качестве значения можно тут же указать и другой объект:</p><code-example><script>`var user = {\n  name: "Таня",\n  age: 25,\nMARK  size: {\nMARK    top: 90,\nMARK    middle: 60,\nMARK    bottom: 90\nMARK  }\n}\n\nalert(user.name) // "Таня"\n\nalert(user.size.top) // 90`</script><code-toolbar></code-toolbar></code-example><p>Здесь значением свойства <code>size</code> является объект <code>{top: 90, middle: 60, bottom: 90 }</code>.</p><h2><a name="3" href="#3">Компактное представление объектов</a></h2><important-warn><h3>Hardcore coders only</h3><p>Эта секция относится ко внутреннему устройству структуры данных. Она не обязательна к прочтению.</p></important-warn><p>Браузер использует специальное «компактное» представление объектов, чтобы сэкономить память в том случае, когда однотипных объектов много.</p><p>Например, посмотрим на такой объект:</p><code-example><script>`var user = {\n  name: "Vasya",\n  age: 25\n};`</script></code-example><p>Здесь содержится информация о свойстве <code>name</code> и его строковом значении, а также о свойстве <code>age</code> и его численном значении. Представим, что таких объектов много.</p><p>Получится, что информация об именах свойств <code>name</code> и <code>age</code> дублируется в каждом объекте. Чтобы этого избежать, браузер применяет оптимизацию.</p><p><strong>При создании множества объектов одного и того же вида (с одинаковыми полями) интерпретатор выносит описание полей в отдельную структуру. А сам объект остаётся в виде непрерывной области памяти с данными.</strong></p><p>Например, есть много объектов с полями <code>name</code> и <code>age</code>:</p><code-example><script>`{name: "Вася", age: 25}\n{name: "Петя", age: 22}\n{name: "Маша", age: 19}\n...`</script></code-example><p>Для их эффективного хранения будет создана структура, которая описывает данный вид объектов. Выглядеть она будет примерно так: <code>&lt;string name, number age&gt;</code>. А сами объекты будут представлены в памяти только данными:</p><code-example><script>`<структура: string name, number age>\nВася 25\nПетя 22\nМаша 19`</script></code-example><p>При добавлении нового объекта такой структуры достаточно хранить значения полей, но не их имена. Экономия памяти – налицо.</p><p>А что происходит, если к объекту добавляется новое свойство? Например, к одному из них добавили свойство <code>isAdmin</code>:</p><code-example><script>`user.isAdmin = true;`</script></code-example><p>В этом случае браузер смотрит, есть ли уже структура, под которую подходит такой объект. Если нет – она создаётся и объект привязывается к ней.</p><p><strong>Эта оптимизация является примером того, что далеко не всё то, что мы пишем, один-в-один переносится в память.</strong></p><p>Современные интерпретаторы очень стараются оптимизировать как код, так и структуры данных. Детали применения и реализации этого способа хранения варьируются от браузера к браузеру. О том, как это сделано в Chrome можно узнать, например, из презентации <a href="http://www.slideshare.net/newmovie/know-yourengines-velocity2011">Know Your Engines</a>. Она была некоторое время назад, но с тех пор мало что изменилось.</p><h2><a name="4" href="#4">Итого</a></h2><p>Объекты – это ассоциативные массивы с дополнительными возможностями:</p><ul><li>Доступ к элементам осуществляется:<ul><li>Напрямую по ключу <code>obj.prop = 5</code></li><li>Через переменную, в которой хранится ключ:<code-example><script>`var key = "prop";\nobj[key] = 5`</script></code-example></li></ul></li><li>Удаление ключей: <code>delete obj.name</code>.</li><li>Существование свойства может проверять оператор <code>in</code>: <code>if ("prop" in obj)</code>, как правило, работает и просто сравнение <code>if (obj.prop !== undefined)</code>.</li></ul><h2 id="tasks"><a href="#5" name="5">Задачи (1)</a></h2><task-content><h3><a href="#12" name="12">Первый объект</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 3</span><p>Мини-задача на синтаксис объектов. Напишите код, по строке на каждое действие.</p><ol><li>Создайте пустой объект <code>user</code>.</li><li>Добавьте свойство <code>name</code> со значением <code>Вася</code>.</li><li>Добавьте свойство <code>surname</code> со значением <code>Петров</code>.</li><li>Поменяйте значение <code>name</code> на <code>Сергей</code>.</li><li>Удалите свойство <code>name</code> из объекта.</li></ol><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`var user = {};\nuser.name = "Вася";\nuser.surname = "Петров";\nuser.name = "Сергей";\ndelete user.name;`</script></code-example></task-answer></task-content><!--  include /blocks/banner-bottom--><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en--><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Строки; Объекты: перебор свойств"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/object",disqus_identifier="object",disqus_title="\u041e\u0431\u044a\u0435\u043a\u0442\u044b \u043a\u0430\u043a \u0430\u0441\u0441\u043e\u0446\u0438\u0430\u0442\u0438\u0432\u043d\u044b\u0435 \u043c\u0430\u0441\u0441\u0438\u0432\u044b";</script></page-content></main>