<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="34">Структуры данных</a></nav-up><h1>Массивы с числовыми индексами</h1><p><em>Массив</em> – разновидность объекта, которая предназначена для хранения пронумерованных значений и предлагает дополнительные методы для удобного манипулирования такой коллекцией.</p><p>Они обычно используются для хранения упорядоченных коллекций данных, например – списка товаров на странице, студентов в группе и т.п.</p><h2><a name="0" href="#0">Объявление</a></h2><p>Синтаксис для создания нового массива – квадратные скобки со списком элементов внутри.</p><p>Пустой массив:</p><code-example><script>`var arr = [];`</script></code-example><p>Массив <code>fruits</code> с тремя элементами:</p><code-example><script>`var fruits = ["Яблоко", "Апельсин", "Слива"];`</script></code-example><p><strong>Элементы нумеруются, начиная с нуля.</strong></p><p>Чтобы получить нужный элемент из массива – указывается его номер в квадратных скобках:</p><code-example><script>`var fruits = ["Яблоко", "Апельсин", "Слива"];\n\nalert( fruits[0] ); // Яблоко\nalert( fruits[1] ); // Апельсин\nalert( fruits[2] ); // Слива`</script><code-toolbar></code-toolbar></code-example><p>Элемент можно всегда заменить:</p><code-example><script>`fruits[2] = \'Груша\'; // теперь ["Яблоко", "Апельсин", "Груша"]`</script></code-example><p>…Или добавить:</p><code-example><script>`fruits[3] = \'Лимон\'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]`</script></code-example><p>Общее число элементов, хранимых в массиве, содержится в его свойстве <code>length</code>:</p><code-example><script>`var fruits = ["Яблоко", "Апельсин", "Груша"];\n\nalert( fruits.length ); // 3`</script><code-toolbar></code-toolbar></code-example><p><strong>Через <code>alert</code> можно вывести и массив целиком.</strong></p><p>При этом его элементы будут перечислены через запятую:</p><code-example><script>`var fruits = ["Яблоко", "Апельсин", "Груша"];\n\nalert( fruits ); // Яблоко,Апельсин,Груша`</script><code-toolbar></code-toolbar></code-example><p><strong>В массиве может храниться любое число элементов любого типа.</strong></p><p>В том числе, строки, числа, объекты, вот например:</p><code-example><script>`// микс значений\nvar arr = [ 1, 'Имя', { name: 'Петя' }, true ];\n\n// получить объект из массива и тут же -- его свойство\nalert( arr[2].name ); // Петя`</script><code-toolbar></code-toolbar></code-example><h2><a name="1" href="#1">Методы pop/push, shift/unshift</a></h2><p>Одно из применений массива – это <a href="http://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C_%28%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%29">очередь</a>. В классическом программировании так называют упорядоченную коллекцию элементов, такую что элементы добавляются в конец, а обрабатываются – с начала.</p><figure><img src="queue.png" style="max-width:187px" width="100%"></figure><p>В реальной жизни эта структура данных встречается очень часто. Например, очередь сообщений, которые надо показать на экране.</p><p>Очень близка к очереди еще одна структура данных: <a href="http://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA">стек</a>. Это такая коллекция элементов, в которой новые элементы добавляются в конец и берутся с конца.</p><figure><img src="stack.png" style="max-width:145px" width="100%"></figure><p>Например, стеком является колода карт, в которую новые карты кладутся сверху, и берутся – тоже сверху.</p><p>Для того, чтобы реализовывать эти структуры данных, и просто для более удобной работы с началом и концом массива существуют специальные методы.</p><h3><a name="10" href="#10">Конец массива</a></h3><dl><dt><code>pop</code></dt><dd><p>Удаляет <em>последний</em> элемент из массива и возвращает его:</p><code-example><script>`var fruits = ["Яблоко", "Апельсин", "Груша"];\n\nalert( fruits.pop() ); // удалили "Груша"\n\nalert( fruits ); // Яблоко, Апельсин`</script><code-toolbar></code-toolbar></code-example></dd><dt><code>push</code></dt><dd><p>Добавляет элемент <em>в конец</em> массива:</p><code-example><script>`var fruits = ["Яблоко", "Апельсин"];\n\nfruits.push("Груша");\n\nalert( fruits ); // Яблоко, Апельсин, Груша`</script><code-toolbar></code-toolbar></code-example><p>Вызов <code>fruits.push(...)</code> равнозначен <code>fruits[fruits.length] = ...</code>.</p></dd></dl><h3><a name="11" href="#11">Начало массива</a></h3><dl><dt><code>shift</code></dt><dd><p>Удаляет из массива <em>первый</em> элемент и возвращает его:</p><code-example><script>`var fruits = ["Яблоко", "Апельсин", "Груша"];\n\nalert( fruits.shift() ); // удалили Яблоко\n\nalert( fruits ); // Апельсин, Груша`</script><code-toolbar></code-toolbar></code-example></dd><dt><code>unshift</code></dt><dd><p>Добавляет элемент <em>в начало</em> массива:</p><code-example><script>`var fruits = ["Апельсин", "Груша"];\n\nfruits.unshift(\'Яблоко\');\n\nalert( fruits ); // Яблоко, Апельсин, Груша`</script><code-toolbar></code-toolbar></code-example></dd></dl><p>Методы <code>push</code> и <code>unshift</code> могут добавлять сразу по несколько элементов:</p><code-example><script>`var fruits = ["Яблоко"];\n\nfruits.push("Апельсин", "Персик");\nfruits.unshift("Ананас", "Лимон");\n\n// результат: ["Ананас", "Лимон", "Яблоко", "Апельсин", "Персик"]\nalert( fruits );`</script><code-toolbar></code-toolbar></code-example><h2><a name="2" href="#2">Внутреннее устройство массива</a></h2><p>Массив – это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством <code>length</code>.</p><p>Так как это объект, то в функцию он передаётся по ссылке:</p><code-example><script>`function eat(arr) {\n  arr.pop();\n}\n\nvar arr = ["нам", "не", "страшен", "серый", "волк"]\n\nalert( arr.length ); // 5\neat(arr);\neat(arr);\nalert( arr.length ); // 3, в функцию массив не скопирован, а передана ссылка`</script><code-toolbar></code-toolbar></code-example><p><strong>Ещё одно следствие – можно присваивать в массив любые свойства.</strong></p><p>Например:</p><code-example><script>`var fruits = []; // создать массив\n\nfruits[99999] = 5; // присвоить свойство с любым номером\n\nfruits.age = 25; // назначить свойство со строковым именем`</script></code-example><p>… Но массивы для того и придуманы в JavaScript, чтобы удобно работать именно <em>с упорядоченными, нумерованными данными</em>. Для этого в них существуют специальные методы и свойство <code>length</code>.</p><p>Как правило, нет причин использовать массив как обычный объект, хотя технически это и возможно.</p><important-warn><h3>Вывод массива с «дырами»</h3><p>Если в массиве есть пропущенные индексы, то при выводе в большинстве браузеров появляются «лишние» запятые, например:</p><code-example><script>`var a = [];\na[0] = 0;\na[5] = 5;\n\nalert( a ); // 0,,,,,5`</script><code-toolbar></code-toolbar></code-example><p>Эти запятые появляются потому, что алгоритм вывода массива идёт от <code>0</code> до <code>arr.length</code> и выводит всё через запятую. Отсутствие значений даёт несколько запятых подряд.</p></important-warn><h3><a name="13" href="#13">Влияние на быстродействие</a></h3><p>Методы <code>push/pop</code> выполняются быстро, а <code>shift/unshift</code> – медленно.</p><figure><img src="array-speed.png" style="max-width:354px" width="100%"></figure><p>Чтобы понять, почему работать с концом массива – быстрее, чем с его началом, разберём подробнее происходящее при операции:</p><code-example><script>`fruits.shift(); // убрать 1 элемент с начала`</script></code-example><p>При этом, так как все элементы находятся в своих ячейках, просто удалить элемент с номером <code>0</code> недостаточно. Нужно еще и переместить остальные элементы на их новые индексы.</p><p>Операция <code>shift</code> должна выполнить целых три действия:</p><ol><li>Удалить нулевой элемент.</li><li>Переместить все свойства влево, с индекса <code>1</code> на <code>0</code>, с <code>2</code> на <code>1</code> и так далее.</li><li>Обновить свойство <code>length</code>.</li></ol><figure><img src="/article/array/array-shift.png" style="max-width:610px" width="100%"></figure><p><strong>Чем больше элементов в массиве, тем дольше их перемещать, это много операций с памятью.</strong></p><p>Аналогично работает <code>unshift</code>: чтобы добавить элемент в начало массива, нужно сначала перенести вправо, в увеличенные индексы, все существующие.</p><p>А что же с <code>push/pop</code>? Им как раз перемещать ничего не надо. Для того, чтобы удалить элемент, метод <code>pop</code> очищает ячейку и уменьшает значение <code>length</code>.</p><p>Действия при операции:</p><code-example><script>`fruits.pop(); // убрать 1 элемент с конца`</script></code-example><figure><img src="/article/array/array-pop.png" style="max-width:479px" width="100%"></figure><p><strong>Перемещать при <code>pop</code> не требуется, так как прочие элементы после этой операции остаются на тех же индексах.</strong></p><p>Аналогично работает <code>push</code>.</p><h2><a name="3" href="#3">Перебор элементов</a></h2><p>Для перебора элементов обычно используется цикл:</p><code-example><script>`var arr = ["Яблоко", "Апельсин", "Груша"];\n\nMARKfor (var i = 0; i < arr.length; i++) {\nMARK  alert( arr[i] );\nMARK}`</script><code-toolbar></code-toolbar></code-example><important-warn><h3>Не используйте <code>for..in</code> для массивов</h3><p>Так как массив является объектом, то возможен и вариант <code>for..in</code>:</p><code-example><script>`var arr = ["Яблоко", "Апельсин", "Груша"];\n\nMARKfor (var key in arr) {\n  alert( arr[key] ); // Яблоко, Апельсин, Груша\n}`</script><code-toolbar></code-toolbar></code-example><p>Недостатки этого способа:</p><ol><li><p>Цикл <code>for..in</code> выведет <em>все свойства</em> объекта, а не только цифровые.</p><p>В браузере, при работе с объектами страницы, встречаются коллекции элементов, которые по виду как массивы, но имеют дополнительные нецифровые свойства. При переборе таких «похожих на массив» коллекций через <code>for..in</code> эти свойства будут выведены, а они как раз не нужны.</p><p>Бывают и библиотеки, которые предоставляют такие коллекции. Классический <code>for</code> надёжно выведет только цифровые свойства, что обычно и требуется.</p></li><li><p>Цикл <code>for (var i=0; i&lt;arr.length; i++)</code> в современных браузерах выполняется в 10-100 раз быстрее. Казалось бы, по виду он сложнее, но браузер особым образом оптимизирует такие циклы.</p></li></ol><p>Если коротко: цикл <code>for(var i=0; i&lt;arr.length...)</code> надёжнее и быстрее.</p></important-warn><h2><a name="4" href="#4">Особенности работы length</a></h2><p>Встроенные методы для работы с массивом автоматически обновляют его длину <code>length</code>.</p><p><strong>Длина <code>length</code> – не количество элементов массива, а <code>последний индекс + 1</code></strong>.</p><p>Так уж оно устроено.</p><p>Это легко увидеть на следующем примере:</p><code-example><script>`var arr = [];\narr[1000] = true;\n\nalert(arr.length); // HIGH1001LIGHT`</script><code-toolbar></code-toolbar></code-example><p>Кстати, если у вас элементы массива нумеруются случайно или с большими пропусками, то стоит подумать о том, чтобы использовать обычный объект. Массивы предназначены именно для работы с непрерывной упорядоченной коллекцией элементов.</p><h3><a name="15" href="#15">Используем length для укорачивания массива</a></h3><p>Обычно нам не нужно самостоятельно менять <code>length</code>… Но есть один фокус, который можно провернуть.</p><p><strong>При уменьшении <code>length</code> массив укорачивается.</strong></p><p>Причем этот процесс необратимый, т.е. даже если потом вернуть <code>length</code> обратно – значения не восстановятся:</p><code-example><script>`var arr = [1, 2, 3, 4, 5];\n\narr.length = 2; // укоротить до 2 элементов\nalert( arr ); // [1, 2]\n\narr.length = 5; // вернуть length обратно, как было\nalert( arr[3] ); // undefined: значения не вернулись`</script><code-toolbar></code-toolbar></code-example><p>Самый простой способ очистить массив – это <code>arr.length=0</code>.</p><h2><a name="5" href="#5">Создание вызовом new Array</a></h2><h3><a name="16" href="#16">new Array()</a></h3><p>Существует еще один синтаксис для создания массива:</p><code-example><script>`var arr = HIGHnew ArrayLIGHT("Яблоко", "Груша", "и т.п.");`</script></code-example><p>Он редко используется, т.к. квадратные скобки <code>[]</code> короче.</p><p>Кроме того, у него есть одна особенность. Обычно <code>new Array(элементы, ...)</code> создаёт массив из данных элементов, но если у него один аргумент-число <code>new Array(число)</code>, то он создает массив <em>без элементов, но с заданной длиной</em>.</p><p>Проверим это:</p><code-example><script>`var arr = new Array(2, 3);\nalert( arr[0] ); // 2, создан массив [2, 3], всё ок\n\nMARKarr = new Array(2); // создаст массив [2] ?\nMARKalert( arr[0] ); // undefined! у нас массив без элементов, длины 2`</script><code-toolbar></code-toolbar></code-example><p>Что же такое этот «массив без элементов, но с длиной»? Как такое возможно?</p><p>Оказывается, очень даже возможно и соответствует объекту <code>{length: 2}</code>. Получившийся массив ведёт себя так, как будто его элементы равны <code>undefined</code>.</p><p>Это может быть неожиданным сюрпризом, поэтому обычно используют квадратные скобки.</p><h3><a name="17" href="#17">Многомерные массивы</a></h3><p>Массивы в JavaScript могут содержать в качестве элементов другие массивы. Это можно использовать для создания многомерных массивов, например матриц:</p><code-example><script>`var matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n];\n\nalert( matrix[1][1] ); // центральный элемент`</script><code-toolbar></code-toolbar></code-example><h2><a name="6" href="#6">Внутреннее представление массивов</a></h2><important-warn><h3>Hardcore coders only</h3><p>Эта секция относится ко внутреннему устройству структуры данных и требует специальных знаний. Она не обязательна к прочтению.</p></important-warn><p>Числовые массивы, согласно спецификации, являются объектами, в которые добавили ряд свойств, методов и автоматическую длину <code>length</code>. Но внутри они, как правило, устроены по-другому.</p><p><strong>Современные интерпретаторы стараются оптимизировать их и хранить в памяти не в виде хэш-таблицы, а в виде непрерывной области памяти, по которой легко пробежаться от начала до конца.</strong></p><p>Операции с массивами также оптимизируются, особенно если массив хранит только один тип данных, например только числа. Порождаемый набор инструкций для процессора получается очень эффективным.</p><p>Чтобы у интерпретатора получались эти оптимизации, программист не должен мешать.</p><p>В частности:</p><ul><li>Не ставить массиву произвольные свойства, такие как <code>arr.test = 5</code>. То есть, работать именно как с массивом, а не как с объектом.</li><li>Заполнять массив непрерывно и по возрастающей. Как только браузер встречает необычное поведение массива, например устанавливается значение <code>arr[0]</code>, а потом сразу <code>arr[1000]</code>, то он начинает работать с ним, как с обычным объектом. Как правило, это влечёт преобразование его в хэш-таблицу.</li></ul><p>Если следовать этим принципам, то массивы будут занимать меньше памяти и быстрее работать.</p><h2><a name="7" href="#7">Итого</a></h2><p>Массивы существуют для работы с упорядоченным набором элементов.</p><p><strong>Объявление:</strong></p><code-example><script>`// предпочтительное\nvar arr = [элемент1, элемент2...];\n\n// new Array\nvar arr = new Array(элемент1, элемент2...);`</script></code-example><p>При этом <code>new Array(число)</code> создаёт массив заданной длины, <em>без элементов</em>. Чтобы избежать ошибок, предпочтителен первый синтаксис.</p><p><strong>Свойство <code>length</code></strong> – длина массива. Если точнее, то последний индекс массива плюс <code>1</code>. Если её уменьшить вручную, то массив укоротится. Если <code>length</code> больше реального количества элементов, то отсутствующие элементы равны <code>undefined</code>.</p><p>Массив можно использовать как очередь или стек.</p><p><strong>Операции с концом массива:</strong></p><ul><li><code>arr.push(элемент1, элемент2...)</code> добавляет элементы в конец.</li><li><code>var elem = arr.pop()</code> удаляет и возвращает последний элемент.</li></ul><p><strong>Операции с началом массива:</strong></p><ul><li><code>arr.unshift(элемент1, элемент2...)</code> добавляет элементы в начало.</li><li><code>var elem = arr.shift()</code> удаляет и возвращает первый элемент.</li></ul><p>Эти операции перенумеровывают все элементы, поэтому работают медленно.</p><p>В следующей главе мы рассмотрим другие методы для работы с массивами.</p><h2 id="tasks"><a href="#8" name="8">Задачи (10)</a></h2><task-content><h3><a href="#19" name="19">Получить последний элемент массива</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Как получить последний элемент из произвольного массива?</p><p>У нас есть массив <code>goods</code>. Сколько в нем элементов – не знаем, но можем прочитать из <code>goods.length</code>.</p><p>Напишите код для получения последнего элемента <code>goods</code>.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer style=""><close- title="закрыть" data-close_answer=""></close-><p>Последний элемент имеет индекс на <code>1</code> меньший, чем длина массива.</p><p>Например:</p><code-example><script>`var fruits = ["Яблоко", "Груша", "Слива"];`</script></code-example><p>Длина этого массива <code>fruits.length</code> равна <code>3</code>. Здесь «Яблоко» имеет индекс <code>0</code>, «Груша» – индекс <code>1</code>, «Слива» – индекс <code>2</code>.</p><p>То есть, для массива длины <code>goods</code>:</p><code-example><script>`var lastItem = goods[goods.length - 1]; // получить последний элемент`</script></code-example></task-answer></task-content><task-content><h3><a href="#20" name="20">Добавить новый элемент в массив</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Как добавить элемент в конец произвольного массива?</p><p>У нас есть массив <code>goods</code>. Напишите код для добавления в его конец значения «Компьютер».</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer style=""><close- title="закрыть" data-close_answer=""></close-><p>Текущий последний элемент имеет индекс <code>goods.length-1</code>. Значит, индексом нового элемента будет <code>goods.length</code>:</p><code-example><script>`goods[goods.length] = 'Компьютер'`</script></code-example></task-answer></task-content><task-content><h3><a href="#21" name="21">Создание массива</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Задача из 5 шагов-строк:</p><ol><li>Создайте массив <code>styles</code> с элементами «Джаз», «Блюз».</li><li>Добавьте в конец значение «Рок-н-Ролл»</li><li>Замените предпоследнее значение с конца на «Классика». Код замены предпоследнего значения должен работать для массивов любой длины.</li><li>Удалите первое значение массива и выведите его <code>alert</code>.</li><li>Добавьте в начало значения «Рэп» и «Регги».</li></ol><p>Массив в результате каждого шага:</p><code-example><script>`Джаз, Блюз\nДжаз, Блюз, Рок-н-Ролл\nДжаз, Классика, Рок-н-Ролл\nКлассика, Рок-н-Ролл\nРэп, Регги, Классика, Рок-н-Ролл`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`var styles = ["Джаз", "Блюз"];\nstyles.push("Рок-н-Ролл");\nstyles[styles.length - 2] = "Классика";\nalert( styles.shift() );\nstyles.unshift("Рэп", "Регги");`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#22" name="22">Получить случайное значение из массива</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 3</span><p>Напишите код для вывода <code>alert</code> случайного значения из массива:</p><code-example><script>`var arr = ["Яблоко", "Апельсин", "Груша", "Лимон"];`</script></code-example><p>P.S. Код для генерации случайного целого от <code>min</code> to <code>max</code> включительно:</p><code-example><script>`var rand = min + Math.floor(Math.random() * (max + 1 - min));`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Для вывода нужен случайный номер от <code>0</code> до <code>arr.length-1</code> включительно.</p><code-example><script>`var arr = ["Яблоко", "Апельсин", "Груша", "Лимон"];\n\nvar rand = Math.floor(Math.random() * arr.length);\n\nalert( arr[rand] );`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#23" name="23">Создайте калькулятор для введённых значений</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>Напишите код, который:</p><ul><li>Запрашивает по очереди значения при помощи <code>prompt</code> и сохраняет их в массиве.</li><li>Заканчивает ввод, как только посетитель введёт пустую строку, не число или нажмёт «Отмена».</li><li>При этом ноль <code>0</code> не должен заканчивать ввод, это разрешённое число.</li><li>Выводит сумму всех значений массива</li></ul><p><a data-click="run_5">Запустить демо</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>В решение ниже обратите внимание: мы не приводим <code>value</code> к числу сразу после <code>prompt</code>, так как если сделать <code>value = +value</code>, то после этого отличить пустую строку от нуля уже никак нельзя. А нам здесь нужно при пустой строке прекращать ввод, а при нуле – продолжать.</p><code-example><script>`var numbers = [];\n\nwhile (true) {\n\n  var value = prompt("Введите число", 0);\n\n  if (value === "" || value === null || isNaN(value)) break;\n\n  numbers.push(+value);\n}\n\nvar sum = 0;\nfor (var i = 0; i < numbers.length; i++) {\n  sum += numbers[i];\n}\n\nalert( sum );`</script><code-toolbar-><a id="run_5" title="показать" data-code_run=""></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example></task-answer></task-content><task-content><h3><a href="#24" name="24">Чему равен элемент массива?</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 3</span><p>Что выведет этот код?</p><code-example><script>`var arr = [1, 2, 3];\n\nvar arr2 = arr;\narr2[0] = 5;\n\nMARKalert( arr[0] );\nMARKalert( arr2[0] );`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`var arr = [1, 2, 3];\n\nvar arr2 = arr; // (*)\narr2[0] = 5;\n\nalert( arr[0] );\nalert( arr2[0] );`</script><code-toolbar></code-toolbar></code-example><p>Код выведет <code>5</code> в обоих случаях, так как массив является объектом. В строке <code>(*)</code> в переменную <code>arr2</code> копируется ссылка на него, а сам объект в памяти по-прежнему один, в нём отражаются изменения, внесенные через <code>arr2</code> или <code>arr</code>.</p><p>В частности, сравнение <code>arr2 == arr</code> даст <code>true</code>.</p><p>Если нужно именно скопировать массив, то это можно сделать, например, так:</p><code-example><script>`var arr2 = [];\nfor (var i = 0; i < arr.length; i++) arr2[i] = arr[i];`</script></code-example></task-answer></task-content><task-content><h3><a href="#25" name="25">Поиск в массиве</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 3</span><p>Создайте функцию <code>find(arr, value)</code>, которая ищет в массиве <code>arr</code> значение <code>value</code> и возвращает его номер, если найдено, или <code>-1</code>, если не найдено.</p><p>Например:</p><code-example><script>`arr = ["test", 2, 1.5, false];\n\nfind(arr, "test"); // 0\nfind(arr, 2); // 1\nfind(arr, 1.5); // 2\n\nfind(arr, 0); // -1`</script></code-example><code-example style="display:none;"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n    // ...Ваш код...\n  <\/script>\n  <script>\n    describe("find", function() {\n\n      describe("возвращает позицию, на которой найден элемент", function() {\n        it("в массиве [1,2,3] находит 1 на позиции 0", function() {\n          assert.equal(find([1, 2, 3], 1), 0);\n        });\n        it("в массиве [1,2,3] находит 2 на позиции 1", function() {\n          assert.equal(find([1, 2, 3], 2), 1);\n        });\n        it("в массиве [1,2,3] находит 3 на позиции 2", function() {\n          assert.equal(find([1, 2, 3], 3), 2);\n        });\n      });\n\n      it("если элемент не найден, возвращает -1", function() {\n        assert.equal(find([1, 2, 3], 0), -1);\n      });\n\n      it("отличает false или null от 0", function() {\n        assert.equal(find([false, true, null], 0), -1);\n      });\n\n      it("отличает 1 от true", function() {\n        assert.equal(find([1, 2, 3], true), -1);\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="task_7" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="task_7">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Возможное решение:</p><code-example><script>`function find(array, value) {\n\n  for (var i = 0; i < array.length; i++) {\n    if (array[i] == value) return i;\n  }\n\n  return -1;\n}`</script></code-example><p>Однако, в нем ошибка, т.к. сравнение <code>==</code> не различает <code>0</code> и <code>false</code>.</p><p>Поэтому лучше использовать <code>===</code>. Кроме того, в современном стандарте JavaScript существует встроенная функция <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf">Array#indexOf</a>, которая работает именно таким образом. Имеет смысл ей воспользоваться, если браузер ее поддерживает.</p><code-example><script>`function find(array, value) {\n  if (array.indexOf) { // если метод существует\n    return array.indexOf(value);\n  }\n\n  for (var i = 0; i < array.length; i++) {\n    if (array[i] === value) return i;\n  }\n\n  return -1;\n}\n\nvar arr = ["a", -1, 2, "b"];\n\nvar index = find(arr, 2);\n\nalert( index );`</script><code-toolbar></code-toolbar></code-example><p>… Но еще лучшим вариантом было бы определить <code>find</code> по-разному в зависимости от поддержки браузером метода <code>indexOf</code>:</p><code-example><script>`// создаем пустой массив и проверяем поддерживается ли indexOf\nif ([].indexOf) {\n\n  var find = function(array, value) {\n    return array.indexOf(value);\n  }\n\n} else {\n  var find = function(array, value) {\n    for (var i = 0; i < array.length; i++) {\n      if (array[i] === value) return i;\n    }\n\n    return -1;\n  }\n\n}`</script></code-example><p>Этот способ – лучше всего, т.к. не требует при каждом запуске <code>find</code> проверять поддержку <code>indexOf</code>.</p><code-example style="display:none;"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n    function find(array, value) {\n      if (array.indexOf) { // если метод существует\n        return array.indexOf(value);\n      }\n    \n      for (var i = 0; i < array.length; i++) {\n        if (array[i] === value) return i;\n      }\n    \n      return -1;\n    }\n  <\/script>\n  <script>\n    describe("find", function() {\n\n      describe("возвращает позицию, на которой найден элемент", function() {\n        it("в массиве [1,2,3] находит 1 на позиции 0", function() {\n          assert.equal(find([1, 2, 3], 1), 0);\n        });\n        it("в массиве [1,2,3] находит 2 на позиции 1", function() {\n          assert.equal(find([1, 2, 3], 2), 1);\n        });\n        it("в массиве [1,2,3] находит 3 на позиции 2", function() {\n          assert.equal(find([1, 2, 3], 3), 2);\n        });\n      });\n\n      it("если элемент не найден, возвращает -1", function() {\n        assert.equal(find([1, 2, 3], 0), -1);\n      });\n\n      it("отличает false или null от 0", function() {\n        assert.equal(find([false, true, null], 0), -1);\n      });\n\n      it("отличает 1 от true", function() {\n        assert.equal(find([1, 2, 3], true), -1);\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="answer_7" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="answer_7">Открыть решение с тестами в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#26" name="26">Фильтр диапазона</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 3</span><p>Создайте функцию <code>filterRange(arr, a, b)</code>, которая принимает массив чисел <code>arr</code> и возвращает новый массив, который содержит только числа из <code>arr</code> из диапазона от <code>a</code> до <code>b</code>. То есть, проверка имеет вид <code>a ≤ arr[i] ≤ b</code>.Функция не должна менять <code>arr</code>.</p><p>Пример работы:</p><code-example><script>`var arr = [5, 4, 3, 8, 0];\n\nvar filtered = filterRange(arr, 3, 5);\n// теперь filtered = [5, 4, 3]\n// arr не изменился`</script></code-example><code-example style="display:none;"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n    // ...Ваш код...\n  <\/script>\n  <script>\n    describe("filterRange", function() {\n      it("не меняет исходный массив", function() {\n        var arr = [5, 4, 3, 8, 0];\n\n        filterRange(arr, 0, 10);\n        assert.deepEqual(arr, [5, 4, 3, 8, 0]);\n      });\n\n      it("оставляет только значения указанного интервала", function() {\n        var arr = [5, 4, 3, 8, 0];\n\n        var result = filterRange(arr, 3, 5);\n        assert.deepEqual(result, [5, 4, 3]);\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="task_8" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="task_8">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="" style="">Алгоритм решения</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Алгоритм решения</h4><ol><li>Создайте временный пустой массив <code>var results = []</code>.</li><li>Пройдите по элементам <code>arr</code> в цикле и заполните его.</li><li>Возвратите <code>results</code>.</li></ol></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Pешениe</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Решение</h4><code-example><script>`function filterRange(arr, a, b) {\n  var result = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i] >= a && arr[i] <= b) {\n      result.push(arr[i]);\n    }\n  }\n\n  return result;\n}\n\nvar arr = [5, 4, 3, 8, 0];\n\nvar filtered = filterRange(arr, 3, 5);\nalert( filtered );`</script><code-toolbar></code-toolbar></code-example><code-example style="display:none;"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n    function filterRange(arr, a, b) {\n      var result = [];\n    \n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] >= a && arr[i] <= b) {\n          result.push(arr[i]);\n        }\n      }\n    \n      return result;\n    }\n  <\/script>\n  <script>\n    describe("filterRange", function() {\n      it("не меняет исходный массив", function() {\n        var arr = [5, 4, 3, 8, 0];\n\n        filterRange(arr, 0, 10);\n        assert.deepEqual(arr, [5, 4, 3, 8, 0]);\n      });\n\n      it("оставляет только значения указанного интервала", function() {\n        var arr = [5, 4, 3, 8, 0];\n\n        var result = filterRange(arr, 3, 5);\n        assert.deepEqual(result, [5, 4, 3]);\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="answer_8" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="answer_8">Открыть песочницу с тестами для задачи.</a></p></task-answer></task-answer-ext></task-content><task-content><h3><a href="#27" name="27">Решето Эратосфена</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 3</span><p>Целое число, большее <code>1</code>, называется <em>простым</em>, если оно не делится нацело ни на какое другое, кроме себя и <code>1</code>.</p><p>Древний алгоритм «Решето Эратосфена» для поиска всех простых чисел до <code>n</code> выглядит так:</p><ol><li>Создать список последовательных чисел от <code>2</code> до <code>n</code>: <code>2, 3, 4, ..., n</code>.</li><li>Пусть <code>p=2</code>, это первое простое число.</li><li>Зачеркнуть все последующие числа в списке с разницей в <code>p</code>, т.е. <code>2*p, 3*p, 4*p</code> и т.д. В случае <code>p=2</code> это будут <code>4,6,8...</code>.</li><li>Поменять значение <code>p</code> на первое не зачеркнутое число после <code>p</code>.</li><li>Повторить шаги 3-4 пока <code>p<sup>2</sup> &lt; n</code>.</li><li>Все оставшиеся не зачеркнутыми числа – простые.</li></ol><p>Посмотрите также <a href="https://learn.javascript.ru/task/eratosthenes-sieve/sieve.gif">анимацию алгоритма</a>.</p><p>Реализуйте «Решето Эратосфена» в JavaScript, используя массив.</p><p>Найдите все простые числа до <code>100</code> и выведите их сумму.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Их сумма равна <code>1060</code>.</p><code-example><script>`// шаг 1\nvar arr = [];\n\nfor (var i = 2; i < 100; i++) {\n  arr[i] = true\n}\n\n// шаг 2\nvar p = 2;\n\ndo {\n  // шаг 3\n  for (i = 2 * p; i < 100; i += p) {\n    arr[i] = false;\n  }\n\n  // шаг 4\n  for (i = p + 1; i < 100; i++) {\n    if (arr[i]) break;\n  }\n\n  p = i;\n} while (p * p < 100); // шаг 5\n\n// шаг 6 (готово)\n// посчитать сумму\nvar sum = 0;\nfor (i = 0; i < arr.length; i++) {\n  if (arr[i]) {\n    sum += i;\n  }\n}\n\nalert( sum );`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#28" name="28">Подмассив наибольшей суммы</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 2</span><p>На входе массив чисел, например: <code>arr = [1, -2, 3, 4, -9, 6]</code>.</p><p>Задача – найти непрерывный подмассив <code>arr</code>, сумма элементов которого максимальна.</p><p>Ваша функция должна возвращать только эту сумму.</p><p>Например:</p><code-example><script>`getMaxSubSum([-1, HIGH2, 3LIGHT, -9]) = 5 (сумма выделенных)\ngetMaxSubSum([HIGH2, -1, 2, 3LIGHT, -9]) = 6\ngetMaxSubSum([-1, 2, 3, -9, HIGH11LIGHT]) = 11\ngetMaxSubSum([-2, -1, HIGH1, 2LIGHT]) = 3\ngetMaxSubSum([HIGH100LIGHT, -9, 2, -3, 5]) = 100\ngetMaxSubSum([HIGH1, 2, 3LIGHT]) = 6 (неотрицательные - берем всех)`</script></code-example><p>Если все элементы отрицательные, то не берём ни одного элемента и считаем сумму равной нулю:</p><code-example><script>`getMaxSubSum([-1, -2, -3]) = 0`</script></code-example><p>Постарайтесь придумать решение, которое работает за O(n<sup>2</sup>), а лучше за O(n) операций.</p><code-example style="display:none;"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n    // ...Ваш код...\n  <\/script>\n  <script>\n    describe("getMaxSubSum", function() {\n      it("максимальная подсумма [1, 2, 3] равна 6", function() {\n        assert.equal(getMaxSubSum([1, 2, 3]), 6);\n      });\n\n      it("максимальная подсумма [-1, 2, 3, -9] равна 5", function() {\n        assert.equal(getMaxSubSum([-1, 2, 3, -9]), 5);\n      });\n\n      it("максимальная подсумма [-1, 2, 3, -9, 11] равна 11", function() {\n        assert.equal(getMaxSubSum([-1, 2, 3, -9, 11]), 11);\n      });\n\n      it("максимальная подсумма [-2, -1, 1, 2] равна 3", function() {\n        assert.equal(getMaxSubSum([-2, -1, 1, 2]), 3);\n      });\n\n      it("максимальная подсумма [100, -9, 2, -3, 5] равна 100", function() {\n        assert.equal(getMaxSubSum([100, -9, 2, -3, 5]), 100);\n      });\n\n      it("максимальная подсумма [] равна 0", function() {\n        assert.equal(getMaxSubSum([]), 0);\n      });\n\n      it("максимальная подсумма [-1] равна 0", function() {\n        assert.equal(getMaxSubSum([-1]), 0);\n      });\n\n      it("максимальная подсумма [-1, -2] равна 0", function() {\n        assert.equal(getMaxSubSum([-1, -2]), 0);\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="task_10" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="task_10">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="" style="">Подсказка (медленное решение)</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4 class="task__step-title">Подсказка (медленное решение)</h4><p>Можно просто посчитать для каждого элемента массива все суммы, которые с него начинаются.</p><p>Например, для <code>[-1, 2, 3, -9, 11]</code>:</p><code-example><script>`// Начиная с -1:\n-1\n-1 + 2\n-1 + 2 + 3\n-1 + 2 + 3 + (-9)\n-1 + 2 + 3 + (-9) + 11\n\n// Начиная с 2:\n2\n2 + 3\n2 + 3 + (-9)\n2 + 3 + (-9) + 11\n\n// Начиная с 3:\n3\n3 + (-9)\n3 + (-9) + 11\n\n// Начиная с -9\n-9\n-9 + 11\n\n// Начиная с 11\n11`</script></code-example><p>Сделайте вложенный цикл, который на внешнем уровне бегает по элементам массива, а на внутреннем – формирует все суммы элементов, которые начинаются с текущей позиции.</p></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Медленное решение</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4 class="task__step-title">Медленное решение</h4><p>Решение через вложенный цикл:</p><code-example><script>`function getMaxSubSum(arr) {\n  var maxSum = 0; // если совсем не брать элементов, то сумма 0\n\n  for (var i = 0; i < arr.length; i++) {\n    var sumFixedStart = 0;\n    for (var j = i; j < arr.length; j++) {\n      sumFixedStart += arr[j];\n      maxSum = Math.max(maxSum, sumFixedStart);\n    }\n  }\n\n  return maxSum;\n}\n\nalert( getMaxSubSum([-1, 2, 3, -9]) ); // 5\nalert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11\nalert( getMaxSubSum([-2, -1, 1, 2]) ); // 3\nalert( getMaxSubSum([1, 2, 3]) ); // 6\nalert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100`</script><code-toolbar></code-toolbar></code-example><p>Такое решение имеет <a href="http://ru.wikipedia.org/wiki/%C2%ABO%C2%BB_%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%BE%D0%B5_%D0%B8_%C2%ABo%C2%BB_%D0%BC%D0%B0%D0%BB%D0%BE%D0%B5">оценку сложности</a> O(n<sup>2</sup>), то есть при увеличении массива в 2 раза алгоритм требует в 4 раза больше времени. На больших массивах (1000, 10000 и более элементов) такие алгоритмы могут приводить к серьёзным «тормозам».</p></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Подсказка (быстрое решение)</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4 class="task__step-title">Подсказка (быстрое решение)</h4><p>Будем идти по массиву и накапливать в некоторой переменной <code>s</code> текущую частичную сумму. Если в какой-то момент s окажется отрицательной, то мы просто присвоим <code>s=0</code>. Утверждается, что максимум из всех значений переменной s, случившихся за время работы, и будет ответом на задачу.</p><p><strong>Докажем этот алгоритм.</strong></p><p>В самом деле, рассмотрим первый момент времени, когда сумма <code>s</code> стала отрицательной. Это означает, что, стартовав с нулевой частичной суммы, мы в итоге пришли к отрицательной частичной сумме – значит, и весь этот префикс массива, равно как и любой его суффикс имеют отрицательную сумму.</p><p>Следовательно, от всего этого префикса массива в дальнейшем не может быть никакой пользы: он может дать только отрицательную прибавку к ответу.</p></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Быстрое решение</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4 class="task__step-title">Быстрое решение</h4><code-example><script>`function getMaxSubSum(arr) {\n  var maxSum = 0,\n    partialSum = 0;\n  for (var i = 0; i < arr.length; i++) {\n    partialSum += arr[i];\n    maxSum = Math.max(maxSum, partialSum);\n    if (partialSum < 0) partialSum = 0;\n  }\n  return maxSum;\n}\n\nalert( getMaxSubSum([-1, 2, 3, -9]) ); // 5\nalert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11\nalert( getMaxSubSum([-2, -1, 1, 2]) ); // 3\nalert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100\nalert( getMaxSubSum([1, 2, 3]) ); // 6\nalert( getMaxSubSum([-1, -2, -3]) ); // 0`</script><code-toolbar></code-toolbar></code-example><p>Информацию об алгоритме вы также можете прочитать здесь: <a href="http://e-maxx.ru/algo/maximum_average_segment">http://e-maxx.ru/algo/maximum_average_segment</a> и здесь: <a href="http://en.wikipedia.org/wiki/Maximum_subarray_problem">Maximum subarray problem</a>.</p><p>Этот алгоритм требует ровно одного прохода по массиву, его сложность имеет оценку <code>O(n)</code>.</p><code-example style="display:none;"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n    function getMaxSubSum(arr) {\n      var maxSum = 0,\n        partialSum = 0;\n      for (var i = 0; i < arr.length; i++) {\n        partialSum += arr[i];\n        maxSum = Math.max(maxSum, partialSum);\n        if (partialSum < 0) partialSum = 0;\n      }\n      return maxSum;\n    }\n  <\/script>\n  <script>\n    describe("getMaxSubSum", function() {\n      it("максимальная подсумма [1, 2, 3] равна 6", function() {\n        assert.equal(getMaxSubSum([1, 2, 3]), 6);\n      });\n\n      it("максимальная подсумма [-1, 2, 3, -9] равна 5", function() {\n        assert.equal(getMaxSubSum([-1, 2, 3, -9]), 5);\n      });\n\n      it("максимальная подсумма [-1, 2, 3, -9, 11] равна 11", function() {\n        assert.equal(getMaxSubSum([-1, 2, 3, -9, 11]), 11);\n      });\n\n      it("максимальная подсумма [-2, -1, 1, 2] равна 3", function() {\n        assert.equal(getMaxSubSum([-2, -1, 1, 2]), 3);\n      });\n\n      it("максимальная подсумма [100, -9, 2, -3, 5] равна 100", function() {\n        assert.equal(getMaxSubSum([100, -9, 2, -3, 5]), 100);\n      });\n\n      it("максимальная подсумма [] равна 0", function() {\n        assert.equal(getMaxSubSum([]), 0);\n      });\n\n      it("максимальная подсумма [-1] равна 0", function() {\n        assert.equal(getMaxSubSum([-1]), 0);\n      });\n\n      it("максимальная подсумма [-1, -2] равна 0", function() {\n        assert.equal(getMaxSubSum([-1, -2]), 0);\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="answer_10" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="answer_10">Открыть решение с тестами в песочнице.</a></p></task-answer></task-answer-ext></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Объекты: передача по ссылке; Массивы: методы"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/array",disqus_identifier="array",disqus_title="\u041c\u0430\u0441\u0441\u0438\u0432\u044b \u0441 \u0447\u0438\u0441\u043b\u043e\u0432\u044b\u043c\u0438 \u0438\u043d\u0434\u0435\u043a\u0441\u0430\u043c\u0438";</script></page-content></main>