<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="34">Структуры данных</a></nav-up><h1>Массив: перебирающие методы</h1><p>Современный стандарт JavaScript предоставляет много методов для «умного» перебора массивов, которые есть в современных браузерах…</p><p>…Ну а для их поддержки в IE8- просто подключите библиотеку <a href="https://github.com/kriskowal/es5-shim">ES5-shim</a>.</p><h2><a name="0" href="#0">forEach</a></h2><p>Метод <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach">«arr.forEach(callback[, thisArg])»</a> используется для перебора массива.</p><p>Он для каждого элемента массива вызывает функцию <code>callback</code>.</p><p>Этой функции он передаёт три параметра <code>callback(item, i, arr)</code>:</p><ul><li><code>item</code> – очередной элемент массива.</li><li><code>i</code> – его номер.</li><li><code>arr</code> – массив, который перебирается.</li></ul><p>Например:</p><code-example><script>`var arr = ["Яблоко", "Апельсин", "Груша"];\n\narr.forEach(function(item, i, arr) {\n  alert( i + ":&nbsp" + item + " ( массив:&nbsp" + arr + " )&nbsp" );\n});`</script><code-toolbar></code-toolbar></code-example><p>Второй, необязательный аргумент <code>forEach</code> позволяет указать контекст <code>this</code> для <code>callback</code>. Мы обсудим его в деталях чуть позже, сейчас он нам не важен.</p><p>Метод <code>forEach</code> ничего не возвращает, его используют только для перебора, как более «элегантный» вариант, чем обычный цикл <code>for</code>.</p><h2><a name="1" href="#1">filter</a></h2><p>Метод <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/filter">«arr.filter(callback[, thisArg])»</a> используется для <em>фильтрации</em> массива через функцию.</p><p>Он создаёт новый массив, в который войдут только те элементы <code>arr</code>, для которых вызов <code>callback(item, i, arr)</code> возвратит <code>true</code>.</p><p>Например:</p><code-example><script>`var arr = [1, -1, 2, -2, 3];\n\nMARKvar positiveArr = arr.filter(function(number) {\nMARK  return number > 0;\nMARK});\n\nalert( positiveArr ); // 1,2,3`</script><code-toolbar></code-toolbar></code-example><h2><a name="2" href="#2">map</a></h2><p>Метод <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/map">«arr.map(callback[, thisArg])»</a> используется для <em>трансформации</em> массива.</p><p>Он создаёт новый массив, который будет состоять из результатов вызова <code>callback(item, i, arr)</code> для каждого элемента <code>arr</code>.</p><p>Например:</p><code-example><script>`var names = ['HTML', 'CSS', 'JavaScript'];\n\nMARKvar nameLengths = names.map(function(name) {\nMARK  return name.length;\nMARK});\n\n// получили массив с длинами\nalert( nameLengths ); // 4,3,10`</script><code-toolbar></code-toolbar></code-example><h2><a name="3" href="#3">every/some</a></h2><p>Эти методы используются для проверки массива.</p><ul><li>Метод <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every">«arr.every(callback[, thisArg])»</a> возвращает <code>true</code>, если вызов <code>callback</code> вернёт <code>true</code> для <em>каждого</em> элемента <code>arr</code>.</li><li>Метод <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some">«arr.some(callback[, thisArg])»</a> возвращает <code>true</code>, если вызов <code>callback</code> вернёт <code>true</code> для <em>какого-нибудь</em> элемента <code>arr</code>.</li></ul><code-example><script>`var arr = [1, -1, 2, -2, 3];\n\nfunction isPositive(number) {\n  return number > 0;\n}\n\nMARKalert( arr.every(isPositive) ); // false, не все положительные\nMARKalert( arr.some(isPositive) ); // true, есть хоть одно положительное`</script><code-toolbar></code-toolbar></code-example><h2><a name="4" href="#4">reduce/reduceRight</a></h2><p>Метод <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/reduce">«arr.reduce(callback[, initialValue])»</a> используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата.</p><p>Это один из самых сложных методов для работы с массивами. Но его стоит освоить, потому что временами с его помощью можно в несколько строк решить задачу, которая иначе потребовала бы в разы больше места и времени.</p><p>Метод <code>reduce</code> используется для вычисления на основе массива какого-либо единого значения, иначе говорят «для свёртки массива». Чуть далее мы разберём пример для вычисления суммы.</p><p>Он применяет функцию <code>callback</code> по очереди к каждому элементу массива слева направо, сохраняя при этом промежуточный результат.</p><p>Аргументы функции <code>callback(previousValue, currentItem, index, arr)</code>:</p><ul><li><code>previousValue</code> – последний результат вызова функции, он же «промежуточный результат».</li><li><code>currentItem</code> – текущий элемент массива, элементы перебираются по очереди слева-направо.</li><li><code>index</code> – номер текущего элемента.</li><li><code>arr</code> – обрабатываемый массив.</li></ul><p>Кроме <code>callback</code>, методу можно передать «начальное значение» – аргумент <code>initialValue</code>. Если он есть, то на первом вызове значение <code>previousValue</code> будет равно <code>initialValue</code>, а если у <code>reduce</code> нет второго аргумента, то оно равно первому элементу массива, а перебор начинается со второго.</p><p>Проще всего понять работу метода <code>reduce</code> на примере.</p><p>Например, в качестве «свёртки» мы хотим получить сумму всех элементов массива.</p><p>Вот решение в одну строку:</p><code-example><script>`var arr = [1, 2, 3, 4, 5]\n\n// для каждого элемента массива запустить функцию,\n// промежуточный результат передавать первым аргументом далее\nvar result = arr.reduce(function(sum, current) {\n  return sum + current;\n}, 0);\n\nalert( result ); // 15`</script><code-toolbar></code-toolbar></code-example><p>Разберём, что в нём происходит.</p><p>При первом запуске <code>sum</code> – исходное значение, с которого начинаются вычисления, равно нулю (второй аргумент <code>reduce</code>).</p><p>Сначала анонимная функция вызывается с этим начальным значением и первым элементом массива, результат запоминается и передаётся в следующий вызов, уже со вторым аргументом массива, затем новое значение участвует в вычислениях с третьим аргументом и так далее.</p><p>Поток вычислений получается такой</p><figure><img src="reduce.png" width="100%" style="max-width:613px"></figure><p>В виде таблицы где каждая строка – вызов функции на очередном элементе массива:</p><table><thead><tr><th></th><th><code>sum</code></th><th><code>current</code></th><th>результат</th></tr></thead><tbody><tr><th>первый вызов</th><td><code>0</code></td><td><code>1</code></td><td><code>1</code></td></tr><tr><th>второй вызов</th><td><code>1</code></td><td><code>2</code></td><td><code>3</code></td></tr><tr><th>третий вызов</th><td><code>3</code></td><td><code>3</code></td><td><code>6</code></td></tr><tr><th>четвёртый вызов</th><td><code>6</code></td><td><code>4</code></td><td><code>10</code></td></tr><tr><th>пятый вызов</th><td><code>10</code></td><td><code>5</code></td><td><code>15</code></td></tr></tbody></table><p>Как видно, результат предыдущего вызова передаётся в первый аргумент следующего.</p><p>Кстати, полный набор аргументов функции для <code>reduce</code> включает в себя <code>function(sum, current, i, array)</code>, то есть номер текущего вызова <code>i</code> и весь массив <code>arr</code>, но здесь в них нет нужды.</p><p>Посмотрим, что будет, если не указать <code>initialValue</code> в вызове <code>arr.reduce</code>:</p><code-example><script>`var arr = [1, 2, 3, 4, 5]\n\n// убрали 0 в конце\nvar result = arr.reduce(function(sum, current) {\n  return sum + current\n});\n\nalert( result ); // 15`</script><code-toolbar></code-toolbar></code-example><p>Результат – точно такой же! Это потому, что при отсутствии <code>initialValue</code> в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.</p><p>Таблица вычислений будет такая же, за вычетом первой строки.</p><p><strong>Метод <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/reduceRight">arr.reduceRight</a> работает аналогично, но идёт по массиву справа-налево.</strong></p><h2><a name="5" href="#5">Итого</a></h2><p>Мы рассмотрели методы:</p><ul><li><code>forEach</code> – для <em>перебора</em> массива.</li><li><code>filter</code> – для <em>фильтрации</em> массива.</li><li><code>every/some</code> – для <em>проверки</em> массива.</li><li><code>map</code> – для <em>трансформации</em> массива в массив.</li><li><code>reduce/reduceRight</code> – для <em>прохода по массиву с вычислением значения</em>.</li></ul><p>Во многих ситуациях их использование позволяет написать код короче и понятнее, чем обычный перебор через <code>for</code>.</p><h2 id="tasks"><a href="#6" name="6">Задачи (2)</a></h2><task-content><h3><a href="#8" name="8">Перепишите цикл через map</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Код ниже получает из массива строк новый массив, содержащий их длины:</p><code-example><script>`var arr = ["Есть", "жизнь", "на", "Марсе"];\n\nMARKvar arrLength = [];\nMARKfor (var i = 0; i < arr.length; i++) {\nMARK  arrLength[i] = arr[i].length;\nMARK}\n\nalert( arrLength ); // 4,5,2,5`</script><code-toolbar></code-toolbar></code-example><p>Перепишите выделенный участок: уберите цикл, используйте вместо него метод <code>map</code>.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`var arr = ["Есть", "жизнь", "на", "Марсе"];\n\nMARKvar arrLength = arr.map(function(item) {\nMARK  return item.length;\nMARK});\n\nalert( arrLength ); // 4,5,2,5`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#9" name="9">Массив частичных сумм</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 2</span><p>На входе массив чисел, например: <code>arr = [1,2,3,4,5]</code>.</p><p>Напишите функцию <code>getSums(arr)</code>, которая возвращает массив его частичных сумм.</p><p>Иначе говоря, вызов <code>getSums(arr)</code> должен возвращать новый массив из такого же числа элементов, в котором на каждой позиции должна быть сумма элементов <code>arr</code> до этой позиции включительно.</p><p>То есть:</p><code-example><script>`для arr = [ 1, 2, 3, 4, 5 ]\ngetSums( arr ) = [ 1, 1+2, 1+2+3, 1+2+3+4, 1+2+3+4+5 ] = [ 1, 3, 6, 10, 15 ]`</script><code-toolbar></code-toolbar></code-example><p>Еще пример: <code>getSums([-2,-1,0,1]) = [-2,-3,-3,-2]</code>.</p><ul><li>Функция не должна модифицировать входной массив.</li><li>В решении используйте метод <code>arr.reduce</code>.</li></ul><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    // ...Ваш код...\n\n  <\/script>\n  <script>\n    describe("getSums", function() {\n\n      it("частичные суммы [1,2,3,4,5] равны [1,3,6,10,15]", function() {\n        assert.deepEqual(getSums([1, 2, 3, 4, 5]), [1, 3, 6, 10, 15]);\n      });\n\n      it("частичные суммы [-2,-1,0,1] равны [-2,-3,-3,-2]", function() {\n        assert.deepEqual(getSums([-2, -1, 0, 1]), [-2, -3, -3, -2]);\n      });\n\n      it("частичные суммы [] равны []", function() {\n        assert.deepEqual(getSums([]), []);\n      });\n\n      it("частичные суммы [1] равны [1]", function() {\n        assert.deepEqual(getSums([1]), [1]);\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="task_2" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="task_2">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Метод <code>arr.reduce</code> подходит здесь идеально. Достаточно пройтись по массиву слева-направа, накапливая текущую сумму в переменной и, кроме того, добавляя её в результирующий массив.</p><p>Неправильный вариант может выглядеть так:</p><code-example><script>`function getSums(arr) {\n  var result = [];\n  if (!arr.length) return result;\n\n  arr.reduce(function(sum, item) {\n    result.push(sum);\n    return sum + item;\n  });\n\n  return result;\n}\n\nalert(getSums([1,2,3,4,5])); // результат: 1,3,6,10`</script><code-toolbar></code-toolbar></code-example><p>Перед тем, как читать дальше, посмотрите на него внимательно. Заметили, в чём ошибка?</p><p>Если вы его запустите, то обнаружите, что результат не совсем тот. В получившемся массиве всего четыре элемента, отсутствует последняя сумма.</p><p>Это из-за того, что последняя сумма является результатом метода <code>reduce</code>, он на ней заканчивает проход и далее функцию не вызывает, поэтому она оказывается не добавленной в <code>result</code>.</p><p>Исправим это:</p><code-example><script>`function getSums(arr) {\n  var result = [];\n  if (!arr.length) return result;\n\nMARK  var totalSum = arr.reduce(function(sum, item) {\n    result.push(sum);\n    return sum + item;\n  });\nMARK  result.push(totalSum);\n\n  return result;\n}\n\nalert(getSums([1,2,3,4,5])); // HIGH1,3,6,10,15LIGHT\nalert(getSums([-2,-1,0,1])); // HIGH-2,-3,-3,-2LIGHT`</script><code-toolbar></code-toolbar></code-example><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    function getSums(arr) {\n      var result = [];\n      if (!arr.length) return result;\n    \n      var totalSum = arr.reduce(function(sum, item) {\n        result.push(sum);\n        return sum + item;\n      });\n      result.push(totalSum);\n    \n      return result;\n    }\n\n  <\/script>\n  <script>\n    describe("getSums", function() {\n\n      it("частичные суммы [1,2,3,4,5] равны [1,3,6,10,15]", function() {\n        assert.deepEqual(getSums([1, 2, 3, 4, 5]), [1, 3, 6, 10, 15]);\n      });\n\n      it("частичные суммы [-2,-1,0,1] равны [-2,-3,-3,-2]", function() {\n        assert.deepEqual(getSums([-2, -1, 0, 1]), [-2, -3, -3, -2]);\n      });\n\n      it("частичные суммы [] равны []", function() {\n        assert.deepEqual(getSums([]), []);\n      });\n\n      it("частичные суммы [1] равны [1]", function() {\n        assert.deepEqual(getSums([1]), [1]);\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="answer_2" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="answer_2">Открыть решение с тестами в песочнице.</a></p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Массивы: методы; Псевдомассив аргументов 'arguments'"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/array-iteration",disqus_identifier="array-iteration",disqus_title="\u041c\u0430\u0441\u0441\u0438\u0432: \u043f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u044e\u0449\u0438\u0435 \u043c\u0435\u0442\u043e\u0434\u044b";</script></page-content></main>