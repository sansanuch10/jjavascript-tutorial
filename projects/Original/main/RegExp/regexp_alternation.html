<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="219">Регулярные выражения</a></nav-up><h1>Альтернация (или) |</h1><p>Альтернация – термин в регулярных выражениях, которому в русском языке соответствует слово «ИЛИ». Она обозначается символом вертикальной черты <code-pattern>|</code-pattern> и позволяет выбирать между вариантами.</p><p>Например, нам нужно найти языки программирования: HTML, PHP, Java и JavaScript.</p><p>Соответствующее регулярное выражение: <code-pattern>html|php|java(script)?</code-pattern>.</p><p>Пример использования:</p><code-example><script>`var reg = GOLD_/html|php|css|java(script)?/gi_GOLD\n\nvar str = "Сначала появился HTML, затем CSS, потом JavaScript"\n\nalert( str.match(reg) ) // 'HTML', 'CSS', 'JavaScript'`</script><code-toolbar></code-toolbar></code-example><p>Мы уже знаем похожую вещь – квадратные скобки. Они позволяют выбирать между символами, например <code-pattern>gr[ae]y</code-pattern> найдёт <code-match>gray</code-match>, либо <code-match>grey</code-match>.</p><p>Альтернация работает уже не посимвольно, а на уровне фраз и подвыражений. Регэксп <code-pattern>A|B|C</code-pattern> обозначает поиск одного из выражений: <code>A</code>, <code>B</code> или <code>C</code>, причём в качестве выражений могут быть другие, сколь угодно сложные регэкспы.</p><p>Для указания границ альтернации используют скобки <code>(...)</code>, например: <code-pattern>before(XXX|YYY)after</code-pattern> будет искать <code-match>beforeXXXafter</code-match> или <code-match>beforeYYYafter</code-match>.</p><h2 id="tasks"><a href="#0" name="0">Задачи (3)</a></h2><task-content><h3><a href="#2" name="2">Найдите языки программирования</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><p>Существует много языков программирования, например Java, JavaScript, PHP, C, C++.</p><p>Напишите регулярное выражение, которое найдёт их все в строке «Java JavaScript PHP C++ C»</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Сначала неправильный способ.</p><p>Если перечислить языки один за другим через <code>|</code>, то получится совсем не то:</p><code-example><script>`var reg = GOLD_/Java|JavaScript|PHP|C|C\\+\\+/g_GOLD;\n\nvar str = "Java, JavaScript, PHP, C, C++";\n\nalert( str.match(reg) ); // Java,Java,PHP,C,C`</script><code-toolbar></code-toolbar></code-example><p>Как видно, движок регулярных выражений ищет альтернации в порядке их перечисления. То есть, он сначала смотрит, есть ли <code-match>Java</code-match>, а если нет – ищет <code-match>JavaScript</code-match>.</p><p>Естественно, при этом <code-match>JavaScript</code-match> не будет найдено никогда.</p><p>То же самое – с языками <code-match>C</code-match> и <code-match>C++</code-match>.</p><p>Есть два решения проблемы:</p><ol><li>Поменять порядок, чтобы более длинное совпадение проверялось первым: <code-pattern>JavaScript|Java|C\+\+|C|PHP</code-pattern>.</li><li>Соединить длинный вариант с коротким: <code-pattern>Java(Script)?|C(\+\+)?|PHP</code-pattern>.</li></ol><p>В действии:</p><code-example><script>`var reg = GOLD_/Java(Script)?|C(\\+\\+)?|PHP/g_GOLD;\n\nvar str = "Java, JavaScript, PHP, C, C++";\n\nalert( str.match(reg) ); // Java,JavaScript,PHP,C,C++`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#3" name="3">Найдите строки в кавычках</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><p>Найдите в тексте при помощи регэкспа строки в двойных кавычках <code-subject>"..."</code-subject>.</p><p>В строке поддерживается экранирование при помощи слеша – примерно в таком же виде, как в обычных строках JavaScript. То есть, строка может содержать любые символы, экранированные слэшем, в частности: <code-subject>\"</code-subject>, <code-subject>\n</code-subject>, и даже сам слэш в экранированном виде: <code-subject>\\</code-subject>.</p><p>Здесь особо важно, что двойная кавычка после слэша не оканчивает строку, а считается её частью. В этом и состоит основная сложность задачи, которая без этого условия была бы элементарной.</p><p>Пример совпадающих строк:</p><code-example><script>`.. HIGH"test me"LIGHT ..  (обычная строка)\n.. HIGH"Скажи \"Привет\"!"LIGHT ... (строка с кавычками внутри)\n.. HIGH"\r\n\\"LLIGHT ..  (строка со спец. символами и слэшем внутри)`</script></code-example><p>Заметим, что в JavaScript такие строки удобнее всего задавать в одинарных кавычках, и слеши придётся удвоить (в одинарных кавычках они являются экранирующими символами):</p><p>Пример задания тестовой строки в JavaScript:</p><code-example><script>`var str = ' .. "test me" .. "Скажи \\\\"Привет\\\\"!" .. "\\\\r\\\\n\\\\\\\\" .. ';\n\n// эта строка будет такой:\nalert(str); //  .. "test me" .. "Скажи \"Привет\"!" .. "\\r\\n\\" ..`</script><code-toolbar></code-toolbar></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Решение задачи: <code-pattern>/"(\\.|[^"\\])*"/g</code-pattern>.</p><p>То есть:</p><ul><li>Сначала ищем кавычку <code-pattern>"</code-pattern></li><li>Затем, если далее слэш <code-pattern>\\</code-pattern> (удвоение слэша – техническое, для вставки в регэксп, на самом деле там один слэш), то после него также подойдёт любой символ (точка).</li><li>Если не слэш, то берём любой символ, кроме кавычек (которые будут означать конец строки) и слэша (чтобы предотвратить одинокие слэши, сам по себе единственный слэш не нужен, он должен экранировать какой-то символ) <code-pattern>[^"\\]</code-pattern></li><li>…И так жадно, до закрывающей кавычки.</li></ul><p>В действии:</p><code-example><script>`var re = GOLD_/"(\\\\.|[^"\\\\])*"/g_GOLD;\nvar str = '.. "test me" .. "Скажи \\\\"Привет\\\\"!" .. "\\\\r\\\\n\\\\\\\\" ..'_GREEN;\n\nalert( str.match(re) ); // "test me","Скажи \\"Привет\\"!","\\r\\n\\\\"`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#4" name="4">Найдите тег style</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><p>Напишите регулярное выражение, которое будет искать в тексте тег <code>&lt;style&gt;</code>. Подходят как обычный тег <code>&lt;style&gt;</code>, так и вариант с атрибутами <code>&lt;style type="..."&gt;</code>.</p><p>Но регулярное выражение не должно находить <code>&lt;styler&gt;</code>!</p><p>Использование:</p><code-example><script>`var re = ваш регэксп\n\nalert( "<style><styler><style test>".match(re) ); // <style>, <style test>`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Начало шаблона очевидно: <code-pattern>&lt;style</code-pattern>.</p><p>А вот дальше… Мы не можем написать просто <code-pattern>&lt;style.*?&gt;</code-pattern>, так как <code-match>&lt;styler&gt;</code-match> удовлетворяет этому регэкспу.</p><p>Нужно уточнить его. После <code-match>&lt;style</code-match> должен быть либо пробел, после которого может быть что-то ещё, либо закрытие тега.</p><p>На языке регэкспов: <code-pattern>&lt;style(&gt;|\s.*?&gt;)</code-pattern>.</p><p>В действии:</p><code-example><script>`<script>\n  var re = GOLD_/<style(>|\\s.*?>)/g_GOLD;\n\n  alert( "<style><styler><style test>".match(re) ); // <style>, <style test>\n<\/script>`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Обратные ссылки: \n и $n; Начало строки ^ и конец $"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/regexp-alternation", disqus_identifier = "regexp-alternation", disqus_title = "\u0410\u043b\u044c\u0442\u0435\u0440\u043d\u0430\u0446\u0438\u044f (\u0438\u043b\u0438) |";</script></page-content></main>