<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="219">Регулярные выражения</a></nav-up><h1>Классы и спецсимволы</h1><p>Рассмотрим практическую задачу – есть телефонный номер <code>"+7(903)-123-45-67"</code>, и нам нужно найти в этой строке цифры. А остальные символы нас не интересуют.</p><p>Для поиска символов определённого вида в регулярных выражениях предусмотрены «классы символов».</p><p>Класс символов – это специальное обозначение, под которое подходит любой символ из определённого набора.</p><p>Например, есть класс «любая цифра». Он обозначается <code>\d</code>. Это обозначение вставляется в шаблон, и при поиске под него подходит любая цифра.</p><p>То есть, регулярное выражение <code-pattern>/\d/</code-pattern> ищет ровно одну цифру:</p><code-example><script>`var str = "+7(903)-123-45-67";\n\nvar reg = GOLD_/\\d/_GOLD;\n\n// не глобальный регэксп, поэтому ищет только первую цифру\nalert( str.match(reg) ); // 7`</script><code-toolbar></code-toolbar></code-example><p>…Ну а для поиска всех цифр достаточно добавить к регэкспу флаг <code>g</code>:</p><code-example><script>`var str = "+7(903)-123-45-67";\n\nvar reg = GOLD_/\\d/g_GOLD;\n\nalert( str.match(reg) ); // массив всех совпадений: 7,9,0,3,1,2,3,4,5,6,7`</script><code-toolbar></code-toolbar></code-example><h2><a name="0" href="#0">Важнейшие классы: \d \s \w</a></h2><p>Это был класс для цифр.</p><p>Конечно же, есть и другие.</p><p>Наиболее часто используются:</p><dl><dt><code>\d</code> (от английского «digit» – «цифра»)</dt><dd>Цифра, символ от <code>0</code> до <code>9</code>.</dd><dt><code>\s</code> (от английского «space» – «пробел»)</dt><dd>Пробельный символ, включая табы, переводы строки и т.п.</dd><dt><code>\w</code> (от английского «word» – «слово»)</dt><dd>Символ «слова», а точнее – буква латинского алфавита или цифра или подчёркивание <code>'_'</code>. Не-английские буквы не являются <code>\w</code>, то есть русская буква не подходит.</dd></dl><p>Например, <code-pattern>\d\s\w</code-pattern> обозначает цифру, за которой идёт пробельный символ, а затем символ слова.</p><p>Регулярное выражение может содержать одновременно и обычные символы и классы.</p><p>Например, <code-pattern>CSS\d</code-pattern> найдёт строку <code-match>CSS</code-match>, с любой цифрой после неё:</p><code-example><script>`var str = "Стандарт CSS4 - это здорово";\nvar reg = GOLD_/CSS\\d/_GOLD\n\nalert( str.match(reg) ); // CSS4`</script><code-toolbar></code-toolbar></code-example><p>И много классов подряд:</p><code-example><script>`alert( "Я люблю HTML5!".match(GOLD_/\\s\\w\\w\\w\\w\\d/_GOLD) ); // 'HTML5'`</script><code-toolbar></code-toolbar></code-example><p>Совпадение (каждому классу в регэкспе соответствует один символ результата):</p><figure><img src="love-html5-classes.png" alt="" width="100%" style="max-width:187px"></figure><h2><a name="1" href="#1">Граница слова \b</a></h2><p>Граница слова <code-pattern>\b</code-pattern> – это особый класс.</p><p>Он интересен тем, что обозначает не символ, а границу между символами.</p><p>Например, <code-pattern>\bJava\b</code-pattern> найдёт слово <code-match>Java</code-match> в строке <code-subject>Hello, Java!</code-subject>, но не в строке <code-subject>Hello, Javascript!</code-subject>.</p><code-example><script>`alert( "Hello, Java!".match(GOLD_/\\bJava\\b/_GOLD) ); // Java\nalert( "Hello, Javascript!".match(GOLD_/\\bJava\\b/_GOLD) ); // null`</script><code-toolbar></code-toolbar></code-example><p>Граница имеет «нулевую ширину» в том смысле, что обычно символам регулярного выражения соответствуют символы строки, но не в этом случае.</p><p>Граница – это проверка.</p><p>При поиске движок регулярных выражений идёт по шаблону и одновременно по строке, пытаясь построить соответствие. Когда он видит <code-pattern>\b</code-pattern>, то проверяет, что текущая позиция в строке подходит под одно из условий:</p><ul><li>Начало текста, если первый символ <code>\w</code>.</li><li>Конец текста, если последний символ <code>\w</code>.</li><li>Внутри текста, если с одной стороны <code>\w</code>, а с другой – не <code>\w</code>.</li></ul><p>Например, в строке <code-subject>Hello, Java!</code-subject> под <code>\b</code> подходят следующие позиции:</p><figure><img src="hello-java-boundaries.png" alt="" width="100%" style="max-width:201px"></figure><p>Как правило, <code>\b</code> используется, чтобы искать отдельно стоящее слово. Не на русском конечно, хотя подобную проверку, как мы увидим далее, можно легко сделать для любого языка. А вот на английском, как в примере выше или для чисел, которые являются частным случаем <code>\w</code> – легко.</p><p>Например, регэксп <code-pattern>\b\d\d\b</code-pattern> ищет отдельно двузначные числа. Иными словами, он требует, чтобы до и после <code-pattern>\d\d</code-pattern> был символ, отличный от <code>\w</code> (или начало/конец текста).</p><h2><a name="2" href="#2">Обратные классы</a></h2><p>Для каждого класса существует «обратный ему», представленный такой же, но заглавной буквой.</p><p>«Обратный» – означает, что ему соответствуют все остальные символы, например:</p><dl><dt><code>\D</code></dt><dd>Не-цифра, то есть любой символ кроме <code>\d</code>, например буква.</dd><dt><code>\S</code></dt><dd>Не-пробел, то есть любой символ кроме <code>\s</code>, например буква.</dd><dt><code>\W</code></dt><dd>Любой символ, кроме <code>\w</code>, то есть не латинница, не подчёркивание, не цифра. В частности, русские буквы принадлежат этому классу.</dd><dt><code>\B</code></dt><dd>Проверка, обратная <code>\b</code>.</dd></dl><p>В начале этой главы мы видели, как получить из телефона <code-subject>+7(903)-123-45-67</code-subject> все цифры.</p><p>Первый способ – найти все цифры через <code>match(/\d/g)</code>.</p><p>Обратные классы помогут реализовать альтернативный – найти все НЕцифры и удалить их из строки:</p><code-example><script>`var str = "+7(903)-123-45-67";\n\nalert( str.replace(GOLD_/\\D/g_GOLD, "") ); // 79031234567`</script><code-toolbar></code-toolbar></code-example><h2><a name="3" href="#3">Пробелы – обычные символы</a></h2><p>Заметим, что в регулярных выражениях пробел – такой же символ, как и другие.</p><p>Обычно мы не обращаем внимание на пробелы. Для нашего взгляда строки <code-subject>1-5</code-subject> и <code-subject>1 - 5</code-subject> почти идентичны.</p><p>Однако, если регэксп не учитывает пробелов, то он не сработает.</p><p>Попытаемся найти цифры, разделённые дефисом:</p><code-example><script>`\nalert( "1 - 5".match(GOLD_/\\d-\\d/_GOLD) ); // null, нет совпадений!`</script><code-toolbar></code-toolbar></code-example><p>Поправим это, добавив в регэксп пробелы:</p><code-example><script>`\nalert( "1 - 5".match(GOLD_/\\d - \\d/_GOLD) ); // работает, пробелы вокруг дефиса`</script><code-toolbar></code-toolbar></code-example><p>Конечно же, пробелы в регэкспе нужны лишь тогда, когда мы их ищем. Лишние пробелы (как и любые лишние символы) могут навредить:</p><code-example><script>`\nalert( "1-5".match(GOLD_/\\d&nbsp-&nbsp\\d/_GOLD) ); // null, так как в строке 1-5 нет пробелов`</script><code-toolbar></code-toolbar></code-example><p>Короче говоря, в регулярном выражении все символы имеют значение. Даже (и тем более) – пробелы.</p><h2><a name="4" href="#4">Точка – любой символ</a></h2><p>Особым классом символов является точка <code>"."</code>.</p><p>В регулярном выражении, точка <code-pattern>"."</code-pattern> обозначает <em>любой символ</em>, кроме перевода строки:</p><code-example><script>`alert( "Z".match(GOLD_/./_GOLD) ); // найдено Z`</script><code-toolbar></code-toolbar></code-example><p>Посередине регулярного выражения:</p><code-example><script>`var re = GOLD_/CS.4/_GOLD;\n\nalert( "CSS4".match(re) ); // найдено "CSS4"\nalert( "CS-4".match(re) ); // найдено "CS-4"\nalert( "CS 4".match(re) ); // найдено "CS 4" (пробел тоже символ)`</script><code-toolbar></code-toolbar></code-example><p>Обратим внимание – точка означает именно «произвольный символ».</p><p>То есть какой-то символ на этом месте в строке должен быть:</p><code-example><script>`alert( "CS4".match(GOLD_/CS.4/_GOLD) ); // нет совпадений, так как для точки нет символа`</script><code-toolbar></code-toolbar></code-example><h2><a name="5" href="#5">Экранирование специальных символов</a></h2><p>В регулярных выражениях есть и другие символы, имеющие особый смысл.</p><p>Они используются, чтобы расширить возможности поиска.</p><p>Вот их полный список: <code-pattern>[ \ ^ $ . | ? * + ( )</code-pattern>.</p><p>Не пытайтесь запомнить его – когда мы разберёмся с каждым из них по отдельности, он запомнится сам собой.</p><p><strong>Чтобы использовать специальный символ в качестве обычного, он должен быть <em>экранирован</em>.</strong></p><p>Или, другими словами, перед символом должен быть обратный слэш <code>'\'</code>.</p><p>Например, нам нужно найти точку <code-pattern>'.'</code-pattern>. В регулярном выражении она означает «любой символ, кроме новой строки», поэтому чтобы найти именно сам символ «точка» – её нужно экранировать: <code-pattern>\.</code-pattern>.</p><code-example><script>`alert( "Глава 5.1".match(GOLD_/\\d\\.\\d/_GOLD) ); // 5.1`</script><code-toolbar></code-toolbar></code-example><p>Круглые скобки также являются специальными символами, так что для поиска именно скобки нужно использовать <code>\(</code>. Пример ниже ищет строку <code>"g()"</code>:</p><code-example><script>`alert( "function g()".match(GOLD_/g\\(\\)/_GOLD) ); // "g()"`</script><code-toolbar></code-toolbar></code-example><p>Сам символ слэш <code>'/'</code>, хотя и не является специальными символом в регулярных выражениях, но открывает-закрывает регэксп в синтаксисе <code-pattern>/...pattern.../</code-pattern>, поэтому его тоже нужно экранировать.</p><p>Так выглядит поиск слэша <code>'/'</code>:</p><code-example><script>`alert( "/".match(GOLD_/\\//_GOLD) );// '/' `</script><code-toolbar></code-toolbar></code-example><p>Ну и, наконец, если нам нужно найти сам обратный слэш <code>\</code>, то его нужно просто задублировать.</p><p>Так выглядит поиск обратного слэша <code>"\"</code>:</p><code-example><script>`alert( "1\\2".match(GOLD_/\\\\/_GOLD) ); // '\'`</script><code-toolbar></code-toolbar></code-example><h2><a name="6" href="#6">Итого</a></h2><p>Мы рассмотрели классы для поиска типов символов:</p><ul><li><code>\d</code> – цифры.</li><li><code>\D</code> – не-цифры.</li><li><code>\s</code> – пробельные символы, переводы строки.</li><li><code>\S</code> – всё, кроме <code>\s</code>.</li><li><code>\w</code> – латинница, цифры, подчёркивание <code>'_'</code>.</li><li><code>\W</code> – всё, кроме <code>\w</code>.</li><li><code>'.'</code> – точка обозначает любой символ, кроме перевода строки.</li></ul><p>Если хочется поискать именно сочетание <code>"\d"</code> или символ «точка», то его экранируют обратным слэшем, вот так: <code-pattern>\.</code-pattern></p><p>Заметим, что регулярное выражение может также содержать перевод строки <code>\n</code>, табуляцию <code>\t</code> и прочие спецсимволы для строк. Конфликта с классами не происходит, так как для них зарезервированы другие буквы.</p><h2 id="tasks"><a href="#7" name="7">Задачи (1)</a></h2><task-content><h3><a href="#9" name="9">Найдите время</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><p>Время имеет формат <code>часы:минуты</code>. И часы и минуты состоят из двух цифр, например: <code>09:00</code>.</p><p>Напишите регулярное выражение для поиска времени в строке: <code-subject>Завтрак в 09:00.</code-subject></p><p>P.S. В этой задаче выражению позволительно найти и некорректное время, например <code>25:99</code>.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Ответ: <code-pattern>\d\d:\d\d</code-pattern>.</p><code-example><script>`alert( "Завтрак в 09:00.".match( GOLD_/\\d\\d:\\d\\d/_GOLD ) ); // 09:00`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Методы RegExp и String; Наборы и диапазоны [...]"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><script>disqus_url="https:\/\/learn.javascript.ru\/regexp-character-classes",disqus_identifier="regexp-character-classes",disqus_title="\u041a\u043b\u0430\u0441\u0441\u044b \u0438 \u0441\u043f\u0435\u0446\u0441\u0438\u043c\u0432\u043e\u043b\u044b";</script></page-content></main>