<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="219">Регулярные выражения</a></nav-up><h1>Методы RegExp и String</h1><p>Регулярные выражения в JavaScript являются объектами класса <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp">RegExp</a>.</p><p>Кроме того, методы для поиска по регулярным выражениям встроены прямо в обычные строки <code>String</code>.</p><p>К сожалению, общая структура встроенных методов слегка запутана, поэтому мы сначала рассмотрим их по отдельности, а затем – рецепты по решению стандартных задач с ними.</p><h2><a name="0" href="#0">str.search(reg)</a></h2><p>Этот метод мы уже видели.</p><p>Он возвращает позицию первого совпадения или <code>-1</code>, если ничего не найдено.</p><code-example><script>`var str = "Люблю регэкспы я, но странною любовью";\n\nalert( str.search( GOLD_/лю/i_GOLD ) ); // 0`</script><code-toolbar></code-toolbar></code-example><p><strong>Ограничение метода <code>search</code> – он всегда ищет только первое совпадение.</strong></p><p>Нельзя заставить <code>search</code> искать дальше первого совпадения, такой синтаксис попросту не предусмотрен. Но есть другие методы, которые это умеют.</p><h2><a name="1" href="#1">str.match(reg) без флага g</a></h2><p>Метод <code>str.match</code> работает по-разному, в зависимости от наличия или отсутствия флага <code>g</code>, поэтому сначала мы разберём вариант, когда его нет.</p><p>В этом случае <code>str.match(reg)</code> находит только одно, первое совпадение.</p><p>Результат вызова – это массив, состоящий из этого совпадения, с дополнительными свойствами <code>index</code> – позиция, на которой оно обнаружено и <code>input</code> – строка, в которой был поиск.</p><p>Например:</p><code-example><script>`var str = "ОЙ-Ой-ой";\n\nvar result = str.match( GOLD_/ой/i_GOLD );\n\nalert( result[0] ); // ОЙ  (совпадение)\nalert( result.index ); // 0 (позиция)\nalert( result.input ); // ОЙ-Ой-ой (вся поисковая строка)`</script><code-toolbar></code-toolbar></code-example><p>У этого массива не всегда только один элемент.</p><p><strong>Если часть шаблона обозначена скобками, то она станет отдельным элементом массива.</strong></p><p>Например:</p><code-example><script>`var str = "javascript - это такой язык";\n\nvar result = str.match( GOLD_/JAVA(SCRIPT)/i_GOLD );\n\nalert( result[0] ); // javascript (всё совпадение полностью)\nalert( result[1] ); // script (часть совпадения, соответствующая скобкам)\nalert( result.index ); // 0\nalert( result.input ); // javascript - это такой язык`</script><code-toolbar></code-toolbar></code-example><p>Благодаря флагу <code>i</code> поиск не обращает внимание на регистр буквы, поэтому находит <code-match>javascript</code-match>. При этом часть строки, соответствующая <code-pattern>SCRIPT</code-pattern>, выделена в отдельный элемент массива.</p><p>Позже мы ещё вернёмся к скобочным выражениям, они особенно удобны для поиска с заменой.</p><h2><a name="2" href="#2">str.match(reg) с флагом g</a></h2><p>При наличии флага <code>g</code>, вызов <code>match</code> возвращает обычный массив из всех совпадений.</p><p>Никаких дополнительных свойств у массива в этом случае нет, скобки дополнительных элементов не порождают.</p><p>Например:</p><code-example><script>`var str = "ОЙ-Ой-ой";\n\nvar result = str.match( GOLD_/ой/ig_GOLD );\n\nalert( result ); // ОЙ, Ой, ой`</script><code-toolbar></code-toolbar></code-example><p>Пример со скобками:</p><code-example><script>`var str = "javascript - это такой язык";\n\nvar result = str.match( GOLD_/JAVA(SCRIPT)/gi_GOLD );\n\nalert( result[0] ); // javascript\nalert( result.length ); // 1\nalert( result.index ); // undefined`</script><code-toolbar></code-toolbar></code-example><p>Из последнего примера видно, что элемент в массиве ровно один, и свойства <code>index</code> также нет. Такова особенность глобального поиска при помощи <code>match</code>  – он просто возвращает все совпадения.</p><p>Для расширенного глобального поиска, который позволит получить все позиции и, при желании, скобки, нужно использовать метод <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec">RegExp#exec</a>, которые будет рассмотрен далее.</p><important-warn><h3>В случае, если совпадений не было, <code>match</code> возвращает <code>null</code></h3><p>Обратите внимание, это важно – если <code>match</code> не нашёл совпадений, он возвращает не пустой массив, а именно <code>null</code>.</p><p>Это важно иметь в виду, чтобы не попасть в такую ловушку:</p><code-example><script>`var str = "Ой-йой-йой";\n\n// результат match не всегда массив!\nalert(str.match(/лю/gi).length) // ошибка! нет свойства length у null`</script><code-toolbar></code-toolbar></code-example></important-warn><h2><a name="3" href="#3">str.split(reg|substr, limit)</a></h2><p>Разбивает строку в массив по разделителю – регулярному выражению <code>regexp</code> или подстроке <code>substr</code>.</p><p>Обычно мы используем метод <code>split</code> со строками, вот так:</p><code-example><script>`alert('12-34-56'.split('-')) // [12, 34, 56]`</script><code-toolbar></code-toolbar></code-example><p>Можно передать в него и регулярное выражение, тогда он разобьёт строку по всем совпадениям.</p><p>Тот же пример с регэкспом:</p><code-example><script>`alert('12-34-56'.split(GOLD_/-/_GOLD)) // [12, 34, 56]`</script><code-toolbar></code-toolbar></code-example><h2><a name="4" href="#4">str.replace(reg, str|func)</a></h2><p>Швейцарский нож для работы со строками, поиска и замены любого уровня сложности.</p><p>Его простейшее применение – поиск и замена подстроки в строке, вот так:</p><code-example><script>`// заменить дефис на двоеточие\nalert('12-34-56'.replace("-", ":")) // 12:34-56`</script><code-toolbar></code-toolbar></code-example><p><strong>При вызове со строкой замены <code>replace</code> всегда заменяет только первое совпадение.</strong></p><p>Чтобы заменить <em>все</em> совпадения, нужно использовать для поиска не строку <code>"-"</code>, а регулярное выражение <code-pattern>/-/g</code-pattern>, причём обязательно с флагом <code>g</code>:</p><code-example><script>`// заменить дефис на двоеточие\nalert( '12-34-56'.replace( GOLD_/-/g_GOLD, ":" ) )  // 12:34:56`</script><code-toolbar></code-toolbar></code-example><p>В строке для замены можно использовать специальные символы:</p><table><thead><tr><th>Спецсимволы</th><th>Действие в строке замены</th></tr></thead><tbody><tr><td><code>$$</code></td><td>Вставляет <code>"$"</code>.</td></tr><tr><td><code>$&amp;</code></td><td>Вставляет всё найденное совпадение.</td></tr><tr><td><code>$`</code></td><td>Вставляет часть строки до совпадения.</td></tr><tr><td><code>$'</code></td><td>Вставляет часть строки после совпадения.</td></tr><tr><td><code>$*n*</code></td><td>где <code>n</code> -- цифра или двузначное число, обозначает <code>n-ю</code> по счёту скобку, если считать слева-направо.</td></tr></tbody></table><p>Пример использования скобок и <code>$1</code>, <code>$2</code>:</p><code-example><script>`var str = "Василий Пупкин";\n\nalert(str.replace(GOLD_/(Василий) (Пупкин)/_GOLD, '$2, $1')) // Пупкин, Василий`</script><code-toolbar></code-toolbar></code-example><p>Ещё пример, с использованием <code>$&amp;</code>:</p><code-example><script>`var str = "Василий Пупкин";\n\nalert(str.replace(GOLD_/Василий Пупкин/_GOLD, 'Великий $&!')) // Великий Василий Пупкин!`</script><code-toolbar></code-toolbar></code-example><p><strong>Для ситуаций, которые требуют максимально «умной» замены, в качестве второго аргумента предусмотрена функция.</strong></p><p>Она будет вызвана для каждого совпадения, и её результат будет вставлен как замена.</p><p>Например:</p><code-example><script>`var i = 0;\n\n// заменить каждое вхождение "ой" на результат вызова функции\nalert("ОЙ-Ой-ой".replace(GOLD_/ой/gi_GOLD, function() {\n  return ++i;\n})); // 1-2-3`</script><code-toolbar></code-toolbar></code-example><p>В примере выше функция просто возвращала числа по очереди, но обычно она основывается на поисковых данных.</p><p>Эта функция получает следующие аргументы:</p><ol><li><code>str</code> – найденное совпадение,</li><li><code>p1, p2, ..., pn</code> – содержимое скобок (если есть),</li><li><code>offset</code> – позиция, на которой найдено совпадение,</li><li><code>s</code> – исходная строка.</li></ol><p>Если скобок в регулярном выражении нет, то у функции всегда будет ровно 3 аргумента: <code>replacer(str, offset, s)</code>.</p><p>Используем это, чтобы вывести полную информацию о совпадениях:</p><code-example><script>`// вывести и заменить все совпадения\nfunction replacer(str, offset, s) {\n  alert( "Найдено:&nbsp" + str + " на позиции:&nbsp" + offset + " в строке:&nbsp" + s );\n  return str.toLowerCase();\n}\n\nvar result = "ОЙ-Ой-ой".replace(GOLD_/ой/gi_GOLD, replacer);\nalert( 'Результат:&nbsp' + result ); // Результат: ой-ой-ой`</script><code-toolbar></code-toolbar></code-example><p>С двумя скобочными выражениями – аргументов уже 5:</p><code-example><script>`function replacer(str, name, surname, offset, s) {\n  return surname + ",&nbsp" + name;\n}\n\nvar str = "Василий Пупкин";\n\nalert(str.replace(GOLD_/(Василий) (Пупкин)/_GOLD, replacer)) // Пупкин, Василий`</script><code-toolbar></code-toolbar></code-example><p>Функция – это самый мощный инструмент для замены, какой только может быть. Она владеет всей информацией о совпадении и имеет доступ к замыканию, поэтому может всё.</p><h2><a name="5" href="#5">regexp.test(str)</a></h2><p>Теперь переходим к методам класса <code>RegExp</code>.</p><p>Метод <code>test</code> проверяет, есть ли хоть одно совпадение в строке <code>str</code>. Возвращает <code>true/false</code>.</p><p>Работает, по сути, так же, как и проверка <code>str.search(reg) != -1</code>, например:</p><code-example><script>`var str = "Люблю регэкспы я, но странною любовью";\n\n// эти две проверки идентичны\nalert( GOLD_/лю/i_GOLD.test(str) ) // true\nalert( str.search(GOLD_/лю/i_GOLD) != -1 ) // true`</script><code-toolbar></code-toolbar></code-example><p>Пример с отрицательным результатом:</p><code-example><script>`var str = "Ой, цветёт калина...";\n\nalert( GOLD_/javascript/i_GOLD.test(str) ) // false\nalert( str.search(GOLD_/javascript/i_GOLD) != -1 ) // false`</script><code-toolbar></code-toolbar></code-example><h2><a name="6" href="#6">regexp.exec(str)</a></h2><p>Для поиска мы уже видели методы:</p><ul><li><code>search</code> – ищет индекс</li><li><code>match</code> – если регэксп без флага <code>g</code> – ищет совпадение с подрезультатами в скобках</li><li><code>match</code> – если регэксп с флагом <code>g</code> – ищет все совпадения, но без скобочных групп.</li></ul><p>Метод <code>regexp.exec</code> дополняет их. Он позволяет искать и все совпадения и скобочные группы в них.</p><p>Он ведёт себя по-разному, в зависимости от того, есть ли у регэкспа флаг <code>g</code>.</p><ul><li>Если флага <code>g</code> нет, то <code>regexp.exec(str)</code> ищет и возвращает первое совпадение, является полным аналогом вызова <code>str.match(reg)</code>.</li><li>Если флаг <code>g</code> есть, то вызов <code>regexp.exec</code> возвращает первое совпадение и <em>запоминает</em> его позицию в свойстве <code>regexp.lastIndex</code>. Последующий поиск он начнёт уже с этой позиции. Если совпадений не найдено, то сбрасывает <code>regexp.lastIndex</code> в ноль.</li></ul><p>Это используют для поиска всех совпадений в цикле:</p><code-example><script>`var str = 'Многое по JavaScript можно найти на сайте http://javascript.ru';\n\nvar regexp = GOLD_/javascript/ig_GOLD;\nvar result;\n\nalert( "Начальное значение lastIndex:&nbsp" + regexp.lastIndex );\n\nwhile (result = regexp.exec(str)) {\n  alert( 'Найдено:&nbsp' + result[0] + ' на позиции:&nbsp' + result.index );\n  alert( 'Свойство lastIndex:&nbsp' + regexp.lastIndex );\n}\n\nalert( 'Конечное значение lastIndex:&nbsp' + regexp.lastIndex );`</script><code-toolbar></code-toolbar></code-example><p>Здесь цикл продолжается до тех пор, пока <code>regexp.exec</code> не вернёт <code>null</code>, что означает «совпадений больше нет».</p><p>Найденные результаты последовательно помещаются в <code>result</code>, причём находятся там в том же формате, что и <code>match</code> – с учётом скобок, со свойствами <code>result.index</code> и <code>result.input</code>.</p><important-><h3>Поиск с нужной позиции</h3><p>Можно заставить <code>regexp.exec</code> искать сразу с нужной позиции, если поставить <code>lastIndex</code> вручную:</p><code-example><script>`var str = 'Многое по JavaScript можно найти на сайте http://javascript.ru';\n\nvar regexp = GOLD_/javascript/ig_GOLD;\nregexp.lastIndex = 40;\n\nalert( regexp.exec(str).index ); // 49, поиск начат с 40-й позиции`</script><code-toolbar></code-toolbar></code-example></important-><h2><a name="7" href="#7">Итого, рецепты</a></h2><p>Методы становятся гораздо понятнее, если разбить их использование по задачам, которые нужны в реальной жизни.</p><dl><dt>Для поиска только одного совпадения:</dt><dd><ul><li>Найти позицию первого совпадения – <code>str.search(reg)</code>.</li></ul></dd></dl><ul><li>Найти само совпадение – <code>str.match(reg)</code>.</li><li>Проверить, есть ли хоть одно совпадение – <code>regexp.test(str)</code> или <code>str.search(reg) != -1</code>.</li><li>Найти совпадение с нужной позиции – <code>regexp.exec(str)</code>, начальную позицию поиска задать в <code>regexp.lastIndex</code>.</li></ul><dl><dt>Для поиска всех совпадений:</dt><dd><ul><li>Найти массив совпадений – <code>str.match(reg)</code>, с флагом <code>g</code>.</li></ul></dd></dl><ul><li>Получить все совпадения, с подробной информацией о каждом – <code>regexp.exec(str)</code> с флагом <code>g</code>, в цикле.</li></ul><dl><dt>Для поиска-и-замены:</dt><dd><ul><li>Замена на другую строку или результат функции – <code>str.replace(reg, str|func)</code></li></ul></dd><dt>Для разбивки строки на части:</dt><dd><ul><li><code>str.split(str|reg)</code></li></ul></dd></dl><p>Зная эти методы, мы уже можем использовать регулярные выражения.</p><p>Конечно, для этого желательно хорошо понимать их синтаксис и возможности, так что переходим к ним дальше.</p><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Паттерны и флаги; Классы и спецсимволы"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><script>disqus_url = "https:\/\/learn.javascript.ru\/regexp-methods", disqus_identifier = "regexp-methods", disqus_title = "\u041c\u0435\u0442\u043e\u0434\u044b RegExp \u0438 String";</script></page-content></main>