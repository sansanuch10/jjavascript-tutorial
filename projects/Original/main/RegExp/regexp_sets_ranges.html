<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="219">Регулярные выражения</a></nav-up><h1>Наборы и диапазоны [...]</h1><p>Если в регулярном выражении несколько символов или символьных классов заключены в квадратные скобки <code>[…]</code>, то это означает "искать любой символ из указанных в <code>[…]</code>".</p><h2><a name="0" href="#0">Набор</a></h2><p>Например, <code-pattern>[еао]</code-pattern> означает любой символ из этих трёх: <code>'а'</code>, <code>'е'</code>, или <code>'о'</code>.</p><p>Такое обозначение называют <em>набором</em>. Наборы используются в регулярном выражении наравне с обычными символами:</p><code-example><script>`// найти [г или т], а затем "оп"\nalert( "Гоп-стоп".match(GOLD_/[гт]оп/gi_GOLD) ); // "Гоп", "топ"`</script><code-toolbar></code-toolbar></code-example><p>Обратим внимание: несмотря на то, что в наборе указано несколько символов, в совпадении должен присутствовать <em>ровно один</em> из них.</p><p>Поэтому в примере ниже нет результатов:</p><code-example><script>`// найти "В", затем [у или а], затем "ля"\nalert( "Вуаля".match(GOLD_/В[уа]ля/_GOLD) ); // совпадений нет`</script><code-toolbar></code-toolbar></code-example><p>Поиск подразумевает:</p><ul><li><code-pattern>В</code-pattern>,</li><li>затем <em>одну</em> из букв набора <code-pattern>[уа]</code-pattern>,</li><li>а затем <code-pattern>ля</code-pattern></li></ul><p>Таким образом, совпадение было бы для строки <code-match>Вуля</code-match> или <code-match>Валя</code-match>.</p><h2><a name="1" href="#1">Диапазоны</a></h2><p>Квадратные скобки могут также содержать <em>диапазоны символов</em>.</p><p>Например, <code-pattern>[a-z]</code-pattern> – произвольный символ от <code>a</code> до <code>z</code>, <code-pattern>[0-5]</code-pattern> – цифра от <code>0</code> до <code>5</code>.</p><p>В примере ниже мы будем искать <code>"x"</code>, после которого идёт два раза любая цифра или буква от A до F:</p><code-example><script>`// найдёт "xAF"\nalert( "Exception 0xAF".match(GOLD_/x[0-9A-F][0-9A-F]/g_GOLD) );`</script><code-toolbar></code-toolbar></code-example><p>Обратим внимание, в слове <code-subject>Exception</code-subject> есть сочетание <code-subject>xce</code-subject>, но оно не подошло, потому что буквы в нём маленькие, а в диапазоне <code-pattern>[0-9A-F]</code-pattern> – большие.</p><p>Если хочется искать и его тоже, можно добавить в скобки диапазон <code>a-f</code>: <code-pattern>[0-9A-Fa-f]</code-pattern>. Или же просто указать у всего регулярного выражения флаг <code>i</code>.</p><p><strong>Символьные классы – всего лишь более короткие записи для диапазонов, в частности:</strong></p><ul><li><strong>\d</strong> – то же самое, что <code-pattern>[0-9]</code-pattern>,</li><li><strong>\w</strong> – то же самое, что <code-pattern>[a-zA-Z0-9_]</code-pattern>,</li><li><strong>\s</strong> – то же самое, что <code-pattern>[\t\n\v\f\r ]</code-pattern> плюс несколько юникодных пробельных символов.</li></ul><p>В квадратных скобках можно использовать и диапазоны и символьные классы – вместе.</p><p>Например, нам нужно найти все слова в тексте. Если они на английском – это достаточно просто:</p><code-example><script>`var str = "The sun is rising!";\n\nalert( str.match(GOLD_/\\w+/g_GOLD) ); // The, sun, is, rising`</script><code-toolbar></code-toolbar></code-example><p>В этом примере мы забежали немного вперёд и использовали <code-pattern>\w+</code-pattern>, что означает один или более символов, подходящих под класс <code-pattern>\w</code-pattern>. Позже мы рассмотрим <code>+</code> детальнее, а пока – давайте посмотрим, найдутся ли слова на русском?</p><code-example><script>`var str = "Солнце встаёт!";\n\nalert( str.match(GOLD_/\\w+/g_GOLD) ); // null`</script><code-toolbar></code-toolbar></code-example><p>Ничего не найдено! Это можно понять, ведь <code-pattern>\w</code-pattern> – это именно английская букво-цифра, как можно видеть из аналога <code-pattern>[a-zA-Z0-9_]</code-pattern>.</p><p>Чтобы находило слово на русском – нужно использовать диапазон, например <code-pattern>/[а-я]/</code-pattern>.</p><p>А чтобы на обоих языках – и то и другое вместе:</p><code-example><script>`var str = "Солнце (the sun) встаёт!";\n\nalert( str.match(GOLD_/[\\wа-я]+/gi_GOLD) ); // Солнце, the, sun, вста, т`</script><code-toolbar></code-toolbar></code-example><p>…Присмотритесь внимательно к предыдущему примеру! Вы видите странность? Оно не находит букву <code-match>ё</code-match>, более того – считает её разрывом в слове. Причина – в кодировке юникод, она подробно раскрыта в главе <a href="/string">Строки</a>.</p><p>Буква <code>ё</code> лежит в стороне от основной кириллицы и её следует добавить в диапазон дополнительно, вот так:</p><code-example><script>`var str = "Солнце (the sun) встаёт!";\n\nalert( str.match(GOLD_/[\\wа-яё]+/gi_GOLD) ); // Солнце, the, sun, встаёт`</script><code-toolbar></code-toolbar></code-example><p>Теперь всё в порядке.</p><h2><a name="2" href="#2">Диапазоны «кроме»</a></h2><p><strong>Кроме обычных, существуют также <em>исключающие</em> диапазоны: <code-pattern>[^…]</code-pattern>.</strong></p><p>Квадратные скобки, начинающиеся со знака каретки: <code-pattern>[^…]</code-pattern> находят любой символ, <em>кроме указанных</em>.</p><p>Например:</p><ul><li><code-pattern>[^аеуо]</code-pattern> – любой символ, кроме <code>'a'</code>, <code>'e'</code>, <code>'y'</code>, <code>'o'</code>.</li><li><code-pattern>[^0-9]</code-pattern> – любой символ, кроме цифры, то же что <code>\D</code>.</li><li><code-pattern>[^\s]</code-pattern> – любой не-пробельный символ, то же что <code>\S</code>.</li></ul><p>Пример ниже ищет любые символы, кроме букв, цифр и пробелов:</p><code-example><script>`alert( "alice15@gmail.com".match(GOLD_/[^\d\sA-Z]/gi_GOLD) ); // "@", "."\n`</script><code-toolbar></code-toolbar></code-example><h2><a name="3" href="#3">Не нужно экранирование</a></h2><p>Обычно, если мы хотим искать именно точку, а не любой символ, или именно символ <code>\</code>, то мы используем экранирование: указываем <code>\.</code> или <code>\\</code>.</p><p>В квадратных скобках большинство специальных символов можно использовать без экранирования, если конечно они не имеют какой-то особый смысл именно внутри квадратных скобок.</p><p>То есть, «как есть», без экранирования можно использовать символы:</p><ul><li>Точка <code-pattern>'.'</code-pattern>.</li><li>Плюс <code-pattern>'+'</code-pattern>.</li><li>Круглые скобки <code-pattern>'( )'</code-pattern>.</li><li>Дефис <code-pattern>'-'</code-pattern>, если он находится в начале или конце квадратных скобок, то есть не выделяет диапазон.</li><li>Символ каретки <code-pattern>'^'</code-pattern>, если не находится в начале квадратных скобок.</li><li>А также открывающая квадратная скобка <code-pattern>'['</code-pattern>.</li></ul><p>То есть, точка <code>"."</code> в квадратных скобках означает не «любой символ», а обычную точку.</p><p>Регэксп <code-pattern>[.,]</code-pattern> ищет один из символов «точка» или «запятая».</p><p>В примере ниже регэксп <code-pattern>[-().^+]</code-pattern> ищет один из символов <code>-().^</code>. Они не экранированы:</p><code-example><script>`// Без экранирования\nvar re = GOLD_/[-().^+]/g_GOLD;\n\nalert( "1 + 2 - 3".match(re) ); // найдёт +, -`</script><code-toolbar></code-toolbar></code-example><p>…Впрочем, даже если вы решите «на всякий случай» заэкранировать эти символы, поставив перед ними обратный слэш <code>\</code> – вреда не будет:</p><code-example><script>`// Всё заэкранировали\nvar re = GOLD_/[\-\(\)\.\^\+]/g_GOLD;\n\nalert( "1 + 2 - 3".match(re) ); // тоже работает: +, -`</script><code-toolbar></code-toolbar></code-example><h2 id="tasks"><a href="#4" name="4">Задачи (2)</a></h2><task-content><h3><a href="#6" name="6">Java[^script]</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><p>Найдет ли регэксп <code-pattern>/Java[^script]/</code-pattern> что-нибудь в строке <code-subject>Java</code-subject>?</p><p>А в строке <code-subject>JavaScript</code-subject>?</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Ответы: <strong>нет, да</strong>.</p><ul><li><p>В строке <code-subject>Java</code-subject> он ничего не найдёт, так как исключающие квадратные скобки в <code>Java[^...]</code> означают «один символ, кроме указанных». А после <code>«Java»</code> – конец строки, символов больше нет.</p><code-example><script>`alert( "Java".match(GOLD_/Java[^script]/_GOLD) ); // нет совпадений`</script><code-toolbar></code-toolbar></code-example></li><li><p>Да, найдёт. Поскольку регэксп регистрозависим, то под <code>[^script]</code> вполне подходит символ <code>"S"</code>.</p><code-example><script>`alert( "JavaScript".match(GOLD_/Java[^script]/_GOLD) ); // "JavaS"`</script><code-toolbar></code-toolbar></code-example></li></ul></task-answer></task-content><task-content><h3><a href="#7" name="7">Найдите время в одном из форматов</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><p>Время может быть в формате <code>часы:минуты</code> или <code>часы-минуты</code>. И часы и минуты состоят из двух цифр, например <code>09:00</code>, <code>21-30</code>.</p><p>Напишите регулярное выражение для поиска времени:</p><code-example><script>`var re = GOLD_/ваше выражение/_GOLD;\nalert( "Завтрак в 09:00. Обед - в 21-30".match(re) ); // 09:00, 21-30`</script><code-toolbar></code-toolbar></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Ответ: <code-pattern>\d\d[-:]\d\d</code-pattern>.</p><code-example><script>`var re = GOLD_/\\d\\d[-:]\\d\\d/g_GOLD;\nalert( "Завтрак в 09:00. Обед - в 21-30".match(re) );`</script><code-toolbar></code-toolbar></code-example><p>Обратим внимание, что дефис <code-pattern>'-'</code-pattern> не экранирован, поскольку в начале скобок он не может иметь специального смысла.</p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Классы и спецсимволы; Квантификаторы +, *, ? и {n}"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><script>disqus_url="https:\/\/learn.javascript.ru\/regexp-character-sets-and-ranges",disqus_identifier="regexp-character-sets-and-ranges",disqus_title="\u041d\u0430\u0431\u043e\u0440\u044b \u0438 \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u044b [...]";</script></page-content></main>