<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="219">Регулярные выражения</a></nav-up><h1>Жадные и ленивые квантификаторы</h1><p>Квантификаторы – с виду очень простая, но на самом деле очень хитрая штука.</p><p>Необходимо очень хорошо понимать, как именно происходит поиск, если конечно мы хотим искать что-либо сложнее чем <code-pattern>/\d+/</code-pattern>.</p><p>Для примера рассмотрим задачу, которая часто возникает в типографике – заменить в тексте кавычки вида <code>"..."</code> (их называют «английские кавычки») на «кавычки-ёлочки»: <code>«...»</code>.</p><p>Для этого нужно сначала найти все слова в таких кавычках.</p><p>Соответствующее регулярное выражение может выглядеть так: <code-pattern>/".+"/g</code-pattern>, то есть мы ищем кавычку, после которой один или более произвольный символ, и в конце опять кавычка.</p><p>Однако, если попробовать применить его на практике, даже на таком простом случае…</p><code-example><script>`var reg = GOLD_/".+"/g_GOLD;\n\nvar str = 'a "witch" and her "broom" is one';\n\nalert( str.match(reg) ); // "witch" and her "broom"`</script><code-toolbar></code-toolbar></code-example><p>…Мы увидим, что оно работает совсем не так, как задумано!</p><p>Вместо того, чтобы найти два совпадения <code-match>"witch"</code-match> и <code-match>"broom"</code-match>, оно находит одно: <code-match>"witch" and her "broom"</code-match>.</p><p>Это как раз тот случай, когда <em>жадность</em> – причина всех зол.</p><h2><a name="0" href="#0">Жадный поиск</a></h2><p>Чтобы найти совпадение, движок регулярных выражений обычно использует следующий алгоритм:</p><ul><li>Для каждой позиции в поисковой строке<ul><li>Проверить совпадение на данной позиции</li><li>Посимвольно, с учётом классов и квантификаторов сопоставив с ней регулярное выражение.</li></ul></li></ul><p>Это общие слова, гораздо понятнее будет, если мы проследим, что именно он делает для регэкспа <code-pattern>".+"</code-pattern>.</p><ol><li><p>Первый символ шаблона – это кавычка <code-pattern>"</code-pattern>.</p><p>Движок регулярных выражений пытается сопоставить её на 0-й позиции в строке, но символ <code>a</code>, поэтому на 0-й позиции соответствия явно нет.</p><p>Далее он переходит 1ю, 2ю позицию в исходной строке и, наконец, обнаруживает кавычку на 3-й позиции:</p><figure><img src="witch_greedy1.png" alt="" width="100%" style="max-width:462px"></figure></li><li><p>Кавычка найдена, далее движок проверяет, есть ли соответствие для остальной части паттерна.</p><p>В данном случае следующий символ шаблона: <code-pattern>.</code-pattern> (точка). Она обозначает «любой символ», так что следующая буква строки <code-match>'w'</code-match> вполне подходит:</p><figure><img src="witch_greedy2.png" alt="" width="100%" style="max-width:462px"></figure></li><li><p>Далее «любой символ» повторяется, так как стоит квантификатор <code-pattern>.+</code-pattern>. Движок регулярных выражений берёт один символ за другим, до тех пор, пока у него это получается.</p><p>В данном случае это означает «до конца строки»:</p><figure><img src="witch_greedy3.png" alt="" width="100%" style="max-width:462px"></figure></li><li><p>Итак, текст закончился, движок регулярных выражений больше не может найти «любой символ», он закончил повторения для <code-pattern>.+</code-pattern> и переходит к следующему символу шаблона.</p><p>Следующий символ шаблона – это кавычка. Её тоже необходимо найти, чтобы соответствие было полным. А тут – беда, ведь поисковый текст завершился!</p><p>Движок регулярных выражений понимает, что, наверное, взял многовато <code-pattern>.+</code-pattern> и начинает отступать обратно.</p><p>Иными словами, он сокращает текущее совпадение на один символ:</p><figure><img src="witch_greedy4.png" alt="" width="100%" style="max-width:462px"></figure><p>Это называется «фаза возврата» или «фаза бэктрекинга» (backtracking – англ.).</p><p>Теперь <code-pattern>.+</code-pattern> соответствует почти вся оставшаяся строка, за исключением одного символа, и движок регулярных выражений ещё раз пытается подобрать соответствие для остатка шаблона, начиная с оставшейся части строки.</p><p>Если бы последним символом строки была кавычка <code-pattern>'"'</code-pattern>, то на этом бы всё и закончилось. Но последний символ <code-subject>'e'</code-subject>, так что совпадения нет.</p></li><li><p>…Поэтому движок уменьшает число повторений <code-pattern>.+</code-pattern> ещё на один символ:</p><figure><img src="witch_greedy5.png" alt="" width="100%" style="max-width:462px"></figure><p>Кавычка <code-pattern>'"'</code-pattern> не совпадает с <code-subject>'n'</code-subject>. Опять неудача.</p></li><li><p>Движок продолжает отступать, он уменьшает количество повторений точки <code-pattern>'.'</code-pattern> до тех пор, пока остаток паттерна, то есть в данном случае кавычка <code-pattern>'"'</code-pattern>, не совпадёт:</p><figure><img src="witch_greedy6.png" alt="" width="100%" style="max-width:462px"></figure></li><li><p>Совпадение получено. Дальнейший поиск по оставшейся части строки <code-subject>is one</code-subject> новых совпадений не даст.</p></li></ol><p>Возможно, это не совсем то, что мы ожидали.</p><p><strong>В жадном режиме (по умолчанию) регэксп повторяет квантификатор настолько много раз, насколько это возможно, чтобы найти соответствие.</strong></p><p>То есть, любой символ <code-pattern>.+</code-pattern> повторился максимальное количество раз, что и привело к такой длинной строке.</p><p>А мы, наверное, хотели, чтобы каждая строка в кавычках была независимым совпадением? Для этого можно переключить квантификатор <code>+</code> в «ленивый» режим, о котором будет речь далее.</p><h2><a name="1" href="#1">Ленивый режим</a></h2><p>Ленивый режим работы квантификаторов – противоположность жадному, он означает «повторять минимальное количество раз».</p><p>Его можно включить, если поставить знак вопроса <code-pattern>'?'</code-pattern> после квантификатора, так что он станет таким: <code-pattern>*?</code-pattern> или <code-pattern>+?</code-pattern> или даже <code-pattern>??</code-pattern> для <code-pattern>'?'</code-pattern>.</p><p>Чтобы не возникло путаницы – важно понимать: обычно <code>?</code> сам является квантификатором (ноль или один). Но если он стоит <em>после другого квантификатора (или даже после себя)</em>, то обретает другой смысл – в этом случае он меняет режим его работы на ленивый.</p><p>Регэксп <code-pattern>/".+?"/g</code-pattern> работает, как задумано – находит отдельно <code-match>witch</code-match> и <code-match>broom</code-match>:</p><code-example><script>`var reg = GOLD_/".+?"/g_GOLD;\n\nvar str = 'a "witch" and her "broom" is one';\n\nalert( str.match(reg) ); // witch, broom`</script><code-toolbar></code-toolbar></code-example><p>Чтобы в точности понять, как поменялась работа квантификатора, разберём поиск по шагам.</p><ol><li><p>Первый шаг – тот же, кавычка <code-pattern>'"'</code-pattern> найдена на 3-й позиции:</p><figure><img src="witch_greedy1.png" alt="" width="100%" style="max-width:462px"></figure></li><li><p>Второй шаг – тот же, находим произвольный символ <code-pattern>'.'</code-pattern>:</p><figure><img src="witch_greedy2.png" alt="" width="100%" style="max-width:462px"></figure></li><li><p>А вот дальше – так как стоит ленивый режим работы <code>+</code>, то движок не повторит точку (произвольный символ) ещё раз, а останавливается на достигнутом и пытается проверить, есть ли соответствие остальной части шаблона, то есть <code-pattern>'"'</code-pattern>:</p><figure><img src="witch_lazy3.png" alt="" width="100%" style="max-width:462px"></figure><p>Если бы остальная часть шаблона на данной позиции совпала, то совпадение было бы найдено. Но в данном случае – нет, символ <code>'i'</code> не равен <code-pattern>'"'</code-pattern>.</p></li><li><p>Движок регулярных выражений увиличивает количество повторений точки на одно и пытается найти соответствие остатку шаблона ещё раз:</p><figure><img src="witch_lazy4.png" alt="" width="100%" style="max-width:462px"></figure><p>Опять неудача. Тогда поисковой движок увеличивает количество повторений ещё и ещё…</p></li><li><p>Только на пятом шаге поисковой движок наконец находит соответствие для остатка паттерна:</p><figure><img src="witch_lazy5.png" alt="" width="100%" style="max-width:462px"></figure></li><li><p>Так как поиск происходит с флагом <code>g</code>, то он продолжается с конца текущего совпадения, давая ещё один результат:</p><figure><img src="witch_lazy6.png" alt="" width="100%" style="max-width:462px"></figure></li></ol><p>В примере выше продемонстрирована работа ленивого режима для <code-pattern>+?</code-pattern>. Квантификаторы  <code-pattern>+?</code-pattern> и <code-pattern>??</code-pattern> ведут себя аналогично – «ленивый» движок увеличивает количество повторений только в том случае, если для остальной части шаблона на данной позиции нет соответствия.</p><p><strong>Ленивость распространяется только на тот квантификатор, после которого стоит <code>?</code>.</strong></p><p>Прочие квантификаторы остаются жадными.</p><p>Например:</p><code-example><script>`alert( "123 456".match(GOLD_/\\d+ \\d+?/g_GOLD) ); // 123 4`</script><code-toolbar></code-toolbar></code-example><ol><li><p>Подшаблон <code-pattern>\d+</code-pattern> пытается найти столько цифр, сколько возможно (работает жадно), так что он находит <code-match>123</code-match> и останавливается, поскольку символ пробела <code-pattern>' '</code-pattern> не подходит под <code-pattern>\d</code-pattern>.</p></li><li><p>Далее в шаблоне пробел, он совпадает.</p></li><li><p>Далее в шаблоне идёт <code-pattern>\d+?</code-pattern>.</p><p>Квантификатор указан в ленивом режиме, поэтому он находит одну цифру <code-match>4</code-match> и пытается проверить, есть ли совпадение с остатком шаблона.</p><p>Но после <code-pattern>\d+?</code-pattern> в шаблоне ничего нет.</p><p><strong>Ленивый режим без необходимости лишний раз квантификатор не повторит.</strong></p><p>Так как шаблон завершился, то искать дальше, в общем-то нечего. Получено совпадение <code-match>123 4</code-match>.</p></li><li><p>Следующий поиск продолжится с <code>5</code>, но ничего не найдёт.</p></li></ol><important-><h3>Конечные автоматы и не только</h3><p>Современные движки регулярных выражений могут иметь более хитрую реализацию внутренних алгоритмов, чтобы искать быстрее.</p><p>Однако, чтобы понять, как работает регулярное выражение, и строить регулярные выражения самому, знание этих хитрых алгоритмов ни к чему. Они служат лишь внутренней оптимизации способа поиска, описанного выше.</p><p>Кроме того, сложные регулярные выражения плохо поддаются всяким оптимизациям, так что поиск вполне может работать и в точности как здесь описано.</p></important-><h2><a name="2" href="#2">Альтернативный подход</a></h2><p>В данном конкретном случае, возможно искать строки в кавычках, оставаясь в жадном режиме, с использованием регулярного выражения <code-pattern>"[^"]+"</code-pattern>:</p><code-example><script>`var reg = GOLD_/"[^"]+"/g_GOLD;\n\nvar str = 'a "witch" and her "broom" is one';\n\nalert( str.match(reg) ); // witch, broom`</script><code-toolbar></code-toolbar></code-example><p>Регэксп <code-pattern>"[^"]+"</code-pattern> даст правильные результаты, поскольку ищет кавычку <code-pattern>'"'</code-pattern>, за которой идут столько не-кавычек (исключающие квадратные скобки), сколько возможно.</p><p>Так что вторая кавычка автоматически прекращает повторения <code-pattern>[^"]+</code-pattern> и позволяет найти остаток шаблона <code-pattern>"</code-pattern>.</p><p><strong>Эта логика ни в коей мере не заменяет ленивые квантификаторы!</strong></p><p>Она просто другая. И то и другое бывает полезно.</p><p>Давайте посмотрим пример, когда нужен именно такой вариант, а ленивые квантификаторы не подойдут.</p><p>Например, мы хотим найти в тексте ссылки вида <code>&lt;a href="..." class="doc"&gt;</code>, с любым содержанием <code>href</code>.</p><p>Какое регулярное выражение для этого подойдёт?</p><p>Первый вариант может выглядеть так: <code-pattern>/&lt;a href=".*" class="doc"&gt;/g</code-pattern>.</p><p>Проверим его:</p><code-example><script>`var str = '...<a href="link" class="doc">...';\nvar reg = GOLD_/<a href=".*" class="doc">/g_GOLD;\n\n// Сработало!\nalert( str.match(reg) ); // <a href="link" class="doc">`</script><code-toolbar></code-toolbar></code-example><p>А если в тексте несколько ссылок?</p><code-example><script>`var str = '...<a href="link1" class="doc">... <a href="link2" class="doc">...';\nvar reg = GOLD_/<a href=".*" class="doc">/g_GOLD;\n\n// Упс! Сразу две ссылки!\nalert( str.match(reg) ); // <a href="link1" class="doc">... <a href="link2" class="doc">`</script><code-toolbar></code-toolbar></code-example><p>На этот раз результат неверен.</p><p>Жадный <code-pattern>.*</code-pattern> взял слишком много символов.</p><p>Соответствие получилось таким:</p><code-example><script>`<a href="....................................." class="doc">\n<a href="link1" class="doc">... <a href="link2" class="doc">`</script></code-example><p>Модифицируем шаблон – добавим ленивость квантификатору <code-pattern>.*?</code-pattern>:</p><code-example><script>`var str = '...<a href="link1" class="doc">... <a href="link2" class="doc">...';\nvar reg = GOLD_/<a href=".*?" class="doc">/g_GOLD;\n\n// Сработало!\nalert( str.match(reg) ); // <a href="link1" class="doc">, <a href="link2" class="doc">`</script><code-toolbar></code-toolbar></code-example><p>Теперь всё верно, два результата:</p><code-example><script>`<a href="....." class="doc">    <a href="....." class="doc">\n<a href="link1" class="doc">... <a href="link2" class="doc">`</script></code-example><p>Почему теперь всё в порядке – для внимательного читателя, после объяснений, данных выше в этой главе, должно быть полностью очевидно.</p><p>Поэтому не будем останавливаться здесь на деталях, а попробуем ещё пример:</p><code-example><script>`var str = '...<a href="link1" class="wrong">... <p style="" class="doc">...';\nvar reg = GOLD_/<a href=".*?" class="doc">/g_GOLD;\n\n// Неправильное совпадение!\nalert( str.match(reg) ); // <a href="link1" class="wrong">... <p style="" class="doc">`</script><code-toolbar></code-toolbar></code-example><p>Совпадение – не ссылка, а более длинный текст.</p><p>Получилось следующее:</p><ol><li><p>Найдено совпадение <code-match>&lt;a href="</code-match>.</p></li><li><p>Лениво ищем <code-pattern>.*?</code-pattern>, после каждого символа проверяя, есть ли совпадение остальной части шаблона.</p><p>Подшаблон <code-pattern>.*?</code-pattern> будет брать символы до тех пор, пока не найдёт <code-match>class="doc"&gt;</code-match>.</p><p>В данном случае этот поиск закончится уже за пределами ссылки, в теге <code>&lt;p&gt;</code>, вообще не имеющем отношения к <code>&lt;a&gt;</code>.</p></li><li><p>Получившееся совпадение:</p><code-example><script>`<a href="..................................." class="doc">\n<a href="link1" class="wrong">... <p style="" class="doc">`</script></code-example></li></ol><p>Итак, ленивость нам не помогла.</p><p>Необходимо как-то прекратить поиск <code-pattern>.*</code-pattern>, чтобы он не вышел за пределы кавычек.</p><p>Для этого мы используем более точное указание, какие символы нам подходят, а какие нет.</p><p>Правильный вариант: <code-pattern>[^"]*</code-pattern>. Этот шаблон будет брать все символы до ближайшей кавычки, как раз то, что требуется.</p><p>Рабочий пример:</p><code-example><script>`var str1 = '...<a href="link1" class="wrong">... <p style="" class="doc">...';\nvar str2 = '...<a href="link1" class="doc">... <a href="link2" class="doc">...';\nvar reg = GOLD_/<a href="[^"]*" class="doc">/g_GOLD;\n\n// Работает!\nalert( str1.match(reg) ); // null, совпадений нет, и это верно\nalert( str2.match(reg) ); // <a href="link1" class="doc">, <a href="link2" class="doc">`</script><code-toolbar></code-toolbar></code-example><h2><a name="3" href="#3">Итого</a></h2><p>Квантификаторы имеют два режима работы:</p><dl><dt>Жадный</dt><dd>Режим по умолчанию – движок регулярных выражений повторяет его по-максимуму. Когда повторять уже нельзя, например нет больше цифр для <code>\d+</code>, он продолжает поиск с оставшейся части текста. Если совпадение найти не удалось – отступает обратно, уменьшая количество повторений.</dd><dt>Ленивый</dt><dd>При указании после квантификатора символа <code>?</code> он работает в ленивом режиме. То есть, он перед каждым повторением проверяет совпадение оставшейся части шаблона на текущей позиции.</dd></dl><p>Как мы видели в примере выше, ленивый режим – не панацея от «слишком жадного» забора символов. Альтернатива – более аккуратно настроенный «жадный», с исключением символов. Как мы увидим далее, можно исключать не только символы, но и целые подшаблоны.</p><h2 id="tasks"><a href="#4" name="4">Задачи (4)</a></h2><task-content><h3><a href="#7" name="7">Совпадение для /d+? d+/</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><p>Что будет при таком поиске, когда сначала стоит ленивый, а потом жадный квантификаторы?</p><code-example><script>`"123 456".match(GOLD_/\\d+? \\d+/g_GOLD) ); // какой результат?`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Результат: <code>123 456</code>.</p><p>Ленивый <code>\d+?</code> будет брать цифры до пробела, то есть <code>123</code>. После каждой цифры он будет останавливаться, проверять – не пробел ли дальше? Если нет – брать ещё цифру, в итоге возьмёт <code>123</code>.</p><p>Затем в дело вступит <code>\d+</code>, который по-максимуму возьмёт дальнейшие цифры, то есть <code>456</code>.</p></task-answer></task-content><task-content><h3><a href="#8" name="8">Различие между "[^"]*" и ".*?"</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><p>Регулярные выражения <code-pattern>"[^"]*"</code-pattern> и <code-pattern>".*?"</code-pattern> – при выполнении одинаковы?</p><p>Иначе говоря, существует ли такая строка, на которой они дадут разные результаты? Если да – дайте такую строку.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer style=""><close- title="закрыть" data-close_answer=""></close-><p>Они очень похожи и, да, <em>почти</em> одинаковы. Оба ищут от одной кавычки до другой.</p><p>Различие здесь в символе точка <code-pattern>'.'</code-pattern>. Как мы помним, точка <code-pattern>'.'</code-pattern> обозначает <em>любой символ, кроме перевода строки</em>.</p><p>А <code-pattern>[^"]</code-pattern> – это *любой символ, кроме кавычки <code-pattern>'"'</code-pattern>.</p><p>Получается, что первый регэксп <code-pattern>"[^"]*"</code-pattern> найдёт закавыченные строки с <code>\n</code> внутри, а второй регэксп <code-pattern>".*?"</code-pattern> – нет.</p><p>Вот пример:</p><code-example><script>`alert( \`"многострочный \n текст"\`.match(GOLD_/"[^"]*"/_GOLD) ); // найдёт\n\nalert( \`"многострочный \n текст"\`.match(GOLD_/".*?"/_GOLD) ); // null (нет совпадений)`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#9" name="9">Найти HTML-комментарии</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><p>Найдите все HTML-комментарии в тексте:</p><code-example><script>`var re = ..ваш регэксп..\n&nbsp\nvar str = '.. <!-- Мой -- комментарий \\n тест --> ..  <!----> .. ';\n\nalert( str.match(re) ); // '<!-- Мой -- комментарий \\n тест -->', '<!---->'`</script><code-toolbar-><div></div><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Нужно найти начало комментария <code-match>&lt;!--</code-match>, затем всё до конца <code-match>--&gt;</code-match>.</p><p>С первого взгляда кажется, что это сделает регулярное выражение <code-pattern>&lt;!--.*?--&gt;</code-pattern> – квантификатор сделан ленивым, чтобы остановился, достигнув <code-match>--&gt;</code-match>.</p><p>Однако, точка в JavaScript – любой символ, <em>кроме</em> конца строки. Поэтому такой регэксп не найдёт многострочный комментарий.</p><p>Всё получится, если вместо точки использовать полностю «всеядный» <code-pattern>[\s\S]</code-pattern>.</p><p>Итого:</p><code-example><script>`var re = GOLD_/<!--[\\s\\S]*?-->/g_GOLD;\n&nbsp\nvar str = '.. <!-- Мой -- комментарий \\n тест --> ..  <!----> .. ';\n\nalert( str.match(re) ); // '<!-- Мой -- комментарий \\n тест -->', '<!---->'`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#10" name="10">Найти HTML-теги</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><p>Создайте регулярное выражение для поиска всех (открывающихся и закрывающихся) HTML-тегов вместе с атрибутами.</p><p>Пример использования:</p><code-example><script>`<script>\n  var re = /* ваш регэксп */\n&nbsp\n  var str = '<><a href="/"><input type="radio" checked><b>';\n\n  alert( str.match(re) ); // '<a href="/">', '<input type="radio" checked>', '<b>'\n<\/script>`</script><code-toolbar-><div></div><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><p>В этой задаче можно считать, что тег начинается с <code>&lt;</code>, заканчивается <code>&gt;</code> и может содержать внутри любые символы, кроме <code>&lt;</code> и <code>&gt;</code>.</p><p>Но хотя бы один символ внутри тега должен быть: <code>&lt;&gt;</code> – не тег.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Начнём поиск с <code-pattern>&lt;</code-pattern>, затем один или более произвольный символ, но до закрывающего «уголка»: <code-pattern>.+?&gt;</code-pattern>.</p><p>Проверим, как работает этот регэксп:</p><code-example><script>`<script>\n  var re = GOLD_/<.+?>/g_GOLD;\n&nbsp\n  var str = '<><a href="/"><input type="radio" checked><b>';\n\n  alert( str.match(re) ); // <><a href="/">, <input type="radio" checked>, <b>\n<\/script>`</script><code-toolbar></code-toolbar></code-example><p>Результат неверен! В качестве первого тега регэксп нашёл подстроку <code-match>&lt;&gt; &lt;a href="/"&gt;</code-match>, но это явно не тег.</p><p>Всё потому, что <code-pattern>.+?</code-pattern> – это «любой символ (кроме <code>\n</code>), повторяющийся один и более раз до того, как оставшаяся часть шаблона совпадёт (ленивость)».</p><p>Поэтому он находит первый <code>&lt;</code>, затем есть «всё подряд» до следующего <code>&gt;</code>.</p><p>Первое совпадение получается как раз таким:</p><code-example><script>`<.............>\n<><a href="/"><input type="radio" checked><b>`</script></code-example><p>Правильным решением будет использовать <code-pattern>&lt;[^&gt;]+&gt;</code-pattern>:</p><code-example><script>`<script>\n  var re = GOLD_/<[^>]+>/g_GOLD\n&nbsp\n  var str = '<><a href="/"><input type="radio" checked><b>';\n\n  alert( str.match(re) ); // <a href="/">, <input type="radio" checked>, <b>\n<\/script>`</script><code-toolbar></code-toolbar></code-example><p>Это же решение автоматически позволяет находится внутри тегу символу <code>\n</code>, который в класс точка <code>.</code> не входит.</p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Квантификаторы +, *, ? и {n}; Скобочные группы"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><script>disqus_url = "https:\/\/learn.javascript.ru\/regexp-greedy-and-lazy", disqus_identifier = "regexp-greedy-and-lazy", disqus_title = "\u0416\u0430\u0434\u043d\u044b\u0435 \u0438 \u043b\u0435\u043d\u0438\u0432\u044b\u0435 \u043a\u0432\u0430\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u044b";</script></page-content></main>