<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="219">Регулярные выражения</a></nav-up><h1>Обратные ссылки: \n и $n</h1><p>Скобочные группы можно не только получать в результате.</p><p>Движок регулярных выражений запоминает их содержимое, и затем его можно использовать как в самом паттерне, так и в строке замены.</p><h2><a name="0" href="#0">Группа в строке замены</a></h2><p>Ссылки в строке замены имеют вид <code>$n</code>, где <code>n</code> – это номер скобочной группы.</p><p>Вместо <code>$n</code> подставляется содержимое соответствующей скобки:</p><code-example><script>`var name = "Александр Пушкин";\n\nname = name.replace(GOLD_/([а-яё]+) ([а-яё]+)/i_GOLD, HIGH"$2, $1"LIGHT);\nalert( name ); // Пушкин, Александр`</script><code-toolbar></code-toolbar></code-example><p>В примере выше вместо <code-pattern>$2</code-pattern> подставляется второе найденное слово, а вместо <code-pattern>$1</code-pattern> – первое.</p><h2><a name="1" href="#1">Группа в шаблоне</a></h2><p>Выше был пример использования содержимого групп в строке замены. Это удобно, когда нужно реорганизовать содержимое или создать новое с использованием старого.</p><p>Но к скобочной группе можно также обратиться в самом поисковом шаблоне, ссылкой вида <code>\номер</code>.</p><p>Чтобы было яснее, рассмотрим это на реальной задаче – необходимо найти в тексте строку в кавычках. Причём кавычки могут быть одинарными <code-subject>'...'</code-subject> или двойными <code-subject>"..."</code-subject> – и то и другое должно искаться корректно.</p><p>Как такие строки искать?</p><p>Можно в регэкспе предусмотреть произвольные кавычки: <code-pattern>['"](.*?)['"]</code-pattern>. Такой регэксп найдёт строки вида <code-match>"..."</code-match>, <code-match>'...'</code-match>, но он даст неверный ответ в случае, если одна кавычка ненароком оказалась внутри другой, как например в строке <code-subject>"She's the one!"</code-subject>:</p><code-example><script>`var str = "He said: \\"She'GREEN_s the one!\\".";\n\nvar reg = GOLD_/['"](.*?)['"]/g_GOLD;\n\n// Результат не соответствует замыслу\nalert( str.match(reg) ); // "She'`</script><code-toolbar></code-toolbar></code-example><p>Как видно, регэксп нашёл открывающую кавычку <code-match>"</code-match>, затем текст, вплоть до новой кавычки <code-match>'</code-match>, которая закрывает соответствие.</p><p>Для того, чтобы попросить регэксп искать закрывающую кавычку – такую же, как открывающую, мы обернём её в скобочную группу и используем обратную ссылку на неё:</p><code-example><script>`var str = "He said: \\"She'GREEN_s the one!\\".";\n\nvar reg = GOLD_/(['"])(.*?)\\1/g_GOLD;\n\nalert( str.match(reg) ); // "She's the one!"`</script><code-toolbar></code-toolbar></code-example><p>Теперь работает верно! Движок регулярных выражений, найдя первое скобочное выражение – кавычку <code-pattern>(['"])</code-pattern>, запоминает его и далее <code-pattern>\1</code-pattern> означает «найти то же самое, что в первой скобочной группе».</p><p>Обратим внимание на два нюанса:</p><ul><li>Чтобы использовать скобочную группу в строке замены – нужно использовать ссылку вида <code>$1</code>, а в шаблоне – обратный слэш: <code>\1</code>.</li><li>Чтобы в принципе иметь возможность обратиться к скобочной группе – не важно откуда, она не должна быть исключена из запоминаемых при помощи <code>?:</code>. Скобочные группы вида <code>(?:...)</code> не участвуют в нумерации.</li></ul><h2 id="tasks"><a href="#2" name="2">Задачи (1)</a></h2><task-content><h3><a href="#4" name="4">Найдите пары тегов</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><p>ББ-тег имеет вид <code>[имя]...[/имя]</code>, где имя – слово, одно из: <code>b</code>, <code>url</code>, <code>quote</code>.</p><p>Например:</p><code-example><script>`[b]текст[/b]\n[url]http://ya.ru[/url]`</script></code-example><p>ББ-теги могут быть вложенными, но сам в себя тег быть вложен не может, например:</p><code-example><script>`Допустимо:\n[url] [b]http://ya.ru[/b] [/url]\n[quote] [b]текст[/b] [/quote]\n\nНельзя:\n[b][b]текст[/b][/b]`</script></code-example><p>Создайте регулярное выражение для поиска ББ-тегов и их содержимого.</p><p>Например:</p><code-example><script>`var re = /* регулярка */\n\nvar str = "..[url]http://ya.ru[/url]..";\nalert( str.match(re) ); // [url]http://ya.ru[/url]`</script></code-example><p>Если теги вложены, то нужно искать самый внешний тег (при желании можно будет продолжить поиск в его содержимом):</p><code-example><script>`var re = /* регулярка */

var str = "..[url][b]http://ya.ru[/b][/url]..";
alert( str.match(re) ); // [url][b]http://ya.ru[/b][/url]`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Открывающий тег – это <code-pattern>\[(b|url|quote)\]</code-pattern>.</p><p>Для того, чтобы найти всё до закрывающего – используем ленивый поиск <code-pattern>[\s\S]*?</code-pattern> и обратную ссылку на открывающий тег.</p><p>Итого, получится: <code-pattern>\[(b|url|quote)\][\s\S]*?\[/\1\]</code-pattern>.</p><p>В действии:</p><code-example><script>`var re = GOLD_/\\[(b|url|quote)\\][\\s\\S]*?\\[\\/\\1\\]/g;\n\nvar str1 = "..[url]http://ya.ru[/url]..";\nvar str2 = "..[url][b]http://ya.ru[/b][/url]..";\n\nalert( str1.match(re) ); // [url]http://ya.ru[/url]\nalert( str2.match(re) ); // [url][b]http://ya.ru[/b][/url]`</script><code-toolbar></code-toolbar></code-example><p>Для закрывающего тега <code>[/1]</code> понадобилось дополнительно экранировать слеш: <code>\[\/1\]</code>.</p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Скобочные группы; Альтернация (или) |"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><script>disqus_url = "https:\/\/learn.javascript.ru\/regexp-backreferences", disqus_identifier = "regexp-backreferences", disqus_title = "\u041e\u0431\u0440\u0430\u0442\u043d\u044b\u0435 \u0441\u0441\u044b\u043b\u043a\u0438: \\n \u0438 $n";</script></page-content></main>