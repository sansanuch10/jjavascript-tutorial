<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="219">Регулярные выражения</a></nav-up><h1>Скобочные группы</h1><p>Часть шаблона может быть заключена в скобки <code-pattern>(...)</code-pattern>. Такие выделенные части шаблона называют «скобочными выражениями» или «скобочными группами».</p><p>У такого выделения есть два эффекта:</p><ol><li>Он позволяет выделить часть совпадения в отдельный элемент массива при поиске через  <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/match">String#match</a> или  <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec">RegExp#exec</a>.</li><li>Если поставить квантификатор после скобки, то он применится  <em>ко всей скобке</em>, а не всего лишь к одному символу.</li></ol><h2><a name="0" href="#0">Пример</a></h2><p>В примере ниже, шаблон <code-pattern>(go)+</code-pattern> находит один или более повторяющихся <code-pattern>'go'</code-pattern>:</p><code-example><script>`alert( 'Gogogo now!'.match(GOLD_/(go)+/i_GOLD) ); // "Gogogo"`</script><code-toolbar></code-toolbar></code-example><p>Без скобок, шаблон <code-pattern>/go+/</code-pattern> означал бы <code-subject>g</code-subject>, после которого идёт одна или более <code-subject>o</code-subject>, например: <code-match>goooo</code-match>. А скобки «группируют» <code-pattern>(go)</code-pattern> вместе.</p><h2><a name="1" href="#1">Содержимое группы</a></h2><p>Скобки нумеруются слева направо. Поисковой движок запоминает содержимое каждой скобки и позволяет обращаться к нему – в шаблоне и строке замены и, конечно же, в результатах.</p><p>Например, найти HTML-тег можно шаблоном <code-pattern>&lt;.*?&gt;</code-pattern>.</p><p>После поиска мы захотим что-то сделать с результатом. Для удобства заключим содержимое <code>&lt;...&gt;</code> в скобки: <code-pattern>&lt;(.*?)&gt;</code-pattern>. Тогда оно будет доступно отдельно.</p><p>При поиске методом <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/match">String#match</a> в результирующем массиве будет сначала всё совпадение, а далее – скобочные группы. В шаблоне <code-pattern>&lt;(.*?)&gt;</code-pattern> скобочная группа только одна:</p><code-example><script>`var str = '<h1>Привет, мир!</h1>';\nvar reg = GOLD_/<(.*?)>/_GOLD;\n\nalert( str.match(reg) ); // массив: <h1>, h1`</script><code-toolbar></code-toolbar></code-example><p>Заметим, что метод <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/match">String#match</a> выдаёт скобочные группы только при поиске без флага <code>/.../g</code>. В примере выше он нашёл только первое совпадение <code-match>&lt;h1&gt;</code-match>, а закрывающий <code-match>&lt;/h1&gt;</code-match> не нашёл, поскольку без флага <code>/.../g</code> ищется только первое совпадение.</p><p>Для того, чтобы искать и с флагом <code>/.../g</code> и со скобочными группами, используется метод <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec">RegExp#exec</a>:</p><code-example><script>`var str = '<h1>Привет, мир!</h1>';\nvar reg = GOLD_/<(.*?)>/g_GOLD;\n\nvar match;\n\nwhile ((match = reg.exec(str)) !== null) {\n  // сначала выведет первое совпадение: <h1>,h1\n  // затем выведет второе совпадение: </h1>,/h1\n  alert(match);\n}`</script><code-toolbar></code-toolbar></code-example><p>Теперь найдено оба совпадения <code-pattern>&lt;(.*?)&gt;</code-pattern>, каждое – массив из полного совпадения и скобочных групп (одна в данном случае).</p><h2><a name="2" href="#2">Вложенные группы</a></h2><p>Скобки могут быть и вложенными. В этом случае нумерация также идёт слева направо.</p><p>Например, при поиске тега в <code-subject>&lt;span class="my"&gt;</code-subject> нас может интересовать:</p><ol><li>Содержимое тега целиком:  <code>span class="my"</code>.</li><li>В отдельную переменную для удобства хотелось бы поместить тег:  <code>span</code>.</li><li>Также может быть удобно отдельно выделить атрибуты  <code>class="my"</code>.</li></ol><p>Добавим скобки в регулярное выражение:</p><code-example><script>`var str = '<span class="my">';\n\nvar reg = GOLD_/<(([a-z]+)\s*([^>]*))>/_GOLD;\n\nalert( str.match(reg) ); // <span class="my">, span class="my", span, class="my"`</script><code-toolbar></code-toolbar></code-example><p>Вот так выглядят скобочные группы:</p><figure><img src="regexp-nested-groups.png" alt="" width="100%" style="max-width:320px"></figure><p>На нулевом месте – всегда совпадение полностью, далее – группы. Нумерация всегда идёт слева направо, по открывающей скобке.</p><p>В данном случае получилось, что группа 1 включает в себя содержимое групп 2 и 3. Это совершенно нормальная ситуация, которая возникает, когда нужно выделить что-то отдельное внутри большей группы.</p><p><strong>Даже если скобочная группа необязательна и не входит в совпадение, соответствующий элемент массива существует  (и равен  <code>undefined</code>).</strong></p><p>Например, рассмотрим регэксп <code-pattern>a(z)?(c)?</code-pattern>. Он ищет <code>"a"</code>, за которой не обязательно идёт буква <code>"z"</code>, за которой необязательно идёт буква <code>"c"</code>.</p><p>Если напустить его на строку из одной буквы <code>"a"</code>, то результат будет таков:</p><code-example><script>`var match = 'a'.match(GOLD_/a(z)?(c)?/_GOLD)\n\nalert( match.length ); // 3\nalert( match[0] ); // a\nalert( match[1] ); // undefined\nalert( match[2] ); // undefined`</script><code-toolbar></code-toolbar></code-example><p>Массив получился длины <code>3</code>, но все скобочные группы – <code>undefined</code>.</p><p>А теперь более сложная ситуация, строка <code-subject>ack</code-subject>:</p><code-example><script>`var match = 'ack'.match(GOLD_/a(z)?(c)?/_GOLD)\n\nalert( match.length ); // 3\nalert( match[0] ); // ac, всё совпадение\nalert( match[1] ); // undefined, для (z)? ничего нет\nalert( match[2] ); // c`</script><code-toolbar></code-toolbar></code-example><p>Длина массива результатов по-прежнему <code>3</code>. Она постоянна. А вот для скобочной группы <code-pattern>(z)?</code-pattern> в ней ничего нет, поэтому результат: <code>["ac", undefined, "c"]</code>.</p><h2><a name="3" href="#3">Исключение из запоминания через ?:</a></h2><p>Бывает так, что скобки нужны, чтобы квантификатор правильно применился, а вот запоминать их содержимое в массиве не нужно.</p><p>Скобочную группу можно исключить из запоминаемых и нумеруемых, добавив в её начало <code-pattern>?:</code-pattern>.</p><p>Например, мы хотим найти <code-pattern>(go)+</code-pattern>, но содержимое скобок ( <code>go</code>) в отдельный элемент массива выделять не хотим.</p><p>Для этого нужно сразу после открывающей скобки поставить <code>?:</code>, то есть: <code-pattern>(?:go)+</code-pattern>.</p><p>Например:</p><code-example><script>`var str = "Gogo John!";\nvar reg = GOLD_/(?:go)+ (\\w+)/i_GOLD;\n\nvar result = str.match(reg);\n\nalert( result.length ); // 2\nalert( result[1] ); // John`</script><code-toolbar></code-toolbar></code-example><p>В примере выше массив результатов имеет длину <code>2</code> и содержит только полное совпадение и результат <code-pattern>(\w+)</code-pattern>. Это удобно в тех случаях, когда содержимое скобок нас не интересует.</p><h2 id="tasks"><a href="#4" name="4">Задачи (2)</a></h2><task-content><h3>  <a href="#6" name="6">Найдите цвет в формате #abc или #abcdef</a>  <task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><p>Напишите регулярное выражение, которое находит цвет в формате  <code>#abc</code> или  <code>#abcdef</code>. То есть, символ  <code>#</code>, после которого идут 3 или 6 шестнадцатиричных символа.</p><p>Пример использования:</p><code-example><script>`var re = /* ваш регэксп */\n\nvar str = "color: #3f3; background-color: #AA00ef; and: #abcd";\n\nalert( str.match(re) ); // #3f3 #AA0ef`</script><code-toolbar-><div></div><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><p>P.S. Значения из любого другого количества букв, кроме 3 и 6, такие как  <code>#abcd</code>, не должны подходить под регэксп.</p><button-answer data-toggle_answer="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Регулярное выражение для поиска 3-значного цвета вида  <code>#abc</code>:  <code-pattern>/#[a-f0-9]{3}/i</code-pattern>.</p><p>Нужно добавить ещё три символа, причём нужны именно три, четыре или семь символов не нужны. Эти три символа  либо есть, либо нет.</p><p>Самый простой способ добавить – просто дописать в конец регэкспа:  <code-pattern>/#[a-f0-9]{3}([a-f0-9]{3})?/i</code-pattern></p><p>Можно поступить и хитрее:  <code-pattern>/#([a-f0-9]{3}){1,2}/i</code-pattern>.</p><p>Здесь регэксп  <code-pattern>[a-f0-9]{3}</code-pattern> заключён в скобки, чтобы квантификатор  <code-pattern>{1,2}</code-pattern> применялся целиком ко всей этой структуре.</p><p>В действии:</p><code-example><script>`var re = GOLD_/#([a-f0-9]{3}){1,2}/gi_GOLD;\n\nvar str = "color: #3f3; background-color: #AA00ef; and: #abcd";\n\nalert( str.match(re) ); // #3f3 #AA0ef #abc`</script><code-toolbar></code-toolbar></code-example><p>В последнем выражении  <code-subject>#abcd</code-subject> было найдено совпадение  <code-match>#abc</code-match>. Чтобы этого не происходило, добавим в конец  <code-pattern>\b</code-pattern>:</p><code-example><script>`var re = GOLD_/#([a-f0-9]{3}){1,2}\\b/gi_GOLD;\n\nvar str = "color: #3f3; background-color: #AA00ef; and: #abcd";\n\nalert( str.match(re) ); // #3f3 #AA0ef`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3>  <a href="#7" name="7">Разобрать выражение</a>  <task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><p>Арифметическое выражение состоит из двух чисел и операции между ними, например:</p><ul><li>  <code>1 + 2</code>  </li><li>  <code>1.2 * 3.4</code>  </li><li>  <code>-3 / -6</code>  </li><li>  <code>-2 - 2</code>  </li></ul><p>Список операций:  <code>"+"</code>,  <code>"-"</code>,  <code>"*"</code> и  <code>"/"</code>.</p><p>Также могут присутствовать пробелы вокруг оператора и чисел.</p><p>Напишите функцию, которая будет получать выражение и возвращать массив из трёх аргументов:</p><ol><li>Первое число.</li><li>Оператор.</li><li>Второе число.</li></ol><p></p><button-answer data-toggle_answer="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Регулярное выражение для числа, возможно, дробного и отрицательного:  <code-pattern>-?\d+(\.\d+)?</code-pattern>. Мы уже разбирали его в предыдущих задачах.</p><p>Оператор – это  <code-pattern>[-+*/]</code-pattern>. Заметим, что дефис  <code-pattern>-</code-pattern> идёт в списке первым, так как на любой позиции, кроме первой и последней, он имеет специальный  смысл внутри  <code-pattern>[...]</code-pattern>, и его понадобилось бы экранировать.</p><p>Кроме того, когда мы оформим это в JavaScript-синтаксис  <code-pattern>/.../</code-pattern> – понадобится заэкранировать слэш  <code-pattern>/</code-pattern>.</p><p>Нам нужно число, затем оператор, затем число, и необязательные пробелы между ними.</p><p>Полное регулярное выражение будет таким:  <code-pattern>-?\d+(\.\d+)?\s*[-+*/]\s*-?\d+(\.\d+)?</code-pattern>.</p><p>Чтобы получить результат в виде массива, добавим скобки вокруг тех данных, которые нам интересны, то есть  – вокруг чисел и оператора:  <code-pattern>(-?\d+(\.\d+)?)\s*([-+*/])\s*(-?\d+(\.\d+)?)</code-pattern>.</p><p>Посмотрим в действии:</p><code-example><script>`var re = GOLD_/(-?\\d+(\\.\\d+)?)\\s*([-+*\\/])\\s*(-?\\d+(\\.\\d+)?)/_GOLD;\n\nalert( "1.2 + 12".match(re) );`</script><code-toolbar></code-toolbar></code-example><p>Итоговый массив будет включать в себя компоненты:</p><ul><li>  <code>result[0] == "1.2 + 12"</code> (вначале всегда полное совпадение)</li><li>  <code>result[1] == "1"</code> (первая скобка)</li><li>  <code>result[2] == "2"</code> (вторая скобка – дробная часть  <code>(\.\d+)?</code>)</li><li>  <code>result[3] == "+"</code> (…)</li><li>  <code>result[4] == "12"</code> (…)</li><li>  <code>result[5] == undefined</code> (последняя скобка, но у второго числа дробная часть отсутствует)</li></ul><p>Нам из этого массива нужны только числа и оператор. А, скажем, дробная часть сама по себе – не нужна.</p><p>Уберём её из запоминания, добавив в начало скобки  <code-pattern>?:</code-pattern>, то есть:  <code-pattern>(?:\.\d+)?</code-pattern>.</p><p>Итого, решение:</p><code-example><script>`function parse(expr) {\n  var re = GOLD_/(-?\\d+(?:\\.\\d+)?)\\s*([-+*\\/])\\s*(-?\\d+(?:\\.\\d+)?)/_GOLD;\n\n  var result = expr.match(re);\n\n  if (!result) return;\n  result.shift();\n\n  return result;\n}\n\nalert( parse("-1.23 * 3.45") );  // -1.23, *, 3.45`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Жадные и ленивые квантификаторы; Обратные ссылки: \n и $n"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><script>disqus_url = "https:\/\/learn.javascript.ru\/regexp-groups", disqus_identifier = "regexp-groups", disqus_title = "\u0421\u043a\u043e\u0431\u043e\u0447\u043d\u044b\u0435 \u0433\u0440\u0443\u043f\u043f\u044b";</script></page-content></main>