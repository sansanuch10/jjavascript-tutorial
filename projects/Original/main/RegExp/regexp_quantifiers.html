<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="219">Регулярные выражения</a></nav-up><h1>Квантификаторы +, *, ? и {n}</h1><p>Рассмотрим ту же задачу, что и ранее – взять телефон вида <code>+7(903)-123-45-67</code> и найти все числа в нём. Но теперь нас интересуют не цифры по отдельности, а именно числа, то есть результат вида <code>7, 903, 123, 45, 67</code>.</p><p>Для поиска цифр по отдельности нам было достаточно класса <code>\d</code>. Но здесь нужно искать <em>числа</em> – последовательности из 1 или более цифр.</p><h2><a name="0" href="#0">Количество {n}</a></h2><p>Количество повторений символа можно указать с помощью числа в фигурных скобках: <code>{n}</code>.</p><p>Такое указание называют <em>квантификатором</em> (от англ. quantifier).</p><p>У него есть несколько подформ записи:</p><dl><dt>Точное количество:  <code>{5}</code></dt><dd><p>Регэксп  <code-pattern>\d{5}</code-pattern> обозначает ровно 5 цифр, в точности как  <code-pattern>\d\d\d\d\d</code-pattern>.</p><p>Следующий пример находит пятизначное число.</p><code-example><script>`alert( "Мне 12345 лет".match(GOLD_/\\d{5}/_GOLD) ); //  "12345"`</script><code-toolbar></code-toolbar></code-example></dd><dt>Количество от-до:  <code>{3,5}</code></dt><dd><p>Для того, чтобы найти, например, числа размером от трёх до пяти знаков, нужно указать границы в фигурных  скобках:  <code-pattern>\d{3,5}</code-pattern> </p><code-example><script>`alert( "Мне не 12, а 1234 года".match(GOLD_/\\d{3,5}/_GOLD) ); // "1234"`</script><code-toolbar></code-toolbar></code-example><p>Последнее значение можно и не указывать. Тогда выражение  <code-pattern>\d{3,}</code-pattern> найдет числа, длиной от трех цифр:</p><code-example><script>`alert( "Мне не 12, а 345678 лет".match(GOLD_/\\d{3,}/_GOLD) ); // "345678"`</script><code-toolbar></code-toolbar></code-example></dd></dl><p>В случае с телефоном нам нужны числа – одна или более цифр подряд. Этой задаче соответствует регулярное выражение <code-pattern>\d{1,}</code-pattern>:</p><code-example><script>`var str = "+7(903)-123-45-67";\n\nalert( str.match(GOLD_/\\d{1,}/g_GOLD) ); // 7,903,123,45,67`</script><code-toolbar></code-toolbar></code-example><h2><a name="1" href="#1">Короткие обозначения</a></h2><p>Для самых часто востребованных квантификаторов есть специальные короткие обозначения.</p><dl><dt><code>+</code></dt><dd><p>Означает «один или более», то же что  <code>{1,}</code>.</p><p>Например,  <code-pattern>\d+</code-pattern> находит числа – последовательности из 1 или более цифр:</p><code-example><script>`var str = "+7(903)-123-45-67";\n\nalert( str.match(GOLD_/\\d+/g_GOLD) ); // 7,903,123,45,67`</script><code-toolbar></code-toolbar></code-example></dd><dt><code>?</code></dt><dd><p>Означает «ноль или один», то же что и  <code>{0,1}</code>. По сути, делает символ необязательным.</p><p>Например, регэксп  <code-pattern>ou?r</code-pattern> найдёт  <code-match>o</code-match>, после которого, возможно, следует  <code-match>u</code-match>, а затем  <code-match>r</code-match>.</p><p>Этот регэксп найдёт  <code-match>or</code-match> в слове  <code-subject>color</code-subject> и  <code-match>our</code-match> в  <code-subject>colour</code-subject>:</p><code-example><script>`var str = "Можно писать color или colour (британский вариант)";\n\nalert( str.match(GOLD_/colou?r/g_GOLD) ); // color, colour`</script><code-toolbar></code-toolbar></code-example></dd><dt><code>*</code></dt><dd><p>Означает «ноль или более», то же что  <code>{0,}</code>. То есть, символ может повторяться много раз или вообще отсутствовать.</p><p>Пример ниже находит цифру вместе со всеми нулями, которые идут за ней (но могут и не идти):</p><code-example><script>`alert( "100 10 1".match(GOLD_/\\d0*/g_GOLD) ); // 100, 10, 1`</script><code-toolbar></code-toolbar></code-example><p>Сравните это с  <code>'+'</code> (один или более):</p><code-example><script>`alert( "100 10 1".match(GOLD_/\\d0+/g_GOLD) ); // 100, 10`</script><code-toolbar></code-toolbar></code-example></dd></dl><h2><a name="2" href="#2">Ещё примеры</a></h2><p>Эти квантификаторы принадлежат к числу самых важных «строительных блоков» для сложных регулярных выражений, поэтому мы рассмотрим ещё примеры.</p><dl><dt>Регэксп «десятичная дробь» (число с точкой внутри):  <code-pattern>\d+\.\d+</code-pattern></dt><dd><p>В действии:</p><code-example><script>`alert( "0 1 12.345 7890".match(GOLD_/\\d+\\.\\d+/g_GOLD) ); // 12.345`</script><code-toolbar></code-toolbar></code-example></dd><dt>Регэксп «открывающий HTML-тег без атрибутов», такой как  <code>&lt;span&gt;</code> или  <code>&lt;p&gt;</code>:  <code-pattern>/&lt;[a-z]+&gt;/i</code-pattern></dt><dd><p>Пример:</p><code-example><script>`alert( "<BODY> ... </BODY>".match(GOLD_/<[a-z]+>/gi_GOLD) ); // <BODY>`</script><code-toolbar></code-toolbar></code-example><p>Это регулярное выражение ищет символ  <code-pattern>'&lt;'</code-pattern>, за которым идут одна или более букв английского алфавита, и затем  <code-pattern>'&gt;'</code-pattern>.</p></dd><dt>Регэксп «открывающий HTML-тег без атрибутов» (лучше):  <code-pattern>/&lt;[a-z][a-z0-9]*&gt;/i</code-pattern></dt><dd><p>Здесь регулярное выражение расширено: в соответствие со стандартом, HTML-тег может иметь символ цифры на  любой позиции, кроме первой, например  <code>&lt;h1&gt;</code>.</p><code-example><script>`alert( "<h1>Привет!</h1>".match(GOLD_/<[a-z][a-z0-9]*>/gi_GOLD) ); // <h1>`</script><code-toolbar></code-toolbar></code-example></dd><dt>Регэксп «открывающий или закрывающий HTML-тег без атрибутов»:  <code-pattern>/&lt;\/?[a-z][a-z0-9]*&gt;/i</code-pattern></dt><dd><p>В предыдущий паттерн добавили необязательный слэш  <code-pattern>/?</code-pattern> перед тегом. Его понадобилось заэкранировать, чтобы JavaScript не принял его за конец  шаблона.</p><code-example><script>`alert( "<h1>Привет!</h1>".match(GOLD_/<\\/?[a-z][a-z0-9]*>/gi_GOLD) ); // <h1>, </h1>`</script><code-toolbar></code-toolbar></code-example></dd></dl><important-><h3>Точнее – значит сложнее</h3><p>В этих примерах мы видим общее правило, которое повторяется из раза в раз: чем точнее регулярное выражение, тем  оно длиннее и сложнее.</p><p>Например, для HTML-тегов, скорее всего, подошло бы и более короткое регулярное выражение  <code-pattern>&lt;\w+&gt;</code-pattern>.</p><p>Так как класс  <code>\w</code> означает "любая цифра или английская буква или  <code>'_'</code>, то под такой регэксп подойдут и не теги, например  <code-match>&lt;_&gt;</code-match>. Однако он гораздо проще, чем более точный регэксп  <code-pattern>&lt;[a-z][a-z0-9]*&gt;</code-pattern>.</p><p>Подойдёт ли нам  <code-pattern>&lt;\w+&gt;</code-pattern> или нужно использовать именно  <code-pattern>&lt;[a-z][a-z0-9]*&gt;</code-pattern>?</p><p>В реальной жизни допустимы оба варианта. Ответ на подобные вопросы зависит от того, насколько реально важна точность  и насколько сложно потом будет отфильтровать лишние совпадения (если появятся).</p></important-><h2 id="tasks"><a href="#3" name="3">Задачи (4)</a></h2><task-content><h3>  <a href="#6" name="6">Как найти многоточие... ?</a>  <task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open>  <task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open>  <task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Напишите регулярное выражения для поиска многоточий: трёх или более точек подряд.</p><p>Проверьте его:</p><code-example><script>`var reg = /ваше выражение/g;\nalert( "Привет!... Как дела?.....".match(reg) ); // ..., .....`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer style=""><close- title="закрыть" data-close_answer=""></close-><p>Решение:</p><code-example><script>`var reg = GOLD_/\\.{3,}/g_GOLD;\nalert( "Привет!... Как дела?.....".match(reg) ); // ..., .....`</script><code-toolbar></code-toolbar></code-example><p>Заметим, что символ  <code>.</code> является специальным, значит его надо экранировать, то есть вставлять как  <code>\.</code>.</p></task-answer></task-content><task-content><h3>  <a href="#7" name="7">Регулярное выражение для цвета</a>  <task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open>  <task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open>  <task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><p>Напишите регулярное выражение для поиска HTML-цвета, заданного как  <code>#ABCDEF</code>, то есть  <code>#</code> и содержит затем 6 шестнадцатеричных символов.</p><p>Пример использования:</p><code-example><script>`var re = /*...ваше регулярное выражение...*/\n\nvar str = "color:#121212; background-color:#AA00ef bad-colors:f#fddee #fd2"\n\nalert( str.match(re) )  // #121212,#AA00ef`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Итак, нужно написать выражение для описания цвета, который начинается с «#», за которым следуют 6 шестнадцатеричных  символов.</p><p>Шестнадцатеричный символ можно описать с помощью  <code-pattern>[0-9a-fA-F]</code-pattern>. Мы можем сократить выражение, используя не чувствительный к регистру шаблон  <code-pattern>[0-9a-f]</code-pattern>.</p><p>Для его шестикратного повторения мы будем использовать квантификатор  <code-pattern>{6}</code-pattern>.</p><p>В итоге, получаем выражение вида  <code-pattern>/#[a-f0-9]{6}/gi</code-pattern>.</p><code-example><script>`var re = GOLD_/#[a-f0-9]{6}/gi_GOLD;\n\nvar str = "color:#121212; background-color:#AA00ef bad-colors:f#fddee #fd2";\n\nalert( str.match(re) );  // #121212,#AA00ef`</script><code-toolbar></code-toolbar></code-example><p>Проблема этого выражения в том, что оно находит цвет и в более длинных последовательностях:</p><code-example><script>`alert( "#12345678".match( GOLD_/#[a-f0-9]{6}/gi_GOLD ) ) // #12345678`</script><code-toolbar></code-toolbar></code-example><p>Чтобы такого не было, можно добавить в конец  <code>\b</code>:</p><code-example><script>`// цвет\nalert( "#123456".match( GOLD_/#[a-f0-9]{6}\\b/gi_GOLD ) ); // #123456\n\n// не цвет\nalert( "#12345678".match( GOLD_/#[a-f0-9]{6}\\b/gi_GOLD ) ); // null`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3>  <a href="#8" name="8">Найдите положительные числа</a>  <task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open>  <task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open>  <task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><p>Создайте регэксп, который ищет все положительные числа, в том числе и с десятичной точкой.</p><p>Пример использования:</p><code-example><script>`var re = /* ваш регэксп */\n\nvar str = "1.5 0 12. 123.4.";\n\nalert( str.match(re) );   // 1.5, 0, 12, 123.4`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Целое число – это  <code-pattern>\d+</code-pattern>.</p><p>Десятичная точка с дробной частью –  <code-pattern>\.\d+</code-pattern>.</p><p>Она не обязательна, так что обернём её в скобки с квантификатором  <code-pattern>'?'</code-pattern>.</p><p>Итого, получилось регулярное выражение  <code-pattern>\d+(\.\d+)?</code-pattern>:</p><code-example><script>`var re = GOLD_/\\d+(\\.\\d+)?/g_GOLD\n\nvar str = "1.5 0 12. 123.4.";\n\nalert( str.match(re) );   // 1.5, 0, 12, 123.4`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3>  <a href="#9" name="9">Найдите десятичные числа</a>  <task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open>  <task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open>  <task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><p>Создайте регэксп, который ищет все числа, в том числе и с десятичной точкой, в том числе и отрицательные.</p><p>Пример использования:</p><code-example><script>`var re = /* ваш регэксп */\n\nvar str = "-1.5 0 2 -123.4.";\n\nalert( str.match(re) );   // -1.5, 0, 2, -123.4`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Целое число с необязательной дробной частью – это  <code-pattern>\d+(\.\d+)?</code-pattern>.</p><p>К этому нужно добавить необязательный  <code>-</code> в начале:</p><code-example><script>`var re = GOLD_/-?\\d+(\\.\\d+)?/g_GOLD\n\nvar str = "-1.5 0 2 -123.4.";\n\nalert( str.match(re) );   // -1.5, 0, 2, -123.4`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Наборы и диапазоны [...]; Жадные и ленивые квантификаторы"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><script>disqus_url = "https:\/\/learn.javascript.ru\/regexp-quantifiers", disqus_identifier = "regexp-quantifiers", disqus_title = "\u041a\u0432\u0430\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u044b +, *, ? \u0438 {n}";</script></page-content></main>