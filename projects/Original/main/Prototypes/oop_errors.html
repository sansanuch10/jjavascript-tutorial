<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="74">ООП в прототипном стиле</a></nav-up><h1>Свои ошибки, наследование от Error</h1><p>Когда мы работаем с внешними данными, возможны самые разные ошибки.</p><p>Если приложение сложное, то ошибки естественным образом укладываются в иерархию, разобраться в которой помогает <code>instanceof</code>.</p><h2><a name="0" href="#0">Свой объект ошибки</a></h2><p>Для примера создадим функцию <code>readUser(json)</code>, которая будет разбирать JSON с данными посетителя. Мы его получаем с сервера – может, нашего, а может – чужого, в общем – желательно проверить на ошибки. А может, это даже и не JSON, а какие-то другие данные – не важно, для наглядности поработаем с JSON.</p><p>Пример <code>json</code> на входе в функцию: <code>{ "name": "Вася", "age": 30 }</code>.</p><p>В процессе работы <code>readUser</code> возможны различные ошибки. Одна – очевидно, <code>SyntaxError</code> – если передан некорректный JSON.</p><p>Но могут быть и другие, например <code>PropertyError</code> – эта ошибка будет возникать, если в прочитанном объекте нет свойства <code>name</code> или <code>age</code>.</p><p>Реализуем класс <code>PropertyError</code>:</p><code-example><script>`function PropertyError(property) {\n  Error.call(this, property) ;\n  this.name = "PropertyError";\n\n  this.property = property;\n  this.message = "Ошибка в свойстве&nbsp" + property;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, PropertyError);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n}\n\nPropertyError.prototype = Object.create(Error.prototype);`</script></code-example><p>В этом коде вы можете видеть ряд важных деталей, важных именно для ошибок:</p><dl><dt><code>name</code> – имя ошибки.</dt><dd><p>Должно совпадать с именем функции.</p></dd><dt><code>message</code> – сообщение об ошибке.</dt><dd><p>Несмотря на то, что <code>PropertyError</code> наследует от <code>Error</code> (последняя строка), конструктор у неё немного другой. Он принимает не сообщение об ошибке, а название свойства <code>property</code>, ну а сообщение генерируется из него.</p><p>В результате в объекте ошибки есть как стандартное свойство <code>message</code>, так и более точное <code>property</code>.</p><p>Это частая практика – добавлять в объект ошибки свойства, которых нет в базовых объектах <code>Error</code>, более подробно описывающие ситуацию для данного класса ошибок.</p></dd><dt><code>stack</code> – стек вызовов, которые в итоге привели к ошибке.</dt><dd><p>У встроенных объектов <code>Error</code> это свойство есть автоматически, вот к примеру:</p><code-example><script>`function f() {\n  alert( new Error().stack );\n}\n\nf(); // выведет список вложенных вызовов, с номерами строк, где они были сделаны`</script><code-toolbar></code-toolbar></code-example><p>Если же объект ошибки делаем мы, то «по умолчанию» такого свойства у него не будет. Нам нужно как-то самим узнавать последовательность вложенных вызовов на текущий момент. Однако удобного способа сделать это в JavaScript нет, поэтому мы поступаем хитро и копируем его из нового объекта <code>new Error</code>, который генерируем тут же.</p><p>В V8 (Chrome, Opera, Node.JS) есть нестандартное расширение <a href="https://github.com/v8/v8/wiki/Stack-Trace-API#stack-trace-collection-for-custom-exceptions">Error.captureStackTrace</a>, которое позволяет получить стек.</p><p>Это делает строка из кода выше:</p><code-example><script>`Error.captureStackTrace(this, PropertyError);`</script></code-example><p>Такой вызов записывает в объект <code>this</code> (текущий объект ошибки) стек вызовов, ну а второй аргумент – вообще не обязателен, но если есть, то говорит, что при генерации стека нужно на этой функции остановиться. В результате в стеке будет информация о цепочке вложенных вызовов вплоть до вызова <code>PropertyError</code>.</p><p>То есть, будет последовательность вызовов до генерации ошибки, но не включая код самого конструктора ошибки, который, как правило, не интересен. Такое поведение максимально соответствует встроенным ошибкам JavaScript.</p></dd></dl><important-><h3>Конструктор родителя здесь не обязателен</h3><p>Обычно, когда мы наследуем, то вызываем конструктор родителя. В данном случае вызов выглядит как <code>Error.call(this, message)</code>.</p><p>Строго говоря, этот вызов здесь не обязателен. Встроенный конструктор <code>Error</code> ничего полезного не делает, даже свойство <code>this.message</code> (не говоря уже о <code>name</code> и <code>stack</code>) не назначает. Единственный возможный смысл его вызова – он ставит специальное внутреннее свойство <code>[[ErrorData]]</code>, которое выводится в <code>toString</code> и позволяет увидеть, что это ошибка. Поэтому по стандарту вызывать конструктор <code>Error</code> при наследовании в таких случаях рекомендовано.</p></important-><h2><a name="1" href="#1">instanceof + try…catch = ♡</a></h2><p>Давайте теперь используем наш новый класс для <code>readUser</code>:</p><code-example><script>`MARK// Объявление\nfunction PropertyError(property) {\n  this.name = "PropertyError";\n\n  this.property = property;\n  this.message = "Ошибка в свойстве&nbsp" + property;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, PropertyError);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n}\n\nPropertyError.prototype = Object.create(Error.prototype);\n\nMARK// Генерация ошибки\nfunction readUser(data) {\n\n  var user = JSON.parse(data);\n\n  if (!user.age) {\n    throw new PropertyError("age");\n  }\n\n  if (!user.name) {\n    throw new PropertyError("name");\n  }\n\n  return user;\n}\n\nMARK// Запуск и try..catch\n\ntry {\n  var user = readUser('{ "age": 25 }');\n} catch (err) {\n  if (err instanceof PropertyError) {\n    if (err.property == 'name') {\n      // если в данном месте кода возможны анонимы, то всё нормально\nMARK      alert( "Здравствуйте, Аноним!" );\n    } else {\n      alert( err.message ); // Ошибка в свойстве ...\n    }\n  } else if (err instanceof SyntaxError) {\n    alert( "Ошибка в синтаксисе данных:&nbsp" + err.message );\n  } else {\n    throw err; // неизвестная ошибка, не знаю что с ней делать\n  }\n}`</script><code-toolbar></code-toolbar></code-example><p>Всё работает – и наша ошибка <code>PropertyError</code> и встроенная <code>SyntaxError</code> корректно генерируются, перехватываются, обрабатываются.</p><p>Обратим внимание на проверку типа ошибки в <code>try..catch</code>. Оператор <code>instanceof</code> проверяет класс с учётом наследования. Это значит, что если мы в дальнейшем решим создать новый тип ошибки, наследующий от <code>PropertyError</code>, то проверка <code>err instanceof PropertyError</code> для класса-наследника тоже будет работать. Код получился расширяемым, это очень важно.</p><h2><a name="2" href="#2">Дальнейшее наследование</a></h2><p><code>PropertyError</code> – это просто общего вида ошибка в свойстве. Создадим ошибку <code>PropertyRequiredError</code>, которая означает, что свойства нет.</p><p>Это подвид <code>PropertyError</code>, так что унаследуем от неё. Общий вид конструктора-наследника – стандартный:</p><code-example><script>`function PropertyRequiredError(property) {\n  // вызываем конструктор родителя и передаём текущие аргументы\n  PropertyError.apply(this, arguments);\n  ...\n}`</script></code-example><p>Достаточно ли в наследнике просто вызвать конструктор родителя? Увы, нет.</p><p>Если так поступить, то свойство <code>this.name</code> будет некорректным, да и <code>Error.captureStackTrace</code> тоже получит неправильную функцию вторым параметром.</p><p>Можно ли как-то поправить конструктор родителя, чтобы от него было проще наследовать?</p><p>Для этого нужно убрать из него упоминания о конкретном классе <code>PropertyError</code>, чтобы сделать код универсальным. Частично – это возможно. Как мы помним, существует свойство <code>constructor</code>, которое есть в <code>prototype</code> по умолчанию, и которое мы можем намеренно сохранить при наследовании.</p><p>Исправим родителя <code>PropertyError</code> для более удобного наследования от него:</p><code-example><script>`function PropertyError(property) {\n  this.name = "PropertyError";\n\n  this.property = property;\n  this.message = "Ошибка в свойстве&nbsp" + property;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, HIGHthis.constructorLIGHT); // (*)\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n}\n\nPropertyError.prototype = Object.create(Error.prototype);\nMARKPropertyError.prototype.constructor = PropertyError;`</script></code-example><p>В строке <code>(*)</code> вместо ссылки на <code>PropertyError</code> используем <code>constructor</code> чтобы получить именно конструктор для текущего объекта. В наследнике там будет <code>PropertyRequiredError</code>, как и задумано.</p><p>Мы убрали одну жёсткую привязку к <code>PropertyError</code>, но со второй (<code>this.name</code>), увы, сложности. Оно должно содержать имя ошибки, то есть, имя её функции-конструктора. Его можно получить через <code>this.name = this.constructor.name</code>, но в IE11- это работать не будет.</p><p>Если поддерживать IE11-, то тут уж придётся в наследнике его записывать вручную.</p><p>Полный код для наследника:</p><code-example><script>`function PropertyRequiredError(property) {\n  PropertyError.apply(this, arguments);\n  this.name = 'PropertyRequiredError';\n  this.message = 'Отсутствует свойство&nbsp' + property;\n}\n\nPropertyRequiredError.prototype = Object.create(PropertyError.prototype);\nPropertyRequiredError.prototype.constructor = PropertyRequiredError;\n\nvar err = new PropertyRequiredError("age");\n// пройдёт проверку\nalert( err instanceof PropertyError ); // true`</script></code-example><p>Здесь заодно и <code>message</code> в наследнике было перезаписано на более точное. Если хочется избежать записи и перезаписи, то можно оформить его в виде геттера через <code>Object.defineProperty</code>.</p><h2><a name="3" href="#3">Итого</a></h2><ul><li>Чтобы наследовать от ошибок <code>Error</code>, нужно самостоятельно позаботиться о <code>name</code>, <code>message</code> и <code>stack</code>.</li><li>Благодаря тому, что <code>instanceof</code> поддерживает наследование, удобно организуются проверки на нужный тип. В иерархию ошибок можно в любой момент добавить новые классы, с понятным кодом и предсказуемым поведением.</li></ul><p>Чтобы создавать наследники от <code>Error</code> было проще, можно создать класс <code>CustomError</code>, записать в него универсальный код, наподобие <code>PropertyError</code> и далее наследовать уже от него:</p><code-example><script>`MARK// общего вида "наша" ошибка\nfunction CustomError(message) {\n  this.name = "CustomError";\n  this.message = message;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n}\n\nCustomError.prototype = Object.create(Error.prototype);\nCustomError.prototype.constructor = CustomError;\n\nMARK// наследник\nfunction PropertyError(property) {\n  CustomError.call(this, "Ошибка в свойстве&nbsp" + property)\n  this.name = "PropertyError";\n\n  this.property = property;\n}\n\nPropertyError.prototype = Object.create(CustomError.prototype);\nPropertyError.prototype.constructor = PropertyError;\n\nMARK// и ещё уровень\nfunction PropertyRequiredError(property) {\n  PropertyError.call(this, property);\n  this.name = 'PropertyRequiredError';\n  this.message = 'Отсутствует свойство&nbsp' + property;\n}\n\nPropertyRequiredError.prototype = Object.create(PropertyError.prototype);\nPropertyRequiredError.prototype.constructor = PropertyRequiredError;\n\nMARK// использование\nvar err = new PropertyRequiredError("age");\n// пройдёт проверку\nalert( err instanceof PropertyRequiredError ); // true\nalert( err instanceof PropertyError ); // true\nalert( err instanceof CustomError ); // true\nalert( err instanceof Error ); // true`</script><code-toolbar></code-toolbar></code-example><h2 id="tasks"><a href="#4" name="4">Задачи (1)</a></h2><task-content><h3><a href="#7" name="7">Унаследуйте от SyntaxError</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Создайте ошибку <code>FormatError</code>, которая будет наследовать от встроенного класса <code>SyntaxError</code>.</p><p>Синтаксис для её создания – такой же, как обычно:</p><code-example><script>`var err = new FormatError("ошибка форматирования");\n\nalert( err.message ); // ошибка форматирования\nalert( err.name ); // FormatError\nalert( err.stack ); // стек на момент генерации ошибки\n\nalert( err instanceof SyntaxError ); // true`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`function FormatError(message) {\n  this.name = "FormatError";\n\n  this.message = message;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n}\n\nFormatError.prototype = Object.create(SyntaxError.prototype);\nFormatError.prototype.constructor = FormatError;\n\n// Использование\n\nvar err = new FormatError("ошибка форматирования");\n\nalert( err.message ); // ошибка форматирования\nalert( err.name ); // FormatError\nalert( err.stack ); // стек на момент генерации ошибки\n\nalert( err instanceof SyntaxError ); // true`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Проверка класса: 'instanceof'; Примеси"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/oop-errors",disqus_identifier="oop-errors",disqus_title="\u0421\u0432\u043e\u0438 \u043e\u0448\u0438\u0431\u043a\u0438, \u043d\u0430\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u043d\u0438\u0435 \u043e\u0442 Error";</script></page-content></main>