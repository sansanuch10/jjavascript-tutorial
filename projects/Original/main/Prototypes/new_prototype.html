<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="74">ООП в прототипном стиле</a></nav-up><h1>Свойство F.prototype и создание объектов через new</h1><p>До этого момента мы говорили о наследовании объектов, объявленных через <code>{...}</code>.</p><p>Но в реальных проектах объекты обычно создаются функцией-конструктором через <code>new</code>. Посмотрим, как указать прототип в этом случае.</p><h2><a name="0" href="#0">Свойство F.prototype</a></h2><p>Самым очевидным решением является назначение <code>__proto__</code> в конструкторе.</p><p>Например, если я хочу, чтобы у всех объектов, которые создаются <code>new Rabbit</code>, был прототип <code>animal</code>, я могу сделать так:</p><code-example><script>`var animal = {\n  eats: true\n};\n\nfunction Rabbit(name) {\n  this.name = name;\nMARK  this.__proto__ = animal;\n}\n\nvar rabbit = new Rabbit("Кроль");\n\nalert( rabbit.eats ); // true, из прототипа`</script><code-toolbar></code-toolbar></code-example><p>Недостаток этого подхода – он не работает в IE10-.</p><p>К счастью, в JavaScript с древнейших времён существует альтернативный, встроенный в язык и полностью кросс-браузерный способ.</p><p><strong>Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство <code>prototype</code>.</strong></p><p><strong>При создании объекта через <code>new</code>, в его прототип <code>__proto__</code> записывается ссылка из <code>prototype</code> функции-конструктора.</strong></p><p>Например, код ниже полностью аналогичен предыдущему, но работает всегда и везде:</p><code-example><script>`var animal = {\n  eats: true\n};\n\nfunction Rabbit(name) {\n  this.name = name;\n}\n\nMARKRabbit.prototype = animal;\n\nvar rabbit = new Rabbit("Кроль"); //  rabbit.__proto__ == animal\n\nalert( rabbit.eats ); // true`</script><code-toolbar></code-toolbar></code-example><p>Установка <code>Rabbit.prototype = animal</code> буквально говорит интерпретатору следующее: <em>"При создании объекта через <code>new Rabbit</code> запиши ему <code>__proto__ = animal</code>".</em></p><important-><h3>Свойство <code>prototype</code> имеет смысл только у конструктора</h3><p>Свойство с именем <code>prototype</code> можно указать на любом объекте, но особый смысл оно имеет, лишь если назначено функции-конструктору.</p><p>Само по себе, без вызова оператора <code>new</code>, оно вообще ничего не делает, его единственное назначение – указывать <code>__proto__</code> для новых объектов.</p></important-><important-warn><h3>Значением <code>prototype</code> может быть только объект</h3><p>Технически, в это свойство можно записать что угодно.</p><p>Однако, при работе <code>new</code>, свойство <code>prototype</code> будет использовано лишь в том случае, если это объект. Примитивное значение, такое как число или строка, будет проигнорировано.</p></important-warn><h2><a name="1" href="#1">Свойство constructor</a></h2><p>У каждой функции по умолчанию уже есть свойство <code>prototype</code>.</p><p>Оно содержит объект такого вида:</p><code-example><script>`function Rabbit() {}\n\nRabbit.prototype = {\n  constructor: Rabbit\n};`</script></code-example><p>В коде выше я создал <code>Rabbit.prototype</code> вручную, но ровно такой же – генерируется автоматически.</p><p>Проверим:</p><code-example><script>`function Rabbit() {}\n\n// в Rabbit.prototype есть одно свойство: constructor\nalert( Object.getOwnPropertyNames(Rabbit.prototype) ); // constructor\n\n// оно равно Rabbit\nalert( Rabbit.prototype.constructor == Rabbit ); // true`</script><code-toolbar></code-toolbar></code-example><p>Можно его использовать для создания объекта с тем же конструктором, что и данный:</p><code-example><script>`function Rabbit(name) {\n  this.name = name;\n  alert( name );\n}\n\nvar rabbit = new Rabbit("Кроль");\n\nvar rabbit2 = new rabbit.constructor("Крольчиха");`</script><code-toolbar></code-toolbar></code-example><p>Эта возможность бывает полезна, когда, получив объект, мы не знаем в точности, какой у него был конструктор (например, сделан вне нашего кода), а нужно создать такой же.</p><important-warn><h3>Свойство <code>constructor</code> легко потерять</h3><p>JavaScript никак не использует свойство <code>constructor</code>. То есть, оно создаётся автоматически, а что с ним происходит дальше – это уже наша забота. В стандарте прописано только его создание.</p><p>В частности, при перезаписи <code>Rabbit.prototype = { jumps: true }</code> свойства <code>constructor</code> больше не будет.</p><p>Сам интерпретатор JavaScript его в служебных целях не требует, поэтому в работе объектов ничего не «сломается». Но если мы хотим, чтобы возможность получить конструктор, всё же, была, то можно при перезаписи гарантировать наличие <code>constructor</code> вручную:</p><code-example><script>`Rabbit.prototype = {\n  jumps: true,\nMARK  constructor: Rabbit\n};`</script></code-example><p>Либо можно поступить аккуратно и добавить свойства к встроенному <code>prototype</code> без его замены:</p><code-example><script>`// сохранится встроенный constructor\nRabbit.prototype.jumps = true`</script></code-example></important-warn><h2><a name="2" href="#2">Эмуляция Object.create для IE8-</a></h2><p>Как мы только что видели, с конструкторами всё просто, назначить прототип можно кросс-браузерно при помощи <code>F.prototype</code>.</p><p>Теперь небольшое «лирическое отступление» в область совместимости.</p><p>Прямые методы работы с прототипом отсутствуют в старых IE, но один из них – <code>Object.create(proto)</code> можно эмулировать, как раз при помощи <code>prototype</code>. И он будет работать везде, даже в самых устаревших браузерах.</p><p>Кросс-браузерный аналог – назовём его <code>inherit</code>, состоит буквально из нескольких строк:</p><code-example><script>`function inherit(proto) {\n  function F() {}\n  F.prototype = proto;\n  var object = new F;\n  return object;\n}`</script></code-example><p>Результат вызова <code>inherit(animal)</code> идентичен <code>Object.create(animal)</code>. Она создаёт новый пустой объект с прототипом <code>animal</code>.</p><p>Например:</p><code-example><script>`function inherit(proto) {\n  function F() {}\n  F.prototype = proto;\n  var object = new F;\n  return object;\n}\n\nvar animal = {\n  eats: true\n};\n\nvar rabbit = inherit(animal);\n\nalert( rabbit.eats ); // true`</script><code-toolbar></code-toolbar></code-example><p>Посмотрите внимательно на функцию <code>inherit</code> и вы, наверняка, сами поймёте, как она работает…</p><p>Если где-то неясности, то её построчное описание:</p><code-example><script>`function inherit(proto) {\n  function F() {}     // (1)\n  F.prototype = proto // (2)\n  var object = new F; // (3)\n  return object;      // (4)\n}`</script></code-example><ol><li>Создана новая функция <code>F</code>. Она ничего не делает с <code>this</code>, так что если вызвать <code>new F</code>, то получим пустой объект.</li><li>Свойство <code>F.prototype</code> устанавливается в будущий прототип <code>proto</code></li><li>Результатом вызова <code>new F</code> будет пустой объект с <code>__proto__</code> равным значению <code>F.prototype</code>.</li><li>Мы получили пустой объект с заданным прототипом, как и хотели. Возвратим его.</li></ol><p>Для унификации можно запустить такой код, и метод <code>Object.create</code> станет кросс-браузерным:</p><code-example><script>`if (!Object.create) Object.create = inherit; /* определение inherit - выше */`</script></code-example><p>В частности, аналогичным образом работает библиотека <a href="https://github.com/es-shims/es5-shim">es5-shim</a>, при подключении которой <code>Object.create</code> станет доступен для всех браузеров.</p><h2><a name="3" href="#3">Итого</a></h2><p>Для произвольной функции – назовём её <code>Person</code>, верно следующее:</p><ul><li>Прототип <code>__proto__</code> новых объектов, создаваемых через <code>new Person</code>, можно задавать при помощи свойства <code>Person.prototype</code>.</li><li>Значением <code>Person.prototype</code> по умолчанию является объект с единственным свойством <code>constructor</code>, содержащим ссылку на <code>Person</code>. Его можно использовать, чтобы из самого объекта получить функцию, которая его создала. Однако, JavaScript никак не поддерживает корректность этого свойства, поэтому программист может его изменить или удалить.</li><li>Современный метод <code>Object.create(proto)</code> можно эмулировать при помощи <code>prototype</code>, если хочется, чтобы он работал в IE8-.</li></ul><h2 id="tasks"><a href="#4" name="4">Задачи (4)</a></h2><task-content><h3><a href="#7" name="7">Прототип после создания</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>В примерах ниже создаётся объект <code>new Rabbit</code>, а затем проводятся различные действия с <code>prototype</code>.</p><p>Каковы будут результаты выполнения? Почему?</p><p>Начнём с этого кода. Что он выведет?</p><code-example><script>`function Rabbit() {}\nRabbit.prototype = {\n  eats: true\n};\n\nvar rabbit = new Rabbit();\n\nalert( rabbit.eats );`</script></code-example><p>Добавили строку (выделена), что будет теперь?</p><code-example><script>`function Rabbit() {}\nRabbit.prototype = {\n  eats: true\n};\n\nvar rabbit = new Rabbit();\n\nMARKRabbit.prototype = {};\n\nalert( rabbit.eats );`</script></code-example><p>А если код будет такой? (заменена одна строка):</p><code-example><script>`function Rabbit(name) {}\nRabbit.prototype = {\n  eats: true\n};\n\nvar rabbit = new Rabbit();\n\nMARKRabbit.prototype.eats = false;\n\nalert( rabbit.eats );`</script></code-example><p>А такой? (заменена одна строка)</p><code-example><script>`function Rabbit(name) {}\nRabbit.prototype = {\n  eats: true\n};\n\nvar rabbit = new Rabbit();\n\nMARKdelete rabbit.eats; // (*)\n\nalert( rabbit.eats );`</script></code-example><p>И последний вариант:</p><code-example><script>`function Rabbit(name) {}\nRabbit.prototype = {\n  eats: true\n};\n\nvar rabbit = new Rabbit();\n\nMARKdelete Rabbit.prototype.eats; // (*)\n\nalert( rabbit.eats );`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer style=""><close- title="закрыть" data-close_answer=""></close-><p>Результат: <code>true</code>, из прототипа</p><p>Результат:  <code>true</code>. Свойство <code>prototype</code> всего лишь задаёт <code>__proto__</code> у новых объектов. Так что его изменение не повлияет на <code>rabbit.__proto__</code>. Свойство <code>eats</code> будет получено из прототипа.</p><p>Результат: <code>false</code>. Свойство <code>Rabbit.prototype</code> и <code>rabbit.__proto__</code> указывают на один и тот же объект. В данном случае изменения вносятся в сам объект.</p><p>Результат: <code>true</code>, так как <code>delete rabbit.eats</code> попытается удалить <code>eats</code> из <code>rabbit</code>, где его и так нет. А чтение в <code>alert</code> произойдёт из прототипа.</p><p>Результат: <code>undefined</code>. Удаление осуществляется из самого прототипа, поэтому свойство <code>rabbit.eats</code> больше взять неоткуда.</p></task-answer></task-content><task-content><h3><a href="#8" name="8">Аргументы по умолчанию</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>Есть функция <code>Menu</code>, которая получает аргументы в виде объекта <code>options</code>:</p><code-example><script>`/* options содержит настройки меню: width, height и т.п. */\nfunction Menu(options) {\n  ...\n}`</script></code-example><p>Ряд опций должны иметь значение по умолчанию. Мы могли бы проставить их напрямую в объекте <code>options</code>:</p><code-example><script>`function Menu(options) {\n  options.width = options.width || 300; // по умолчанию ширина 300\n  ...\n}`</script></code-example><p>…Но такие изменения могут привести к непредвиденным результатам, т.к. объект <code>options</code> может быть повторно использован во внешнем коде. Он передается в <code>Menu</code> для того, чтобы параметры из него читали, а не писали.</p><p>Один из способов безопасно назначить значения по умолчанию – скопировать все свойства <code>options</code> в локальные переменные и затем уже менять. Другой способ – клонировать <code>options</code> путём копирования всех свойств из него в новый объект, который уже изменяется.</p><p>При помощи наследования и <code>Object.create</code> предложите третий способ, который позволяет избежать копирования объекта и не требует новых переменных.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer style=""><close- title="закрыть" data-close_answer=""></close-><p>Можно прототипно унаследовать от <code>options</code> и добавлять/менять опции в наследнике:</p><code-example><script>`function Menu(options) {\n  options = Object.create(options);\n  options.width = 300;\n\n  alert("width:&nbsp" + options.width); // возьмёт width из наследника\n  alert("height:&nbsp" + options.height); // возьмёт height из исходного объекта\n}\n\nvar options = {\n  width: 100,\n  height: 200\n};\n\nvar menu = new Menu(options);\n\nalert("original width:&nbsp" + options.width); // width исходного объекта\nalert("original height:&nbsp" + options.height); // height исходного объекта`</script><code-toolbar></code-toolbar></code-example><p>Все изменения будут происходить не в исходном <code>options</code>, а в его наследнике, при этом <code>options</code> останется незатронутым.</p></task-answer></task-content><task-content><h3><a href="#9" name="9">Есть ли разница между вызовами?</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Создадим новый объект, вот такой:</p><code-example><script>`function Rabbit(name) {\n  this.name = name;\n}\nRabbit.prototype.sayHi = function() {\n  alert( this.name );\n};\n\nvar rabbit = new Rabbit("Rabbit");`</script></code-example><p>Одинаково ли сработают эти вызовы?</p><code-example><script>`rabbit.sayHi();\nRabbit.prototype.sayHi();\nObject.getPrototypeOf(rabbit).sayHi();\nrabbit.__proto__.sayHi();`</script></code-example><p>Все ли они являются кросс-браузерными? Если нет – в каких браузерах сработает каждый?</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="" style="">Разница между вызовами</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Разница между вызовами</h4><p>Первый вызов ставит <code>this == rabbit</code>, остальные ставят <code>this</code> равным <code>Rabbit.prototype</code>, следуя правилу "<code>this</code> – объект перед точкой".</p><p>Так что только первый вызов выведет <code>Rabbit</code>, в остальных он будет <code>undefined</code>.</p><p>Код для проверки:</p><code-example><script>`function Rabbit(name) {\n  this.name = name;\n}\nRabbit.prototype.sayHi = function() {\n  alert( this.name );\n};\n\nvar rabbit = new Rabbit("Rabbit");\n\nrabbit.sayHi();\nRabbit.prototype.sayHi();\nObject.getPrototypeOf(rabbit).sayHi();\nrabbit.__proto__.sayHi();`</script><code-toolbar></code-toolbar></code-example></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Совместимость</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Совместимость</h4><ol><li>Первый вызов работает везде.</li><li>Второй вызов работает везде.</li><li>Третий вызов не будет работать в IE8-, там нет метода <code>getPrototypeOf</code></li><li>Четвёртый вызов – самый «несовместимый», он не будет работать в IE10-, ввиду отсутствия свойства  <code>__proto__</code>.</li></ol></task-answer></task-answer-ext></task-content><task-content><h3><a href="#10" name="10">Создать объект тем же конструктором</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Пусть у нас есть произвольный объект <code>obj</code>, созданный каким-то конструктором, каким – мы не знаем, но хотели бы создать новый объект с его помощью.</p><p>Сможем ли мы сделать так?</p><code-example><script>`var obj2 = new obj.constructor();`</script></code-example><p>Приведите пример конструкторов для <code>obj</code>, при которых такой код будет работать верно – и неверно.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Да, можем, но только если уверены, что кто-то позаботился о том, чтобы значение <code>constructor</code> было верным.</p><p>В частности, без вмешательства в прототип код точно работает, например:</p><code-example><script>`function User(name) {\n  this.name = name;\n}\n\nvar obj = new User('Вася');\nvar obj2 = new obj.constructor('Петя');\n\nalert( obj2.name ); // Петя (сработало)`</script><code-toolbar></code-toolbar></code-example><p>Сработало, так как <code>User.prototype.constructor == User</code>.</p><p>Но если кто-то, к примеру, перезапишет <code>User.prototype</code> и забудет указать <code>constructor</code>, то такой фокус не пройдёт, например:</p><code-example><script>`function User(name) {\n    this.name = name;\n  }\nMARKUser.prototype = {}; // (*)\n\nvar obj = new User('Вася');\nvar obj2 = new obj.constructor('Петя');\n\nalert( obj2.name ); // undefined`</script><code-toolbar></code-toolbar></code-example><p>Почему obj2.name равен undefined? Вот как это работает:</p><ol><li>При вызове new <code>obj.constructor('Петя')</code>, <code>obj</code> ищет у себя свойство <code>constructor</code> – не находит.</li><li>Обращается к своему свойству <code>__proto__</code>, которое ведёт к прототипу.</li><li>Прототипом будет (*), пустой объект.</li><li>Далее здесь также ищется свойство constructor – его нет.</li><li>Где ищем дальше? Правильно – у следующего прототипа выше, а им будет <code>Object.prototype</code>.</li><li>Свойство <code>Object.prototype.constructor</code> существует, это встроенный конструктор объектов, который, вообще говоря, не предназначен для вызова с аргументом-строкой, поэтому создаст совсем не то, что ожидается, но то же самое, что вызов <code>new Object('Петя')</code>, и у такого объекта не будет <code>name</code>.</li></ol></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Прототип объекта; Встроенные 'классы' в JavaScript"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/new-prototype", disqus_identifier = "new-prototype", disqus_title = "\u0421\u0432\u043e\u0439\u0441\u0442\u0432\u043e F.prototype \u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 \u0447\u0435\u0440\u0435\u0437 new";</script></page-content></main>