<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="74">ООП в прототипном стиле</a></nav-up><h1>Встроенные "классы" в JavaScript</h1><p>В JavaScript есть встроенные объекты: <code>Date</code>, <code>Array</code>, <code>Object</code> и другие. Они используют прототипы и демонстрируют организацию «псевдоклассов» на JavaScript, которую мы вполне можем применить и для себя.</p><h2><a name="0" href="#0">Откуда методы у {} ?</a></h2><p>Начнём мы с того, что создадим пустой объект и выведем его.</p><code-example><script>`var obj = {};\nalert( obj ); // "[object Object]" ?`</script><code-toolbar></code-toolbar></code-example><p>Где код, который генерирует строковое представление для <code>alert(obj)</code>? Объект-то ведь пустой.</p><h2><a name="1" href="#1">Object.prototype</a></h2><p>…Конечно же, это сделал метод <code>toString</code>, который находится… Конечно, не в самом объекте (он пуст), а в его прототипе <code>obj.__proto__</code>, можно его даже вывести:</p><code-example><script>`alert( {}.__proto__.toString ); // function toString`</script><code-toolbar></code-toolbar></code-example><p>Откуда новый объект <code>obj</code> получает такой <code>__proto__</code>?</p><ol><li>Запись <code>obj = {}</code> является краткой формой <code>obj = new Object</code>, где <code>Object</code> – встроенная функция-конструктор для объектов.</li><li>При выполнении <code>new Object</code>, создаваемому объекту ставится <code>__proto__</code> по <code>prototype</code> конструктора, который в данном случае равен встроенному <code>Object.prototype</code>.</li><li>В дальнейшем при обращении к <code>obj.toString()</code> – функция будет взята из <code>Object.prototype</code>.</li></ol><figure><img src="native-prototypes-object.png" style="max-width:225px" width="100%"></figure><p>Это можно легко проверить:</p><code-example><script>`var obj = {};\n\n// метод берётся из прототипа?\nalert( obj.toString == Object.prototype.toString ); // true, да\n\n// проверим, правда ли что __proto__ это Object.prototype?\nalert( obj.__proto__ == Object.prototype ); // true\n\n// А есть ли __proto__ у Object.prototype?\nalert( obj.__proto__.__proto__ ); // null, нет`</script><code-toolbar></code-toolbar></code-example><h2><a name="2" href="#2">Встроенные «классы» в JavaScript</a></h2><p>Точно такой же подход используется в массивах <code>Array</code>, функциях <code>Function</code> и других объектах. Встроенные методы для них находятся в <code>Array.prototype</code>, <code>Function.prototype</code> и т.п.</p><figure><img src="native-prototypes-classes.png" style="max-width:682px" width="100%"></figure><p>Например, когда мы создаём массив, <code>[1, 2, 3]</code>, то это альтернативный вариант синтаксиса <code>new Array</code>, так что у массивов есть стандартный прототип <code>Array.prototype</code>.</p><p>Но в нём есть методы лишь для массивов, а для общих методов всех объектов есть ссылка <code>Array.prototype.__proto__</code>, равная <code>Object.prototype</code>.</p><p>Аналогично, для функций.</p><p>Лишь для чисел (как и других примитивов) всё немного иначе, но об этом чуть далее.</p><p>Объект <code>Object.prototype</code> – вершина иерархии, единственный, у которого <code>__proto__</code> равно <code>null</code>.</p><p><strong>Поэтому говорят, что "все объекты наследуют от <code>Object</code>", а если более точно, то от <code>Object.prototype</code>.</strong></p><p>«Псевдоклассом» или, более коротко, «классом», называют функцию-конструктор вместе с её <code>prototype</code>. Такой способ объявления классов называют «прототипным стилем ООП».</p><p>При наследовании часть методов переопределяется, например, у массива <code>Array</code> есть свой <code>toString</code>, который выводит элементы массива через запятую:</p><code-example><script>`var arr = [1, 2, 3]\nalert( arr ); // 1,2,3 <-- результат Array.prototype.toString`</script><code-toolbar></code-toolbar></code-example><p>Как мы видели раньше, у <code>Object.prototype</code> есть свой <code>toString</code>, но так как в <code>Array.prototype</code> он ищется первым, то берётся именно вариант для массивов:</p><figure><img src="native-prototypes-array-tostring.png" style="max-width:233px" width="100%"></figure><important-><h3>Вызов методов через <code>call</code> и <code>apply</code> из прототипа</h3><p>Ранее мы говорили о применении методов массивов к «псевдомассивам», например, можно использовать <code>[].join</code> для <code>arguments</code>:</p><code-example><script>`function showList() {\nMARK  alert( [].join.call(arguments, " - ") );\n}\n\nshowList("Вася", "Паша", "Маша"); // Вася - Паша - Маша`</script><code-toolbar></code-toolbar></code-example><p>Так как метод <code>join</code> находится в <code>Array.prototype</code>, то можно вызвать его оттуда напрямую, вот так:</p><code-example><script>`function showList() {\nMARK  alert( Array.prototype.join.call(arguments, " - ") );\n}\n\nshowList("Вася", "Паша", "Маша"); // Вася - Паша - Маша`</script><code-toolbar></code-toolbar></code-example><p>Это эффективнее, потому что не создаётся лишний объект массива <code>[]</code>, хотя, с другой стороны – больше букв писать.</p></important-><h2><a name="3" href="#3">Примитивы</a></h2><p>Примитивы не являются объектами, но методы берут из соответствующих прототипов: <code>Number.prototype</code>, <code>Boolean.prototype</code>, <code>String.prototype</code>.</p><p>По стандарту, если обратиться к свойству числа, строки или логического значения, то будет создан объект соответствующего типа, например <code>new String</code> для строки, <code>new Number</code> для чисел, <code>new Boolean</code> – для логических выражений.</p><p>Далее будет произведена операция со свойством или вызов метода по обычным правилам, с поиском в прототипе, а затем этот объект будет уничтожен.</p><p>Именно так работает код ниже:</p><code-example><script>`var user = "Вася"; // создали строку (примитив)\n\nMARKalert( user.toUpperCase() ); // ВАСЯ\nMARK// был создан временный объект new String\nMARK// вызван метод\nMARK// new String уничтожен, результат возвращён`</script><code-toolbar></code-toolbar></code-example><p>Можно даже попробовать записать в этот временный объект свойство:</p><code-example><script>`// попытаемся записать свойство в строку:\nvar user = "Вася";\nuser.age = 30;\n\nMARKalert( user.age ); // undefined`</script><code-toolbar></code-toolbar></code-example><p>Свойство <code>age</code> было записано во временный объект, который был тут же уничтожен, так что смысла в такой записи немного. Пример выше выполняется без <code>use strict</code>, в строгом режиме была бы ошибка, и это хорошо, так как такая запись, по большому счету, не имеет смысла.</p><important-warn><h3>Конструкторы <code>String/Number/Boolean</code> – только для внутреннего использования</h3><p>Технически, можно создавать объекты для примитивов и вручную, например <code>new Number</code>. Но в ряде случаев получится откровенно бредовое поведение. Например:</p><code-example><script>`alert( typeof 1 ); // "number"\n\nalert( typeof new Number(1) ); // "object" ?!?`</script><code-toolbar></code-toolbar></code-example><p>Или, ещё страннее:</p><code-example><script>`var zero = new Number(0);\n\nif (zero) { // объект - true, так что alert выполнится\n  alert( "число ноль -- true?!?" );\n}`</script><code-toolbar></code-toolbar></code-example><p>Поэтому в явном виде <code>new String</code>, <code>new Number</code> и <code>new Boolean</code> никогда не вызываются.</p></important-warn><important-warn><h3>Значения <code>null</code> и <code>undefined</code> не имеют свойств</h3><p>Значения <code>null</code> и <code>undefined</code> стоят особняком. Вышесказанное к ним не относится.</p><p>Для них нет соответствующих классов, в них нельзя записать свойство (будет ошибка), в общем, на конкурсе «самое примитивное значение» они точно разделили бы первое место.</p></important-warn><h2><a name="4" href="#4">Изменение встроенных прототипов</a></h2><p>Встроенные прототипы можно изменять. В том числе – добавлять свои методы.</p><p>Мы можем написать метод для многократного повторения строки, и он тут же станет доступным для всех строк:</p><code-example><script>`String.prototype.repeat = function(times) {\n  return new Array(times + 1).join(this);\n};\n\nalert( "ля".repeat(3) ); // ляляля`</script><code-toolbar></code-toolbar></code-example><p>Аналогично мы могли бы создать метод <code>Object.prototype.each(func)</code>, который будет применять <code>func</code> к каждому свойству:</p><code-example><script>`Object.prototype.each = function(f) {\n  for (var prop in this) {\n    var value = this[prop];\n    f.call(value, prop, value); // вызовет f(prop, value), this=value\n  }\n}\n\n// Попробуем! (внимание, пока что это работает неверно!)\nvar user = {\n  name: 'Вася',\n  age: 25\n};\n\nuser.each(function(prop, val) {\n  alert( prop ); // name -> age -> (!) each\n});`</script><code-toolbar></code-toolbar></code-example><p>Обратите внимание – пример выше работает не совсем корректно. Вместе со свойствами объекта <code>user</code> он выводит и наше свойство <code>each</code>. Технически, это правильно, так как цикл <code>for..in</code> перебирает свойства и в прототипе тоже, но не очень удобно.</p><p>Конечно, это легко поправить добавлением проверки <code>hasOwnProperty</code>:</p><code-example><script>`Object.prototype.each = function(f) {\n\n  for (var prop in this) {\n\nMARK    // пропускать свойства из прототипа\nMARK    if (!this.hasOwnProperty(prop)) continue;\n\n    var value = this[prop];\n    f.call(value, prop, value);\n\n  }\n\n};\n\n// Теперь все будет в порядке\nvar obj = {\n  name: 'Вася',\n  age: 25\n};\n\nobj.each(function(prop, val) {\n  alert( prop ); // name -> age\n});`</script><code-toolbar></code-toolbar></code-example><p>Здесь это сработало, теперь код работает верно. Но мы же не хотим добавлять  <code>hasOwnProperty</code> в цикл по любому объекту! Поэтому либо не добавляйте свойства в <code>Object.prototype</code>, либо можно использовать <a href="/descriptors-getters-setters">дескриптор свойства</a> и флаг <code>enumerable</code>.</p><p>Это, конечно, не будет работать в IE8-:</p><code-example><script>`Object.prototype.each = function(f) {\n\n  for (var prop in this) {\n    var value = this[prop];\n    f.call(value, prop, value);\n  }\n\n};\n\nMARK// поправить объявление свойства, установив флаг enumerable: false\nMARKObject.defineProperty(Object.prototype, 'each', {\nMARK  enumerable: false\nMARK});\n\n// Теперь все будет в порядке\nvar obj = {\n  name: 'Вася',\n  age: 25\n};\n\nobj.each(function(prop, val) {\n  alert( prop ); // name -> age\n});`</script><code-toolbar></code-toolbar></code-example><p>Есть несколько «за» и «против» модификации встроенных прототипов:</p><balance-><balance-pluses><div>Достоинства</div><ul><li>Методы в прототипе автоматически доступны везде, их вызов прост и красив.</li></ul></balance-pluses><balance-minuses><div>Недостатки</div><ul><li>Новые свойства, добавленные в прототип из разных мест, могут конфликтовать между собой. Представьте, что вы подключили две библиотеки, которые добавили одно и то же свойство в прототип, но определили его по-разному. Конфликт неизбежен.</li><li>Изменения встроенных прототипов влияют глобально, на все-все скрипты, делать их не очень хорошо с архитектурной точки зрения.</li></ul></balance-minuses></balance-><p>Как правило, минусы весомее, но есть одно исключение, когда изменения встроенных прототипов не только разрешены, но и приветствуются.</p><p><strong>Допустимо изменение прототипа встроенных объектов, которое добавляет поддержку метода из современных стандартов в те браузеры, где её пока нет.</strong></p><p>Например, добавим <code>Object.create(proto)</code> в старые браузеры:</p><code-example><script>`if (!Object.create) {\n\n  Object.create = function(proto) {\n    function F() {}\n    F.prototype = proto;\n    return new F;\n  };\n\n}`</script></code-example><p>Именно так работает библиотека <a href="https://github.com/kriskowal/es5-shim">es5-shim</a>, которая предоставляет многие функции современного JavaScript для старых браузеров. Они добавляются во встроенные объекты и их прототипы.</p><h2><a name="5" href="#5">Итого</a></h2><ul><li><p>Методы встроенных объектов хранятся в их прототипах.</p></li><li><p>Встроенные прототипы можно расширить или поменять.</p></li><li><p>Добавление методов в <code>Object.prototype</code>, если оно не сопровождается <code>Object.defineProperty</code> с установкой <code>enumerable</code> (IE9+), «сломает» циклы <code>for..in</code>, поэтому стараются в этот прототип методы не добавлять.</p><p>Другие прототипы изменять менее опасно, но все же не рекомендуется во избежание конфликтов.</p><p>Отдельно стоит изменение с целью добавления современных методов в старые браузеры, таких как <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create">Object.create</a>, <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys">Object.keys</a>, <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">Function.prototype.bind</a> и т.п. Это допустимо и как раз делается <a href="https://github.com/kriskowal/es5-shim">es5-shim</a>.</p></li></ul><h2 id="tasks"><a href="#6" name="6">Задачи (2)</a></h2><task-content><h3><a href="#9" name="9">Добавить функциям defer</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Добавьте всем функциям в прототип метод <code>defer(ms)</code>, который откладывает вызов функции на <code>ms</code> миллисекунд.</p><p>После этого должен работать такой код:</p><code-example><script>`function f() {\n  alert( "привет" );\n}\n\nf.defer(1000); // выведет "привет" через 1 секунду`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`Function.prototype.defer = function(ms) {\n  setTimeout(this, ms);\n}\n\nfunction f() {\n  alert( "привет" );\n}\n\nf.defer(1000); // выведет "привет" через 1 секунду`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#10" name="10">Добавить функциям defer с аргументами</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>Добавьте всем функциям в прототип метод defer(ms), который возвращает обёртку, откладывающую вызов функции на ms миллисекунд.</p><p>Например, должно работать так:</p><code-example><script>`function f(a, b) {\n  alert( a + b );\n}\n\nf.defer(1000)(1, 2); // выведет 3 через 1 секунду.`</script></code-example><p>То есть, должны корректно передаваться аргументы.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`Function.prototype.defer = function(ms) {\n  var f = this;\n  return function() {\n    var args = arguments,\n      context = this;\n    setTimeout(function() {\n      f.apply(context, args);\n    }, ms);\n  }\n}\n\n// проверка\nfunction f(a, b) {\n  alert( a + b );\n}\n\nf.defer(1000)(1, 2); // выведет 3 через 1 секунду.`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Свойство F.prototype и создание объектов через new; Свои классы на прототипах"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/native-prototypes", disqus_identifier = "native-prototypes", disqus_title = "\u0412\u0441\u0442\u0440\u043e\u0435\u043d\u043d\u044b\u0435 \"\u043a\u043b\u0430\u0441\u0441\u044b\" \u0432 JavaScript";</script></page-content></main>