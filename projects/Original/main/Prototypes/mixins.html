<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="74">ООП в прототипном стиле</a></nav-up><h1>Примеси</h1><p>В JavaScript невозможно унаследовать от двух и более объектов. Ссылка <code>__proto__</code> – только одна.</p><p>Но потребность такая существует – к примеру, мы написали код, реализующий методы работы с шаблонизатором или методы по обмену событиями, и хочется легко и непринуждённо добавлять эти возможности к любому классу.</p><p>Обычно это делают через примеси.</p><p>Примесь (англ. mixin) – класс или объект, реализующий какое-либо чётко выделенное поведение. Используется для уточнения поведения других классов, не предназначен для самостоятельного использования.</p><h2><a name="0" href="#0">Пример примеси</a></h2><p>Самый простой вариант примеси – это объект с полезными методами, которые мы просто копируем в нужный прототип.</p><p>Например:</p><code-example><script>`MARK// примесь\nvar sayHiMixin = {\n  sayHi: function() {\n    alert("Привет&nbsp" + this.name);\n  },\n  sayBye: function() {\n    alert("Пока&nbsp" + this.name);\n  }\n};\n\nMARK// использование:\nfunction User(name) {\n  this.name = name;\n}\n\n// передать методы примеси\nfor(var key in sayHiMixin) User.prototype[key] = sayHiMixin[key];\n\n// User "умеет" sayHi\nnew User("Вася").sayHi(); // Привет Вася`</script><code-toolbar></code-toolbar></code-example><p>Как видно из примера, методы примеси активно используют <code>this</code> и предназначены именно для запуска в контексте «объекта-носителя примеси».</p><p>Если какие-то из методов примеси не нужны – их можно перезаписать своими после копирования.</p><h2><a name="1" href="#1">Примесь для событий</a></h2><p>Теперь пример из реальной жизни.</p><p>Важный аспект, который может понадобиться объектам – это умение работать с событиями.</p><p>То есть, чтобы объект мог специальным вызовом генерировать «уведомление о событии», а на эти уведомления другие объекты могли «подписываться», чтобы их получать.</p><p>Например, объект «Пользователь» при входе на сайт может генерировать событие <code>"login"</code>, а другие объекты, например «Календарь» может такие уведомления получать и подгружать информацию о пользователе.</p><p>Или объект «Меню» может при выборе пункта меню генерировать событие <code>"select"</code> с информацией о выбранном пункте меню, а другие объекты – подписавшись на это событие, будут узнавать об этом.</p><p>События – это средство «поделиться информацией» с неопределённым кругом заинтересованных лиц. А там уже кому надо – тот среагирует.</p><p>Примесь <code>eventMixin</code>, реализующая события:</p><code-example><script>`var eventMixin = {\n\n  /**\n   * Подписка на событие\n   * Использование:\n   *  menu.on('select', function(item) { ... }\n   */\n  on: function(eventName, handler) {\n    if (!this._eventHandlers) this._eventHandlers = {};\n    if (!this._eventHandlers[eventName]) {\n      this._eventHandlers[eventName] = [];\n    }\n    this._eventHandlers[eventName].push(handler);\n  },\n\n  /**\n   * Прекращение подписки\n   *  menu.off('select',  handler)\n   */\n  off: function(eventName, handler) {\n    var handlers = this._eventHandlers && this._eventHandlers[eventName];\n    if (!handlers) return;\n    for(var i=0; i<handlers.length; i++) {\n      if (handlers[i] == handler) {\n        handlers.splice(i--, 1);\n      }\n    }\n  },\n\n  /**\n   * Генерация события с передачей данных\n   *  this.trigger('select', item);\n   */\n  trigger: function(eventName /*, ... */) {\n\n    if (!this._eventHandlers || !this._eventHandlers[eventName]) {\n      return; // обработчиков для события нет\n    }\n\n    // вызвать обработчики\n    var handlers = this._eventHandlers[eventName];\n    for (var i = 0; i < handlers.length; i++) {\n      handlers[i].apply(this, [].slice.call(arguments, 1));\n    }\n\n  }\n};`</script></code-example><p>Здесь есть три метода:</p><ol><li><code>.on(имя события, функция)</code> – назначает функцию к выполнению при наступлении события с данным именем. Такие функции хранятся в защищённом свойстве объекта <code>_eventHandlers</code>.</li><li><code>.off(имя события, функция)</code> – удаляет функцию из списка предназначенных к выполнению.</li><li><code>.trigger(имя события, аргументы)</code> – генерирует событие, при этом вызываются все назначенные на него функции, и им передаются аргументы.</li></ol><p>Использование:</p><code-example><script>`// Класс Menu с примесью eventMixin\nfunction Menu() {\n  // ...\n}\n\nfor(var key in eventMixin) {\n  Menu.prototype[key] = eventMixin[key];\n}\n\n// Генерирует событие select при выборе значения\nMenu.prototype.choose = function(value) {\nMARK  this.trigger("select", value);\n}\n\n// Создадим меню\nvar menu = new Menu();\n\n// При наступлении события select вызвать эту функцию\nMARKmenu.on("select", function(value) {\nMARK  alert("Выбрано значение&nbsp" + value);\nMARK});\n\n// Запускаем выбор (событие select вызовет обработчики)\nmenu.choose("123");`</script></code-example><p>…То есть, смысл событий – обычно в том, что объект, в процессе своей деятельности, внутри себя (<code>this.trigger</code>) генерирует уведомления, на которые внешний код через <code>menu.on(...)</code> может быть подписан. И узнавать из них ценную информацию о происходящем, например – что выбран некий пункт меню.</p><p>Один раз написав методы <code>on/off/trigger</code> в примеси, мы затем можем использовать их во множестве прототипов.</p><h2><a name="2" href="#2">Итого</a></h2><ul><li>Примесь – объект, содержащий методы и свойства для реализации конкретного функционала.Возможны вариации этого приёма проектирования. Например, примесь может предусматривать конструктор, который должен запускаться в конструкторе объекта. Но как правило просто набора методов хватает.</li><li>Для добавления примеси в класс – её просто «подмешивают» в прототип.</li><li>«Подмешать» можно сколько угодно примесей, но если имена методов в разных примесях совпадают, то возможны конфликты. Их уже разрешать – разработчику. Например, можно заменить конфликтующий метод на свой, который будет решать несколько задач сразу. Конфликты при грамотно оформленных примесях возникают редко.</li></ul><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Свои ошибки, наследование от Error; Современные возможности ES-2015"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/mixins", disqus_identifier = "mixins", disqus_title = "\u041f\u0440\u0438\u043c\u0435\u0441\u0438";</script></page-content></main>