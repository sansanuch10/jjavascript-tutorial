<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="128">События в деталях</a></nav-up><h1>Загрузка скриптов, картинок, фреймов: onload и onerror</h1><p>Браузер позволяет отслеживать загрузку внешних ресурсов – скриптов, ифреймов, картинок и других.</p><p>Для этого есть два события:</p><ul><li><code>onload</code> – если загрузка успешна.</li><li><code>onerror</code> – если при загрузке произошла ошибка.</li></ul><h2><a name="0" href="#0">Загрузка SCRIPT</a></h2><p>Рассмотрим следующую задачу.</p><p>В браузере работает сложный интерфейс и, чтобы создать очередной компонент, нужно загрузить скрипт с сервера.</p><p>Подгрузить внешний скрипт – достаточно просто:</p><code-example><script>`var script = document.createElement('script');\nscript.src = "my.js";\n\ndocument.body.appendChild(script);`</script></code-example><p>…Но как после подгрузки выполнить функцию, которая объявлена в этом скрипте? Для этого нужно отловить момент окончания загрузки и выполнения тега <code>&lt;script&gt;</code>.</p><h3><a name="6" href="#6">script.onload</a></h3><p>Главным помощником станет событие <code>onload</code>. Оно сработает, когда скрипт загрузился и выполнился.</p><p>Например:</p><code-example><script>`var script = document.createElement('script');\nscript.src = "https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"\ndocument.body.appendChild(script);\n\nMARKscript.onload = function() {\nMARK    // после выполнения скрипта становится доступна функция _\nMARK    alert( _ ); // её код\nMARK  }\nscript.remove();`</script><code-toolbar></code-toolbar></code-example><p>Это даёт возможность, как в примере выше, получить переменные из скрипта и выполнять объявленные в нём функции.</p><p>…А что, если загрузка скрипта не удалась? Например, такого скрипта на сервере нет (ошибка 404) или сервер «упал» (ошибка 500).</p><p>Такую ситуацию тоже нужно как-то обрабатывать, хотя бы сообщить посетителю о возникшей проблеме.</p><h3><a name="7" href="#7">script.onerror</a></h3><p>Любые ошибки загрузки (но не выполнения) скрипта отслеживаются обработчиком <code>onerror</code>.</p><p>Например, сделаем запрос заведомо отсутствующего скрипта:</p><code-example><script>`var script = document.createElement('script');\nscript.src = "https://example.com/404.js"\ndocument.body.appendChild(script);\n\nMARKscript.onerror = function() {\nMARK  alert( "Ошибка:&nbsp" + this.src );\nMARK};\nscript.remove();`</script><code-toolbar></code-toolbar></code-example><h3><a name="8" href="#8">IE8-: script.onreadystatechange</a></h3><p>Примеры выше работают во всех браузерах, кроме IE8-.</p><p>В IE для отслеживания загрузки есть другое событие: <code>onreadystatechange</code>. Оно срабатывает многократно, при каждом обновлении состояния загрузки.</p><p>Текущая стадия процесса находится в <code>script.readyState</code>:</p><dl><dt><code>loading</code></dt><dd>В процессе загрузки.</dd><dt><code>loaded</code></dt><dd>Получен ответ с сервера – скрипт или ошибка. Скрипт на фазе <code>loaded</code> может быть ещё не выполнен.</dd><dt><code>complete</code></dt><dd>Скрипт выполнен.</dd></dl><p>Например, рабочий скрипт:</p><code-example><script>`var script = document.createElement('script');\nscript.src = "https://code.jquery.com/jquery.js";\ndocument.documentElement.appendChild(script);\n\nMARKscript.onreadystatechange = function() {\nMARK  alert(this.readyState); // loading -> loaded -> complete\nMARK}\nscript.remove();`</script><code-toolbar></code-toolbar></code-example><p>Скрипт с ошибкой:</p><code-example><script>`var script = document.createElement('script');\ndocument.documentElement.appendChild(script);\nscript.src = "http://ajax.googleapis.com/404.js";\n\nMARKscript.onreadystatechange = function() {\nMARK  alert(this.readyState);  // loading -> loaded\nMARK}\nscript.remove();`</script><code-toolbar></code-toolbar></code-example><p>Обратим внимание на две особенности:</p><ul><li><p><strong>Стадии могут пропускаться.</strong></p><p>Если скрипт в кэше браузера – он сразу даст <code>complete</code>. Вы можете увидеть это, если несколько раз запустите первый пример.</p></li><li><p><strong>Нет особой стадии для ошибки.</strong></p><p>В примере выше это видно, обработка останавливается на <code>loaded</code>.</p></li></ul><p>Итак, самое надёжное средство для IE8- поймать загрузку (или ошибку загрузки) – это повесить обработчик на событие <code>onreadystatechange</code>, который будет срабатывать и на стадии <code>complete</code> и на стадии <code>loaded</code>. Так как скрипт может быть ещё не выполнен к этому моменту, то вызов функции лучше сделать через <code>setTimeout(.., 0)</code>.</p><p>Пример ниже вызывает <code>afterLoad</code> после загрузки скрипта и работает только в IE:</p><code-example><script>`var script = document.createElement('script');\nscript.src = "https://code.jquery.com/jquery.js";\ndocument.documentElement.appendChild(script);\n\nfunction afterLoad() {\n  alert("Загрузка завершена:&nbsp" + typeof(jQuery));\n}\n\nMARKscript.onreadystatechange = function() {\nMARK  if (this.readyState == "complete") { // на случай пропуска loaded\nMARK    afterLoad(); // (2)\nMARK  }\nMARK&nbsp\nMARK  if (this.readyState == "loaded") {\nMARK    setTimeout(afterLoad, 0);  // (1)\nMARK&nbsp\nMARK    // убираем обработчик, чтобы не сработал на complete\nMARK    this.onreadystatechange = null;\nMARK  }\nMARK}\nscript.remove();`</script><code-toolbar></code-toolbar></code-example><p>Вызов <code>(1)</code> выполнится при первой загрузке скрипта, а <code>(2)</code> – при второй, когда он уже будет в кеше, и стадия станет сразу <code>complete</code>.</p><p>Функция <code>afterLoad</code> может и не обнаружить <code>jQuery</code>, если при загрузке была ошибка, причём не важно какая – файл не найден или синтаксис скрипта ошибочен.</p><h3><a name="9" href="#9">Кросс-браузерное решение</a></h3><p>Для кросс-браузерной обработки загрузки скрипта или её ошибки поставим обработчик на все три события: <code>onload</code>, <code>onerror</code>, <code>onreadystatechange</code>.</p><p>Пример ниже выполняет функцию <code>afterLoad</code> после загрузки скрипта <em>или</em> при ошибке.</p><p>Работает во всех браузерах:</p><code-example><script>`var script = document.createElement('script');\nscript.src = "https://code.jquery.com/jquery.js";\ndocument.documentElement.appendChild(script);\n\nfunction afterLoad() {\n  alert( "Загрузка завершена:&nbsp" + typeof(jQuery) );\n}\n\nscript.onload = script.onerror = function() {\n  if (!this.executed) { // выполнится только один раз\n    this.executed = true;\n    afterLoad();\n  }\n};\n\nscript.onreadystatechange = function() {\n  var self = this;\n  if (this.readyState == "complete" || this.readyState == "loaded") {\n    setTimeout(function() {\n      self.onload()\n    }, 0); // сохранить "this" для onload\n  }\n};\nscript.remove();`</script><code-toolbar></code-toolbar></code-example><h2><a name="1" href="#1">Загрузка других ресурсов</a></h2><p>Поддержка этих событий для других типов ресурсов различна:</p><dl><dt><code>&lt;img&gt;</code>, <code>&lt;link&gt;</code> (стили)</dt><dd><p>Поддерживает <code>onload/onerror</code> во всех браузерах.</p></dd><dt><code>&lt;iframe&gt;</code></dt><dd><p>Поддерживает <code>onload</code> во всех браузерах. Это событие срабатывает как при успешной загрузке, так и при ошибке.</p><p>Обратим внимание, что если <code>&lt;iframe&gt;</code> загружается с того же домена, то можно, используя <code>iframe.contentWindow.document</code> получить ссылку на документ и поставить обработчик <code>DOMContentLoaded</code>. А вот если <code>&lt;iframe&gt;</code> – с другого домена, то так не получится, однако сработает <code>onload</code>.</p></dd></dl><h2><a name="2" href="#2">Итого</a></h2><p>В этой статье мы рассмотрели события <code>onload/onerror</code> для ресурсов.</p><p>Их можно обобщить, разделив на рецепты:</p><dl><dt>Отловить загрузку скрипта (включая ошибку)</dt><dd><p>Ставим обработчики на <code>onload</code> + <code>onerror</code> + (для IE8-) <code>onreadystatechange</code>, как указано в рецепте выше</p></dd><dt>Отловить загрузку картинки <code>&lt;img&gt;</code> или стиля <code>&lt;link&gt;</code></dt><dd><p>Ставим обработчики на <code>onload</code> + <code>onerror</code></p><code-example><script>`var img = document.createElement('img');\nimg.onload = function() { alert("Успех&nbsp" + this.src) };\nimg.onerror = function() { alert("Ошибка&nbsp" + this.src) };\nimg.src = ...`</script></code-example><p>Изображения начинают загружаться сразу при создании, не нужно их для этого вставлять в HTML.</p><p><strong>Чтобы работало в IE8-, <code>src</code> нужно ставить <em>после</em><code>onload/onerror</code>.</strong></p></dd><dt>Отловить загрузку <code>&lt;iframe&gt;</code></dt><dd><p>Поддерживается только обработчик <code>onload</code>. Он сработает, когда <code>IFRAME</code> загрузится, со всеми подресурсами, а также в случае ошибки.</p></dd></dl><h2 id="tasks"><a href="#3" name="3">Задачи (4)</a></h2><task-content><h3><a href="#10" name="10">Красивый "ALT"</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Обычно, до того как изображение загрузится (или при отключенных картинках), посетитель видит пустое место с текстом из «ALT». Но этот атрибут не допускает HTML-форматирования.</p><p>При мобильном доступе скорость небольшая, и хочется, чтобы посетитель сразу видел красивый текст.</p><p><strong>Реализуйте «красивый» (HTML) аналог <code>alt</code> при помощи CSS/JavaScript, который затем будет заменён картинкой сразу же как только она загрузится.</strong> А если загрузка не состоится – то не заменён.</p><p>Демо: (нажмите «перезагрузить», чтобы увидеть процесс загрузки и замены)</p><code-result><iframe id="new_1" style="height:100px" src="iframe.html"></iframe><script>setTimeout(() =>{run_1.click();new_1.src=new_1.getAttribute('src');},100);</script></code-result><p>Картинки для <code>bing</code> специально нет, так что текст остается «как есть».</p><p>Исходный документ содержит разметку текста и ссылки на изображения.</p><p><a data-click="task_1">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="" style="">Подсказка</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Подсказка</h4><p>Текст на странице пусть будет изначально <code>DIV</code>, с атрибутом <code>data-src</code> для картинки.</p><p>Функция <code>replaceImg()</code> должна искать такие <code>DIV</code> и загружать изображение с указанным <code>src</code>. По <code>onload</code> осуществляется замена <code>DIV</code> на картинку.</p></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Решение</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Решение</h4><code-example><script>`<style>\n  GOLD_div, img_GOLD {\n    float: left;\n    border: 1px solid black;\n    font-size: 33px;\n    BLUE_letter-spacing_BLUE: 3px;\n    width: auto;\n    height: 40px;\n    display: flex;\n  }\n</style>\n\n<button onclick="window.location.reload(true)">Перезагрузить ифрейм</button>\n<RED_hr_RED>\n<div data-src="https://js.cx/search/google.png">\n  <span style="color:#1A53F7">G</span>\n  <span style="color:#E42131">o</span>\n  <span style="color:#FEB819">o</span>\n  <span style="color:#164AF2">g</span>\n  <span style="color:#00a315">l</span>\n  <span style="color:#E42131">e</span>\n</div>\n\n<div data-src="https://js.cx/search/yandex.png" style="letter-spacing:0;">\n  <span style="color:#F00">Я</span>ндекс\n</div>\n\n<div style="color:#006dd4;font-weight:bold;font-family:Arial" data-src="bing.png">bing</div>\n\n<script>\n  function replaceImg() {\n    var divs = document.querySelectorAll('div');\n    for (var i = 0; i < divs.length; i++)(function(i) {\n      var img = document.createElement('img');\n      img.src = divs[i].getAttribute('data-src');\n\n      img.onload = function() {\n        divs[i].parentNode.replaceChild(img, divs[i]);\n      }\n\n    }(i))\n  }\n\n  setTimeout(replaceImg, 1000); // задержка на 1 сек для демонстрации\n<\/script>`</script><code-toolbar iframe="190"><a id="run_1" title="показать" data-code_run="0"></a><a id="task_1" data-code_edit="?" style="display:none"></a><a id="answer_1" title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p><a data-click="answer_1">Открыть решение в песочнице.</a></p></task-answer></task-answer-ext></task-content><task-content><h3><a href="#11" name="11">Загрузить изображения с коллбэком</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>Создайте функцию <code>preloadImages(sources, callback)</code>, которая предзагружает изображения из массива <code>sources</code>, и после загрузки вызывает функцию <code>callback</code>.</p><code-example><script>`function preloadImages(sources, callback) {\n  /* ваш код */\n}\n\n// ---------- Проверка ----------\n/* файлы для загрузки */\nvar sources = [\n  "https://js.cx/images-load/1.jpg",\n  "https://js.cx/images-load/2.jpg",\n  "https://js.cx/images-load/3.jpg"\n];\nfor (var i = 0; i < sources.length; i++) {\n  sources[i] += '?' + Math.random(); // добавляем параметр, чтобы без кеша (для теста)\n}\n/** если картинка загружена, то можно будет сразу получить её ширину\n * создадим все картинки и проверим, есть ли у них ширина\n */\nfunction testLoaded() {\n  var widthSum = 0;\n  for (var i = 0; i < sources.length; i++) {\n    var img = document.createElement('img');\n    img.src = sources[i];\n    widthSum += img.width;\n  }\n  // каждое изображение 100x100, общая ширина должна быть 300px\n  alert(widthSum);\n}\n\n// до загрузки - выведет 0\ntestLoaded();\n// после загрузки - выведет 300\npreloadImages(sources, testLoaded);`</script><code-toolbar></code-toolbar></code-example><p>Если вдруг возникает ошибка при загрузке – считаем такое изображение загруженным, чтобы не ломать поток выполнения.</p><p>Такая функция может быть полезна, например, для фоновой загрузки картинок в онлайн-галерею.</p><p>В исходном документе содержатся ссылки на картинки, а также код для проверки, действительно ли изображения загрузились. Он должен выводить «0», затем «300».</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Создайте переменную-счетчик для подсчёта количества загруженных картинок, и увеличивайте при каждом <code>onload/onerror</code>.</p><p>Когда счетчик станет равен количеству картинок – вызывайте <code>callback</code>.</p><code-example><script>`function preloadImages(sources, callback) {\n  var counter = 0;\n\n  function onLoad() {\n    counter++;\n    if (counter == sources.length) callback();\n  }\n  for (var i = 0; i < sources.length; i++) {\n    var img = document.createElement('img');\n    // сначала onload/onerror, затем src - важно для IE8-\n    img.onload = img.onerror = onLoad;\n    img.src = sources[i];\n  }\n}\n// ---------- Проверка ----------\nvar sources = [\n  "https://js.cx/images-load/1.jpg",\n  "https://js.cx/images-load/2.jpg",\n  "https://js.cx/images-load/3.jpg"\n];\nfor (var i = 0; i < sources.length; i++) {\n  sources[i] += '?' + Math.random();\n}\n\nfunction testLoaded() {\n  var widthSum = 0;\n  for (var i = 0; i < sources.length; i++) {\n    var img = document.createElement('img');\n    img.src = sources[i];\n    widthSum += img.width;\n  }\n  alert(widthSum); // 300!\n}\n// до загрузки - 0\ntestLoaded();\n// после загрузки - 300\npreloadImages(sources, testLoaded);`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#12" name="12">Скрипт с коллбэком</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>Создайте функцию <code>addScript(src, callback)</code>, которая загружает скрипт с данным <code>src</code>, и после его загрузки и выполнения вызывает функцию <code>callback</code>.</p><p>Скрипт может быть любым, работа функции не должна зависеть от его содержимого.</p><p>Пример использования:</p><code-example><script>`function addScript(src, callback) {\n  /* ваш код */\n}\n\naddScript("go.js", function() {\n  go();\n});`</script><code-toolbar-><div></div><a id="task_3" title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><p>Ошибки загрузки обрабатывать не нужно.</p><p><a data-click="task_3">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="" style="">Подсказка</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Подсказка</h4><p>Добавляйте <code>SCRIPT</code> при помощи методов <code>DOM</code>:</p><code-example><script>`var script = document.createElement('script');\nscript.src = src;\n\n// в документе может не быть HEAD или BODY,\n// но хотя бы один (текущий) SCRIPT в документе есть\nvar s = document.getElementsByTagName('script')[0];\ns.parentNode.insertBefore(script, s); // перед ним и вставим`</script></code-example><p>На скрипт повесьте обработчики <code>onload/onreadystatechange</code>.</p></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Решение</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Решение</h4><code-example><script>`function addScript(src, callback) {\n  var script = document.createElement('script');\n  script.src = src;\n  var s = document.getElementsByTagName('script')[0]\n  s.parentNode.insertBefore(script, s);\n  var loaded = false;\n  \n  function onload() {\n    if (loaded) return; // повторный вызов\n    loaded = true;\n    callback();\n  }\n\n  script.onload = onload; // все браузеры, IE с версии 9\n  script.onreadystatechange = function() { // IE8-\n    if (this.readyState == 'loaded' || this.readyState == 'complete') {\n      setTimeout(onload, 0);\n    }\n  };\n}\n\naddScript("go.js", function() {\n  go();\n});`</script><code-toolbar></code-toolbar></code-example><p><a href="http://plnkr.co/edit/7akrK6r4TP3npXJDOGrs?p=preview" target="_blank" data-plunk-id="7akrK6r4TP3npXJDOGrs">Открыть решение в песочнице.</a></p></task-answer></task-answer-ext></task-content><task-content><h3><a href="#13" name="13">Скрипты с коллбэком</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Создайте функцию <code>addScripts(scripts, callback)</code>, которая загружает скрипты из массива <code>scripts</code>, и <em>после загрузки и выполнения их всех</em> вызывает функцию <code>callback</code>.</p><p>Скрипт может быть любым, работа функции не должна зависеть от его содержимого.</p><code-example><script>`/* ваш код */\n\n// функция a() сработает только если загружены a.js, b.js, c.js\naddScripts(["a.js", "b.js", "c.js"], function() {\n  a()\n});`</script><code-toolbar-><div></div><a id="task_3" title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><ul><li>Ошибки загрузки обрабатывать не нужно.</li><li>Один скрипт не ждёт другого. Они все загружаются, а по окончании вызывается обработчик <code>callback</code>.</li></ul><p>Исходный код содержит скрипты <code>a.js</code>, <code>b.js</code>, <code>c.js</code>:</p><p><a href="http://plnkr.co/edit/NkMpLbcFHu6b6EpzVkG9?p=preview" target="_blank" data-plunk-id="NkMpLbcFHu6b6EpzVkG9">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="" style="">Подсказки</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Подсказки</h4><p>Создайте переменную-счетчик для подсчёта количества загруженных скриптов.</p><p>Чтобы один скрипт не учитывался два раза (например, <code>onreadystatechange</code> запустился при <code>loaded</code> и <code>complete</code>), учитывайте его состояние в объекте <code>loaded</code>. Свойство <code>loaded[i] = true</code> означает что <code>i</code>-й скрипт уже учтён.</p></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Решение</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Решение</h4><code-example><script>`function addScript(src) {\n  var script = document.createElement('script');\n  script.src = src;\n  var s = document.getElementsByTagName('script')[0]\n  s.parentNode.insertBefore(script, s);\n  return script;\n}\n\nfunction addScripts(scripts, callback) {\n  var loaded = {}; // Для загруженных файлов loaded[i] = true\n  var counter = 0;\n\n  function onload(i) {\n    if (loaded[i]) return; // лишний вызов onload/onreadystatechange\n    loaded[i] = true;\n    counter++;\n    if (counter == scripts.length) callback();\n  }\n\n  for (var i = 0; i < scripts.length; i++)(function(i) {\n    var script = addScript(scripts[i]);\n\n    script.onload = function() {\n      onload(i);\n    };\n\n    script.onreadystatechange = function() { // IE8-\n      if (this.readyState == 'loaded' || this.readyState == 'complete') {\n        setTimeout(this.onload, 0); // возможны повторные вызовы onload\n      }\n    };\n  }(i));\n}\n\naddScripts(["a.js", "b.js", "c.js"], function() {\n  a()\n});`</script><code-toolbar></code-toolbar></code-example></task-answer></task-answer-ext></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Загрузка документа: DOMContentLoaded, load, beforeunload, unload; Формы, элементы управления"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/onload-onerror",disqus_identifier="onload-onerror",disqus_title="\u0417\u0430\u0433\u0440\u0443\u0437\u043a\u0430 \u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0432, \u043a\u0430\u0440\u0442\u0438\u043d\u043e\u043a, \u0444\u0440\u0435\u0439\u043c\u043e\u0432: onload \u0438 onerror";</script></page-content></main>