<main> <script>! function(){var e=0;window.logClear=function(t){e=0,document.forms[t+"form"].getElementsByTagName("textarea")[0].value="",lines=0},window.logMouse=function(t){for (var n=t.type;n.length<11;) n += " ";return function(t,n){0 == e&&(e=new Date);var o=new Date;o-e>300&&(t="------------------------------\n"+t);var a=document.forms[n+"form"].getElementsByTagName("textarea")[0];a.value += t+"\n",a.scrollTop=a.scrollHeight,e=o}(n+" which="+t.which+" button="+t.button,"test"),!1}}();</script><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="128">События в деталях</a></nav-up><h1>Мышь: клики, кнопка, координаты</h1><p>В этой главе мы глубже разберёмся со списком событий мыши, рассмотрим их общие свойства, а также те события, которые связаны с кликом.</p><h2><a name="0" href="#0">Типы событий мыши</a></h2><p>Условно можно разделить события на два типа: «простые» и «комплексные».</p><h3><a name="9" href="#9">Простые события</a></h3><dl><dt><code>mousedown</code></dt><dd>Кнопка мыши нажата над элементом.</dd><dt><code>mouseup</code></dt><dd>Кнопка мыши отпущена над элементом.</dd><dt><code>mouseover</code></dt><dd>Мышь появилась над элементом.</dd><dt><code>mouseout</code></dt><dd>Мышь ушла с элемента.</dd><dt><code>mousemove</code></dt><dd>Каждое движение мыши над элементом генерирует это событие.</dd></dl><h3><a name="10" href="#10">Комплексные события</a></h3><dl><dt><code>click</code></dt><dd>Вызывается при клике мышью, то есть при <code>mousedown</code>, а затем <code>mouseup</code> на одном элементе</dd><dt><code>contextmenu</code></dt><dd>Вызывается при клике правой кнопкой мыши на элементе.</dd><dt><code>dblclick</code></dt><dd>Вызывается при двойном клике по элементу.</dd></dl><p>Комплексные можно составить из простых, поэтому в теории можно было бы обойтись вообще без них. Но они есть, и это хорошо, потому что с ними удобнее.</p><h3><a name="11" href="#11">Порядок срабатывания событий</a></h3><p>Одно действие может вызывать несколько событий.</p><p>Например, клик вызывает сначала <code>mousedown</code> при нажатии, а затем <code>mouseup</code> и <code>click</code> при отпускании кнопки.</p><p>В тех случаях, когда одно действие генерирует несколько событий, их порядок фиксирован. То есть, обработчики вызовутся в порядке <code>mousedown</code> → <code>mouseup</code> → <code>click</code>.</p><p>Кликните по кнопке ниже и вы увидите, какие при этом происходят события. Попробуйте также двойной клик.</p><p>На тест-стенде ниже все мышиные события записываются, и если между событиями проходит больше 1 секунды, то они для удобства чтения отделяются линией. Также присутствуют свойства <code>which/button</code>, по которым можно определить кнопку мыши. Мы их рассмотрим далее.</p><p><input onmousedown="return logMouse(event)" onmouseup="return logMouse(event)" onclick="return logMouse(event)" oncontextmenu="return logMouse(event)" ondblclick="return logMouse(event)" value="Кликни меня левой или правой кнопкой мыши" type="button"><input onclick="logClear('test')" value="Очистить" type="button"></p><form name="testform"><textarea style="font-size:12px;height:150px;width:360px;"></textarea></form><p></p><p><strong>Каждое событие обрабатывается независимо.</strong></p><p>Например, при клике события <code>mouseup + click</code> возникают одновременно, но обрабатываются последовательно. Сначала полностью завершается обработка <code>mouseup</code>, затем запускается <code>click</code>.</p><h2><a name="1" href="#1">Получение информации о кнопке: which</a></h2><p>При обработке событий, связанных с кликами мыши, бывает важно знать, какая кнопка нажата.</p><p><strong>Для получения кнопки мыши в объекте <code>event</code> есть свойство <code>which</code>.</strong></p><p>На практике оно используется редко, т.к. обычно обработчик вешается либо <code>onclick</code> – только на левую кнопку мыши, либо <code>oncontextmenu</code> – только на правую.</p><p>Возможны следующие значения:</p><ul><li><code>event.which == 1</code> – левая кнопка</li><li><code>event.which == 2</code> – средняя кнопка</li><li><code>event.which == 3</code> – правая кнопка</li></ul><p>Это свойство не поддерживается IE8-, но его можно получить способом, описанным в конце главы.</p><h2><a name="2" href="#2">Правый клик: oncontextmenu</a></h2><p>Это событие срабатывает при клике правой кнопкой мыши:</p><code-example><script> `<div>Правый клик на этой кнопке выведет "Клик".</div>\n<button oncontextmenu="alert('Клик!');">Правый клик сюда</button>`</script><code-toolbar- iframe="80"><a title="показать" data-code_run=""></a><div></div></code-toolbar-></code-example><p>При клике на кнопку выше после обработчика <code>oncontextmenu</code> будет показано обычное контекстное меню, которое браузер всегда показывает при клике правой кнопкой. Это является его действием по умолчанию.</p><p>Если мы не хотим, чтобы показывалось встроенное меню, например потому что показываем своё, специфичное для нашего приложения, то можно отменить действие по умолчанию.</p><p>В примере ниже встроенное меню показано не будет:</p><code-example><script> `<button oncontextmenu="alert('Клик!');return false">Правый клик сюда</button>`</script><code-toolbar- iframe="60"><a title="показать" data-code_run=""></a><div></div></code-toolbar-></code-example><h2><a name="3" href="#3">Модификаторы shift, alt, ctrl и meta</a></h2><p>Во всех событиях мыши присутствует информация о нажатых клавишах-модификаторах.</p><p>Соответствующие свойства:</p><ul><li><code>shiftKey</code></li><li><code>altKey</code></li><li><code>ctrlKey</code></li><li><code>metaKey</code> (для Mac)</li></ul><p>Например, кнопка ниже сработает только на Alt+Shift+Клик:</p><code-example><script>`<button>Alt+Shift+Кликни меня!</button>\n\n<script>\n  document.body.children[0].onclick = function(e) {\nMARK    if (!e.altKey || !e.shiftKey) return;\n    alert( 'Ура!' );\n  }\n<\/script>`</script><code-toolbar- iframe="60"><a title="показать" data-code_run=""></a><div></div></code-toolbar-></code-example><important-warn><h3>Внимание: на Mac вместо <code>Ctrl</code> используется <code>Cmd</code></h3><p>На компьютерах под управлением Windows и Linux есть специальные клавиши <shortcut>Alt</shortcut>, <shortcut>Shift</shortcut> и <shortcut>Ctrl</shortcut>. На Mac есть ещё одна специальная клавиша: <shortcut>Cmd</shortcut>, которой соответствует свойство <code>metaKey</code>.</p><p>В большинстве случаев там, где под Windows/Linux используется <shortcut class="shortcut">Ctrl</shortcut>, на Mac используется <shortcut class="shortcut">Cmd</shortcut>. Там, где пользователь Windows нажимает <shortcut>Ctrl<shortcut-plus>+</shortcut-plus>Enter</shortcut> или <shortcut>Ctrl<shortcut-plus>+</shortcut-plus>A</shortcut>, пользователь Mac нажмёт <shortcut>Cmd<shortcut-plus>+</shortcut-plus>Enter</shortcut> или <shortcut>Cmd<shortcut-plus>+</shortcut-plus>A</shortcut>, и так далее, почти всегда <shortcut>Cmd</shortcut> вместо <shortcut>Ctrl</shortcut>.</p><p>Поэтому, если мы хотим поддерживать сочетание <shortcut>Ctrl</shortcut>+click или другие подобные, то под Mac имеет смысл использовать <shortcut>Cmd</shortcut>+click. Пользователям Mac это будет гораздо комфортнее.</p><p>Более того, даже если бы мы хотели бы заставить пользователей Mac использовать именно <shortcut>Ctrl</shortcut>+click – это было бы затруднительно. Дело в том, что обычный клик с зажатым <shortcut>Ctrl</shortcut> под Mac работает как <em>правый клик</em> и генерирует событие <code>oncontextmenu</code>, а вовсе не <code>onclick</code>, как под Windows/Linux.</p><p>Решение – чтобы пользователи обоих операционных систем работали с комфортом, в паре с <code>ctrlKey</code> нужно обязательно использовать <code>metaKey</code>.</p><p>В JS-коде это означает, что для удобства пользователей Mac нужно проверять <code>if (event.ctrlKey || event.metaKey)</code>.</p></important-warn><h2><a name="4" href="#4">Координаты в окне: clientX/Y</a></h2><p>Все мышиные события предоставляют текущие координаты курсора в двух видах: относительно окна и относительно документа.</p><p>Пара свойств <code>clientX/clientY</code> содержит координаты курсора относительно текущего окна.</p><p>При этом, например, если ваше окно размером 500x500, а мышь находится в центре, тогда и <code>clientX</code> и <code>clientY</code> будут равны 250.</p><p>Можно как угодно прокручивать страницу, но если не двигать при этом мышь, то координаты курсора <code>clientX/clientY</code> не изменятся, потому что они считаются относительно окна, а не документа.</p><p>Проведите мышью над полем ввода, чтобы увидеть <code>clientX/clientY</code>:</p><code-example><script>`<input onmousemove="this.value = event.clientX + ':' + event.clientY">`</script><code-toolbar- iframe="80"><a title="показать" data-code_run=""></a><div></div></code-toolbar-></code-example><input onmousemove="this.value = event.clientX+':'+event.clientY"><p>В той же системе координат работает и метод <code>elem.getBoundingClientRect()</code>, возвращающий координаты элемента, а также <code>position:fixed</code>.</p><h3><a name="13" href="#13">Относительно документа: pageX/Y</a></h3><p>Координаты курсора относительно документа находятся в свойствах <code>pageX/pageY</code>.</p><p>Так как эти координаты – относительно левого-верхнего узла документа, а не окна, то они учитывают прокрутку. Если прокрутить страницу, а мышь не трогать, то координаты курсора <code>pageX/pageY</code> изменятся на величину прокрутки, они привязаны к конкретной точке в документе.</p><p>В IE8- этих свойств нет, но можно получить их способом, описанным в конце главы.</p><p>Проведите мышью над полем ввода, чтобы увидеть <code>pageX/pageY</code> (кроме IE8-):</p><code-example><script>`<input onmousemove="this.value = event.pageX + ':' + event.pageY">`</script></code-example><input onmousemove="this.value = event.pageX+':'+event.pageY"><p>В той же системе координат работает <code>position:absolute</code>, если элемент позиционируется относительно документа.</p><important-warn><h3>Устарели: <code>x, y, layerX, layerY</code></h3><p>Некоторые браузеры поддерживают свойства <code>event.x/y</code>, <code>event.layerX/layerY</code>.</p><p>Эти свойства устарели, они нестандартные и не добавляют ничего к описанным выше. Использовать их не стоит.</p></important-warn><h2><a name="5" href="#5">Особенности IE8-</a></h2><h3><a name="15" href="#15">Двойной клик</a></h3><p>Все браузеры, кроме IE8-, генерируют <code>dblclick</code><em>в дополнение</em> к другим событиям.</p><p>То есть, обычно:</p><ul><li><code>mousedown</code> (нажал)</li><li><code>mouseup+click</code> (отжал)</li><li><code>mousedown</code> (нажал)</li><li><code>mouseup+click+dblclick</code> (отжал).</li></ul><p><strong>IE8- на втором клике не генерирует <code>mousedown</code> и <code>click</code>.</strong></p><p>Получается:</p><ul><li><code>mousedown</code> (нажал)</li><li><code>mouseup+click</code> (отжал)</li><li>(нажал второй раз, без события)</li><li><code>mouseup+dblclick</code> (отжал).</li></ul><p>Поэтому отловить двойной клик в IE8-, отслеживая только <code>click</code>, нельзя, ведь при втором нажатии его нет. Нужно именно событие <code>dblclick</code>.</p><h3><a name="16" href="#16">Свойство which/button</a></h3><p>В старых IE8- не поддерживалось свойство <code>which</code>, а вместо него использовалось свойство <code>button</code>, которое является 3-х битным числом, в котором каждому биту соответствует кнопка мыши. Бит установлен в 1, только если соответствующая кнопка нажата.</p><p>Чтобы его расшифровать – нужна <a data-load_page="17#c">побитовая операция</a><code>&amp;</code> («битовое И»):</p><ul><li><code>!!(button &amp; 1) == true</code> (1-й бит установлен), если нажата левая кнопка,</li><li><code>!!(button &amp; 2) == true</code> (2-й бит установлен), если нажата правая кнопка,</li><li><code>!!(button &amp; 4) == true</code> (3-й бит установлен), если нажата средняя кнопка.</li></ul><p>Что интересно, при этом мы можем узнать, были ли две кнопки нажаты одновременно, в то время как стандартный <code>which</code> такой возможности не даёт. Так что, в некотором смысле, свойство <code>button</code> – более мощное.</p><p>Можно легко сделать функцию, которая будет ставить свойство <code>which</code> из <code>button</code>, если его нет:</p><code-example><script>`function fixWhich(e) {\n  if (!e.which && e.button) { // если which нет, но есть button... (IE8-)\n    if (e.button & 1) e.which = 1; // левая кнопка\n    else if (e.button & 4) e.which = 2; // средняя кнопка\n    else if (e.button & 2) e.which = 3; // правая кнопка\n  }\n}`</script></code-example><h3><a name="17" href="#17">Свойства pageX/pageY</a></h3><p>В IE до версии 9 не поддерживаются свойства <code>pageX/pageY</code>, но их можно получить, прибавив к <code>clientX/clientY</code> величину прокрутки страницы.</p><p>Более подробно о её вычислении вы можете прочитать в разделе <a data-load_page="115#2">прокрутка страницы</a>.</p><p>Мы же здесь приведем готовый вариант, который позволяет нам получить <code>pageX/pageY</code> для старых и совсем старых IE:</p><code-example><script>`function fixPageXY(e) {\n  if (e.pageX == null && e.clientX != null) { // если нет pageX..\n    var html = document.documentElement;\n    var body = document.body;\n\n    e.pageX = e.clientX + (html.scrollLeft || body && body.scrollLeft || 0);\n    e.pageX -= html.clientLeft || 0;\n\n    e.pageY = e.clientY + (html.scrollTop || body && body.scrollTop || 0);\n    e.pageY -= html.clientTop || 0;\n  }\n}`</script></code-example><h2><a name="6" href="#6">Итого</a></h2><p>События мыши имеют следующие свойства:</p><ul><li>Кнопка мыши: <code>which</code> (для IE8-: нужно ставить из <code>button</code>)</li><li>Элемент, вызвавший событие: <code>target</code></li><li>Координаты, относительно окна: <code>clientX/clientY</code></li><li>Координаты, относительно документа: <code>pageX/pageY</code> (для IE8-: нужно ставить по <code>clientX/Y</code> и прокрутке)</li><li>Если зажата спец. клавиша, то стоит соответствующее свойство: <code>altKey</code>, <code>ctrlKey</code>, <code>shiftKey</code> или <code>metaKey</code> (Mac).</li><li>Для поддержки <shortcut>Ctrl</shortcut>+ <code>click</code> не забываем проверить <code>if (e.metaKey || e.ctrlKey)</code>, чтобы пользователи <code>Mac</code> тоже были довольны.</li></ul><h2 id="tasks"><a href="#7" name="7">Задачи (2)</a></h2><task-content><h3><a href="#18" name="18">Список с выделением</a><task-open hover-style="" data-show_task="" title="Закрыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Эта задача состоит из трёх частей.</p><ol><li>Сделайте список, элементы которого можно выделять кликом.</li><li>Добавьте мульти-выделение. Если клик с нажатым <shortcut>Ctrl</shortcut> ( <shortcut>Cmd</shortcut> под Mac), то элемент добавляется-удаляется из выделенных.</li><li>Добавьте выделение промежутков. Если происходит клик с нажатым <shortcut>Shift</shortcut>, то к выделению добавляется промежуток элементов от предыдущего кликнутого до этого. При этом не важно, какое именно действие делал предыдущий клик.Это похоже на то, как работает файловый менеджер в ряде ОС, но чуть проще, так как конкретная реализация выделений различается у разных ОС, и её точное воспроизведение не входит в эту задачу.</li></ol><p>Демо:</p><figure- style="height:220px;padding: 10px;" changeable=""><style> .selected{background:#0f0}li{cursor:pointer}</style>Клик на элементе выделяет только его.<br><code>Ctrl(Cmd)+Клик</code> добавляет/убирает элемент из выделенных.<br><code>Shift+Клик</code> добавляет промежуток от последнего кликнутого к выделению.<br><ul id="ul"><li>Кристофер Робин </li><li>Винни-Пух </li><li>Ослик Иа </li><li>Мудрая Сова </li><li>Кролик. Просто кролик.</li></ul><script> var lastClickedLi=null;ul.onclick=function(event){var target=event.target;if (target.tagName != "LI") return;/* возможно,клик был внутри списка UL,но вне элементов LI */ if (event.metaKey||event.ctrlKey){/* для Mac проверяем Cmd,т.к. Ctrl+click там контекстное меню */ toggleSelect(target);}else if (event.shiftKey){selectFromLast(target);}else{selectSingle(target);}lastClickedLi=target;}ul.onmousedown=function(){return false;};/* --- функции для выделения --- */ function toggleSelect(li){li.classList.toggle('selected');}function selectFromLast(target){var startElem=lastClickedLi||ul.children[0];var isLastClickedBefore=startElem.compareDocumentPosition(target) & 4;if (isLastClickedBefore){for (var elem=startElem;elem != target;elem=elem.nextElementSibling){elem.classList.add('selected');}} else{for (var elem=startElem;elem != target;elem=elem.previousElementSibling){elem.classList.add('selected');}} elem.classList.add('selected');}function deselectAll(){for (var i=0;i<ul.children.length;i++){ul.children[i].removeAttribute('class');}} function selectSingle(li){deselectAll();li.classList.add('selected');}</script><code-toolbar-><a title="reset list" onclick="deselectAll()"></a><a id="answer_1" onclick="deselectAll()" style="display:none" title="открыть в песочнице" data-code_edit=""></a><a id="task_1" onclick="deselectAll()" title="открыть в песочнице" data-code_edit="task"></a></code-toolbar-></figure-><p>P.S. В этой задаче можно считать, что в элементах списка может быть только текст, без вложенных тегов. <br>P.P.S. Обработка одновременного нажатия <shortcut>Ctrl</shortcut>( <shortcut>Cmd</shortcut>) и <shortcut>Shift</shortcut> может быть любой.</p><p><a data-click="task_1">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p><a data-click="answer_1">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#19" name="19">Дерево: проверка клика на заголовке</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 3</span><p>Есть кликабельное JavaScript-дерево UL/LI (см. задачу <a data-load_page="124-2">Раскрывающееся дерево</a>).</p><code-example><script>`<ul>\n  <li>Млекопитающие\n    <ul>\n      <li>Коровы</li>\n      <li>Ослы</li>\n      <li>Собаки</li>\n      <li>Тигры</li>\n    </ul>\n  </li>\n</ul>`</script></code-example><p>При клике на заголовке его список его детей скрывается-раскрывается.Выглядит это так: (кликайте на заголовки)</p><iframe- changeable="" style="height: 340px;" src="tree.html"><script> function on(){tree.onclick=function(evt){var evt=evt||event;var target=evt.target||evt.srcElement;/* раскрыть-закрыть детей */ var node=target.getElementsByTagName('ul')[0];if (!node) return;/* нет детей */ node.style.display=node.style.display ? '' :'none';}}</script><code-toolbar-><a id="answer_2" data-code_edit="" style="display:none"></a><a id="task_2" title="открыть в песочнице" data-code_edit="?"></a></code-toolbar-></iframe-><p>Однако, проблема в том, что скрытие-раскрытие происходит даже при клике <em>вне заголовка</em>, на пустом пространстве справа от него.</p><p><strong>Как скрывать/раскрывать детей только при клике на заголовок?</strong></p><p>В задаче <a data-load_page="124-2">Раскрывающееся дерево</a> это решено так: заголовки завёрнуты в элементы <code>SPAN</code> и проверяются клики только на них. Представим на минуту, что мы не хотим оборачивать текст в <code>SPAN</code>, а хотим оставить как есть. Например, по соображениям производительности, если дерево и так очень большое, ведь оборачивание всех заголовков в <code>SPAN</code> увеличит количество DOM-узлов в 2 раза.</p><p><strong>Решите задачу без обёртывания заголовков в <code>SPAN</code>, используя работу с координатами.</strong></p><p>Исходный документ содержит кликабельное дерево.</p><p>P.S. Задача – скорее на сообразительность, однако подход может быть полезен в реальной жизни.</p><p><a data-click="task_2">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="" style="">Подсказка</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Подсказка</h4><p>У события клика есть координаты. Проверьте по ним, попал ли клик на заголовок.</p><p>Самый глубокий узел на координатах можно получить вызовом <a href="https://developer.mozilla.org/en/DOM/document.elementFromPoint">document.elementFromPoint(clientX, clientY)</a>.</p><p>…Но заголовок является текстовым узлом, поэтому эта функция для него работать не будет. Однако это, всё же, можно обойти. Как?</p></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Подсказка 2</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Подсказка 2</h4><p>Можно при клике на <code>LI</code> сделать временный <code>SPAN</code> и переместить в него текстовый узел-заголовок.</p><p>После этого проверить, попал ли клик в него и вернуть всё как было.</p><code-example><script>`// 1) заворачиваем текстовый узел в SPAN\n\n// 2) проверяем\nvar elem = document.elementFromPoint(e.clientX, e.clientY);\nvar isClickOnTitle = (elem == span);\n\n// 3) возвращаем текстовый узел обратно из SPAN`</script></code-example><p>На шаге 3 текстовый узел вынимается обратно из <code>SPAN</code>, всё возвращается в исходное состояние.</p></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Решение</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Решение</h4><p><a data-click="answer_2">Открыть решение в песочнице.</a></p><p></p><p><a data-load_page="131-3">Впереди подобная задача.</a></p><p></p></task-answer></task-answer-ext></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="События в деталях; Мышь: отмена выделения, невыделяемые элементы"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script> disqus_url="https:\/\/learn.javascript.ru\/mouse-clicks",disqus_identifier="mouse-clicks",disqus_title="\u041c\u044b\u0448\u044c: \u043a\u043b\u0438\u043a\u0438, \u043a\u043d\u043e\u043f\u043a\u0430, \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b";</script></page-content></main>