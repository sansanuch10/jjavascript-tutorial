<main> <script>window.onscroll||(window.onscroll=function(){document.getElementById("showScroll")&&(document.getElementById("showScroll").innerHTML=(window.pageYOffset||document.documentElement.scrollTop)+"px")});</script><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="128">События в деталях</a></nav-up><h1>Прокрутка: событие scroll</h1><p>Событие <code>onscroll</code> происходит, когда элемент прокручивается.</p><p>В отличие от события <code>onwheel</code> (колесико мыши), его могут генерировать только прокручиваемые элементы или окно <code>window</code>. Но зато оно генерируется всегда, при любой прокрутке, не обязательно «мышиной».</p><p>Например, следующая функция при прокрутке окна выдает количество прокрученных пикселей:</p><code-example><script>`window.onscroll = function() {\n  var scrolled = window.pageYOffset || document.documentElement.scrollTop;\n  document.getElementById('showScroll').innerHTML = scrolled + 'px';\n}`</script></code-example><p>В действии: Текущая прокрутка = <b id="showScroll">2358px</b></p><p>Каких-либо особенностей события здесь нет, разве что для его использования нужно отлично представлять, как получить текущее значение прокрутки или прокрутить документ. Об этом мы говорили ранее, в главе <a data-load_page="114">Размеры и прокрутка элементов</a>.</p><p>Некоторые области применения <code>onscroll</code>:</p><ul><li>Показ дополнительных элементов навигации при прокрутке.</li><li>Подгрузка и инициализация элементов интерфейса, ставших видимыми после прокрутки.</li></ul><p>Вашему вниманию предлагаются несколько задач, которые вы можете решить сами или посмотреть использование <code>onscroll</code> на их примере.</p><h2 id="tasks"><a href="#0" name="0">Задачи (3)</a></h2><task-content><h3><a href="#3" name="3">Аватар наверху при прокрутке</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Сделайте так, чтобы при прокрутке ниже элемента <code>#avatar</code> (картинка с Винни-Пухом) – он продолжал показываться в левом-верхнем углу.</p><p>При прокрутке вверх – должен возвращаться на обычное место.</p><p>Прокрутите вниз, чтобы увидеть:</p><figure-><code-toolbar-><a id="answer_1" style="display:none" data-code_edit=""></a><a title="открыть в новом окне" data-new_window=""></a><a id="task_1" title="открыть в песочнице" data-code_edit="?"></a></code-toolbar-><style>scroll-{display:block;position:relative;overflow:auto;height:300px;}column-left{display:block;float:left;width:30%;background:#aef;}column-right{display:block;margin-left:30%;width:70%;background:tan;overflow:auto;/* расшириться вниз захватить float'ы */ } header- { display: block; line-height: 60px; background: yellow; } inner { display: block; margin: 1em; font-size: 130%; } #avatar { float: left; margin: 0 1em .5em 0; border: 1px solid black; text-align: center; background: white; top: 0; left: 0; } </style><scroll-><header->Шапка</header-><column-left><inner><h3>Персонажи:</h3><ul><li>Винни-Пух</li><li>Ослик Иа</li><li>Сова</li><li>Кролик</li></ul></inner></column-left><column-right><inner><h3>Винни-Пух</h3><div id="avatar" style=""><img src="winnie-mult.jpg" width="200" height="150"><div>Кадр из мультфильма</div></div><p>Ви́нни-Пу́х (англ. Winnie-the-Pooh) — плюшевый мишка, персонаж повестей и стихов Алана Александра Милна (цикл не имеет общего названия и обычно тоже называется «Винни-Пух», по первой книге). Один из самых известных героев детской литературы XX века.</p><p>В 1960-е—1970-е годы, благодаря пересказу Бориса Заходера «Винни-Пух и все-все-все», а затем и фильмам студии «Союзмультфильм», где мишку озвучивал Евгений Леонов, Винни-Пух стал очень популярен и в Советском Союзе.</p><p>Как и многие другие персонажи книги Милна, медвежонок Винни получил имя от одной из реальных игрушек Кристофера Робина (1920—1996), сына писателя. В свою очередь, плюшевый мишка Винни-Пух был назван по имени медведицы по кличке Виннипег (Винни), содержавшейся в 1920-х в Лондонском зоопарке.</p><p>Медведица Виннипег (американский чёрный медведь) попала в Великобританию как живой талисман (маскот) Канадского армейского ветеринарного корпуса из Канады, а именно из окрестностей города Виннипега. Она оказалась в кавалерийском полку «Форт Гарри Хорс» 24 августа 1914 года ещё будучи медвежонком (её купил у канадского охотника-траппера за двадцать долларов 27-летний полковой ветеринар лейтенант Гарри Колборн, заботившийся о ней и в дальнейшем). Уже в октябре того же года медвежонок был привезён вместе с войсками в Британию, а так как полк должен был быть в ходе Первой мировой войны переправлен во Францию, то в декабре было принято решение оставить зверя до конца войны в Лондонском зоопарке. Медведица полюбилась лондонцам, и военные не стали возражать против того, чтобы не забирать её из зоопарка и после войны[1]. До конца дней (она умерла 12 мая 1934 года) медведица находилась на довольствии ветеринарного корпуса, о чём в 1919 году на её клетке сделали соответствующую надпись. </p><p>«Винни-Пух» представляет собой дилогию, но каждая из двух книг Милна распадается на 10 рассказов (stories) с собственным сюжетом, которые могут читаться, экранизироваться и т. д. независимо друг от друга. В некоторых переводах деление на две части не сохранено, в других не переведена вторая («Дом на Пуховой опушке»). Иногда первая и вторая книги выполнены разными переводчиками. Такова необычная судьба немецкого Винни-Пуха: первая книга вышла в немецком переводе в 1928 году, а вторая лишь в 1954; между этими датами — ряд трагических событий германской истории.</p><p>Действие книг о Пухе происходит в 500-акровом лесу Эшдаун близ купленной Милнами в 1925 году фермы Кочфорд в графстве Восточный Сассекс, Англия, представленном в книге как Стоакровый лес (англ. The Hundred Acre Wood, в пересказе Заходера — Чудесный лес). Реальными являются также Шесть сосен и ручеёк, у которого был найден Северный Полюс, а также упоминаемая в тексте растительность, в том числе колючий утёсник (gorse-bush, чертополох у Заходера), в который падает Пух[2]. Маленький Кристофер Робин любил забираться в дупла деревьев и играть там с Пухом, поэтому многие персонажи книг живут в дуплах, и значительная часть действия происходит в таких жилищах или на ветвях деревьев[2]. Алан Милн, Кристофер Робин и Винни-Пух. Фотография из Британской национальной портретной галереи</p><p>Действие «Винни-Пуха» разворачивается одновременно в трёх планах — это мир игрушек в детской, мир зверей «на своей территории» в Стоакровом лесу и мир персонажей в рассказах отца сыну (это наиболее чётко показано в самом начале)[4]. В дальнейшем рассказчик исчезает из повествования, и сказочный мир начинает собственное существование, разрастаясь от главы к главе[6]. Отмечалось сходство пространства и мира персонажей «Винни-Пуха» с классическим античным и средневековым эпосом[6]. Многообещающие эпические начинания персонажей (путешествия, подвиги, охоты, игры) оказываются комически малозначительными, в то время как настоящие события происходят во внутреннем мире героев (помощь в беде, гостеприимство, дружба)[6].</p><p>Книги Милна выросли из устных рассказов и игр с Кристофером Робином; устное происхождение характерно и для многих других знаменитых литературных сказок[6]. «Я, собственно, ничего не придумывал, мне оставалось только описывать», как говорил впоследствии Милн[5]. Реальными игрушками Кристофера Робина были также Пятачок (подарок соседей), Иа-Иа без хвоста (ранний подарок родителей), Кенга с Крошкой Ру в сумке и Тигра (куплены родителями впоследствии специально для развития сюжета вечерних рассказов сыну). В рассказах они появляются именно в таком порядке[2]. Сову и Кролика Милн придумал сам; на иллюстрациях Шепарда они выглядят не как игрушки, а как настоящие животные, Кролик говорит Сове: «Только у меня и тебя есть мозги. У остальных — опилки». В процессе игры все эти персонажи получили индивидуальные повадки, привычки и манеру разговора[6]. На созданный Милном мир животных повлияла повесть Кеннета Грэма «Ветер в ивах», которой он восхищался и которую ранее иллюстрировал Шепард[5], возможна также скрытая полемика с «Книгой джунглей» Киплинга[5]. Текст взят из Википедии.</p></inner></column-right></scroll-><script>avatar.style='';document.querySelector('scroll-').onscroll=function(){let t=this.scrollTop+1;if (t<230){avatar.style='';}else{avatar.style='position:absolute;top:'+Math.round(t)+'px';}};</script></figure-><p><a data-click="task_1">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p><a data-click="answer_1">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#4" name="4">Кнопка вверх-вниз</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 3</span><p>Создайте кнопку навигации, которая помогает при прокрутке страницы.</p><p>Работать должна следующим образом:</p><ul><li>Пока страница промотана меньше чем на высоту экрана вниз – кнопка не видна.</li><li>При промотке страницы вниз больше, чем на высоту экрана, появляется кнопка «стрелка вверх».</li><li>При нажатии на нее страница прыгает вверх, но не только. Дополнительно, кнопка меняется на «стрелка вниз» и при клике возвратит на старое место. Если же в этом состоянии посетитель сам прокрутит вниз больше, чем один экран, то она вновь изменится на «стрелка вверх».</li></ul><p>Должен получиться удобный навигационный помощник.</p><p>Посмотрите, как оно должно работать, в ифрейме ниже. Прокрутите ифрейм, навигационная стрелка появится слева-сверху.</p><figure><code-toolbar-><div></div><a target="_blank" title="открыть в новом окне" data-click="new_2"></a><div></div></code-toolbar-><iframe id="load_run_2" src="iframe.html" style="height: 200px;"></iframe></figure><script>setTimeout(() =>{run_2.click();load_run_2.src=load_run_2.getAttribute('src');},100)</script><p><a data-click="task_2">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>...</p><code-example><script>`<!DOCTYPE HTML>\n<html>\n<head>\n  <meta charset="utf-8">\n  <style>\n    GOLD_#matrix_GOLD {\n      width: 400px;\n      margin: auto;\n      overflow: auto;\n      text-align: justify;\n    }\n    /*Кнопка является CSS-спрайтом, поэтому мы дополнительно добавляем ей размер и два состояния:*/\n    GOLD_#updown_GOLD {\n      height: 9px;\n      width: 14px;\n      color: green;\n      position: fixed; /*Сама кнопка должна иметь position:fixed.*/\n      top: 10px;\n      left: 10px;\n      cursor: pointer;\n    }\n    GOLD_#updown.up::before_GOLD {\n      content: '▲';\n    }\n    GOLD_#updown.down::before_GOLD {\n      content: '▼';\n    }\n  </style>\n</head>\n\n<body>\n  <!--Добавим в документ DIV с кнопкой:-->\n  <div id="updown"></div>\n\n  <div id="matrix">\n    <script>\n      for (var i = 0; i < 2000; i++) document.writeln(i);\n      \n      var updownElem = document.getElementById('updown');\n    // При клике состояния меняются следующим образом:\n      var pageYLabel = 0;\n      \n      updownElem.onclick = function() {\n        var pageY = window.pageYOffset || document.documentElement.scrollTop;\n  \n        switch (this.className) {\n          case 'up':\n            pageYLabel = pageY;\n            window.scrollTo(0, 0);\n            this.className = 'down';\n            break;\n          case 'down':\n            window.scrollTo(0, pageYLabel);\n            this.className = 'up';\n        }\n      }\n    // Для решения необходимо аккуратно разобрать все возможные состояния кнопки и указать, что делать при каждом.\n    // Состояние – это просто класс элемента: up/down или пустая строка, если кнопка не видна.\n    // При прокрутке состояния меняются следующим образом:\n      window.onscroll = function() {\n        var pageY = window.pageYOffset || document.documentElement.scrollTop;\n        var innerHeight = document.documentElement.clientHeight;\n  \n        switch (updownElem.className) {\n          case '':\n            if (pageY > innerHeight) {\n              updownElem.className = 'up';\n            }\n            break;\n          case 'up':\n            if (pageY < innerHeight) {\n              updownElem.className = '';\n            }\n            break;\n          case 'down':\n            if (pageY > innerHeight) {\n              updownElem.className = 'up';\n            }\n            break;\n        }\n      }      \n    <\/script>\n  </div>\n</body>\n</html>`</script><code-toolbar- iframe="300"><a id="run_2" data-code_run="0"></a><a id="new_2" title="открыть в новом окне" data-new_window="code"></a><a id="task_2" title="открыть в песочнице" data-code_edit="?" style="display:none"></a><a id="answer_2" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="answer_2">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#5" name="5">Загрузка видимых изображений</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>Задача, которая описана ниже, демонстрирует результативный метод оптимизации страницы.</p><p>С целью экономии трафика и более быстрой загрузки страницы изображения на ней заменяются на «макеты».</p><p>Вместо такого изображения:</p><code-example><script>`<img src="yozhik.jpg" width="128" height="128">`</script></code-example><figure><img src="yozhik.jpg" alt="" width="100%" style="max-width:127px"></figure><p>Стоит вот такое:</p><code-example><script>`<img HIGHsrc="1.gif"LIGHT width="128" height="128" HIGHBLUE_realsrc_BLUE="yozhik.jpg"LIGHT>`</script></code-example><figure><img src="1.gif" alt="" width="100%" style="max-width:127px"></figure><p>То есть настоящий URL находится в атрибуте <code>realsrc</code> (название атрибута можно выбрать любое). А в <code>src</code> поставлен серый GIF размера 1x1, и так как <code>width/height</code> правильные, то он растягивается, так что вместо изображения виден серый прямоугольник.</p><p>При этом, чтобы браузер загрузил изображение, нужно заменить значение <code>src</code> на то, которое находится в <code>realsrc</code>.</p><p>Если страница большая, то замена больших изображений на такие макеты существенно убыстряет полную загрузку страницы. Это особенно заметно в случае, когда на странице много анонсов новостей с картинками или изображений товаров, из которых многие находятся за пределами прокрутки.</p><p>Кроме того, для мобильных устройств JavaScript может подставлять URL уменьшенного варианта картинки.</p><p>Напишите код, который при прокрутке окна загружает ставшие видимыми изображения.</p><p>То есть, как только изображение попало в видимую часть документа – в <code>src</code> нужно прописать правильный URL из <code>realsrc</code>.</p><p>Пример работы вы можете увидеть в <code>iframe</code> ниже, если прокрутите его:</p><figure><code-toolbar-><a id="answer_3" style="display:none" data-code_edit=""></a><a title="открыть в новом окне" href="load_visible_img.html" target="_blank"></a><a id="task_3" title="открыть в песочнице" data-code_edit="?"></a></code-toolbar-><iframe changeable="" src="load_visible_img.html" style="height:300px"></iframe></figure><p>Особенности реализации:</p><ul><li>При начальной загрузке некоторые изображения должны быть видны сразу, до прокрутки. Код должен это учитывать.</li><li>Некоторые изображения могут быть обычными, без <code>realsrc</code>. Их код не должен трогать вообще.</li><li>Также код не должен перегружать уже показанное изображение.</li><li>Желательно предусмотреть загрузку изображений не только видимых сейчас, но и на страницу вперед и назад от текущего места.</li></ul><p>P.S. Горизонтальной прокрутки нет.</p><p><a data-click="task_3">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Функция должна по текущей прокрутке определять, какие изображения видимы, и загружать их.</p><p>Она должна срабатывать не только при прокрутке, но и при загрузке. Вполне достаточно для этого – указать ее вызов в скрипте под страницей, вот так:</p><code-example><script>`...страница...\n\nfunction isVisible(elem) {\n\n  var coords = elem.getBoundingClientRect();\n\n  var windowHeight = document.documentElement.clientHeight;\n\n  // верхняя граница elem в пределах видимости ИЛИ нижняя граница видима\n  var topVisible = coords.top > 0 && coords.top < windowHeight;\n  var bottomVisible = coords.bottom < windowHeight && coords.bottom > 0;\n\n  return topVisible || bottomVisible;\n}\n\nMARKshowVisible();\nMARKwindow.onscroll = showVisible;`</script></code-example><p>При запуске функция ищет все видимые картинки с <code>realsrc</code> и перемещает значение <code>realsrc</code> в <code>src</code>. Обратите внимание, т.к. атрибут <code>realsrc</code> нестандартный, то для доступа к нему мы используем <code>get/setAttribute</code>. А <code>src</code> – стандартный, поэтому можно обратиться по DOM-свойству.</p><p><strong>Функция проверки видимости <code>isVisible(elem)</code> получает координаты текущей видимой области и сравнивает их с элементом.</strong></p><p>Для видимости достаточно, чтобы координаты верхней(или нижней) границы элемента находились между границами видимой области.</p><p>В решении также указан вариант с <code>isVisible</code>, который расширяет область видимости на ±1 страницу (высота страницы – <code>document.documentElement.clientHeight</code>).</p><p><a data-click="answer_3">Открыть решение в песочнице.</a></p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Мышь: IE8-, исправление события; Клавиатура: keyup, keydown, keypress"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/onscroll",disqus_identifier="onscroll",disqus_title="\u041f\u0440\u043e\u043a\u0440\u0443\u0442\u043a\u0430: \u0441\u043e\u0431\u044b\u0442\u0438\u0435 scroll";</script></page-content></main>