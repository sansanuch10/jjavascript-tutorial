<main> <page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="128">События в деталях</a></nav-up><h1>Мышь: Drag'n'Drop</h1><p>Drag’n’Drop – это возможность захватить мышью элемент и перенести его. В свое время это было замечательным открытием в области интерфейсов, которое позволило упростить большое количество операций.</p><p>Перенос мышкой может заменить целую последовательность кликов. И, самое главное, он упрощает внешний вид интерфейса: функции, реализуемые через Drag’n’Drop, в ином случае потребовали бы дополнительных полей, виджетов и т.п.</p><h2><a name="0" href="#0">Отличия от HTML5 Drag’n’Drop</a></h2><p>В современном стандарте HTML5 есть поддержка Drag’n’Drop при помощи <a href="http://www.html5rocks.com/en/tutorials/dnd/basics/">специальных событий</a>.</p><p>Эти события поддерживаются всеми современными браузерами, и у них есть свои интересные особенности, например, можно перетащить файл в браузер, так что JS получит доступ к его содержимому. Они заслуживают отдельного рассмотрения.</p><p>Но в плане именно Drag’n’Drop у них есть существенные ограничения. Например, нельзя организовать перенос «только по горизонтали» или «только по вертикали». Также нельзя ограничить перенос внутри заданной зоны. Есть и другие интерфейсные задачи, которые такими встроенными событиями нереализуемы.</p><p>Поэтому здесь мы будем рассматривать Drag’n’Drop при помощи событий мыши.</p><p>Рассматриваемые приёмы, вообще говоря, применяются не только в Drag’n’Drop, но и для любых интерфейсных взаимодействий вида «захватить – потянуть – отпустить».</p><h2><a name="1" href="#1">Алгоритм Drag’n’Drop</a></h2><p>Основной алгоритм Drag’n’Drop выглядит так:</p><ol><li>Отслеживаем нажатие кнопки мыши на переносимом элементе при помощи события <code>mousedown</code>.</li><li>При нажатии – подготовить элемент к перемещению.</li><li>Далее отслеживаем движение мыши через <code>mousemove</code> и передвигаем переносимый элемент на новые координаты путём смены <code>left/top</code> и <code>position:absolute</code>.</li><li>При отпускании кнопки мыши, то есть наступлении события <code>mouseup</code> – остановить перенос элемента и произвести все действия, связанные с окончанием Drag’n’Drop.</li></ol><p>В следующем примере эти шаги реализованы для переноса мяча:</p><code-example><script>`var ball = document.getElementById('ball');\n\nMARKball.onmousedown = function(e) { // 1. отследить нажатие\n\n  // подготовить к перемещению\nMARK  // 2. разместить на том же месте, но в абсолютных координатах\n  ball.style.position = 'absolute';\n  moveAt(e);\n  // переместим в body, чтобы мяч был точно не внутри position:relative\n  document.body.appendChild(ball);\n\n  ball.style.zIndex = 1000; // показывать мяч над другими элементами\n\n  // передвинуть мяч под координаты курсора\n  // и сдвинуть на половину ширины/высоты для центрирования\n  function moveAt(e) {\n    ball.style.left = e.pageX - ball.offsetWidth / 2 + 'px';\n    ball.style.top = e.pageY - ball.offsetHeight / 2 + 'px';\n  }\n\nMARK  // 3, перемещать по экрану\n  document.onmousemove = function(e) {\n    moveAt(e);\n  }\n\nMARK  // 4. отследить окончание переноса\n  ball.onmouseup = function() {\n    document.onmousemove = null;\n    ball.onmouseup = null;\n  }\n}`</script></code-example><p>Если запустить этот код, то мы заметим нечто странное. При начале переноса мяч «раздваивается» и переносится не сам мяч, а его «клон».</p><p>Это можно увидеть в действии внутри ифрейма:</p><iframe id="ball" src="ball_drag.html" style="height:230px;"></iframe><script>! function(){frameAddScript('ball',on);function on(){var ball_img=document.getElementById('ball_img');ball_img.onmousedown=function(e){moveAt_img(e);document.body.appendChild(ball_img);document.addEventListener('mousemove',moveAt_img,true);};ball_img.onmouseup=function(){document.removeEventListener('mousemove',moveAt_img,true);/* ball_img.onmouseup=null;*/};function moveAt_img(e){ball_img.style.left=e.pageX-ball_img.style.width.slice(0,-2)/2+'px';ball_img.style.top=e.pageY-ball_img.style.height.slice(0,-2)/2+'px';}var ball_svg=document.getElementById('ball_svg');ball_svg.onmousedown=function(e){moveAt_svg(e);document.body.appendChild(ball_svg);document.addEventListener('mousemove',moveAt_svg,true);ball_svg.onmouseup=function(){document.removeEventListener('mousemove',moveAt_svg,true);ball_svg.onmouseup=null;};function moveAt_svg(e){ball_svg.style.left=e.pageX-ball_svg.style.width.slice(0,-2)/2+'px';ball_svg.style.top=e.pageY-ball_svg.style.height.slice(0,-2)/2+'px';}}}}()</script><p>Попробуйте перенести мяч мышкой и вы увидите описанное, довольно-таки странное, поведение.</p><p>Это потому, что браузер имеет свой собственный Drag’n’Drop, который автоматически запускается и вступает в конфликт с нашим. Это происходит именно для картинок и некоторых других элементов.</p><p>Его нужно отключить:</p><code-example><script>`ball.ondragstart = function() {\n  return false;\n};`</script></code-example><p>Теперь всё будет в порядке.</p><p>В действии (внутри ифрейма):</p><figure><code-toolbar-><div></div><a title="open new window" data-new_window=""></a><a title="редактировать в песочнице" data-code_edit=""></a></code-toolbar-><iframe id="ball_1" style="height:230px" src="ball_drag.html"></iframe></figure><script>! function(){frameAddScript('ball_1',on);function on(){var ball_img=document.getElementById('ball_img');ball_img.onmousedown=function(e){moveAt_img(e);document.body.appendChild(ball_img);document.addEventListener('mousemove',moveAt_img,true);};ball_img.onmouseup=function(){document.removeEventListener('mousemove',moveAt_img,true);/* ball_img.onmouseup=null;*/};function moveAt_img(e){ball_img.style.left=e.pageX-ball_img.style.width.slice(0,-2)/2+'px';ball_img.style.top=e.pageY-ball_img.style.height.slice(0,-2)/2+'px';}ball_img.ondragstart=function(){return false;};var ball_svg=document.getElementById('ball_svg');ball_svg.onmousedown=function(e){moveAt_svg(e);document.body.appendChild(ball_svg);document.addEventListener('mousemove',moveAt_svg,true);ball_svg.onmouseup=function(){document.removeEventListener('mousemove',moveAt_svg,true);/* ball_svg.onmouseup=null;*/};function moveAt_svg(e){ball_svg.style.left=e.pageX-ball_svg.style.width.slice(0,-2)/2+'px';ball_svg.style.top=e.pageY-ball_svg.style.height.slice(0,-2)/2+'px';}}}}()</script><p>Ещё одна особенность правильного Drag’n’Drop – событие <code>mousemove</code> отслеживается на <code>document</code>, а не на <code>ball</code>.</p><p>С первого взгляда кажется, что мышь всегда над мячом и обработчик <code>mousemove</code> можно повесить на сам мяч, а не на документ.</p><p>Однако, на самом деле мышь во время переноса не всегда над мячом.</p><p>Вспомним, событие <code>mousemove</code> возникает хоть и часто, но не для каждого пикселя. Быстрое движение курсора вызовет <code>mousemove</code> уже не над мячом, а, например, в дальнем конце страницы.</p><p>Вот почему мы должны отслеживать <code>mousemove</code> на всём <code>document</code>.</p><h2><a name="2" href="#2">Правильное позиционирование</a></h2><p>В примерах выше мяч позиционируется в центре под курсором мыши:</p><code-example><script>`self.style.left = e.pageX - ball.offsetWidth / 2 + 'px';\nself.style.top = e.pageY - ball.offsetHeight / 2 + 'px';`</script></code-example><p>Если поставить <code>left/top</code> ровно в <code>pageX/pageY</code>, то мячик прилипнет верхним-левым углом к курсору мыши. Будет некрасиво. Поэтому мы сдвигаем его на половину высоты/ширины, чтобы был центром под мышью. Уже лучше.</p><p>Но не идеально. В частности, в самом начале переноса, особенно если мячик «взят» за край – он резко «прыгает» центром под курсор мыши.</p><p><strong>Для правильного переноса необходимо, чтобы изначальный сдвиг курсора относительно элемента сохранялся.</strong></p><p>Где захватили, за ту «часть элемента» и переносим:</p><figure><img src="ball_shift.png" alt="" width="100%" style="max-width:156px"></figure><ol><li><p>Когда человек нажимает на мячик <code>mousedown</code> – курсор сдвинут относительно левого-верхнего угла мяча на расстояние, которое мы обозначим <code>shiftX/shiftY</code>. И нужно при переносе сохранить этот сдвиг.</p><p>Получить значения <code>shiftX/shiftY</code> легко: достаточно вычесть из координат курсора <code>pageX/pageY</code> левую-верхнюю границу мячика, полученную при помощи функции <a data-load_page="117#1">getCoords</a>.</p><p><strong>При Drag’n’Drop мы везде используем координаты относительно документа, так как они подходят в большем количестве ситуаций.</strong></p><p>Конечно же, не проблема перейти к координатам относительно окна, если это понадобится. Достаточно использовать <code>position:fixed</code>, <code>elem.getBoundingClientRect()</code> для определения координат и <code>e.clientX/Y</code>.</p><code-example><script>`// onmousedown\nshiftX = e.pageX - getCoords(ball).left;\nshiftY = e.pageY - getCoords(ball).top;`</script></code-example></li><li><p>Далее при переносе мяча мы располагаем его <code>left/top</code> с учетом сдвига, то есть вот так:</p><code-example><script>`// onmousemove\nball.style.left = e.pageX - HIGHshiftXLIGHT + 'px';\nball.style.top = e.pageY - HIGHshiftYLIGHT + 'px';`</script></code-example></li></ol><p>Итоговый код с правильным позиционированием:</p><code-example><script>`<p>Кликните по мячу и тяните, чтобы двигать его.</p>\n<img src="https://js.cx/clipart/ball.svg" style="cursor:pointer" width="40" height="40" id="ball">\n\n<script>\n  ball.onmousedown = function(e) {\n    var coords = getCoords(ball);\n    var shiftX = e.pageX - coords.left;\n    var shiftY = e.pageY - coords.top;\n\n    ball.style.position = 'absolute';\n    document.body.appendChild(ball);\n    moveAt(e);\n\n    ball.style.zIndex = 1000; // над другими элементами\n\n    function moveAt(e) {\n      ball.style.left = e.pageX - shiftX + 'px';\n      ball.style.top = e.pageY - shiftY + 'px';\n    }\n\n    document.onmousemove = function(e) {\n      moveAt(e);\n    };\n\n    ball.onmouseup = function() {\n      document.onmousemove = null;\n      ball.onmouseup = null;\n    };\n  }\n\n  ball.ondragstart = function() {\n    return false;\n  };\n\n  function getCoords(elem) { // кроме IE8-\n    var box = elem.getBoundingClientRect();\n    return {\n      top: box.top + pageYOffset,\n      left: box.left + pageXOffset\n    };\n  }\n<\/script>`</script><code-toolbar iframe="220"><a title="показать" data-code_run="0"></a><a data-code_edit="" title="редактировать в песочнице"></a></code-toolbar></code-example><p>Различие особенно заметно, если захватить мяч за правый-нижний угол. В предыдущем примере мячик «прыгнет» серединой под курсор, в этом – будет плавно переноситься с текущей позиции.</p><h2><a name="3" href="#3">Итого</a></h2><p>Мы рассмотрели «минимальный каркас» <code>Drag'n'Drop</code>.</p><p>Его компоненты:</p><ol><li>События <code>ball.mousedown</code> → <code>document.mousemove</code> → <code>ball.mouseup</code>.</li><li>Передвижение с учётом изначального сдвига <code>shiftX/shiftY</code>.</li><li>Отмена действия браузера по событию <code>dragstart</code>.</li></ol><p>На этой основе можно сделать очень многое.</p><ul><li>При <code>mouseup</code> можно обработать окончание переноса, произвести изменения в данных, если они нужны.</li><li>Во время самого переноса можно подсвечивать элементы, над которыми проходит элемент.</li><li>При обработке событий <code>mousedown</code> и <code>mouseup</code> можно использовать делегирование, так что одного обработчика достаточно для управления переносом в зоне с сотнями элементов.</li></ul><p>Это и многое другое мы рассмотрим в статье про <a data-load_page="133">Drag’n’Drop объектов</a>.</p><h2 id="tasks"><a href="#4" name="4">Задачи (2)</a></h2><task-content><h3><a href="#7" name="7">Слайдер</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Создайте слайдер:</p><iframe- src="slider.html" changeable=""><script> function on(){let sliders=document.querySelectorAll('slider-');let thumbCoords,shiftX,shiftY,newLeft,rightEdge,temp;for (let i=0,l=sliders.length;i<l;i++){sliders[i].innerHTML='';sliders[i].thumb=document.createElement('thumb-');temp=sliders[i].attributes;if (temp[0]){sliders[i].thumb.style.background=temp[0].name;}sliders[i].appendChild(sliders[i].thumb);sliders[i].onmousedown=function(event){if (event.target.closest('thumb-')){startDrag(this,sliders[i].thumb,event);return false;/* disable selection start (cursor change) */}}}function startDrag(slider,thumbElem,e){slider.left=slider.getBoundingClientRect().left;shiftX=e.clientX-thumbElem.getBoundingClientRect().left;document.addEventListener('mousemove',moveTo);document.addEventListener('mouseup',endDrag);function moveTo(e){newLeft=e.clientX-shiftX-slider.left;/* вычесть координату родителя,т.к. position:relative */ if (newLeft<0){/* курсор ушёл вне слайдера */ newLeft=0;}rightEdge=slider.offsetWidth-thumbElem.offsetWidth;if (newLeft>rightEdge){newLeft=rightEdge;}thumbElem.style.left=Math.round(newLeft)+'px';}function endDrag(){document.removeEventListener('mousemove',moveTo);document.removeEventListener('mouseup',endDrag);}}}</script><code-toolbar-><a id="task_1" data-code_edit="?" style="display:none"></a><a id="answer_1" data-code_edit="" style="display:none"></a></code-toolbar-></iframe-><p>Захватите мышкой бегунок и двигайте его, чтобы увидеть в работе.</p><p>Важно:</p><ul><li>Слайдер должен нормально работать при резком движении мыши влево или вправо, за пределы полосы. При этом бегунок должен останавливаться четко в нужном конце полосы.</li><li>При нажатом бегунке мышь может выходить за пределы полосы слайдера, но слайдер пусть все равно работает (это удобно для пользователя).</li></ul><p><a data-click="task_1">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Как можно видеть из HTML/CSS, слайдер – это <code>DIV</code>, подкрашенный фоном/градиентом, внутри которого находится другой <code>DIV</code>, оформленный как бегунок, с <code>position:relative</code>.</p><p>Бегунок немного поднят, и вылезает по высоте из родителя.</p><p>На этой основе мы реализуем горизонтальный Drag’n’Drop, ограниченный по ширине. Его особенность – в <code>position:relative</code> у переносимого элемента, т.е. координата ставится не абсолютная, а относительно родителя.</p><p><a data-click="answer_1">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#8" name="8">Расставить супергероев по полю</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>В этой задаче вы можете проверить своё понимание сразу нескольких аспектов Drag’n’Drop.</p><p>Сделайте так, чтобы элементы с классом <code>draggable</code> можно было переносить мышкой. По окончании переноса элемент остаётся на том месте в документе, где его положили.</p><p>Требования к реализации:</p><ul><li>Должен быть 1 обработчик на <code>document</code>, использующий делегирование.</li><li>Если элементы подносят к вертикальным краям окна – оно должно прокручиваться вниз/вверх.</li><li>Горизонтальной прокрутки в этой задаче не существует.</li><li>Элемент при переносе, даже при резких движениях мышкой, не должен попасть вне окна.</li></ul><p>Футбольное поле в этой задаче слишком большое, чтобы показывать его здесь, поэтому откройте его, кликнув по ссылке ниже. Там же и подробное описание задачи (осторожно, винни-пух и супергерои!).</p><p><a href="drag_heroes.html" target="blank">Демо в новом окне</a></p><p><a data-code_edit="drag_heroes.html-?">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>В решении этой задачи для переноса мы используем координаты относительно окна и <code>position:fixed</code>. Так проще.</p><p>А по окончании – прибавляем прокрутку и делаем <code>position:absolute</code>, чтобы элемент был привязан к определённому месту в документе, а не в окне. Можно было и сразу <code>position:absolute</code> и оперировать в абсолютных координатах, но код был бы немного длиннее.</p><p>Детали решения расписаны в комментариях в исходном коде.</p><p><a data-code_edit="drag_heroes.html">Открыть решение в песочнице.</a></p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Мышь: движение mouseover/out, mouseenter/leave; Мышь: Drag'n'Drop более глубоко"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/drag-and-drop",disqus_identifier="drag-and-drop",disqus_title="\u041c\u044b\u0448\u044c: Drag'n'Drop";</script></page-content></main>