<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="128">События в деталях</a></nav-up><h1>Загрузка документа: DOMContentLoaded, load, beforeunload, unload</h1><p>Процесс загрузки HTML-документа, условно, состоит из трёх стадий:</p><ul><li><code>DOMContentLoaded</code> – браузер полностью загрузил HTML и построил DOM-дерево.</li><li><code>load</code> – браузер загрузил все ресурсы.</li><li><code>beforeunload/unload</code> – уход со страницы.</li></ul><p>Все эти стадии очень важны. На каждую можно повесить обработчик, чтобы совершить полезные действия:</p><ul><li><code>DOMContentLoaded</code> – означает, что все DOM-элементы разметки уже созданы, можно их искать, вешать обработчики, создавать интерфейс, но при этом, возможно, ещё не догрузились какие-то картинки или стили.</li><li><code>load</code> – страница и все ресурсы загружены, используется редко, обычно нет нужды ждать этого момента.</li><li><code>beforeunload/unload</code> – можно проверить, сохранил ли посетитель изменения, уточнить, действительно ли он хочет покинуть страницу.</li></ul><p>Далее мы рассмотрим важные детали этих событий.</p><h2><a name="0" href="#0">DOMContentLoaded</a></h2><p>Событие <code>DOMContentLoaded</code> происходит на <code>document</code> и поддерживается во всех браузерах, кроме IE8-. Про поддержку аналогичного функционала в старых IE мы поговорим в конце главы.</p><p>Обработчик на него вешается только через <code>addEventListener</code>:</p><code-example><script>`document.addEventListener("DOMContentLoaded", ready);`</script></code-example><p>Пример:</p><code-example><script>`<script>\n  function ready() {\n    alert( 'DOM готов' );\n    alert( "Размеры картинки:&nbsp" + img.offsetWidth  + "x" + img.offsetHeight );\n  }\n\nMARK  document.addEventListener("DOMContentLoaded", ready);\n<\/script>\n\n<img id="img" src="https://js.cx/clipart/yozhik.jpg?speed=1">`</script><code-toolbar iframe="190"><a title="показать" data-code_run="0"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>В примере выше обработчик <code>DOMContentLoaded</code> сработает сразу после загрузки документа, не дожидаясь получения картинки.</p><p>Поэтому на момент вывода <code>alert</code> и сама картинка будет невидна и её размеры – неизвестны (кроме случая, когда картинка взята из кеша браузера).</p><p>В своей сути, событие <code>onDOMContentLoaded</code> – простое, как пробка. Полностью создано DOM-дерево – и вот событие. Но с ним связан ряд существенных тонкостей.</p><h3><a name="7" href="#7">DOMContentLoaded и скрипты</a></h3><p>Если в документе есть теги <code>&lt;script&gt;</code>, то браузер обязан их выполнить до того, как построит DOM. Поэтому событие <code>DOMContentLoaded</code> ждёт загрузки и выполнения таких скриптов.</p><p>Исключением являются скрипты с атрибутами <code>async</code> и <code>defer</code>, которые подгружаются асинхронно.</p><p><strong>Побочный эффект: если на странице подключается скрипт с внешнего ресурса (к примеру, реклама), и он тормозит, то событие <code>DOMContentLoaded</code> и связанные с ним действия могут сильно задержаться.</strong></p><p>Современные системы рекламы используют атрибут <code>async</code>, либо вставляют скрипты через DOM: <code>document.createElement('script')...</code>, что работает так же как <code>async</code>: такой скрипт выполняется полностью независимо от страницы и от других скриптов – сам ничего не ждёт и ничего не блокирует.</p><h3><a name="8" href="#8">DOMContentLoaded и стили</a></h3><p>Внешние стили никак не влияют на событие <code>DOMContentLoaded</code>. Но есть один нюанс.</p><p><strong>Если после стиля идёт скрипт, то этот скрипт обязан дождаться, пока стиль загрузится:</strong></p><code-example><script>`<link type="text/css" rel="stylesheet" href="style.css">\n<script>\n  // сработает после загрузки style.css\n<\/script>`</script></code-example><p>Такое поведение прописано в стандарте. Его причина – скрипт может захотеть получить информацию со страницы, зависящую от стилей, например, ширину элемента, и поэтому обязан дождаться загрузки <code>style.css</code>.</p><p><strong>Побочный эффект – так как событие <code>DOMContentLoaded</code> будет ждать выполнения скрипта, то оно подождёт и загрузки стилей, которые идут перед <code>&lt;script&gt;</code>.</strong></p><h3><a name="9" href="#9">Автозаполнение</a></h3><p>Firefox/Chrome/Opera автозаполняют формы по <code>DOMContentLoaded</code>.</p><p>Это означает, что если на странице есть форма для ввода логина-пароля, то браузер введёт в неё запомненные значения только по <code>DOMContentLoaded</code>.</p><p><strong>Побочный эффект: если <code>DOMContentLoaded</code> ожидает множества скриптов и стилей, то автозаполнение не сработает до полной их загрузки.</strong></p><p>Конечно, это довод в пользу того, чтобы не задерживать <code>DOMContentLoaded</code>, в частности – использовать у скриптов атрибуты <code>async</code> и <code>defer</code>.</p><h2><a name="1" href="#1">window.onload</a></h2><p>Событие <code>onload</code> на <code>window</code> срабатывает, когда загружается <em>вся</em> страница, включая ресурсы на ней – стили, картинки, ифреймы и т.п.</p><p>Пример ниже выведет <code>alert</code> лишь после полной загрузки окна, включая <code>IFRAME</code> и картинку:</p><code-example><script>`<script>\nMARK  window.onload = function() {\nMARK    alert( 'Документ и все ресурсы загружены' );\nMARK  };\n<\/script>\n<iframe src="https://example.com/" style="height:60px"></iframe>\n<img src="https://js.cx/clipart/yozhik.jpg?speed=1">`</script><code-toolbar iframe="150"><a title="показать" data-code_run="0"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><h2><a name="2" href="#2">window.onunload</a></h2><p>Когда человек уходит со страницы или закрывает окно, на <code>window</code> срабатывает событие <code>unload</code>. В нём можно сделать что-то, не требующее ожидания, например, закрыть вспомогательные popup-окна, но отменить сам переход нельзя.</p><p>Это позволяет другое событие – <code>onbeforeunload</code>, которое поэтому используется гораздо чаще.</p><h2><a name="3" href="#3">window.onbeforeunload</a></h2><p>Если посетитель инициировал переход на другую страницу или нажал «закрыть окно», то обработчик <code>onbeforeunload</code> может приостановить процесс и спросить подтверждение.</p><p>Для этого ему нужно вернуть строку. По историческим причинам некоторые браузеры покажут ее, но большинство – стандартное сообщение.</p><p>Кликните на кнопку в <code>IFRAME'е</code> ниже, чтобы поставить обработчик, а затем по ссылке, чтобы увидеть его в действии:</p><code-example><script>`<script>\n  function setHandler() {\n    window.onbeforeunload = function() {\n      return "Данные не сохранены. Точно перейти?";\n    };\n  }\n<\/script>\n\n<button onclick="setHandler()">Поставить window.onbeforeunload</button>\n\n<a href="http://example.com">Уйти на EXAMPLE.COM</a>`</script><code-toolbar- iframe="80px"><a title="показать" data-code_run="0"></a><a href="onbeforeunload.html" target="_blank" title="открыть в новом окне"></a><div></div></code-toolbar-></code-example><h2><a name="4" href="#4">Эмуляция DOMContentLoaded для IE8-</a></h2><p>Прежде чем что-то эмулировать, заметим, что альтернативой событию <code>onDOMContentLoaded</code> является вызов функции <code>init</code> из скрипта в самом конце <code>BODY</code>, когда основная часть DOM уже готова:</p><code-example><script>`<body>\n  ...\n  <script>\n    init();\n  <\/script>\n</body>`</script></code-example><p>Причина, по которой обычно предпочитают именно событие – одна: удобство. Вешается обработчик и не надо ничего писать в конец <code>BODY</code>.</p><h3><a name="10" href="#10">Мини-скрипт documentReady</a></h3><p>Если вы всё же хотите использовать <code>onDOMContentLoaded</code> кросс-браузерно, то нужно либо подключить какой-нибудь фреймворк – почти все предоставляют такой функционал, либо использовать функцию из мини-библиотеки <a href="https://github.com/Couto/jquery.parts/blob/master/jquery.documentReady.js">jquery.documentReady.js</a>.</p><p>Несмотря на то, что в названии содержится слово «jquery», эта библиотечка не требует <a href="http://jquery.com">jQuery</a>. Наоборот, она представляет собой единственную функцию с названием <code>$</code>, вызов которой <code>$(callback)</code> добавляет обработчик <code>callback</code> на <code>DOMContentLoaded</code> (можно вызывать много раз), либо, если документ уже загружен – выполняет его тут же.</p><p>Пример использования:</p><code-example><script>`<script src="documentReady.js"><\/script>\n\n<script>\nMARK  $(function() {\nMARK    alert( "DOMContentLoaded" );\nMARK  });\n<\/script>\n\n<img src="https://js.cx/clipart/yozhik.jpg?speed=1">\n<div>Текст страницы</div>`</script><code-toolbar iframe="190"><a title="показать" data-code_run="0"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>Здесь <code>alert</code> сработает до загрузки картинки, но после создания DOM, в частности, после появления текста. И так будет для всех браузеров, включая даже очень старые IE.</p><important-><h3>Как именно эмулируется <code>DOMContentLoaded</code>?</h3><p>Технически, эмуляция <code>DOMContentLoaded</code> для старых IE осуществляется очень забавно.</p><p>Основной приём – это попытка прокрутить документ вызовом:</p><code-example><script>`document.documentElement.doScroll("left");`</script></code-example><p>Метод <code>doScroll</code> работает только в IE и «методом тыка» было обнаружено, что он бросает исключение, если DOM не полностью создан.</p><p>Поэтому библиотека пытается вызвать прокрутку, если не получается – через <code>setTimeout(.., 1)</code> пытается прокрутить его ещё раз, и так до тех пор, пока действие не перестанет вызывать ошибку. На этом этапе документ считается загрузившимся.</p><p>Внутри фреймов и в очень старых браузерах такой подход может ошибаться, поэтому дополнительно ставится резервный обработчик на <code>onload</code>, чтобы уж точно сработал.</p></important-><h2><a name="5" href="#5">Итого</a></h2><ul><li><p>Самое востребованное событие из описанных – без сомнения, <code>DOMContentLoaded</code>. Многие страницы сделаны так, что инициализируют интерфейсы именно по этому событию.</p><p>Это удобно, ведь можно в <code>&lt;head&gt;</code> написать скрипт, который будет запущен в момент, когда все DOM-элементы доступны.</p><p>С другой стороны, следует иметь в виду, что событие <code>DOMContentLoaded</code> будет ждать не только, собственно, HTML-страницу, но и внешние скрипты, подключенные тегом <code>&lt;script&gt;</code> без атрибутов <code>defer/async</code>, а также стили перед такими скриптами.</p><p>Событие <code>DOMContentLoaded</code> не поддерживается в IE8-, но почти все фреймворки умеют его эмулировать. Если нужна отдельная функция только для кросс-браузерного аналога <code>DOMContentLoaded</code> – можно использовать <a href="https://github.com/Couto/jquery.parts/blob/master/jquery.documentReady.js">jquery.documentReady.js</a>.</p></li><li><p>Событие <code>window.onload</code> используют редко, поскольку обычно нет нужды ждать подгрузки <em>всех</em> ресурсов. Если же нужен конкретный ресурс (картинка или ифрейм), то можно поставить событие <code>onload</code> непосредственно на нём, мы посмотрим, как это сделать, далее.</p></li><li><p>Событие <code>window.onunload</code> почти не используется, как правило, оно бесполезно – мало что можно сделать, зная, что окно браузера прямо сейчас закроется.</p></li><li><p>Гораздо чаще применяется <code>window.onbeforeunload</code> – это де-факто стандарт для того, чтобы проверить, сохранил ли посетитель данные, действительно ли он хочет покинуть страницу. В системах редактирования документов оно используется повсеместно.</p></li></ul><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Клавиатура: keyup, keydown, keypress; Загрузка скриптов, картинок, фреймов: onload и onerror"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/onload-ondomcontentloaded",disqus_identifier="onload-ondomcontentloaded",disqus_title="\u0417\u0430\u0433\u0440\u0443\u0437\u043a\u0430 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430: DOMContentLoaded, load, beforeunload, unload";</script></page-content></main>