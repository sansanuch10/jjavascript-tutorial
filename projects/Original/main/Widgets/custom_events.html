<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="145">Создание графических компонентов</a></nav-up><h1>Коллбэки и события на компонентах</h1><p>Компоненты, хоть и каждый сам по себе, обычно как-то общаются с остальной частью страницы</p><p>Есть несколько способов, при помощи которых компоненты сообщают друг другу о важных событиях, которые в них произошли.</p><h2><a name="0" href="#0">Коллбэки</a></h2><p>Коллбэк (от англ. callback) – это функция, которую мы передаём куда-либо и ожидаем, что она будет вызвана при наступлении события.</p><p>Например, мы можем добавить в <code>options</code> для <code>Menu</code> новый параметр – функцию <code>onselect</code>, которая будет вызываться при выборе пункта меню:</p><code-example><script>`var menu=new Menu({\n  title:"Сладости",\n  template:_.template(document.getElementById('menu-template').innerHTML),\n  listTemplate:_.template(document.getElementById('menu-list-template').innerHTML,\n  items:{\n    "donut":"Пончик",\n    "cake":"Пирожное",\n    "chocolate":"Шоколадка"\n  },\nMARK  onselect:showSelected\n});\n\nMARKfunction showSelected(href) {\nMARK  alert(href);\nMARK}`</script></code-example><p>В коде меню нужно будет вызывать её, например так:</p><code-example><script>`...\n  function select(link) {\n    options.onselect(link.getAttribute('href').slice(1));\n    ...\n  }\n...`</script></code-example><p>Полный пример:</p><code-example><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <style>\n    GOLD_.menu ul_GOLD {\n      display: none;\n      margin: 0;\n    }\n\n    GOLD_.menu .title_GOLD {\n      font-weight: bold;\n      cursor: pointer;\n    }\n\n    GOLD_.menu .title:before_GOLD {\n      content: '▶';\n      padding-right: 6px;\n      color: green;\n    }\n\n    GOLD_.menu.open ul_GOLD {\n      display: block;\n    }\n\n    GOLD_.menu.open .title:before_GOLD {\n      content: '▼';\n    }\n  </style>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"><\/script>\n  <script src="https://cdn.polyfill.io/v1/polyfill.js?features=Element.prototype.closest"><\/script>\n  <script>\n    function Menu(options) {\n      var elem;\n      function getElem() {\n        if (!elem) render();\n        return elem;\n      }\n\n      function render() {\n        var html = options.template({\n          title: options.title\n        });\n\n        elem = document.createElement('div');\n        elem.innerHTML = html;\n        elem = elem.firstElementChild;\n\n        elem.onmousedown = function() {\n          return false;\n        }\n\n        elem.onclick = function(event) {\n          if (event.target.closest('.title')) {\n            toggle();\n          }\n\n          if (event.target.closest('a')) {\n            event.preventDefault();\n            select(event.target.closest('a'));\n          }\n        }\n      }\n\n      function renderItems() {\n        if (elem.querySelector('ul')) return;\n\n        var listHtml = options.listTemplate({\n          items: options.items\n        });\n        elem.insertAdjacentHTML("beforeEnd", listHtml);\n      }\n\n      function select(link) {\n        options.onselect(link.getAttribute('href').slice(1));\n      }\n\n      function open() {\n        renderItems();\n        elem.classList.add('open');\n      };\n\n      function close() {\n        elem.classList.remove('open');\n      };\n\n      function toggle() {\n        if (elem.classList.contains('open')) close();\n        else open();\n      };\n\n      this.getElem = getElem;\n      this.toggle = toggle;\n      this.close = close;\n      this.open = open;\n    }\n  <\/script>\n</head>\n\n<body>\n\n  <script type="text/template" id="menu-template">\n    <div class="menu">\n      <span class="title"><%-title%></span>\n    </div>\n  <\/script>\n\n<!-- встроенная браузерная функция encodeURIComponent\nCOMMENT  кодирует спец-символы для URL, например русские буквы\nCOMMENT  и пробелы в этом примере русских букв в ключах items нет,\nCOMMENT  но потенциально они возможны\n-->\n  <script type="text/template" id="menu-list-template">\n    <ul>\n      <% for(var name in items) { %>\n        <li>\n          <a href="#<%=encodeURIComponent(name)%>">\n            <%-items[name]%>\n          </a>\n        </li>\n        <% } %>\n    </ul>\n  <\/script>\n\n  <script>\n    var menu = new Menu({\n      title: "Сладости",\n      template: _.template(document.getElementById('menu-template').innerHTML.trim()),\n      listTemplate: _.template(document.getElementById('menu-list-template').innerHTML.trim()),\n      items: {\n        cake: "Торт", // cake  <a href="#cake">Торт</a>\n        donut: "Пончик", // donut\n        chocolate: "Шоколадка" // chocolate\n      },\nMARK      onselect: showSelected\n    });\n\nMARK    function showSelected(itemName) {\nMARK      alert(itemName);\nMARK    }\n\n    document.body.appendChild(menu.getElem());\n  <\/script>\n\n</body>\n\n</html>`</script><code-toolbar iframe="150"><a title="показать" data-code_run="0"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><h2><a name="1" href="#1">Свои события</a></h2><p>Как мы уже знаем, в современных браузерах DOM-элементы могут <a data-load_page="127">генерировать произвольные события</a> при помощи встроенных методов, а в IE8- это возможно с использованием фреймворка, к примеру, jQuery.</p><p>Воспользуемся ими, чтобы корневой элемент меню генерировал событие, которое мы назовём <code>select</code>, при выборе элемента, и передавал в объект события выбранное значение.</p><p>Для этого модифицируем функцию <code>select</code>:</p><code-example><script>`function Menu(options) {\n  ...\n\n  function select(link) {\nMARK    var widgetEvent = new CustomEvent("select", {\nMARK      bubbles: true,\nMARK      // detail - стандартное свойство CustomEvent для произвольных данных\nMARK      detail: link.getAttribute('href').slice(1)\nMARK    });\nMARK    elem.dispatchEvent(widgetEvent);\n  }\n\n  ...\n}`</script></code-example><p>Код, который заинтересован в том, чтобы узнавать, что выбрано в меню, подписывается на событие <code>select</code> его корневого элемента:</p><code-example><script>`var menu = new Menu(...);\n\nvar elem = menu.getElem();\n\nelem.addEventListener('select', function(event) {\n  alert( event.detail );\n});`</script></code-example><p>Вместо <code>detail</code> можно было бы выбрать и другое название свойства, но тогда нужно позаботиться о том, чтобы оно не конфликтовало со стандартными. Кроме того, в конструкторе <code>CustomEvent</code> разрешено только <code>detail</code>, другое свойство понадобилось бы присваивать в отдельной строке.</p><p>Полный пример:</p><code-example><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <style>\n    GOLD_.menu ul_GOLD {\n      display: none;\n      margin: 0;\n    }\n\n    GOLD_.menu .title_GOLD {\n      font-weight: bold;\n      cursor: pointer;\n    }\n\n    GOLD_.menu .title:before_GOLD {\n      content: '▶';\n      padding-right: 6px;\n      color: green;\n    }\n\n    GOLD_.menu.open ul_GOLD {\n      display: block;\n    }\n\n    GOLD_.menu.open .title:before_GOLD {\n      content: '▼';\n    }\n  </style>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"><\/script>\n  <script src="https://cdn.polyfill.io/v1/polyfill.js?features=Element.prototype.closest"><\/script>\n  <script>\n    function Menu(options) {\n      var elem;\n\n      function getElem() {\n        if (!elem) render();\n        return elem;\n      }\n\n      function render() {\n        var html = options.template({\n          title: options.title\n        });\n\n        elem = document.createElement('div');\n        elem.innerHTML = html;\n        elem = elem.firstElementChild;\n\n        elem.onmousedown = function() {\n          return false;\n        }\n\n        elem.onclick = function(event) {\n          if (event.target.closest('.title')) {\n            toggle();\n          }\n\n          if (event.target.closest('a')) {\n            event.preventDefault();\n            select(event.target.closest('a'));\n          }\n\n        }\n      }\n\n      function renderItems() {\n        if (elem.querySelector('ul')) return;\n\n        var listHtml = options.listTemplate({\n          items: options.items\n        });\n        elem.insertAdjacentHTML("beforeEnd", listHtml);\n      }\n\nMARK      function select(link) {\nMARK        var widgetEvent = new CustomEvent("select", {\nMARK          bubbles: true,\nMARK          detail: link.getAttribute('href').slice(1)\nMARK        });\nMARK        elem.dispatchEvent(widgetEvent);\nMARK      }\n\n      function open() {\n        renderItems();\n        elem.classList.add('open');\n      };\n\n      function close() {\n        elem.classList.remove('open');\n      };\n\n      function toggle() {\n        if (elem.classList.contains('open')) close();\n        else open();\n      };\n\n      this.getElem = getElem;\n      this.toggle = toggle;\n      this.close = close;\n      this.open = open;\n    }\n  <\/script>\n</head>\n\n<body>\n\n  <script type="text/template" id="menu-template">\n    <div class="menu">\n      <span class="title"><%-title%></span>\n    </div>\n  <\/script>\n\n<!-- встроенная браузерная функция encodeURIComponent\nCOMMENT  кодирует спец-символы для URL, например русские буквы\nCOMMENT  и пробелы в этом примере русских букв в ключах items нет,\nCOMMENT  но потенциально они возможны\n-->\n  <script type="text/template" id="menu-list-template">\n    <ul>\n      <% for(var name in items) { %>\n        <li>\n          <a href="#<%=encodeURIComponent(name)%>">\n            <%-items[name]%>\n          </a>\n        </li>\n        <% } %>\n    </ul>\n  <\/script>\n\n  <script>\n    var menu = new Menu({\n      title: "Сладости",\n      template: _.template(document.getElementById('menu-template').innerHTML.trim()),\n      listTemplate: _.template(document.getElementById('menu-list-template').innerHTML.trim()),\n      items: {\n        cake: "Торт", // cake  <a href="#cake">Торт</a>\n        donut: "Пончик", // donut\n        chocolate: "Шоколадка" // chocolate\n      }\n    });\n\n    var elem = menu.getElem();\n    document.body.appendChild(elem);\nMARK    elem.addEventListener('select', function(event) {\nMARK      alert(event.detail);\nMARK    });\n  <\/script>\n\n</body>\n\n</html>`</script><code-toolbar iframe="150"><a title="показать" data-code_run="0"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><important-warn><h3>Внимание, инкапсуляция!</h3><p>Очень важно, что внешний код ставит обработчик на корневой элемент, но не на внутренние элементы меню.</p><p>Строго говоря, он вообще не знает про то, как устроено меню, есть ли там ссылки и какие, или там вообще всё реализовано через кнопки.</p><p>Меню для него – «чёрный ящик». Корневой элемент – точка доступа к его функционалу. Событие – не то, которое произошло на ссылке, а «переработанный вариант», интерпретация действия со стороны меню.</p><p>Такое правило позволяет нам не опасаться проблем при оптимизации, расширении и даже полной переделке DOM-структуры меню. Коль скоро события и методы сохраняются, внешний код будет работать как прежде.</p><p>Ещё раз – внешний код не имеет права залезать внутрь DOM-структуры меню, ставить там обработчики и так далее.</p></important-warn><h2><a name="2" href="#2">Итого</a></h2><p>Для того, чтобы внешний код мог узнавать о важных событиях, произошедших внутри компонента, используются:</p><ul><li>Коллбэки – функции, которые передаются «снаружи» при создании компонента, и которые он обязуется вызвать при наступлении событий.</li><li>События – компонент генерирует их на корневом элементе при помощи <code>dispatchEvent</code>, а внешний код ставит обработчики при помощи <code>addEventListener</code>. Такие события всплывают, если указан флаг <code>bubbles</code>, поэтому с ними можно использовать делегирование.</li></ul><h2 id="tasks"><a href="#3" name="3">Задачи (4)</a></h2><task-content><h3><a href="#6" name="6">Голосовалка "на событиях"</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Добавьте событие в голосовалку, созданную в задаче <a data-load_page="147-4">Голосовалка</a>, используя механизм генерации событий на объекте.</p><p>Пусть каждое изменение голоса сопровождается событием <code>change</code> со свойством <code>detail</code>, содержащим обновлённое значение:</p><code-example><script>`var voter = new Voter({\n  elem: document.getElementById('voter')\n});\n\nvoter.setVote(5);\n\ndocument.getElementById('voter').addEventListener('change', function(e) {\n  alert( e.detail ); // новое значение голоса\n});`</script></code-example><p>Все изменения голоса должны производиться централизованно, через метод <code>setVote</code>, который и генерирует событие.</p><p>Результат использования кода выше (планируемый):</p><figure- style="height:60px"><code-toolbar-><a id="answer_1" style="display:none" title="открыть в песочнице" data-code_edit=""></a><a title="открыть в песочнице" data-code_edit="?"></a></code-toolbar-><style> voter-{font-family:Consolas,"Lucida Console",monospace;font-size:18px;margin:20px;}up-,down-{cursor:pointer;color:blue;font-weight:bold;}</style><voter-><down->— </down-><vote->5</vote-><up-> +</up-></voter-><script>function Voter(options){var elem=options.elem;var voteElem=elem.querySelector('vote-');elem.onclick=function(event){/* сам обработчик не меняет голос,он вызывает функцию */ if (event.target.closest('down-')){voteDecrease();}else if (event.target.closest('up-')){voteIncrease();}} elem.onmousedown=function(){return false;};/* ----------- методы ------------- */ function voteDecrease(){setVote(+voteElem.innerHTML-1);}function voteIncrease(){setVote(+voteElem.innerHTML+1);}function setVote(vote){voteElem.innerHTML=+vote;var widgetEvent=new CustomEvent("change",{bubbles:true,detail:+vote});elem.dispatchEvent(widgetEvent);};this.setVote=setVote;}var voter=new Voter({elem:document.querySelector('voter-')});voter.setVote(5);document.querySelector('voter-').addEventListener('change',function(e){alert(e.detail);});</script></figure-><code-result></code-result><p>Исходный документ возьмите из решения задачи <a href="/task/voter">Голосовалка</a>.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p><a data-click="answer_1">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#7" name="7">Список с выделением и событием</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Добавьте в решение задачи <a data-load_page="147-3">Компонент: список с выделением</a> событие <code>select</code>.</p><p>Оно должно срабатывать при каждом изменении выбора и в свойстве <code>detail</code> содержать список выбранных строк.</p><p>Во внешнем коде добавьте обработчик к списку, который при изменениях выводит список значений.</p><figure- style="height:200px;padding: 10px;"><style> .selected{background:#0f0}li{cursor:pointer}</style><p>Клик на элементе выделяет только его.<br><code>Ctrl(Cmd)+Клик</code> добавляет/убирает элемент из выделенных.<br><code>Shift+Клик</code> добавляет промежуток от последнего кликнутого к выделению.</p><ul id="heroes"><li class="">Кристофер Робин </li><li>Винни-Пух </li><li class="">Ослик Иа </li><li>Мудрая Сова </li><li>Кролик. Просто кролик.</li></ul><script> function ListSelect(options){var elem=options.elem;var lastClickedLi=null;elem.onmousedown=function(){return false;};elem.onclick=function(e){var li=e.target.closest('li');if (!li) return;if (e.metaKey||e.ctrlKey){/* для Mac проверяем Cmd,т.к. Ctrl+click там контекстное меню */ toggleSelect(li);}else if (e.shiftKey){selectFromLast(li);}else{selectSingle(li);}dispatchEvent();lastClickedLi=li;}function deselectAll(){[].forEach.call(elem.children,function(child){child.classList.remove('selected')});}function toggleSelect(li){li.classList.toggle('selected');}function selectSingle(li){deselectAll();li.classList.add('selected');}function selectFromLast(target){var startElem=lastClickedLi||elem.children[0];target.classList.add('selected');if (startElem == target){/* клик на том же элементе,что и раньше,это особый случай */ return;}var isLastClickedBefore=startElem.compareDocumentPosition(target) & 4;if (isLastClickedBefore){for (var elem=startElem;elem != target;elem=elem.nextElementSibling){elem.classList.add('selected');}} else{for (var elem=startElem;elem != target;elem=elem.previousElementSibling){elem.classList.add('selected');}}}function dispatchEvent(){var widgetEvent=new CustomEvent("select",{bubbles:true,detail:getSelected()});elem.dispatchEvent(widgetEvent);}function getSelected(){return [].map.call(elem.querySelectorAll('.selected'),function(li){return li.innerHTML;});};this.getSelected=getSelected;this.deselectAll=deselectAll;}var listSelect=new ListSelect({elem:document.querySelector('#heroes')});document.querySelector('#heroes').addEventListener('select',function(event){alert(event.detail);});</script><code-toolbar-><a title="reset list" onclick="listSelect.deselectAll()"></a><a id="answer_2" onclick="listSelect.deselectAll()" style="display:none" data-code_edit=""></a><a onclick="listSelect.deselectAll()" title="открыть в песочнице" data-code_edit="?"></a></code-toolbar-></figure-><p>В качестве исходного кода возьмите решение задачи <a data-load_page="147-3">Компонент: список с выделением</a>.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p><a data-click="answer_2">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#8" name="8">Свой селект</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Напишите свой, самостоятельно оформленный, селект.</p><p>Требования:</p><ul><li>Открытие и закрытие по клику на заголовок.</li><li>Закрытие селекта происходит при выборе или клике на любое другое место документа, в том числе на другой аналогичный селект.</li><li>Событие <code>"select"</code> при выборе опции возникает на элементе селекта и всплывает.</li><li>Значение опции хранится в атрибуте <code>data-value</code> (HTML-структура есть в исходном документе).</li></ul><p>Например:</p><script src="https://cdn.polyfill.io/v1/polyfill.js?features=CustomEvent,Element.prototype.closest"></script><figure- style="height: 150px;"><code-toolbar-><a title="reset list" href="/"></a><a id="answer_3" style="display:none" data-code_edit=""></a><a id="task_3" title="открыть в песочнице" data-code_edit="?"></a></code-toolbar-><style>select-{width:200px;font-size:14px;display:inline-block;margin-right:5px}title-1{display:inline-block;height:20px;border:2px groove #ADD8E6;background:white;width:200px;box-sizing:border-box;padding:2px;line-height:14px;cursor:pointer;text-align:left;}select- li{padding:2px;cursor:pointer;}select- li:nth-child(even){background-color:#f0f8ff;}select- li:hover{background-color:#7fffd4;}select- ul{list-style:none;margin:0;padding:0;display:none;position:absolute;z-index:1000;background:white;width:200px;border-bottom:1px solid #add8e6;border-left:1px solid #add8e6;border-right:1px solid #add8e6;box-sizing:border-box;}select-.open ul{display:block;} </style><p>Последний результат: <result-> ...</result-></p><select-><title-1>Выберите</title-1><ul><!-- значение хранится в свойстве data-value --><li data-value="bird">Птицы</li><li data-value="fish">Рыбы</li><li data-value="animal">Звери</li><li data-value="dino">Динозавры</li><li data-value="simplest">Одноклеточные</li></ul></select-><select-><title-1>Выберите</title-1><ul style=""><li data-value="carnivore">Плотоядные</li><li data-value="herbivore">Травоядные</li><li data-value="omnivore">Всеядные</li></ul></select-><script>function CustomSelect(options){var elem=options.elem;elem.onclick=function(event){if (event.target.tagName == 'TITLE-1'){toggle();}else if (event.target.tagName == 'LI'){setValue(event.target.innerHTML,event.target.dataset.value);close();}} /* ------ обработчики ------ */ function onDocumentClick(event){/* закрыть селект,если клик вне его */ if (!elem.contains(event.target)) close();}function setValue(title,value){elem.querySelector('title-1').innerHTML=title;var widgetEvent=new CustomEvent('select',{bubbles:true,detail:{title:title,value:value}});elem.dispatchEvent(widgetEvent);}var isOpen=false;function toggle(){if (isOpen) close() else open();}function open(){elem.querySelector('ul').style.display='block';document.addEventListener('click',onDocumentClick);isOpen=true;}function close(){elem.querySelector('ul').removeAttribute('style');document.removeEventListener('click',onDocumentClick);isOpen=false;}}var animalSelect=new CustomSelect({elem:document.body.querySelectorAll('select-')[0]});var foodSelect=new CustomSelect({elem:document.body.querySelectorAll('select-')[1]});document.addEventListener('select',function(event){document.querySelector('result-').innerHTML=event.detail.value;});</script></figure-><p>В примере выше два селекта, чтобы можно было проверить процесс открытия-закрытия.</p><p><a data-click="task_3">Открыть решение в песочнице.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>В этом решении для закрытия селекта по клику вне него используется отслеживание произвольных кликов внутри документа.</p><p>Альтернатива – события <code>focusin/focusout</code>, т.е. считаем, что пока фокус в селекте – он открыт. С одной стороны, это более мощный способ, он позволяет перемещаться по элементам управления при помощи <kbd class="shortcut">Tab</kbd> и корректно обрабатывать уход при помощи клавиатуры.</p><p>С другой стороны, это решение не универсально: если выводится <code>alert</code>, то фокус «прыгает» в него, уходя с элемента, а потом возвращается обратно. При этом JavaScript зарегистрирует уход фокуса <code>focusout</code> и возвращение <code>focusin</code>, хотя по смыслу фокус с элемента никуда не уходил, просто был <code>alert</code>.</p><p>Побочный эффект – закрытие и (лишнее) раскрытие элемента управления при таких «ненамеренных» потерях фокуса. Поэтому был выбран <code>onclick</code>.</p><p>Решение:</p><p><a data-click="answer_3">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#9" name="9">Слайдер с событиями</a><task-open hover-style="" data-show_task="" title="Закрыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>На основе слайдера из задачи <a data-load_page="147-2">Слайдер-компонент</a> создайте графический компонент, который умеет возвращать/получать значение.</p><p>Синтаксис:</p><code-example><script>`var slider = new Slider({\n  elem: document.getElementById('slider'),\n  max: 100 // слайдер на самой правой позиции соответствует 100\n});`</script></code-example><p>Метод <code>setValue</code> устанавливает значение:</p><code-example><script>`slider.setValue(50);`</script></code-example><p>У слайдера должно быть два события: <code>slide</code> при каждом передвижении и <code>change</code> при отпускании мыши (установке значения).</p><p>Пример использования:</p><code-example><script>`var sliderElem = document.getElementById('slider');\n\nsliderElem.addEventListener('slide', function(event) {\n  document.getElementById('slide').innerHTML = event.detail;\n});\n\nsliderElem.addEventListener('change', function(event) {\n  document.getElementById('change').innerHTML = event.detail;\n});`</script></code-example><p>В действии:</p><figure- style="height: 80px;"><code-toolbar-><a title="reset" href="/"></a><a id="answer_4" style="display:none" data-code_edit=""></a><a id="task_4" title="открыть в песочнице" data-code_edit="?"></a></code-toolbar-><style> slider-1{display:block;margin:15px;width:310px;height:15px;border-radius:5px;background:#e0e0e0;background:linear-gradient(to right,#e0e0e0,#eee)}thumb-1{display:block;position:relative;top:-5px;left:0;width:10px;height:25px;border-radius:3px;background:#00f;cursor:pointer}</style><slider-1><thumb-1></thumb-1></slider-1><div>&nbsp; Slide: <b id="slide">&nbsp;</b> Change: <b id="change">&nbsp;</b>&nbsp;<button onclick="slider.setValue(50)">slider.setValue(50)</button></div><script>function Slider(options){var elem=options.elem;var thumbElem=elem.querySelector('thumb-1');var max=options.max||100;var sliderCoords,thumbCoords,shiftX,shiftY;var pixelsPerValue=(elem.clientWidth-thumbElem.clientWidth)/max;elem.ondragstart=function(){return false;};elem.onmousedown=function(event){if (event.target.closest('thumb-1')){startDrag(event.clientX,event.clientY);return false;/* disable selection start (cursor change) */}} function startDrag(startClientX,startClientY){thumbCoords=thumbElem.getBoundingClientRect();shiftX=startClientX-thumbCoords.left;shiftY=startClientY-thumbCoords.top;sliderCoords=elem.getBoundingClientRect();document.addEventListener('mousemove',onDocumentMouseMove);document.addEventListener('mouseup',onDocumentMouseUp);}function moveTo(clientX){/* вычесть координату родителя,т.к. position:relative */ var newLeft=clientX-shiftX-sliderCoords.left;if (newLeft<0){/* курсор ушёл вне слайдера */ newLeft=0;}var rightEdge=elem.offsetWidth-thumbElem.offsetWidth;if (newLeft>rightEdge){newLeft=rightEdge;}thumbElem.style.left=newLeft+'px';elem.dispatchEvent(new CustomEvent('slide',{bubbles:true,detail:positionToValue(newLeft)}));}function valueToPosition(value){return pixelsPerValue * value;}function positionToValue(left){return Math.round(left/pixelsPerValue);}function onDocumentMouseMove(e){moveTo(e.clientX);}function onDocumentMouseUp(){endDrag();}function endDrag(){document.removeEventListener('mousemove',onDocumentMouseMove);document.removeEventListener('mouseup',onDocumentMouseUp);elem.dispatchEvent(new CustomEvent('change',{bubbles:true,detail:positionToValue(parseInt(thumbElem.style.left))}));}function setValue(value){thumbElem.style.left=valueToPosition(value)+'px';}this.setValue=setValue;}var sliderElem=document.querySelector('slider-1');var slider=new Slider({elem:sliderElem,max:100});sliderElem.addEventListener('slide',function(event){document.getElementById('slide').innerHTML=event.detail;});sliderElem.addEventListener('change',function(event){document.getElementById('change').innerHTML=event.detail;});</script></figure-><ul><li>Ширина/высота слайдера может быть любой, JS-код это должен учитывать.</li><li>Центр бегунка должен располагаться в точности над выбранным значением. Например, он должен быть в центре для 50 при <code>max=100</code>.</li></ul><p>Исходный документ – возьмите решение задачи <a data-load_page="147-2">Слайдер-компонент</a>.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Для решения этой задачи достаточно создать две функции: <code>valueToPosition</code> будет получать по значению положение бегунка, а <code>positionToValue</code> – наоборот, транслировать текущую координату бегунка в значение.</p><p>Как сопоставить позицию слайдера и значение?</p><p>Для этого посмотрим крайние значения слайдера. Допустим, размер бегунка <code>10px</code>.</p><p>Раз центр соответствует значению, то крайнее левое значение будет соответствовать центру на <code>5px</code>, а крайнее правой – центру на <code>5px</code> от правой границы:</p><figure><img src="slider.png" alt="" width="100%" style="max-width:567px"></figure><p>Соответственно, ширина области изменения будет <code>sliderElem.clientWidth - thumbElem.clientWidth</code>. Далее её можно уже поделить на части, количество пикселей на значение будет:</p><code-example><script>`pixelsPerValue = (sliderElem.clientWidth - thumbElem.clientWidth) / max;`</script></code-example><p>Может получиться так, что это значение будет дробным, меньше единицы. Например, если <code>max = 1000</code>, а ширина слайдера <code>110</code> (пробег 100), то будет <code>0.1</code> пикселя на значение.</p><p>Используя <code>pixelsPerValue</code> мы сможем переводить позицию бегунка в значение и обратно.</p><p>Крайнее левое значение <code>thumbElem.style.left</code> равно нулю, крайнее правой – как раз ширине доступной области <code>sliderElem.clientWidth - thumbElem.clientWidth</code>. Поэтому можно получить значение слайдера, поделив его на <code>pixelsPerValue</code>:</p><code-example><script>`function positionToValue(left) {\n  return Math.round(left / pixelsPerValue);\n}\n\nfunction valueToPosition(value) {\n  return pixelsPerValue * value;\n}`</script></code-example><p><a data-click="answer_4">Открыть решение в песочнице.</a></p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Шаблонизатор LoDash; Что изучать дальше"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/custom-events",disqus_identifier="custom-events",disqus_title="\u041a\u043e\u043b\u043b\u0431\u044d\u043a\u0438 \u0438 \u0441\u043e\u0431\u044b\u0442\u0438\u044f \u043d\u0430 \u043a\u043e\u043c\u043f\u043e\u043d\u0435\u043d\u0442\u0430\u0445";</script></page-content></main>