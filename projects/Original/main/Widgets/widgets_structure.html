<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="145">Создание графических компонентов</a></nav-up><h1>Графические компоненты</h1><p>Первый и главный шаг в наведении порядка – это оформить код в объекты, каждый из которых будет решать свою задачу.</p><p>Здесь мы сосредоточимся на графических компонентах, которые также называют «виджетами».</p><p>В браузерах есть встроенные виджеты, например <code>&lt;select&gt;</code>, <code>&lt;input&gt;</code> и другие элементы, о которых мы даже и не думаем, «как они работают». Они «просто работают»: показывают значение, вызывают события…</p><p>Наша задача – сделать то же самое на уровне выше. Мы будем создавать объекты, которые генерируют меню, диалог или другие компоненты интерфейса, и дают возможность удобно работать с ними.</p><h2><a name="0" href="#0">Виджет Menu</a></h2><p>Мы начнём работу с виджета, который предусматривает уже готовую разметку.</p><p>То есть, в нужном месте HTML находится DOM-структура для меню – заголовок и список опций:</p><code-example><script>`<div class="menu" id="sweets-menu">\n  <span class="title">Сладости</span>\n  <ul>\n    <li>Торт</li>\n    <li>Пончик</li>\n    <li>...</li>\n  </ul>\n</div>`</script></code-example><p>Далее она может дополняться, изменяться, но в начале – она такая.</p><p>Обратим внимание на важные соглашения виджета:</p><dl><dt>Вся разметка заключена в корневой элемент <code>&lt;div class="menu" id="sweets-menu"&gt;</code>.</dt><dd><p>Это очень удобно: вынул этот элемент из DOM – нет меню, вставил в другое место – переместил меню. Кроме того, можно удобно искать подэлементы.</p></dd><dt>Внутри корневого элемента – только классы, не <code>id</code>.</dt><dd><p>Документ вполне может содержать много различных меню. Они не должны конфликтовать между собой, поэтому для разметки везде используются классы.</p><p>Исключение – корневой элемент. В данном случае мы предполагаем, что данное конкретное «меню сладостей» в документе только одно, поэтому даём ему <code>id</code>.</p></dd></dl><h2><a name="1" href="#1">Класс виджета</a></h2><p>Для работы с разметкой будем создавать объект <code>new Menu</code> и передавать ему корневой элемент. В конструкторе он поставит необходимые обработчики:</p><code-example><script>`function Menu(options) {\n  var elem = options.elem;\n\n  elem.onmousedown = function() {\n    return false;\n  }\n\n  elem.onclick = function(event) {\n    if (event.target.closest('.title')) {\n      elem.classList.toggle('open');\n    }\n  };\n\n}\n\n// использование\nvar menu = new Menu({\n  elem: document.getElementById('sweets-menu')\n});`</script></code-example><p>Меню:</p><code-tabs data-code_switch=""><tools-><button-0 class="current">index.html</button-0><button-1>menu.js</button-1><button-2>style.css</button-2></tools-><code-example style="display: block;"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <style>\n    GOLD_menu- ul_GOLD {\n      display: none;\n      margin: 0;\n    }\n    \n    GOLD_menu- .title_GOLD {\n      font-weight: bold;\n      cursor: pointer;\n    }\n    \n    GOLD_menu- .title:before_GOLD {\n      content: '▶';\n      padding-right: 6px;\n      color: green;\n    }\n    \n    GOLD_menu-.open ul_GOLD {\n      display: block;\n    }\n    \n    GOLD_menu-.open .title:before_GOLD {\n      content: '▼';\n    }\n  </style>\n  \n  <script>\n    function Menu(options) {\n      var elem = options.elem;\n    \n      elem.onmousedown = function() {\n        return false;\n      }\n      elem.onclick = function(event) {\n        if (event.target.closest('.title')) {\n          elem.classList.toggle('open');\n        }\n      };\n    }\n  <\/script>\n</head>\n\n<body style="margin:20px">\n\n  <RED_menu-_RED id="sweets-menu">\n    <span class="title">Сладости</span>\n    <ul>\n      <li>Торт</li>\n      <li>Пончик</li>\n      <li>Пирожное</li>\n      <li>Шоколадка</li>\n      <li>Мороженое</li>\n    </ul>\n  </RED_menu-_RED>\n\n  <script>\n    var menu = new Menu({\n      elem: document.getElementById('sweets-menu')\n    });\n  <\/script>\n\n</body>\n</html>`</script><code-toolbar- iframe="190"><a title="показать" data-code_run="0"></a><a title="открыть в новом окне" data-new_window="code"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><code-example><script>`function Menu(options) {\n  var elem = options.elem;\n\n  elem.onmousedown = function() {\n    return false;\n  }\n\n  elem.onclick = function(event) {\n    if (event.target.closest('.title')) {\n      elem.classList.toggle('open');\n    }\n  };\n\n}`</script></code-example><code-example><script>`GOLD_menu- ul_GOLD {\n  display: none;\n  margin: 0;\n}\n\nGOLD_menu- .title_GOLD {\n  font-weight: bold;\n  cursor: pointer;\n}\n\nGOLD_menu- .title:before_GOLD {\n  content: '▶';\n  padding: 0 6px 0 0;\n  color: green;\n}\n\nGOLD_menu-.open ul_GOLD {\n  display: block;\n}\n\nGOLD_menu-.open .title:before_GOLD {\n  content: '▼';\n}`</script></code-example></code-tabs><p>Это, конечно, только первый шаг, но уже здесь видны некоторые важные соглашения в коде.</p><dl><dt>У конструктора только один аргумент – объект <code>options</code>.</dt><dd><p>Это удобно, так как у графических компонентов обычно много настроек, большинство из которых имеют разумные значения «по умолчанию». Если передавать аргументы через запятую – их будет слишком много.</p></dd><dt>Обработчики назначаются через делегирование.</dt><dd><p>Вместо того, чтобы найти элемент и поставить обработчик на него:</p><code-example><script>`var titleElem = elem.querySelector('.title');\n\ntitleElem.onclick = function() {\n  elem.classList.toggle('open');\n}`</script></code-example><p>…Мы ставим обработчик на корневой <code>elem</code> и используем делегирование:</p><code-example><script>`elem.onclick = function(event) {\n  if (event.target.closest('.title')) {\n    elem.classList.toggle('open');\n  }\n};`</script></code-example><p>Это ускоряет инициализацию, так как не надо искать элементы, и даёт возможность в любой момент менять DOM внутри, в том числе через <code>innerHTML</code>, без необходимости переставлять обработчик.</p></dd></dl><p>В этот код лучше добавить дополнительную проверку на то, что найденный <code>.title</code> находится внутри <code>elem</code>:</p><code-example><script>`elem.onclick = function(event) {\n  var closestTitle = event.target.closest('.title');\n  if (closestTitle && elem.contains(closestTitle)) {\n    elem.classList.toggle('open');\n  }\n};`</script></code-example><h2><a name="2" href="#2">Публичные методы</a></h2><p>Уважающий себя компонент обычно имеет публичные методы, которые позволяют управлять им снаружи.</p><p>Рассмотрим повнимательнее этот фрагмент:</p><code-example><script>`if (event.target.closest('.title')) {\n  elem.classList.toggle('open');\n}`</script></code-example><p>Здесь в обработчике события сразу код работы с элементом. Пока одна строка – всё понятно, но если их будет много, то при чтении понадобится долго и упорно вникать: «А что же, всё-таки, такое делается при клике?»</p><p>Для улучшения читаемости выделим обработчик в отдельную функцию <code>toggle</code>, которая к тому же станет полезным публичным методом:</p><code-example><script>`function Menu(options) {\n  var elem = options.elem;\n\n  elem.onmousedown = function() {\n    return false;\n  }\n\n  elem.onclick = function(event) {\n    if (event.target.closest('.title')) {\n      toggle();\n    }\n  };\n\n  function toggle() {\n    elem.classList.toggle('open');\n  }\n\n  this.toggle = toggle;\n}`</script></code-example><p>Теперь метод <code>toggle</code> можно использовать и снаружи:</p><code-example><script>`var menu = new Menu(...);\nmenu.toggle();`</script></code-example><h2><a name="3" href="#3">Генерация DOM-элемента</a></h2><p>До этого момента меню «оживляло» уже существующий HTML.</p><p>Но далеко не всегда в HTML уже есть готовая разметка. В сложных интерфейсах намного чаще её нет, а есть данные, на основе которых компонент генерирует разметку.</p><p>В случае меню, данные – это набор пунктов меню, которые передаются конструктору.</p><p>Для генерации DOM добавим меню три метода:</p><ul><li><code>render()</code> – генерирует корневой DOM-элемент и заголовок меню.</li><li><code>renderOpen()</code> – генерирует DOM для списка опций <code>ul/li</code>.</li><li><code>renderClose()</code> – генерирует DOM для закрытого меню.</li><li><code>getElem()</code> – возвращает DOM-элемент меню, при необходимости запуская генерацию, публичный метод.</li></ul><p>Функция генерации корневого элемента с заголовком <code>render</code> отделена от генерации списка <code>renderItems</code>. Почему – будет видно чуть далее.</p><p>Новый способ использования меню:</p><code-example><script>`MARK// создать объект меню с данным заголовком и опциями\nvar menu = new Menu({\n  title: "Сладости",\n  items: [\n    "Торт",\n    "Пончик",\n    "Пирожное",\n    "Шоколадка",\n    "Мороженое"\n  ]\n});\n\nMARK// получить сгенерированный DOM-элемент меню\nvar elem = menu.getElem();\n\nMARK// вставить меню в нужное место страницы\ndocument.body.appendChild(elem);`</script></code-example><p>В действии:</p><code-tabs data-code_switch=""><tools-><button-0 class="current">index.html</button-0><button-1>menu.js</button-1><button-2>style.css</button-2></tools-><code-example style="display: block;"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <style>\n    GOLD_title-close, title-open_GOLD {\n      font-weight: bold;\n      cursor: pointer;\n    }\n    \n    GOLD_title-close:before_GOLD {\n      content: '▶';\n      color: green;\n    }\n    \n    GOLD_title-open:before_GOLD {\n      content: '▼';\n      color: green;\n    }    \n  </style>\n  \n  <script>\n    function Menu(options) {\n      var menu, isOpen;\n    \n      function getElem() {\n        if (!menu) render();\n        return menu;\n      }\n    \n      function render() {\n        menu = document.createElement('div');\n        renderClose();\n        menu.onmousedown = function() {\n          return false;\n        };\n        menu.onclick = toggle;\n      }\n      \n      function toggle(){\n        isOpen = !isOpen;\n        if (isOpen) renderOpen();\n        else renderClose();\n      }\n      \n      function renderClose(){\n        isOpen = false;\n        var titleElem = document.createElement('title-close');\n        titleElem.textContent = options.title;\n        menu.innerHTML = titleElem.outerHTML;\n      }\n    \n      function renderOpen() {\n        isOpen = true;\n        var titleElem = document.createElement('title-open');\n        titleElem.textContent = options.title;     \n        var items = options.items || [];\n        var list = document.createElement('ul');\n        list.style.margin = '0';\n        items.forEach(function(item) {\n          var li = document.createElement('li');\n          li.textContent = item;\n          list.appendChild(li);\n        });\n        menu.innerHTML = '';\n        menu.appendChild(titleElem);\n        menu.appendChild(list);\n      }\n    \n      this.getElem = getElem;\n      this.toggle = toggle;\n      this.close = renderClose;\n      this.open = renderOpen;\n    }\n  <\/script>\n</head>\n\n<body style="margin:20px">\n\n  <button onclick="menu.toggle()">menu.toggle()</button>\n  <button onclick="menu.open()">menu.open()</button>\n  <button onclick="menu.close()">menu.close()</button>\n\n  <script>\n    var menu = new Menu({\n      title: " Сладости",\n      items: [\n        "Торт",\n        "Пончик",\n        "Пирожное",\n        "Шоколадка",\n        "Мороженое"\n      ]\n    });\n    document.body.appendChild(menu.getElem());\n    \n  <\/script>\n</body>\n</html>`</script><code-toolbar- iframe="190"><a title="показать" data-code_run="0"></a><a title="открыть в новом окне" data-new_window="code"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><code-example><script>`function Menu(options) {\n  var menu, isOpen;\n\n  function getElem() {\n    if (!menu) render();\n    return menu;\n  }\n\n  function render() {\n    menu = document.createElement('div');\n    renderClose();\n    menu.onmousedown = function() {\n      return false;\n    };\n    menu.onclick = toggle;\n  }\n  \n  function toggle(){\n    isOpen = !isOpen;\n    if (isOpen) renderOpen();\n    else renderClose();\n  }\n  \n  function renderClose(){\n    isOpen = false;\n    var titleElem = document.createElement('title-close');\n    titleElem.textContent = options.title;\n    menu.innerHTML = titleElem.outerHTML;\n  }\n\n  function renderOpen() {\n    isOpen = true;\n    var titleElem = document.createElement('title-open');\n    titleElem.textContent = options.title;     \n    var items = options.items || [];\n    var list = document.createElement('ul');\n    list.style.margin = '0';\n    items.forEach(function(item) {\n      var li = document.createElement('li');\n      li.textContent = item;\n      list.appendChild(li);\n    });\n    menu.innerHTML = '';\n    menu.appendChild(titleElem);\n    menu.appendChild(list);\n  }\n\n  this.getElem = getElem;\n  this.toggle = toggle;\n  this.close = renderClose;\n  this.open = renderOpen;\n}`</script></code-example><code-example><script>`<style>\n  GOLD_title-close, title-open_GOLD {\n    font-weight: bold;\n    cursor: pointer;\n  }\n  \n  GOLD_title-close:before_GOLD {\n    content: '▶';\n    color: green;\n  }\n  \n  GOLD_title-open:before_GOLD {\n    content: '▼';\n    color: green;\n  }    \n</style>`</script></code-example></code-tabs><p>Отметим некоторые особенности этого кода.</p><dl><dt>Обработчики отделяются от реальных действий.</dt><dd><p>В обработчике <code>onclick</code> мы «ловим» событие и выясняем, что именно произошло. Возможно, нужно проверить <code>event.target</code>, координаты, клавиши-модификаторы, и т.п. Это всё можно делать здесь же.</p><p>Выяснив, что нужно сделать, обработчик <code>onclick</code> не делает это сам, а вызывает для этого соответствующий метод. Этот метод уже не знает ничего о событии, он просто делает что-то с виджетом. Его можно вызвать и отдельно, не из обработчика.</p><p>Здесь есть ряд важных плюсов:</p></dd></dl><ul><li>Обработчик <code>onclick</code> не «распухает» чрезмерно.</li><li>Код гораздо лучше читается.</li><li>Метод можно повторно использовать, в том числе и сделать публичным, как в коде выше.</li></ul><dl><dt>Генерация DOM, по возможности, должна быть «ленивой».</dt><dd><p>Мы стараемся откладывать работу до момента, когда она реально нужна. Например, когда <code>new Menu</code> создаётся, то переменная <code>elem</code> лишь объявляется. DOM-дерево будет сгенерировано только при вызове <code>getElem()</code> функцией <code>render()</code>.</p><p>Более того! Пока меню закрыто – достаточно заголовка. Кроме того, возможно, посетитель вообще никогда не раскроет это меню, так зачем генерировать список раньше времени? А при первом открытии <code>open()</code> вызовет функцию <code>renderItems()</code>, которая специально для этого выделена отдельно от <code>render()</code>.</p><p><strong>Фаза инициализации очень чувствительна к производительности, так как обычно в сложном интерфейсе создаётся много всего.</strong></p><p>Если изначально подходить к оптимизации на этой фазе «спустя рукава», то потом поправить долгий старт может быть сложно. Тем более, что инициализация – это фундамент, начало работы виджета, её оптимизация в будущем может потребовать сильных изменений кода.</p><p>Конечно, здесь, как и везде в оптимизации – без фанатизма. Бывают ситуации, когда гораздо удобнее что-то сделать сразу. Если это один элемент, то оптимизация здесь ни к чему. А если большой фрагмент DOM, который, как в случае с меню, прямо сейчас не нужен – то лучше отложить.</p></dd></dl><h2><a name="4" href="#4">Итого</a></h2><p>Мы начали создавать компонент «с чистого листа», пока без дополнительных библиотек.</p><p>Основные принципы:</p><ul><li>Виджет – это объект, который либо контролирует готовое дерево DOM, либо создаёт своё.</li><li>В конструктор виджета передаётся объект аргументов <code>options</code>.</li><li>Виджет при необходимости создаёт элемент или «оживляет» готовый. Внутри в разметке не используются <code>id</code>.</li><li>Обработчики назначаются через делегирование – для производительности и упрощения виджета.</li><li>Обработчики событий вызывают соответствующий метод, не пытаются делать всё сами.</li><li>При инициализации, если существенный участок работы можно отложить до реального задействования виджета – откладываем его.</li></ul><h2 id="tasks"><a href="#5" name="5">Задачи (6)</a></h2><task-content><h3><a href="#7" name="7">Часики</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Создайте компонент «Часы» (Clock).</p><p>Интерфейс:</p><code-example><script>`var clock = new Clock({\n  elem: элемент\n});\n\nclock.start(); // старт\nclock.stop(); // стоп`</script></code-example><p>Остальные методы, если нужны, должны быть приватными.</p><p>При нажатии на <code>alert</code> часы должны приостанавливаться, а затем продолжать идти с правильным временем.</p><p>Пример результата:</p><code-result><iframe id="frame_1" style="height:80px" src="iframe.html"></iframe></code-result><script>setTimeout(() =>{run_1.click();frame_1.src=frame_1.getAttribute('src');},100);</script><p><a data-click="task_1">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Решение</p><code-example><script>`<style>\n  GOLD_clock-_GOLD {\n    display: flex;\n    margin: 0 auto;\n  }\n\n  GOLD_hour-_GOLD {\n    color: red;\n  }\n\n  GOLD_min-_GOLD {\n    color: green;\n  }\n\n  GOLD_sec-_GOLD {\n    color: #00f;\n  }\n</style>\n\n<RED_clock-_RED>\n  <RED_hour-_RED>00</RED_hour-_RED>:\n  <RED_min-_RED>00</RED_min-_RED>:\n  <RED_sec-_RED>00</RED_sec-_RED>\n</RED_clock-_RED>\n\n<input type="button" onclick="pageClock.start()" value="Старт">\n<input type="button" onclick="pageClock.stop()" value="Стоп">\n\n<input type="button" onclick="alert('Часы должны останавливаться во время alert,\\nи продолжать корректно работать после нажатия на ОК')" value="alert для проверки корректного возобновления">\n\n<script>\n  var pageClock = new Clock({\n    elem: document.querySelector('clock-')\n  });\n  \n  function Clock(options) {\n    var elem = options.elem;\n    var timer;\n  \n    function render() {\n      var date = new Date();\n      var hours = date.getHours();\n      if (hours < 10) hours = '0' + hours;\n      elem.querySelector('hour-').innerHTML = hours;\n  \n      var min = date.getMinutes();\n      if (min < 10) min = '0' + min;\n      elem.querySelector('min-').innerHTML = min;\n  \n      var sec = date.getSeconds();\n      if (sec < 10) sec = '0' + sec;\n      elem.querySelector('sec-').innerHTML = sec;\n    }\n  \n    this.stop = function() {\n      clearInterval(timer);\n    };\n    this.start = function() {\n      render();\n      timer = setInterval(render, 1000);\n    };\n  }\n<\/script>`</script><code-toolbar iframe="630"><a id="run_1" title="показать" data-code_run="0"></a><a id="task_1" data-code_edit="?" style="display:none"></a><a id="answer_1" title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p><a data-click="answer_1">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#8" name="8">Слайдер-компонент</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Перепишите слайдер в виде компонента:</p><iframe- style="height:110px" src="slider.html" changeable=""><script> function on(){document.querySelectorAll('slider-').forEach((slider) =>{new Slider({elem:slider});});function Slider(options){var slider=options.elem;let thumbCoords,shiftX,shiftY,newLeft,rightEdge,temp;slider.innerHTML='';slider.thumb=document.createElement('thumb-');temp=slider.attributes;if (temp[0]){slider.thumb.style.background=temp[0].name;}slider.appendChild(slider.thumb);slider.onmousedown=function(event){if (event.target.closest('thumb-')){startDrag(this,slider.thumb,event);return false;/* disable selection start (cursor change) */}} function startDrag(slider,thumbElem,e){slider.left=slider.getBoundingClientRect().left;shiftX=e.clientX-thumbElem.getBoundingClientRect().left;document.addEventListener('mousemove',moveTo);document.addEventListener('mouseup',endDrag);function moveTo(e){newLeft=e.clientX-shiftX-slider.left;/* вычесть координату родителя,т.к. position:relative */ if (newLeft<0){/* курсор ушёл вне слайдера */ newLeft=0;}rightEdge=slider.offsetWidth-thumbElem.offsetWidth;if (newLeft>rightEdge){newLeft=rightEdge;}thumbElem.style.left=Math.round(newLeft)+'px';}function endDrag(){document.removeEventListener('mousemove',moveTo);document.removeEventListener('mouseup',endDrag);}}}}</script><code-toolbar-><a id="task_2" data-code_edit="?" style="display:none"></a><a id="answer_2" data-code_edit="" style="display:none"></a></code-toolbar-></iframe-><p>Исходный документ возьмите из решения задачи <a data-load_page="132-1">Слайдер</a>.</p><p><a data-click="task_2">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p><a data-click="answer_2">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#9" name="9">Компонент: список с выделением</a><task-open hover-style="" data-show_task="" title="Закрыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Перепишите решение задачи <a data-load_page="129-1">Список с выделением</a> в виде компонента.</p><p>У компонента должен быть единственный публичный метод <code>getSelected()</code>, который возвращает выбранные значения в виде массива.</p><p>Использование:</p><code-example><script>`var listSelect = new ListSelect({\n  elem: document.querySelector('ul')\n});\n// listSelect.getSelected()`</script></code-example><p>Демо:</p><figure- style="height:250px;padding: 10px;"><style> .selected{background:#0f0}li{cursor:pointer}</style>Клик на элементе выделяет только его.<br><code>Ctrl(Cmd)+Клик</code> добавляет/убирает элемент из выделенных.<br><code>Shift+Клик</code> добавляет промежуток от последнего кликнутого к выделению.<br><ul id="ul"><li>Кристофер Робин </li><li>Винни-Пух </li><li>Ослик Иа </li><li>Мудрая Сова </li><li>Кролик. Просто кролик.</li></ul><button onclick="alert(listSelect.getSelected())">listSelect.getSelected()</button><script> var listSelect=new ListSelect({elem:document.querySelector('#ul')});function ListSelect(options){var elem=options.elem;var lastClickedLi=null;elem.onmousedown=function(){return false;};elem.onclick=function(e){var li=e.target.closest('li');if (!li) return;if (e.metaKey||e.ctrlKey){/* для Mac проверяем Cmd,т.к. Ctrl+click там контекстное меню */ toggleSelect(li);}else if (e.shiftKey){selectFromLast(li);}else{selectSingle(li);}lastClickedLi=li;}function deselectAll(){[].forEach.call(elem.children,function(child){child.removeAttribute('class')});}function toggleSelect(li){li.classList.toggle('selected');}function selectSingle(li){deselectAll();li.classList.add('selected');}function selectFromLast(target){var startElem=lastClickedLi||elem.children[0];target.classList.add('selected');if (startElem == target){/* клик на том же элементе,что и раньше это особый случай */ return;}var isLastClickedBefore=startElem.compareDocumentPosition(target) & 4;if (isLastClickedBefore){for (var elem=startElem;elem != target;elem=elem.nextElementSibling){elem.classList.add('selected');}} else{for (var elem=startElem;elem != target;elem=elem.previousElementSibling){elem.classList.add('selected');}}}this.deselectAll=deselectAll;this.getSelected=function(){return [].map.call(elem.querySelectorAll('.selected'),function(li){return li.innerHTML;});};}</script><code-toolbar-><a title="reset list" onclick="listSelect.deselectAll()"></a><a id="answer_3" onclick="listSelect.deselectAll()" style="display:none" title="открыть в песочнице" data-code_edit=""></a><a id="task_3" onclick="listSelect.deselectAll()" title="открыть в песочнице" data-code_edit="?"></a></code-toolbar-></figure-><p><a data-click="task_3">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer style=""><close- title="закрыть" data-close_answer=""></close-><p><a data-click="answer_3">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#10" name="10">Голосовалка</a><task-open hover-style="" data-show_task="" title="Закрыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Напишите функцию-конструктор <code>new Voter(options)</code> для голосовалки.Она должна получать элемент в <code>options.elem</code>, в следующей разметке:</p><code-example><script>`<div id="voter">\n  <RED_down-_RED> - </RED_down-_RED>\n  <RED_vote-_RED>0</RED_vote-_RED>\n  <RED_up-_RED> + </RED_up-_RED>\n</div>`</script></code-example><p>По клику на <code>+</code> и <code>—</code> число должно увеличиваться или уменьшаться.</p><p>Публичный метод <code>voter.setVote(vote)</code> должен устанавливать текущее число – значение голоса.</p><p>Все остальные методы и свойства пусть будут приватными.</p><p>Результат:</p><figure- style="height:60px"><code-toolbar-><a id="answer_4" style="display:none" title="открыть в песочнице" data-code_edit=""></a><a title="открыть в песочнице" data-code_edit="?"></a></code-toolbar-><style> #voter{font-family:Consolas,"Lucida Console",monospace;font-size:18px;margin:20px;}up-,down-{cursor:pointer;color:blue;font-weight:bold;}</style><div id="voter"><down->— </down-><vote->1</vote-><up-> +</up-></div><script> function Voter(options){var elem=options.elem;var voteElem=elem.querySelector('vote-');elem.onclick=function(event){/* сам обработчик не меняет голос,он вызывает функцию */ if (event.target.closest('down-')){voteDecrease();}else if (event.target.closest('up-')){voteIncrease();}} elem.onmousedown=function(){return false;};function voteDecrease(){voteElem.innerHTML=+voteElem.innerHTML-1;}function voteIncrease(){voteElem.innerHTML=+voteElem.innerHTML+1;}this.setVote=function(vote){voteElem.innerHTML=+vote;};}var voter=new Voter({elem:document.getElementById('voter')});voter.setVote(1);</script></figure-><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p><a data-click="answer_4">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#11" name="11">Голосовалка в прототипном стиле ООП</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Поменяйте стиль ООП в голосовалке, созданной в задаче <a href="#10">Голосовалка</a> на прототипный.</p><p>Внешний код, использующий класс <code>Voter</code>, не должен измениться.</p><p>В качестве исходного кода возьмите решение задачи <a data-load_page="147-4">Голосовалка</a>.</p><figure- style="height:60px"><code-toolbar-><a id="answer_5" style="display:none" title="открыть в песочнице" data-code_edit=""></a><a title="открыть в песочнице" data-code_edit="?"></a></code-toolbar-><style> #voter_1{font-family:Consolas,"Lucida Console",monospace;font-size:18px;margin:20px;}up-,down-{cursor:pointer;color:blue;font-weight:bold;}</style><div id="voter_1"><down->— </down-><vote->0</vote-><up-> +</up-></div><script>function Voter(options){var elem=this._elem=options.elem;this._voteElem=elem.querySelector('vote-');elem.onmousedown=function(){return false;};elem.onclick=this._onClick.bind(this);}Voter.prototype._onClick=function(event){if (event.target.closest('down-')){this._voteDecrease();}else if (event.target.closest('up-')){this._voteIncrease();}};Voter.prototype._voteIncrease=function(){this._voteElem.innerHTML=+this._voteElem.innerHTML+1;};Voter.prototype._voteDecrease=function(){this._voteElem.innerHTML=+this._voteElem.innerHTML-1;};Voter.prototype.setVote=function(vote){this._voteElem.innerHTML=+vote;};var voter=new Voter({elem:document.getElementById('voter_1')});</script></figure-><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p><a data-click="answer_5">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#12" name="12">Добавить двойной голос в голосовалку</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Создайте функцию-конструктор <code>StepVoter</code>, которая наследует от голосовалки, созданной в задаче <a data-load_page="147-5">Голосовалка в прототипном стиле ООП</a> и добавляет голосовалке опцию <code>options.step</code>, которая задаёт «шаг» голоса.</p><p>Пример:</p><code-example><script>`var voter = new StepVoter({\n  elem: document.getElementById('voter'),\n  step: 2 // увеличивать/уменьшать сразу на 2 пункта\n});`</script></code-example><p>Результат:</p><figure- style="height:60px"><code-toolbar-><a id="answer_6" style="display:none" title="открыть в песочнице" data-code_edit=""></a><a title="открыть в песочнице" data-code_edit="?"></a></code-toolbar-><style> #voter_2{font-family:Consolas,"Lucida Console",monospace;font-size:18px;margin:20px;}up-,down-{cursor:pointer;color:blue;font-weight:bold;}</style><div id="voter_2"><down->— </down-><vote->0</vote-><up-> +</up-></div><script>function Voter(options){var elem=this._elem=options.elem;this._voteElem=elem.querySelector('vote-');elem.onmousedown=function(){return false;};elem.onclick=this._onClick.bind(this);}Voter.prototype._onClick=function(event){if (event.target.closest('down-')){this._voteDecrease();}else if (event.target.closest('up-')){this._voteIncrease();}};Voter.prototype._voteIncrease=function(){this._voteElem.innerHTML=+this._voteElem.innerHTML+1;};Voter.prototype._voteDecrease=function(){this._voteElem.innerHTML=+this._voteElem.innerHTML-1;};Voter.prototype.setVote=function(vote){this._voteElem.innerHTML=+vote;};function StepVoter(options){Voter.apply(this,arguments);this._step=options.step||1;}StepVoter.prototype=Object.create(Voter.prototype);StepVoter.prototype._voteIncrease=function(){this._voteElem.innerHTML=+this._voteElem.innerHTML+this._step;};StepVoter.prototype._voteDecrease=function(){this._voteElem.innerHTML=+this._voteElem.innerHTML-this._step;};var voter=new StepVoter({elem:document.getElementById('voter_2'),step:2});</script></figure-><p>В реальном проекте влияние клика на голосовалку может зависеть от полномочий или репутации посетителя.</p><p>В качестве исходного кода используйте решение задачи <a data-load_page="147-5">Голосовалка в прототипном стиле ООП</a>.</p><p>P.S. Код <code>voter.js</code> изменять нельзя, нужно не переписать <code>Voter</code>, а отнаследовать от него.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p><a data-click="answer_6">Открыть решение в песочнице.</a></p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Введение; Вёрстка графических компонентов"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/widgets-structure",disqus_identifier="widgets-structure",disqus_title="\u0413\u0440\u0430\u0444\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u043a\u043e\u043c\u043f\u043e\u043d\u0435\u043d\u0442\u044b";</script></page-content></main>