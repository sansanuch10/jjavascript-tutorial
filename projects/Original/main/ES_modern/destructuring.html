<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="83">Современные возможности ES-2015</a></nav-up><h1>Деструктуризация</h1><p><em>Деструктуризация</em> (destructuring assignment) – это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части.</p><h2><a name="0" href="#0">Массив</a></h2><p>Пример деструктуризации массива:</p><code-example><script>`'use strict';\n\nlet [firstName, lastName] = ["Илья", "Кантор"];\n\nalert(firstName); // Илья\nalert(lastName);  // Кантор`</script><code-toolbar></code-toolbar></code-example><p>При таком присвоении первое значение массива пойдёт в переменную <code>firstName</code>, второе – в <code>lastName</code>, а последующие (если есть) – будут отброшены.</p><p>Ненужные элементы массива также можно отбросить, поставив лишнюю запятую:</p><code-example><script>`'use strict';\n\nMARK// первый и второй элементы не нужны\nMARKlet [, , title] = "Юлий Цезарь Император Рима".split(" ");\n\nalert(title); // Император`</script><code-toolbar></code-toolbar></code-example><p>В коде выше первый и второй элементы массива никуда не записались, они были отброшены. Как, впрочем, и все элементы после третьего.</p><h3><a name="6" href="#6">Оператор «spread»</a></h3><p>Если мы хотим получить и последующие значения массива, но не уверены в их числе – можно добавить ещё один параметр, который получит «всё остальное», при помощи оператора <code>"..."</code> («spread», троеточие):</p><code-example><script>`'use strict';\n\nMARKlet [firstName, lastName, ...rest] = "Юлий Цезарь Император Рима".split(" ");\n\nalert(firstName); // Юлий\nalert(lastName);  // Цезарь\nalert(rest);      // Император,Рима (массив из 2х элементов)`</script><code-toolbar></code-toolbar></code-example><p>Значением <code>rest</code> будет массив из оставшихся элементов массива. Вместо <code>rest</code> можно использовать и другое имя переменной, оператор здесь – троеточие. Оно должно стоять только последним элементом в списке слева.</p><h3><a name="7" href="#7">Значения по умолчанию</a></h3><p>Если значений в массиве меньше, чем переменных – ошибки не будет, просто присвоится <code>undefined</code>:</p><code-example><script>`'use strict';\n\nMARKlet [firstName, lastName] = [];\n\nalert(firstName); // undefined`</script><code-toolbar></code-toolbar></code-example><p>Впрочем, как правило, в таких случаях задают значение по умолчанию. Для этого нужно после переменной использовать символ <code>=</code> со значением, например:</p><code-example><script>`'use strict';\n\nMARK// значения по умолчанию\nMARKlet [firstName="Гость", lastName="Анонимный"] = [];\n\nalert(firstName); // Гость\nalert(lastName);  // Анонимный`</script><code-toolbar></code-toolbar></code-example><p>В качестве значений по умолчанию можно использовать не только примитивы, но и выражения, даже включающие в себя вызовы функций:</p><code-example><script>`'use strict';\n\nfunction defaultLastName() {\n  return Date.now() + '-visitor';\n}\n\nMARK// lastName получит значение, соответствующее текущей дате:\nMARKlet [firstName, lastName=defaultLastName()] = ["Вася"];\n\nalert(firstName); // Вася\nalert(lastName);  // 1436...-visitor`</script><code-toolbar></code-toolbar></code-example><p>Заметим, что вызов функции <code>defaultLastName()</code> для генерации значения по умолчанию будет осуществлён только при необходимости, то есть если значения нет в массиве.</p><h2><a name="1" href="#1">Деструктуризация объекта</a></h2><p>Деструктуризацию можно использовать и с объектами. При этом мы указываем, какие свойства в какие переменные должны «идти».</p><p>Базовый синтаксис:</p><code-example><script>`let {var1, var2} = {var1: …, var2: …};`</script></code-example><p>Объект справа – уже существующий, который мы хотим разбить на переменные. А слева – список переменных, в которые нужно соответствующие свойства записать.</p><p>Например:</p><code-example><script>`'use strict';\n\nlet options = {\n  title: "Меню",\n  width: 100,\n  height: 200\n};\n\nMARKlet {title, width, height} = options;\n\nalert(title);  // Меню\nalert(width);  // 100\nalert(height); // 200`</script><code-toolbar></code-toolbar></code-example><p>Как видно, свойства <code>options.title</code>, <code>options.width</code> и <code>options.height</code> автоматически присвоились соответствующим переменным.</p><p>Если хочется присвоить свойство объекта в переменную с другим именем, например, чтобы свойство <code>options.width</code> пошло в переменную <code>w</code>, то можно указать соответствие через двоеточие, вот так:</p><code-example><script>`'use strict';\n\nlet options = {\n  title: "Меню",\n  width: 100,\n  height: 200\n};\n\nMARKlet {width: w, height: h, title} = options;\n\nalert(title);  // Меню\nalert(w);      // 100\nalert(h);      // 200`</script><code-toolbar></code-toolbar></code-example><p>В примере выше свойство <code>width</code> отправилось в переменную <code>w</code>, свойство <code>height</code> – в переменную <code>h</code>, а <code>title</code> – в переменную с тем же названием.</p><p>Если каких-то свойств в объекте нет, можно указать значение по умолчанию через знак равенства <code>=</code>, вот так;</p><code-example><script>`'use strict';\n\nlet options = {\n  title: "Меню"\n};\n\nMARKlet {width=100, height=200, title} = options;\n\nalert(title);  // Меню\nalert(width);  // 100\nalert(height); // 200`</script><code-toolbar></code-toolbar></code-example><p>Можно и сочетать одновременно двоеточие и равенство:</p><code-example><script>`'use strict';\n\nlet options = {\n  title: "Меню"\n};\n\nMARKlet {width:w=100, height:h=200, title} = options;\n\nalert(title);  // Меню\nalert(w);      // 100\nalert(h);      // 200`</script><code-toolbar></code-toolbar></code-example><p>А что, если в объекте больше значений, чем переменных? Можно ли куда-то присвоить «остаток», аналогично массивам?</p><p>Такой возможности в текущем стандарте нет. Она планируется в будущем стандарте, и выглядеть она будет примерно так:</p><code-example><script>`'use strict';\n\nlet options = {\n  title: "Меню",\n  width: 100,\n  height: 200\n};\n\nMARKlet {title, ...size} = options;\n\n// title = "Меню"\n// size = { width: 100, height: 200} (остаток)`</script></code-example><p>Этот код будет работать, например, при использовании Babel со включёнными экспериментальными возможностями, но ещё раз заметим, что в текущий стандарт такая возможность не вошла.</p><important-><h3>Деструктуризация без объявления</h3><p>В примерах выше переменные объявлялись прямо перед присваиванием: <code>let {…} = {…}</code>. Конечно, можно и без <code>let</code>, использовать уже существующие переменные.</p><p>Однако, здесь есть небольшой «подвох». В JavaScript, если в основном потоке кода (не внутри другого выражения) встречается <code>{...}</code>, то это воспринимается как блок.</p><p>Например, можно использовать такой блок для ограничения видимости переменных:</p><code-example><script>`'use strict';\n{\n  // вспомогательные переменные, локальные для блока\n  let a = 5;\n  // поработали с ними\n  alert(a); // 5\n  // больше эти переменные не нужны\n}\nalert(a); // ошибка нет такой переменной`</script><code-toolbar></code-toolbar></code-example><p>Конечно, это бывает удобно, но в данном случае это создаст проблему при деструктуризации:</p><code-example><script>`let a, b;\n{a, b} = {a:5, b:6}; // будет ошибка, оно посчитает, что {a,b} - блок`</script></code-example><p>Чтобы избежать интерпретации <code>{a, b}</code> как блока, нужно обернуть всё присваивание в скобки:</p><code-example><script>`let a, b;\n({a, b} = {a:5, b:6}); // внутри выражения это уже не блок`</script></code-example></important-><h2><a name="2" href="#2">Вложенные деструктуризации</a></h2><p>Если объект или массив содержат другие объекты или массивы, и их тоже хочется разбить на переменные – не проблема.</p><p>Деструктуризации можно как угодно сочетать и вкладывать друг в друга.</p><p>В коде ниже <code>options</code> содержит подобъект и подмассив. В деструктуризации ниже сохраняется та же структура:</p><code-example><script>`'use strict';\n\nlet options = {\n  size: {\n    width: 100,\n    height: 200\n  },\n  items: ["Пончик", "Пирожное"]\n}\n\nlet { title="Меню", size: {width, height}, items: [item1, item2] } = options;\n\n// Меню 100 200 Пончик Пирожное\nalert(title);  // Меню\nalert(width);  // 100\nalert(height); // 200\nalert(item1);  // Пончик\nalert(item2);  // Пирожное`</script><code-toolbar></code-toolbar></code-example><p>Как видно, весь объект <code>options</code> корректно разбит на переменные.</p><h2><a name="3" href="#3">Итого</a></h2><ul><li><p>Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.</p></li><li><p>Синтаксис:</p><code-example><script>`let {prop : varName = default, ...} = object`</script></code-example><p>Здесь двоеточие <code>:</code> задаёт отображение свойства <code>prop</code> в переменную <code>varName</code>, а равенство <code>=default</code> задаёт выражение, которое будет использовано, если значение отсутствует (не указано или <code>undefined</code>).</p><p>Для массивов имеет значение порядок, поэтому нельзя использовать <code>:</code>, но значение по умолчанию – можно:</p><code-example><script>`let [var1 = default, var2, ...rest] = array`</script></code-example><p>Объявление переменной в начале конструкции не обязательно. Можно использовать и существующие переменные. Однако при деструктуризации объекта может потребоваться обернуть выражение в скобки.</p></li><li><p>Вложенные объекты и массивы тоже работают, при деструктуризации нужно лишь сохранить ту же структуру, что и исходный объект/массив.</p></li></ul><p>Как мы увидим далее, деструктуризации особенно удобны при чтении объектных параметров функций.</p><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Переменные: let и const; Функции"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/destructuring", disqus_identifier = "destructuring", disqus_title = "\u0414\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0438\u0437\u0430\u0446\u0438\u044f";</script></page-content></main>