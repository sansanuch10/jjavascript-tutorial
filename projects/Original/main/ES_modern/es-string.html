<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="83">Современные возможности ES-2015</a></nav-up><h1>Строки</h1><p>Есть ряд улучшений и новых методов для строк.</p><p>Начнём с, пожалуй, самого важного.</p><h2><a name="0" href="#0">Строки-шаблоны</a></h2><p>Добавлен новый вид кавычек для строк:</p><code-example><script>`let str = \`GREEN_обратные кавычки_GREEN\`;`</script></code-example><p>Основные отличия от двойных <code>"…"</code> и одинарных <code>'…'</code> кавычек:</p><ul><li><p><strong>В них разрешён перевод строки.</strong></p><p>Например:</p><code-example><script>`alert(\`GREEN_моя_GREEN\n  GREEN_многострочная_GREEN\n  GREEN_строка_GREEN\`);`</script><code-toolbar></code-toolbar></code-example><p>Заметим, что пробелы и, собственно, перевод строки также входят в строку, и будут выведены.</p></li><li><p><strong>Можно вставлять выражения при помощи <code>${…}</code>.</strong></p><p>Например:</p><code-example><script>`'use strict';\nlet apples = 2;\nlet oranges = 3;\n\nalert(\`\${apples} + \${oranges} = \${apples + oranges}\`); // 2 + 3 = 5`</script><code-toolbar></code-toolbar></code-example><p>Как видно, при помощи <code>${…}</code> можно вставлять как и значение переменной <code>${apples}</code>, так и более сложные выражения, которые могут включать в себя операторы, вызовы функций и т.п. Такую вставку называют «интерполяцией».</p></li></ul><h2><a name="1" href="#1">Функции шаблонизации</a></h2><p>Можно использовать свою функцию шаблонизации для строк.</p><p>Название этой функции ставится перед первой обратной кавычкой:</p><code-example><script>`let str = func\`GREEN_моя строка_GREEN\`;`</script></code-example><p>Эта функция будет автоматически вызвана и получит в качестве аргументов строку, разбитую по вхождениям параметров <code>${…}</code> и сами эти параметры.</p><p>Например:</p><code-example><script>`'use strict';\n\nfunction f(strings, ...values) {\n  alert(JSON.stringify(strings));     // ["Sum of "," + "," =\\n ","!"]\n  alert(JSON.stringify(strings.raw)); // ["Sum of "," + "," =\\n ","!"]\n  alert(JSON.stringify(values));      // [3,5,8]\n}\n\nlet apples = 3;\nlet oranges = 5;\n\n//          |  s[0] | v[0] |s[1]| v[1]  |s[2]  |      v[2]      |s[3]\nlet str = f\`GREEN_Sum of_GREEN \${apples} + \${oranges} =\\n \${apples + oranges}!\`;`</script><code-toolbar></code-toolbar></code-example><p>В примере выше видно, что строка разбивается по очереди на части: «кусок строки» – «параметр» – «кусок строки» – «параметр».</p><ul><li>Участки строки идут в первый аргумент-массив <code>strings</code>.</li><li>У этого массива есть дополнительное свойство <code>strings.raw</code>. В нём находятся строки в точности как в оригинале. Это влияет на спец-символы, например в <code>strings</code> символ <code>\n</code> – это перевод строки, а в <code>strings.raw</code> – это именно два символа <code>\n</code>.</li><li>Дальнейший список аргументов функции шаблонизации – это значения выражений в <code>${...}</code>, в данном случае их три.</li></ul><important-><h3>Зачем <code>strings.raw</code>?</h3><p>В отличие от <code>strings</code>, в <code>strings.raw</code> содержатся участки строки в «изначально введённом» виде.</p><p>То есть, если в строке находится <code>\n</code> или <code>\u1234</code> или другое особое сочетание символов, то оно таким и останется.</p><p>Это нужно в тех случаях, когда функция шаблонизации хочет произвести обработку полностью самостоятельно (свои спец. символы?). Или же когда обработка спец. символов не нужна – например, строка содержит «обычный текст», набранный непрограммистом без учёта спец. символов.</p></important-><p>Как видно, функция имеет доступ ко всему: к выражениям, к участкам текста и даже, через <code>strings.raw</code> – к оригинально введённому тексту без учёта стандартных спец. символов.</p><p>Функция шаблонизации может как-то преобразовать строку и вернуть новый результат.</p><p>В простейшем случае можно просто «склеить» полученные фрагменты в строку:</p><code-example><script>`'use strict';\n\n// str восстанавливает строку\nfunction str(strings, ...values) {\n  let str = "";\n  for(let i=0; i<values.length; i++) {\n    str += strings[i];\n    str += values[i];\n  }\n\n  // последний кусок строки\n  str += strings[strings.length-1];\n  return str;\n}\n\nlet apples = 3;\nlet oranges = 5;\n\n// Sum of 3 + 5 = 8!\nalert( str\`GREEN_Sum of_GREEN \${apples} + \${oranges} = \${apples + oranges}!\`);`</script><code-toolbar></code-toolbar></code-example><p>Функция <code>str</code> в примере выше делает то же самое, что обычные обратные кавычки. Но, конечно, можно пойти намного дальше. Например, генерировать из HTML-строки DOM-узлы (функции шаблонизации не обязательно возвращать именно строку).</p><p>Или можно реализовать интернационализацию. В примере ниже функция <code>i18n</code> осуществляет перевод строки.</p><p>Она подбирает по строке вида <code>"Hello, ${name}!"</code> шаблон перевода <code>"Привет, {0}!"</code> (где <code>{0}</code> – место для вставки параметра) и возвращает переведённый результат со вставленным именем <code>name</code>:</p><code-example><script>`'use strict';\n\nlet messages = {\n  "Hello, {0}!": "Привет, {0}!"\n};\n\nfunction i18n(strings, ...values) {\n  // По форме строки получим шаблон для поиска в messages\n  // На месте каждого из значений будет его номер: {0}, {1}, …\n  let pattern = "";\n  for(let i=0; i<values.length; i++) {\n    pattern += strings[i] + '{' + i + '}';\n  }\n  pattern += strings[strings.length-1];\n  // Теперь pattern = "Hello, {0}!"\n\n  let translated = messages[pattern]; // "Привет, {0}!"\n\n  // Заменит в "Привет, {0}" цифры вида {num} на values[num]\n  return translated.replace(GOLD_/\\{(\\d)\\}/g_GOLD, (s, num) => values[num]);\n}\n\n// Пример использования\nMARKlet name = "Вася";\nMARK&nbsp\nMARK// Перевести строку\nMARKalert(i18n\`GREEN_Hello_GREEN, \${name}GREEN_!_GREEN\`); // Привет, Вася!`</script><code-toolbar></code-toolbar></code-example><p>Итоговое использование выглядит довольно красиво, не правда ли?</p><p>Разумеется, эту функцию можно улучшить и расширить. Функция шаблонизации – это своего рода «стандартный синтаксический сахар» для упрощения форматирования и парсинга строк.</p><h2><a name="2" href="#2">Улучшена поддержка юникода</a></h2><p>Внутренняя кодировка строк в JavaScript – это UTF-16, то есть под каждый символ отводится ровно два байта.</p><p>Но под всевозможные символы всех языков мира 2 байт не хватает. Поэтому бывает так, что одному символу языка соответствует два юникодных символа (итого 4 байта). Такое сочетание называют «суррогатной парой».</p><p>Самый частый пример суррогатной пары, который можно встретить в литературе – это китайские иероглифы.</p><p>Заметим, однако, что не всякий китайский иероглиф – суррогатная пара. Существенная часть «основного» юникод-диапазона как раз отдана под китайский язык, поэтому некоторые иероглифы – которые в неё «влезли» – представляются одним юникод-символом, а те, которые не поместились (реже используемые) – двумя.</p><p>Например:</p><code-example><script>`alert( '我'.length ); // 1\nalert( '𩷶'.length ); // 2`</script><code-toolbar></code-toolbar></code-example><p>В тексте выше для первого иероглифа есть отдельный юникод-символ, и поэтому длина строки <code>1</code>, а для второго используется суррогатная пара. Соответственно, длина – <code>2</code>.</p><p>Китайскими иероглифами суррогатные пары, естественно, не ограничиваются.</p><p>Ими представлены редкие математические символы, а также некоторые символы для эмоций, к примеру:</p><code-example><script>`alert( '𝒳'.length ); // 2, MATHEMATICAL SCRIPT CAPITAL X\nalert( '😂'.length ); // 2, FACE WITH TEARS OF JOY`</script><code-toolbar></code-toolbar></code-example><p>В современный JavaScript добавлены методы <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint">String.fromCodePoint</a> и <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt">str.codePointAt</a> – аналоги <code>String.fromCharCode</code> и <code>str.charCodeAt</code>, корректно работающие с суррогатными парами.</p><p>Например, <code>charCodeAt</code> считает суррогатную пару двумя разными символами и возвращает код каждой:</p><code-example><script>`// как будто в строке два разных символа (на самом деле один)\nalert( '𝒳'.charCodeAt(0) + '&nbsp' + '𝒳'.charCodeAt(1) ); // 55349 56499`</script><code-toolbar></code-toolbar></code-example><p>…В то время как <code>codePointAt</code> возвращает его Unicode-код суррогатной пары правильно:</p><code-example><script>`// один символ с "длинным" (более 2 байт) unicode-кодом\nalert( '𝒳'.codePointAt(0) ); // 119987`</script><code-toolbar></code-toolbar></code-example><p>Метод <code>String.fromCodePoint(code)</code> корректно создаёт строку из «длинного кода», в отличие от старого <code>String.fromCharCode(code)</code>.</p><p>Например:</p><code-example><script>`// Правильно\nalert( String.fromCodePoint(119987) ); // 𝒳\n// Неверно!\nalert( String.fromCharCode(119987) ); // 풳`</script><code-toolbar></code-toolbar></code-example><p>Более старый метод <code>fromCharCode</code> в последней строке дал неверный результат, так как он берёт только первые два байта от числа <code>119987</code> и создаёт символ из них, а остальные отбрасывает.</p><h3><a name="7" href="#7">\u{длинный код}</a></h3><p>Есть и ещё синтаксическое улучшение для больших Unicode-кодов.</p><p>В JavaScript-строках давно можно вставлять символы по Unicode-коду, вот так:</p><code-example><script>`alert( "\\u2033" ); // ″, символ двойного штриха`</script><code-toolbar></code-toolbar></code-example><p>Синтаксис: <code>\uNNNN</code>, где <code>NNNN</code> – четырёхзначный шестнадцатиричный код, причём он должен быть ровно четырёхзначным.</p><p>«Лишние» цифры уже не войдут в код, например:</p><code-example><script>`alert( "\\u20331" ); // Два символа: символ двойного штриха ″, а затем 1`</script><code-toolbar></code-toolbar></code-example><p>Чтобы вводить более длинные коды символов, добавили запись <code>\u{NNNNNNNN}</code>, где <code>NNNNNNNN</code> – максимально восьмизначный (но можно и меньше цифр) код.</p><p>Например:</p><code-example><script>`alert("\\u{20331}"); // 𠌱, китайский иероглиф с этим кодом`</script><code-toolbar></code-toolbar></code-example><h3><a name="8" href="#8">Unicode-нормализация</a></h3><p>Во многих языках есть символы, которые получаются как сочетание основного символа и какого-то значка над ним или под ним.</p><p>Например, на основе обычного символа <code>a</code> существуют символы: <code>àáâäãåā</code>. Самые часто встречающиеся подобные сочетания имеют отдельный юникодный код. Но отнюдь не все.</p><p>Для генерации произвольных сочетаний используются несколько юникодных символов: основа и один или несколько значков.</p><p>Например, если после символа <code>S</code> идёт символ «точка сверху» (код <code>\u0307</code>), то показано это будет как «S с точкой сверху» <code>Ṡ</code>.</p><p>Если нужен ещё значок над той же буквой (или под ней) – без проблем. Просто добавляем соответствующий символ.</p><p>К примеру, если добавить символ «точка снизу» (код <code>\u0323</code>), то будет «S с двумя точками сверху и снизу» <code>Ṩ</code> .</p><p>Пример этого символа в JavaScript-строке:</p><code-example><script>`alert("S\\u0307\\u0323"); // Ṩ`</script><code-toolbar></code-toolbar></code-example><p>Такая возможность добавить произвольной букве нужные значки, с одной стороны, необходима, а с другой стороны – возникает проблемка: можно представить одинаковый с точки зрения визуального отображения и интерпретации символ – разными сочетаниями Unicode-кодов.</p><p>Вот пример:</p><code-example><script>`alert("S\\u0307\\u0323"); // Ṩ\nalert("S\\u0323\\u0307"); // Ṩ\n\nalert( "S\\u0307\\u0323" == "S\\u0323\\u0307" ); // false`</script><code-toolbar></code-toolbar></code-example><p>В первой строке после основы <code>S</code> идёт сначала значок «верхняя точка», а потом – нижняя, во второй – наоборот. По кодам строки не равны друг другу. Но символ задают один и тот же.</p><p>С целью разрешить эту ситуацию, существует <em>юникодная нормализация</em>, при которой строки приводятся к единому, «нормальному», виду.</p><p>В современном JavaScript это делает метод <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/normalize">str.normalize()</a>.</p><code-example><script>`alert( "S\\u0307\\u0323".normalize() == "S\\u0323\\u0307".normalize() ); // true`</script><code-toolbar></code-toolbar></code-example><p>Забавно, что в данной конкретной ситуации <code>normalize()</code> приведёт последовательность из трёх символов к одному: <a href="http://www.fileformat.info/info/unicode/char/1e68/index.htm">\u1e68 (S с двумя точками)</a>.</p><code-example><script>`alert( "S\\u0307\\u0323".normalize().length ); // 1, нормализовало в один символ\nalert( "S\\u0307\\u0323".normalize() == "\\u1e68" ); // true`</script><code-toolbar></code-toolbar></code-example><p>Это, конечно, не всегда так, просто в данном случае оказалось, что именно такой символ в юникоде уже есть. Если добавить значков, то нормализация уже даст несколько символов.</p><p>Для большинства практических задач информации, данной выше, должно быть вполне достаточно, но если хочется более подробно ознакомиться с вариантами и правилами нормализации – они описаны в приложении к стандарту юникод <a href="http://www.unicode.org/reports/tr15/">Unicode Normalization Forms</a>.</p><h2><a name="3" href="#3">Полезные методы</a></h2><p>Добавлен ряд полезных методов общего назначения:</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes">str.includes(s)</a> – проверяет, включает ли одна строка в себя другую, возвращает <code>true/false</code>.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith">str.endsWith(s)</a> – возвращает <code>true</code>, если строка <code>str</code> заканчивается подстрокой <code>s</code>.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith">str.startsWith(s)</a> – возвращает <code>true</code>, если строка <code>str</code> начинается со строки <code>s</code>.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat">str.repeat(times)</a> – повторяет строку <code>str</code><code>times</code> раз.</li></ul><p>Конечно, всё это можно было сделать при помощи других встроенных методов, но новые методы более удобны.</p><h2><a name="4" href="#4">Итого</a></h2><p>Улучшения:</p><ul><li>Строки-шаблоны – для удобного задания строк (многострочных, с переменными), плюс возможность использовать функцию шаблонизации для самостоятельного форматирования.</li><li>Юникод – улучшена работа с суррогатными парами.</li><li>Полезные методы для проверок вхождения одной строки в другую.</li></ul><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Функции; Объекты и прототипы"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/es-string", disqus_identifier = "es-string", disqus_title = "\u0421\u0442\u0440\u043e\u043a\u0438";</script></page-content></main>