<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="83">Современные возможности ES-2015</a></nav-up><h1>Итераторы</h1><p>В современный JavaScript добавлена новая концепция «итерируемых» (iterable) объектов.</p><p>Итерируемые или, иными словами, «перебираемые» объекты – это те, содержимое которых можно перебрать в цикле.</p><p>Например, перебираемым объектом является массив. Но не только он. В браузере существует множество объектов, которые не являются массивами, но содержимое которых можно перебрать (к примеру, список DOM-узлов).</p><p>Для перебора таких объектов добавлен новый синтаксис цикла: <code>for..of</code>.</p><p>Например:</p><code-example><script>`'use strict';\n\nlet arr = [1, 2, 3]; // массив — пример итерируемого объекта\n\nfor (let value of arr) {\n  alert(value); // 1, затем 2, затем 3\n}`</script><code-toolbar></code-toolbar></code-example><p>Также итерируемой является строка:</p><code-example><script>`'use strict';\n\nfor (let char of "Привет") {\n  alert(char); // Выведет по одной букве: П, р, и, в, е, т\n}`</script><code-toolbar></code-toolbar></code-example><p>Итераторы – расширяющая понятие «массив» концепция, которая пронизывает современный стандарт JavaScript сверху донизу.</p><p>Практически везде, где нужен перебор, он осуществляется через итераторы. Это включает в себя не только строки, массивы, но и вызов функции с оператором spread <code>f(...args)</code>, и многое другое.</p><p>В отличие от массивов, «перебираемые» объекты могут не иметь «длины» <code>length</code>. Как мы увидим далее, итераторы дают возможность сделать «перебираемыми» любые объекты.</p><h2><a name="0" href="#0">Свой итератор</a></h2><p>Допустим, у нас есть некий объект, который надо «умным способом» перебрать.</p><p>Например, <code>range</code> – диапазон чисел от <code>from</code> до <code>to</code>, и мы хотим, чтобы <code>for (let num of range)</code> «перебирал» этот объект. При этом под перебором мы подразумеваем перечисление чисел от <code>from</code> до <code>to</code>.</p><p>Объект <code>range</code> без итератора:</p><code-example><script>`let range = {\n  from: 1,\n  to: 5\n};\n\n// хотим сделать перебор\n// for (let num of range) ...`</script><code-toolbar></code-toolbar></code-example><p>Для возможности использовать объект в <code>for..of</code> нужно создать в нём свойство с названием <code>Symbol.iterator</code> (системный символ).</p><p>При вызове метода <code>Symbol.iterator</code> перебираемый объект должен возвращать другой объект («итератор»), который умеет осуществлять перебор.</p><p>По стандарту у такого объекта должен быть метод <code>next()</code>, который при каждом вызове возвращает очередное значение и проверяет, окончен ли перебор.</p><p>В коде это выглядит следующим образом:</p><code-example><script>`'use strict';\n\nlet range = {\n  from: 1,\n  to: 5\n}\n\n// сделаем объект range итерируемым\nrange[Symbol.iterator] = function() {\n\n  let current = this.from;\n  let last = this.to;\n\n  // метод должен вернуть объект с методом next()\n  return {\n    next() {\n      if (current <= last) {\n        return {\n          done: false,\n          value: current++\n        };\n      } else {\n        return {\n          done: true\n        };\n      }\n    }\n\n  }\n};\n\nfor (let num of range) {\n  alert(num); // 1, затем 2, 3, 4, 5\n}`</script><code-toolbar></code-toolbar></code-example><p>Как видно из кода выше, здесь имеет место разделение сущностей:</p><ul><li>Перебираемый объект <code>range</code> сам не реализует методы для своего перебора.</li><li>Для этого создаётся другой объект, который хранит текущее состояние перебора и возвращает значение. Этот объект называется итератором и возвращается при вызове метода <code>range[Symbol.iterator]</code>.</li><li>У итератора должен быть метод <code>next()</code>, который при каждом вызове возвращает объект со свойствами:<ul><li><code>value</code> – очередное значение,</li><li><code>done</code> – равно <code>false</code> если есть ещё значения, и <code>true</code> – в конце.</li></ul></li></ul><p>Конструкция <code>for..of</code> в начале своего выполнения автоматически вызывает <code>Symbol.iterator()</code>, получает итератор и далее вызывает метод <code>next()</code> до получения <code>done: true</code>. Такова внутренняя механика. Внешний код при переборе через <code>for..of</code> видит только значения.</p><p>Такое отделение функционала перебора от самого объекта даёт дополнительную гибкость. Например, объект может возвращать разные итераторы в зависимости от своего настроения и времени суток. Однако, бывают ситуации когда оно не нужно.</p><p>Если функционал по перебору (метод <code>next</code>) предоставляется самим объектом, то можно вернуть <code>this</code> в качестве итератора:</p><code-example><script>`'use strict';\n\nlet range = {\n  from: 1,\n  to: 5,\n\nMARK  [Symbol.iterator]() {\nMARK    return this;\nMARK  },\n\n  next() {\n    if (this.current === undefined) {\n      // инициализация состояния итерации\n      this.current = this.from;\n    }\n\n    if (this.current <= this.to) {\n      return {\n        done: false,\n        value: this.current++\n      };\n    } else {\n      // очистка текущей итерации\n      delete this.current;\n      return {\n        done: true\n      };\n    }\n  }\n\n};\n\nfor (let num of range) {\n  alert(num); // 1, затем 2, 3, 4, 5\n}\n\n// Произойдёт вызов Math.max(1,2,3,4,5);\nalert( Math.max(...range) ); // 5 (*)`</script><code-toolbar></code-toolbar></code-example><p>При таком подходе сам объект и хранит состояние итерации (текущий перебираемый элемент).</p><p>В данном случае это работает, но для большей гибкости и понятности кода рекомендуется, всё же, выделять итератор в отдельный объект со своим состоянием и кодом.</p><important-><h3>Оператор spread <code>...</code> и итераторы</h3><p>В последней строке <code>(*)</code> примера выше можно видеть, что итерируемый объект передаётся через spread для <code>Math.max</code>.</p><p>При этом <code>...range</code> автоматически превращает итерируемый объект в массив. То есть произойдёт цикл <code>for..of</code> по <code>range</code>, и его результаты будут использованы в качестве списка аргументов.</p></important-><important-><h3>Бесконечные итераторы</h3><p>Возможны и бесконечные итераторы. Например, пример выше при <code>range.to = Infinity</code> будет таковым. Или можно сделать итератор, генерирующий бесконечную последовательность псевдослучайных чисел. Тоже полезно.</p><p>Нет никаких ограничений на <code>next</code>, он может возвращать всё новые и новые значения, и это нормально.</p><p>Разумеется, цикл <code>for..of</code> по такому итератору тоже будет бесконечным, нужно его прерывать, например, через <code>break</code>.</p></important-><h2><a name="1" href="#1">Встроенные итераторы</a></h2><p>Встроенные в JavaScript итераторы можно получить и явным образом, без <code>for..of</code>, прямым вызовом <code>Symbol.iterator</code>.</p><p>Например, этот код получает итератор для строки и вызывает его полностью «вручную»:</p><code-example><script>`'use strict';\n\nlet str = "Hello";\n\n// Делает то же, что и\n// for (var letter of str) alert(letter);\n\nlet iterator = str[Symbol.iterator]();\n\nwhile(true) {\n  let result = iterator.next();\n  if (result.done) break;\n  alert(result.value); // Выведет все буквы по очереди\n}`</script><code-toolbar></code-toolbar></code-example><p>То же самое будет работать и для массивов.</p><h2><a name="2" href="#2">Итого</a></h2><ul><li><em>Итератор</em> – объект, предназначенный для перебора другого объекта.</li><li>У итератора должен быть метод <code>next()</code>, возвращающий объект <code>{done: Boolean, value: any}</code>, где <code>value</code> – очередное значение, а <code>done: true</code> в конце.</li><li>Метод <code>Symbol.iterator</code> предназначен для получения итератора из объекта. Цикл <code>for..of</code> делает это автоматически, но можно и вызвать его напрямую.</li><li>В современном стандарте есть много мест, где вместо массива используются более абстрактные «итерируемые» (со свойством <code>Symbol.iterator</code>) объекты, например оператор spread <code>...</code>.</li><li>Встроенные объекты, такие как массивы и строки, являются итерируемыми, в соответствии с описанным выше.</li></ul><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Тип данных Symbol; Set, Map, WeakSet и WeakMap"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/iterator", disqus_identifier = "iterator", disqus_title = "\u0418\u0442\u0435\u0440\u0430\u0442\u043e\u0440\u044b";</script></page-content></main>