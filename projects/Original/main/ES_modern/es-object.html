<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="83">Современные возможности ES-2015</a></nav-up><h1>Объекты и прототипы</h1><p>В этом разделе мы рассмотрим нововведения, которые касаются именно объектов.</p><p>По классам – чуть позже, в отдельном разделе, оно того заслуживает.</p><h2><a name="0" href="#0">Короткое свойство</a></h2><p>Зачастую у нас есть переменные, например, <code>name</code> и <code>isAdmin</code>, и мы хотим использовать их в объекте.</p><p>При объявлении объекта в этом случае достаточно указать только имя свойства, а значение будет взято из переменной с аналогичным именем.</p><p>Например:</p><code-example><script>`'use strict';\n\nlet name = "Вася";\nlet isAdmin = true;\n\nMARKlet user = {\nMARK  name,\nMARK  isAdmin\nMARK};\nalert( JSON.stringify(user) ); // {"name": "Вася", "isAdmin": true}`</script><code-toolbar></code-toolbar></code-example><h2><a name="1" href="#1">Вычисляемые свойства</a></h2><p>В качестве имени свойства можно использовать выражение, например:</p><code-example><script>`'use strict';\n\nlet propName = "firstName";\n\nlet user = {\nMARK  [propName]: "Вася"\n};\n\nalert( user.firstName ); // Вася`</script><code-toolbar></code-toolbar></code-example><p>Или даже так:</p><code-example><script>`'use strict';\n\nlet a = "Мой ";\nlet b = "Зелёный ";\nlet c = "Крокодил";\n\nlet user = {\nMARK  [(a + b + c).toLowerCase()]: "Гена"\n};\n\nalert( user["мой зелёный крокодил"] ); // Гена`</script><code-toolbar></code-toolbar></code-example><h2><a name="2" href="#2">Геттер-сеттер для прототипа</a></h2><p>В ES5 для прототипа был метод-геттер:</p><ul><li><code>Object.getPrototypeOf(obj)</code></li></ul><p>В ES-2015 также добавился сеттер:</p><ul><li><code>Object.setPrototypeOf(obj, newProto)</code></li></ul><p>…А также «узаконено» свойство <code>__proto__</code>, которое даёт прямой доступ к прототипу. Его, в качестве «нестандартного», но удобного способа работы с прототипом, реализовали почти все браузеры (кроме IE10-), так что было принято решение добавить его в стандарт.</p><h2><a name="3" href="#3">Object.assign</a></h2><p>Функция <code>Object.assign</code> получает список объектов и копирует в первый <code>target</code> свойства из остальных.</p><p>Синтаксис:</p><code-example><script>`Object.assign(target, src1, src2...)`</script></code-example><p>При этом последующие свойства перезаписывают предыдущие.</p><p>Например:</p><code-example><script>`'use strict';\n\nlet user = { name: "Вася" };\nlet visitor = { isAdmin: false, visits: true };\nlet admin = { isAdmin: true };\n\nObject.assign(user, visitor, admin);\n\n// user <- visitor <- admin\nalert( JSON.stringify(user) ); // name: Вася, visits: true, isAdmin: true`</script><code-toolbar></code-toolbar></code-example><p>Его также можно использовать для 1-уровневого клонирования объекта:</p><code-example><script>`'use strict';\n\nlet user = { name: "Вася", isAdmin: false };\n\nMARK// clone = пустой объект + все свойства user\nMARKlet clone = Object.assign({}, user);`</script></code-example><h2><a name="4" href="#4">Object.is(value1, value2)</a></h2><p>Новая функция для проверки равенства значений.</p><p>Возвращает <code>true</code>, если значения <code>value1</code> и <code>value2</code> равны, иначе <code>false</code>.</p><p>Она похожа на обычное строгое равенство <code>===</code>, но есть отличия:</p><code-example><script>`// Сравнение +0 и -0\nalert( Object.is(+0, -0)); // false\nalert( +0 === -0 );        // true\n\n// Сравнение с NaN\nalert( Object.is(NaN, NaN) ); // true\nalert( NaN === NaN );         // false`</script><code-toolbar></code-toolbar></code-example><p>Отличия эти в большинстве ситуаций некритичны, так что непохоже, чтобы эта функция вытеснила обычную проверку <code>===</code>. Что интересно – этот алгоритм сравнения, который называется <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-samevalue">SameValue</a>, применяется во внутренних реализациях различных методов современного стандарта.</p><h2><a name="5" href="#5">Методы объекта</a></h2><p>Долгое время в JavaScript термин «метод объекта» был просто альтернативным названием для свойства-функции.</p><p>Теперь это уже не так. Добавлены именно «методы объекта», которые, по сути, являются свойствами-функциями, привязанными к объекту.</p><p>Их особенности:</p><ol><li>Более короткий синтаксис объявления.</li><li>Наличие в методах специального внутреннего свойства <code>[[HomeObject]]</code> («домашний объект»), ссылающегося на объект, которому метод принадлежит. Мы посмотрим его использование чуть дальше.</li></ol><p>Для объявления метода вместо записи <code>"prop: function() {…}"</code> нужно написать просто <code>"prop() { … }"</code>.</p><p>Например:</p><code-example><script>`'use strict';\n\nlet name = "Вася";\nlet user = {\n  name,\nMARK  // вместо "sayHi: function() {...}" пишем "sayHi() {...}"\nMARK  sayHi() {\nMARK    alert(this.name);\nMARK  }\n};\n\nuser.sayHi(); // Вася`</script><code-toolbar></code-toolbar></code-example><p>Как видно, для создания метода нужно писать меньше букв. Что же касается вызова – он ничем не отличается от обычной функции. На данном этапе можно считать, что «метод» – это просто сокращённый синтаксис для свойства-функции. Дополнительные возможности, которые даёт такое объявление, мы рассмотрим позже.</p><p>Также методами станут объявления геттеров <code>get prop()</code> и сеттеров <code>set prop()</code>:</p><code-example><script>`'use strict';\n\nlet name = "Вася", surname = "Петров";\nlet user = {\n  name,\n  surname,\n  get fullName() {\n    return \`\${name} \${surname}\`;\n  }\n};\n\nalert( user.fullName ); // Вася Петров`</script><code-toolbar></code-toolbar></code-example><p>Можно задать и метод с вычисляемым названием:</p><code-example><script>`'use strict';\n\nlet methodName = "getFirstName";\n\nlet user = {\n  // в квадратных скобках может быть любое выражение,\n  // которое должно вернуть название метода\n  [methodName]() {  // вместо [methodName]: function() {\n    return "Вася";\n  }\n};\n\nalert( user.getFirstName() ); // Вася`</script><code-toolbar></code-toolbar></code-example><p>Итак, мы рассмотрели синтаксические улучшения. Если коротко, то не надо писать слово «function». Теперь перейдём к другим отличиям.</p><h2><a name="6" href="#6">super</a></h2><p>В ES-2015 появилось новое ключевое слово <code>super</code>. Оно предназначено только для использования в методах объекта.</p><p>Вызов <code>super.parentProperty</code> позволяет из метода объекта получить свойство его прототипа.</p><p>Например, в коде ниже <code>rabbit</code> наследует от <code>animal</code>.</p><p>Вызов <code>super.walk()</code> из метода объекта <code>rabbit</code> обращается к <code>animal.walk()</code>:</p><code-example><script>`'use strict';\n\nlet animal = {\n  walk() {\n    alert("I'm walking");\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  walk() {\nMARK    alert(super.walk); // walk() { … }\nMARK    super.walk(); // I'm walking\n  }\n};\n\nrabbit.walk();`</script><code-toolbar></code-toolbar></code-example><p>Как правило, это используется в <a href="/es-class">классах</a>, которые мы рассмотрим в следующем разделе, но важно понимать, что «классы» здесь на самом деле ни при чём. Свойство <code>super</code> работает через прототип, на уровне методов объекта.</p><p>При обращении через <code>super</code> используется <code>[[HomeObject]]</code> текущего метода, и от него берётся <code>__proto__</code>. Поэтому <code>super</code> работает только внутри методов.</p><p>В частности, если переписать этот код, оформив <code>rabbit.walk</code> как обычное свойство-функцию, то будет ошибка:</p><code-example><script>`'use strict';\n\nlet animal = {\n  walk() {\n    alert("I'm walking");\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\nMARK  walk: function() { // Надо: walk() {\nMARK    super.walk(); // Будет ошибка!\nMARK  }\n};\n\nrabbit.walk();`</script><code-toolbar></code-toolbar></code-example><p>Ошибка возникнет, так как <code>rabbit.walk</code> теперь обычная функция и не имеет <code>[[HomeObject]]</code>. Поэтому в ней не работает <code>super</code>.</p><p>Исключением из этого правила являются функции-стрелки. В них используется <code>super</code> внешней функции. Например, здесь функция-стрелка в <code>setTimeout</code> берёт внешний <code>super</code>:</p><code-example><script>`'use strict';\n\nlet animal = {\n  walk() {\n    alert("I'm walking");\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  walk() {\nMARK    setTimeout(() => super.walk()); // I'm walking\n  }\n};\n\nrabbit.walk();`</script><code-toolbar></code-toolbar></code-example><p>Ранее мы говорили о том, что у функций-стрелок нет своего <code>this</code>, <code>arguments</code>: они используют те, которые во внешней функции. Теперь к этому списку добавился ещё и <code>super</code>.</p><important-><h3>Свойство <code>[[HomeObject]]</code> – не изменяемое</h3><p>При создании метода – он привязан к своему объекту навсегда. Технически можно даже скопировать его и запустить отдельно, и <code>super</code> продолжит работать:</p><code-example><script>`'use strict';\n\nlet animal = {\n  walk() { alert("I'm walking"); }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  walk() {\n    super.walk();\n  }\n};\n\nlet walk = rabbit.walk; // скопируем метод в переменную\nMARKwalk(); // вызовет animal.walk()\nMARK// I'm walking`</script><code-toolbar></code-toolbar></code-example><p>В примере выше метод <code>walk()</code> запускается отдельно от объекта, но всё равно, благодаря <code>[[HomeObject]]</code>, сохраняется доступ к его прототипу через <code>super</code>.</p><p>Это – скорее технический момент, так как методы объекта, всё же, предназначены для вызова в контексте этого объекта. В частности, правила для <code>this</code> в методах – те же, что и для обычных функций. В примере выше при вызове <code>walk()</code> без объекта <code>this</code> будет <code>undefined</code>.</p></important-><h2><a name="7" href="#7">Итого</a></h2><p>Улучшения в описании свойств:</p><ul><li>Запись <code>name: name</code> можно заменить на просто <code>name</code></li><li>Если имя свойства находится в переменной или задано выражением <code>expr</code>, то его можно указать в квадратных скобках <code>[expr]</code>.</li><li>Свойства-функции можно оформить как методы: <code>"prop: function() {}"</code> → <code>"prop() {}"</code>.</li></ul><p>В методах работает обращение к свойствам прототипа через <code>super.parentProperty</code>.</p><p>Для работы с прототипом:</p><ul><li><code>Object.setPrototypeOf(obj, proto)</code> – метод для установки прототипа.</li><li><code>obj.__proto__</code> – ссылка на прототип.</li></ul><p>Дополнительно:</p><ul><li>Метод <code>Object.assign(target, src1, src2...)</code> – копирует свойства из всех аргументов в первый объект.</li><li>Метод <code>Object.is(value1, value2)</code> проверяет два значения на равенство. В отличие от <code>===</code> считает <code>+0</code> и <code>-0</code> разными числами. А также считает, что <code>NaN</code> равно самому себе.</li></ul><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Строки; Классы"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/es-object", disqus_identifier = "es-object", disqus_title = "\u041e\u0431\u044a\u0435\u043a\u0442\u044b \u0438 \u043f\u0440\u043e\u0442\u043e\u0442\u0438\u043f\u044b";</script></page-content></main>