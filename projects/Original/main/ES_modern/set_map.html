<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="83">Современные возможности ES-2015</a></nav-up><h1>Set, Map, WeakSet и WeakMap</h1><p>В ES-2015 появились новые типы коллекций в JavaScript: <code>Set</code>, <code>Map</code>, <code>WeakSet</code> и <code>WeakMap</code>.</p><h2><a name="0" href="#0">Map</a></h2><p><code>Map</code> – коллекция для хранения записей вида <code>ключ:значение</code>.</p><p>В отличие от объектов, в которых ключами могут быть только строки, в <code>Map</code> ключом может быть произвольное значение, например:</p><code-example><script>`'use strict';\n\nlet map = new Map();\n\nmap.set('1', 'str1');   // ключ-строка\nmap.set(1, 'num1');     // число\nmap.set(true, 'bool1'); // булевое значение\n\n// в обычном объекте это было бы одно и то же,\n// map сохраняет тип ключа\nalert( map.get(1)   ); // 'num1'\nalert( map.get('1') ); // 'str1'\n\nalert( map.size ); // 3`</script><code-toolbar></code-toolbar></code-example><p>Как видно из примера выше, для сохранения и чтения значений используются методы <code>get</code> и <code>set</code>. И ключи и значения сохраняются «как есть», без преобразований типов.</p><p>Свойство <code>map.size</code> хранит общее количество записей в <code>map</code>.</p><p>Метод <code>set</code> можно чейнить:</p><code-example><script>`map\n  .set('1', 'str1')\n  .set(1, 'num1')\n  .set(true, 'bool1');`</script></code-example><p>При создании <code>Map</code> можно сразу инициализировать списком значений.</p><p>Объект <code>map</code> с тремя ключами, как и в примере выше:</p><code-example><script>`let map = new Map([\n  ['1',  'str1'],\n  [1,    'num1'],\n  [true, 'bool1']\n]);`</script></code-example><p>Аргументом <code>new Map</code> должен быть итерируемый объект (не обязательно именно массив). Везде утиная типизация, максимальная гибкость.</p><p><strong>В качестве ключей <code>map</code> можно использовать и объекты:</strong></p><code-example><script>`'use strict';\n\nlet user = { name: "Вася" };\n\n// для каждого пользователя будем хранить количество посещений\nlet visitsCountMap = new Map();\n\nMARK// объект user является ключом в visitsCountMap\nMARKvisitsCountMap.set(user, 123);\n\nalert( visitsCountMap.get(user) ); // 123`</script><code-toolbar></code-toolbar></code-example><p>Использование объектов в качестве ключей – как раз тот случай, когда <code>Map</code> сложно заменить обычными объектами <code>Object</code>. Ведь для обычных объектов ключ может быть только строкой.</p><important-><h3>Как map сравнивает ключи</h3><p>Для проверки значений на эквивалентность используется алгоритм <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-samevaluezero">SameValueZero</a>. Он аналогичен строгому равенству <code>===</code>, отличие – в том, что <code>NaN</code> считается равным <code>NaN</code>. Поэтому значение <code>NaN</code> также может быть использовано в качестве ключа.</p><p>Этот алгоритм нельзя изменять или задавать свою функцию сравнения.</p></important-><p>Методы для удаления записей:</p><ul><li><code>map.delete(key)</code> удаляет запись с ключом <code>key</code>, возвращает <code>true</code>, если такая запись была, иначе <code>false</code>.</li><li><code>map.clear()</code> – удаляет все записи, очищает <code>map</code>.</li></ul><p>Для проверки существования ключа:</p><ul><li><code>map.has(key)</code> – возвращает <code>true</code>, если ключ есть, иначе <code>false</code>.</li></ul><h3><a name="6" href="#6">Итерация</a></h3><p>Для итерации по <code>map</code> используется один из трёх методов:</p><ul><li><code>map.keys()</code> – возвращает итерируемый объект для ключей,</li><li><code>map.values()</code> – возвращает итерируемый объект для значений,</li><li><code>map.entries()</code> – возвращает итерируемый объект для записей <code>[ключ, значение]</code>, он используется по умолчанию в <code>for..of</code>.</li></ul><p>Например:</p><code-example><script>`'use strict';\n\nlet recipeMap = new Map([\n  ['огурцов',   '500 гр'],\n  ['помидоров', '350 гр'],\n  ['сметаны',   '50 гр']\n]);\n\n// цикл по ключам\nfor(let fruit of recipeMap.keys()) {\n  alert(fruit); // огурцов, помидоров, сметаны\n}\n\n// цикл по значениям\nfor(let amount of recipeMap.values()) {\n  alert(amount); // 500 гр, 350 гр, 50 гр\n}\n\n// цикл по записям [ключ,значение]\nfor(let entry&nbspof recipeMap) { // то же что и recipeMap.entries()\n  alert(entry); // огурцов,500 гр , и т.д., массивы по 2 значения\n}`</script><code-toolbar></code-toolbar></code-example><important-><h3>Перебор идёт в том же порядке, что и вставка</h3><p>Перебор осуществляется в порядке вставки. Объекты <code>Map</code> гарантируют это, в отличие от обычных объектов <code>Object</code>.</p></important-><p>Кроме того, у <code>Map</code> есть стандартный метод <code>forEach</code>, аналогичный встроенному в массивы:</p><code-example><script>`'use strict';\n\nlet recipeMap = new Map([\n  ['огурцов',   '500 гр'],\n  ['помидоров', '350 гр'],\n  ['сметаны',   '50 гр']\n]);\n\nrecipeMap.forEach( (value, key, map) => {\n  alert(\`\${key}: \${value}\`); // огурцов: 500 гр, и т.д.\n});`</script><code-toolbar></code-toolbar></code-example><h2><a name="1" href="#1">Set</a></h2><p><code>Set</code> – коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз.</p><p>Например, к нам приходят посетители, и мы хотели бы сохранять всех, кто пришёл. При этом повторные визиты не должны приводить к дубликатам, то есть каждого посетителя нужно «посчитать» ровно один раз.</p><p><code>Set</code> для этого отлично подходит:</p><code-example><script>`'use strict';\n\nlet&nbspset = new Set();\n\nlet vasya = {name: "Вася"};\nlet petya = {name: "Петя"};\nlet dasha = {name: "Даша"};\n\n// посещения, некоторые пользователи заходят много раз\nset.add(vasya);\nset.add(petya);\nset.add(dasha);\nset.add(vasya);\nset.add(petya);\n\n//&nbspset сохраняет только уникальные значения\nalert(&nbspset.size ); // 3\n\nset.forEach( user => alert(user.name ) ); // Вася, Петя, Даша`</script><code-toolbar></code-toolbar></code-example><p>В примере выше многократные добавления одного и того же объекта в <code>set</code> не создают лишних копий.</p><p>Альтернатива <code>Set</code> – это массивы с поиском дубликата при каждом добавлении, но они гораздо хуже по производительности. Или можно использовать обычные объекты, где в качестве ключа выступает какой-нибудь уникальный идентификатор посетителя. Но это менее удобно, чем простой и наглядный <code>Set</code>.</p><p>Основные методы:</p><ul><li><code>set.add(item)</code> – добавляет в коллекцию <code>item</code>, возвращает <code>set</code> (чейнится).</li><li><code>set.delete(item)</code> – удаляет <code>item</code> из коллекции, возвращает <code>true</code>, если он там был, иначе <code>false</code>.</li><li><code>set.has(item)</code> – возвращает <code>true</code>, если <code>item</code> есть в коллекции, иначе <code>false</code>.</li><li><code>set.clear()</code> – очищает <code>set</code>.</li></ul><p>Перебор <code>Set</code> осуществляется через <code>forEach</code> или <code>for..of</code> аналогично <code>Map</code>:</p><code-example><script>`'use strict';\n\nlet&nbspset = new Set(["апельсины", "яблоки", "бананы"]);\n\n// то же, что: for(let value of set)\nset.forEach((value, valueAgain,&nbspset) => {\n  alert(value); // апельсины, затем яблоки, затем бананы\n});`</script><code-toolbar></code-toolbar></code-example><p>Заметим, что в <code>Set</code> у функции в <code>.forEach</code> три аргумента: значение, ещё раз значение, и затем сам перебираемый объект <code>set</code>. При этом значение повторяется в аргументах два раза.</p><p>Так сделано для совместимости с <code>Map</code>, где у <code>.forEach</code>-функции также три аргумента. Но в <code>Set</code> первые два всегда совпадают и содержат очередное значение множества.</p><h2><a name="2" href="#2">WeakMap и WeakSet</a></h2><p><code>WeakSet</code> – особый вид <code>Set</code> не препятствующий сборщику мусора удалять свои элементы. То же самое – <code>WeakMap</code> для <code>Map</code>.</p><p>То есть, если некий объект присутствует только в <code>WeakSet/WeakMap</code> – он удаляется из памяти.</p><p>Это нужно для тех ситуаций, когда основное место для хранения и использования объектов находится где-то в другом месте кода, а здесь мы хотим хранить для них «вспомогательные» данные, существующие лишь пока жив объект.</p><p>Например, у нас есть элементы на странице или, к примеру, пользователи, и мы хотим хранить для них вспомогательную информацию, например обработчики событий или просто данные, но действительные лишь пока объект, к которому они относятся, существует.</p><p>Если поместить такие данные в <code>WeakMap</code>, а объект сделать ключом, то они будут автоматически удалены из памяти, когда удалится элемент.</p><p>Например:</p><code-example><script>`// текущие активные пользователи\nlet activeUsers = [\n  {name: "Вася"},\n  {name: "Петя"},\n  {name: "Маша"}\n];\n\n// вспомогательная информация о них,\n// которая напрямую не входит в объект юзера,\n// и потому хранится отдельно\nlet weakMap = new WeakMap();\n\nweakMap.set(activeUsers[0], 1);\nweakMap.set(activeUsers[1], 2);\nweakMap.set(activeUsers[2], 3);\nweakMap.set('Katya', 4); // Будет ошибка TypeError: "Katya" is not a non-null object\n\nalert( weakMap.get(activeUsers[0]) ); // 1\n\nactiveUsers.splice(0, 1); // Вася более не активный пользователь\n\n// weakMap теперь содержит только 2 элемента\n\nactiveUsers.splice(0, 1); // Петя более не активный пользователь\n\n// weakMap теперь содержит только 1 элемент`</script></code-example><p>Таким образом, <code>WeakMap</code> избавляет нас от необходимости вручную удалять вспомогательные данные, когда удалён основной объект.</p><p>У WeakMap есть ряд ограничений:</p><ul><li>Только объекты в качестве ключей.</li><li>Нет свойства <code>size</code>.</li><li>Нельзя перебрать элементы итератором или <code>forEach</code>.</li><li>Нет метода <code>clear()</code>.</li></ul><p>Иными словами, <code>WeakMap</code> работает только на запись (<code>set</code>, <code>delete</code>) и чтение (<code>get</code>, <code>has</code>) элементов по конкретному ключу, а не как полноценная коллекция. Нельзя вывести всё содержимое <code>WeakMap</code>, нет соответствующих методов.</p><p>Это связано с тем, что содержимое <code>WeakMap</code> может быть модифицировано сборщиком мусора в любой момент, независимо от программиста. Сборщик мусора работает сам по себе. Он не гарантирует, что очистит объект сразу же, когда это стало возможным. В равной степени он не гарантирует и обратное. Нет какого-то конкретного момента, когда такая очистка точно произойдёт – это определяется внутренними алгоритмами сборщика и его сведениями о системе.</p><p>Поэтому содержимое <code>WeakMap</code> в произвольный момент, строго говоря, не определено. Может быть, сборщик мусора уже удалил какие-то записи, а может и нет. С этим, а также с требованиями к эффективной реализации <code>WeakMap</code>, и связано отсутствие методов, осуществляющих доступ ко всем записям.</p><p>То же самое относится и к <code>WeakSet</code>: можно добавлять элементы, проверять их наличие, но нельзя получить их список и даже узнать количество.</p><p>Эти ограничения могут показаться неудобными, но по сути они не мешают <code>WeakMap/WeakSet</code> выполнять свою основную задачу – быть «вторичным» хранилищем данных для объектов, актуальный список которых (и сами они) хранятся в каком-то другом месте.</p><h2><a name="3" href="#3">Итого</a></h2><ul><li><code>Map</code> – коллекция записей вида <code>ключ: значение</code>, лучше <code>Object</code> тем, что перебирает всегда в порядке вставки и допускает любые ключи.</li><li><code>Set</code> – коллекция уникальных элементов, также допускает любые ключи.</li></ul><p>Основная область применения <code>Map</code> – ситуации, когда строковых ключей не хватает (нужно хранить соответствия для ключей-объектов), либо когда строковый ключ может быть совершенно произвольным.</p><p>К примеру, в обычном объекте <code>Object</code> нельзя использовать «совершенно любые» ключи. Есть встроенные методы, и уж точно есть свойство с названием <code>__proto__</code>, которое зарезервировано системой. Если название ключа даётся посетителем сайта, то он может попытаться использовать такое свойство, заменить прототип, а это, при запуске JavaScript на сервере, уже может привести к серьёзным ошибкам.</p><ul><li><code>WeakMap</code> и <code>WeakSet</code> – «урезанные» по функционалу варианты <code>Map/Set</code>, которые позволяют только «точечно» обращаться к элементам (по конкретному ключу или значению). Они не препятствуют сборке мусора, то есть если ссылка на объект осталась только в <code>WeakSet/WeakMap</code> – она будет удалена.</li></ul><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Итераторы; Promise"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/set-map", disqus_identifier = "set-map", disqus_title = "Set, Map, WeakSet \u0438 WeakMap";</script></page-content></main>