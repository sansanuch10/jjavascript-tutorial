<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="83">Современные возможности ES-2015</a></nav-up><h1>Модули</h1><p>Концепция модулей как способа организации JavaScript-кода существовала давно.</p><p>Когда приложение сложное и кода много – мы пытаемся разбить его на файлы. В каждом файле описываем какую-то часть, а в дальнейшем – собираем эти части воедино.</p><p>Модули в стандарте ECMAScript предоставляют удобные средства для этого.</p><p>Такие средства предлагались сообществом и ранее, например:</p><ul><li><a href="https://en.wikipedia.org/wiki/Asynchronous_module_definition">AMD</a> – одна из самых древних систем организации модулей, требует лишь наличия клиентской библиотеки, к примеру, <a href="http://requirejs.org/">require.js</a>, но поддерживается и серверными средствами.</li><li><a href="http://wiki.commonjs.org/wiki/Modules/1.1">CommonJS</a> – система модулей, встроенная в сервер Node.JS. Требует поддержки на клиентской и серверной стороне.</li><li><a href="https://github.com/umdjs/umd">UMD</a> – система модулей, которая предложена в качестве универсальной. UMD-модули будут работать и в системе AMD и в CommonJS.</li></ul><p>Все перечисленные выше системы требуют различных библиотек или систем сборки для использования.</p><p>Новый стандарт отличается от них прежде всего тем, что это – стандарт. А значит, со временем, будет поддерживаться браузерами без дополнительных утилит.</p><p>Однако, сейчас браузерной поддержки почти нет. Поэтому ES-модули используются в сочетании с системами сборки, такими как <a href="http://webpack.github.io/">webpack</a>, <a href="http://brunch.io/">brunch</a> и другими, при подключённом <a href="https://babeljs.io">Babel.JS</a>. Мы рассмотрим это далее.</p><h2><a name="0" href="#0">Что такое модуль?</a></h2><p>Модулем считается файл с кодом.</p><p>В этом файле ключевым словом <code>export</code> помечаются переменные и функции, которые могут быть использованы снаружи.</p><p>Другие модули могут подключать их через вызов <code>import</code>.</p><h2><a name="1" href="#1">export</a></h2><p>Ключевое слово <code>export</code> можно ставить:</p><ul><li>перед объявлением переменных, функций и классов.</li><li>отдельно, при этом в фигурных скобках указывается, что именно экспортируется.</li></ul><p>Например, так экспортируется переменная <code>one</code>:</p><code-example><script>`// экспорт прямо перед объявлением\nexport let one = 1;`</script></code-example><p>Можно написать <code>export</code> и отдельно от объявления:</p><code-example><script>`let two = 2;\n\nexport {two};`</script></code-example><p>При этом в фигурных скобках указываются одна или несколько экспортируемых переменных.</p><p>Для двух переменных будет так:</p><code-example><script>`export {one, two};`</script></code-example><p>При помощи ключевого слова <code>as</code> можно указать, что переменная <code>one</code> будет доступна снаружи (экспортирована) под именем <code>once</code>, а <code>two</code> – под именем <code>twice</code>:</p><code-example><script>`export {one as once, two as twice};`</script></code-example><p>Экспорт функций и классов выглядит так же:</p><code-example><script>`export class User {\n constructor(name) {\n  this.name = name;\n }\n};\n\nexport function sayHi() {\n alert("Hello!");\n};\n\n// отдельно от объявлений было бы так:\n// export {User, sayHi}`</script></code-example><important-><h3>Для экспорта обязательно нужно имя</h3><p>Заметим, что и у функции и у класса при таком экспорте должно быть имя.</p><p>Так будет ошибка:</p><code-example><script>`// функция без имени\nexport function() { alert("Error"); };`</script></code-example><p>В экспорте указываются именно имена, а не произвольные выражения.</p></important-><h2><a name="2" href="#2">import</a></h2><p>Другие модули могут подключать экспортированные значения при помощи ключевого слова <code>import</code>.</p><p>Синтаксис:</p><code-example><script>`import {one, two} from "./nums";`</script></code-example><p>Здесь:</p><ul><li><code>"./nums"</code> – модуль, как правило это путь к файлу модуля.</li><li><code>one, two</code> – импортируемые переменные, которые должны быть обозначены в <code>nums</code> словом <code>export</code>.</li></ul><p>В результате импорта появятся локальные переменные <code>one</code>, <code>two</code>, которые будут содержать значения соответствующих экспортов.</p><p>Например, при таком файле <code>nums.js</code>:</p><code-example><script>`export let one = 1;\nexport let two = 2;`</script></code-example><p>Модуль ниже выведет «1 and 2»:</p><code-example><script>`import {one, two} from "./nums";\n\nalert( \`\${one} and \${two}\` ); // 1 and 2`</script></code-example><p>Импортировать можно и под другим именем, указав его в «as»:</p><code-example><script>`// импорт one под именем item1, а two – под именем item2\nimport {one as item1, two as item2} from "./nums";\n\nalert( \`\${item1} and \${item2}\` ); // 1 and 2`</script></code-example><important-><h3>Импорт всех значений в виде объекта</h3><p>Можно импортировать все значения сразу в виде объекта вызовом <code>import * as obj</code>, например:</p><code-example><script>`MARKimport * as numbers from "./nums";\n\n// теперь экспортированные переменные - свойства numbers\nalert( \`\${numbers.one} and \${numbers.two}\` ); // 1 and 2`</script></code-example></important-><h2><a name="3" href="#3">export default</a></h2><p>Выше мы видели, что модуль может экспортировать выбранные переменные при помощи <code>export</code>.</p><p>Однако, как правило, код стараются организовать так, чтобы каждый модуль делал одну вещь. Иначе говоря, «один файл – одна сущность, которую он описывает». Например, файл <code>user.js</code> содержит <code>class User</code>, файл <code>login.js</code> – функцию <code>login()</code> для авторизации, и т.п.</p><p>При этом модули, разумеется, будут использовать друг друга. Например, <code>login.js</code>, скорее всего, будет импортировать класс <code>User</code> из модуля <code>user.js</code>.</p><p>Для такой ситуации, когда один модуль экспортирует одно значение, предусмотрено особое ключевое сочетание <code>export default</code>.</p><p>Если поставить после <code>export</code> слово <code>default</code>, то значение станет «экспортом по умолчанию».</p><p>Такое значение можно импортировать без фигурных скобок.</p><p>Например, файл <code>user.js</code>:</p><code-example><script>`HIGHexport default LIGHTclass User {\n constructor(name) {\n  this.name = name;\n }\n};`</script></code-example><p>…А в файле <code>login.js</code>:</p><code-example><script>`import User from './user';\n\nnew User("Вася");`</script></code-example><p>«Экспорт по умолчанию» – своего рода «синтаксический сахар». Можно было бы и без него, импортировать значение обычным образом через фигурные скобки <code>{…}</code>. Если бы в <code>user.js</code> не было <code>default</code>, то в <code>login.js</code> необходимо было бы указать фигурные скобки:</p><code-example><script>`// если бы user.js содержал\n// export class User { ... }\n\n// …то при импорте User понадобились бы фигурные скобки:\nimport {User} from './user';\n\nnew User("Вася");`</script></code-example><p>На практике этот «сахар» весьма приятен, так как позволяет легко видеть, какое именно значение экспортирует модуль, а также обойтись без лишних символов при импорте.</p><h2><a name="4" href="#4">CommonJS</a></h2><p>Если вы раньше работали с Node.JS или использовали систему сборки в синтаксисе CommonJS, то вот соответствия.</p><p>Для экспорта по умолчанию вместо:</p><code-example><script>`module.exports = VARIABLE;`</script></code-example><p>Пишем:</p><code-example><script>`export default VARIABLE;`</script></code-example><p>А при импорте из такого модуля вместо:</p><code-example><script>`const VARIABLE = require('./file');`</script></code-example><p>Пишем:</p><code-example><script>`import VARIABLE from './file';`</script></code-example><p>Для экспорта нескольких значений из модуля, вместо:</p><code-example><script>`exports.NAME = VARIABLE;`</script></code-example><p>Пишем в фигурных скобках, что надо экспортировать и под каким именем (без <code>as</code>, если имя совпадает):</p><code-example><script>`export {VARIABLE as NAME};`</script></code-example><p>При импорте – также фигурные скобки:</p><code-example><script>`import {NAME} from './file';`</script></code-example><h2><a name="5" href="#5">Использование</a></h2><p>Современный стандарт ECMAScript описывает, как импортировать и экспортировать значения из модулей, но он ничего не говорит о том, как эти модули искать, загружать и т.п.</p><p>Такие механизмы предлагались в процессе создания стандарта, но были убраны по причине недостаточной проработанности. Возможно, они появятся в будущем.</p><p>Сейчас используются системы сборки, как правило, в сочетании с Babel.JS.</p><p>Система сборки обрабатывает скрипты, находит в них <code>import/export</code> и заменяет их на свои внутренние JavaScript-вызовы. При этом, как правило, много файлов-модулей объединяются в один или несколько скриптов, смотря как указано в конфигурации сборки.</p><p>Ниже вы можете увидеть полный пример использования модулей с системой сборки <a href="http://webpack.github.io">webpack</a>.</p><p>В нём есть:</p><ul><li><code>nums.js</code> – модуль, экспортирующий <code>one</code> и <code>two</code>, как описано выше.</li><li><code>main.js</code> – модуль, который импортирует <code>one</code>, <code>two</code> из <code>nums</code> и выводит их сумму.</li><li><code>webpack.config.js</code> – конфигурация для системы сборки.</li><li><code>bundle.js</code> – файл, который создала система сборки из <code>main.js</code> и <code>nums.js</code>.</li><li><code>index.html</code> – простой HTML-файл для демонстрации.</li></ul><code-tabs data-code_switch=""><tools-><code-toolbar-><a href="http://plnkr.co/edit/heyfENvcLg0WnLTUjgMs?p=preview" target="_blank" title="открыть в песочнице"></a></code-toolbar-><button-0 class="current">Результат</button-0><button-1>bundle.js</button-1><button-2>main.js</button-2><button-3>nums.js</button-3><button-4>webpack.config.js</button-4><button-5>index.html</button-5></tools-><code-example code_no="" style="display: block;"><script id="bundle_js">function runBundle(){if (document.getElementById('removable')) return;var script=document.createElement('script');script.id='removable';script.src='bundle.js';document.getElementById('bundle_js').parentElement.appendChild(script);console.log('bunle_js******')}</script><input value="Cумма импортов =" type="button" style="margin:20px 0 20px 20px" onclick="runBundle()"></code-example><code-example><script>`/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n\n\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n\n	var _nums = __webpack_require__(1);\n\n	document.write('Сумма импортов:&nbsp' + (_nums.one + _nums.two));\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n\n	Object.defineProperty(exports, "__esModule", {\n	 value: true\n	});\n	var one = 1;\n\n	exports.one = one;\n	var two = 2;\n\n	exports.two = two;\n\n/***/ }\n/******/ ]);`</script></code-example><code-example><script>`import {one, two} from './nums';\n\ndocument.write(\`GREEN_Сумма импортов_GREEN: \${one + two}\`);\n\n\n\n\n\n\n`</script></code-example><code-example><script>`export let one = 1;\n\nlet two = 2;\n\nexport {two};\n\n\n\n\n`</script></code-example><code-example><script>`// Для использования нужен Node.JS\n// Поставьте webpack:\n//  npm i -g webpack\n// Поставьте babel-loader:\n//  npm i babel-loader\n// Запустите его в директории с файлами:\n//  webpack\n\nmodule.exports = {\n entry: './main',\n\n output: {\n  filename: 'bundle.js'\n },\n\n module: {\n  loaders: [\n   { test: /\.js$/, loader: "babel" }\n  ]\n }\n};`</script></code-example><code-example><script>`<!doctype html>\n<html lang="en">\n<head>\n <meta charset="UTF-8">\n</head>\n<body>\n\n <script src="bundle.js"><\/script>\n\n</body>\n</html>`</script><code-toolbar-><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example></code-tabs><h2><a name="6" href="#6">Итого</a></h2><p>Современный стандарт описывает, как организовать код в модули, экспортировать и импортировать значения.</p><p>Экспорт:</p><ul><li><code>export</code> можно поставить прямо перед объявлением функции, класса, переменной.</li><li>Если <code>export</code> стоит отдельно от объявления, то значения в нём указываются в фигурных скобках: <code>export {…}</code>.</li><li>Также можно экспортировать «значение по умолчанию» при помощи <code>export default</code>.</li></ul><p>Импорт:</p><ul><li>В фигурных скобках указываются значения, а затем – модуль, откуда их брать: <code>import {a, b, c as d} from "module"</code>.</li><li>Можно импортировать все значения в виде объекта при помощи <code>import * as obj from "module"</code>.</li><li>Без фигурных скобок будет импортировано «значение по умолчанию»: <code>import User from "user"</code>.</li></ul><p>На текущий момент модули требуют системы сборки на сервере. Автор этого текста преимущественно использует webpack, но есть и другие варианты.</p><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Генераторы; Proxy"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/modules",disqus_identifier="modules",disqus_title="\u041c\u043e\u0434\u0443\u043b\u0438";</script></page-content></main>