<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="83">Современные возможности ES-2015</a></nav-up><h1>Promise</h1><p>Promise (обычно их так и называют «промисы») – предоставляют удобный способ организации асинхронного кода.</p><p>В современном JavaScript промисы часто используются в том числе и неявно, при помощи генераторов, но об этом чуть позже.</p><h2><a name="0" href="#0">Что такое Promise?</a></h2><p>Promise – это специальный объект, который содержит своё состояние. Вначале <code>pending</code> («ожидание»), затем – одно из: <code>fulfilled</code> («выполнено успешно») или <code>rejected</code> («выполнено с ошибкой»).</p><figure><img src="promiseInit.png" style="max-width:359px;width:100%;"></figure><p>На <code>promise</code> можно навешивать коллбэки двух типов:</p><ul><li><code>onFulfilled</code> – срабатывают, когда <code>promise</code> в состоянии «выполнен успешно».</li><li><code>onRejected</code> – срабатывают, когда <code>promise</code> в состоянии «выполнен с ошибкой».</li></ul><p>Способ использования, в общих чертах, такой:</p><ol><li>Код, которому надо сделать что-то асинхронно, создаёт объект <code>promise</code> и возвращает его.</li><li>Внешний код, получив <code>promise</code>, навешивает на него обработчики.</li><li>По завершении процесса асинхронный код переводит <code>promise</code> в состояние <code>fulfilled</code> (с результатом) или <code>rejected</code> (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.</li></ol><p>Синтаксис создания <code>Promise</code>:</p><code-example><script>`var promise = new Promise(function(resolve, reject) {\n  // Эта функция будет вызвана автоматически\n\n  // В ней можно делать любые асинхронные операции,\n  // А когда они завершатся — нужно вызвать одно из:\n  // resolve(результат) при успешном выполнении\n  // reject(ошибка) при ошибке\n})`</script></code-example><p>Универсальный метод для навешивания обработчиков:</p><code-example><script>`promise.then(onFulfilled, onRejected)`</script></code-example><ul><li><code>onFulfilled</code> – функция, которая будет вызвана с результатом при <code>resolve</code>.</li><li><code>onRejected</code> – функция, которая будет вызвана с ошибкой при <code>reject</code>.</li></ul><p>С его помощью можно назначить как оба обработчика сразу, так и только один:</p><code-example><script>`// onFulfilled сработает при успешном выполнении\npromise.then(onFulfilled)\n// onRejected сработает при ошибке\npromise.then(null, onRejected)`</script></code-example><important-><h3>.catch</h3><p>Для того, чтобы поставить обработчик только на ошибку, вместо <code>.then(null, onRejected)</code> можно написать <code>.catch(onRejected)</code> – это то же самое.</p></important-><important-><h3>Синхронный <code>throw</code> – то же самое, что <code>reject</code></h3><p>Если в функции промиса происходит синхронный <code>throw</code> (или иная ошибка), то вызывается <code>reject</code>:</p><code-example><script>`'use strict';\n\nlet p = new Promise((resolve, reject) => {\n  // то же что reject(new Error("o_O"))\n  throw new Error("o_O");\n})\n\np.catch(alert); // Error: o_O`</script><code-toolbar></code-toolbar></code-example></important-><p>Посмотрим, как это выглядит вместе, на простом примере.</p><h2><a name="1" href="#1">Пример с setTimeout</a></h2><p>Возьмём <code>setTimeout</code> в качестве асинхронной операции, которая должна через некоторое время успешно завершиться с результатом «result»:</p><code-example><script>`'use strict';\n\n// Создаётся объект promise\nlet promise = new Promise((resolve, reject) => {\n\n  setTimeout(() => {\n    // переведёт промис в состояние fulfilled с результатом "result"\n    resolve("result");\n  }, 1000);\n\n});\n\n// promise.then навешивает обработчики на успешный результат или ошибку\npromise\n  .then(\n    result => {\n      // первая функция-обработчик - запустится при вызове resolve\n      alert("Fulfilled:&nbsp" + result); // result - аргумент resolve\n    },\n    error => {\n      // вторая функция - запустится при вызове reject\n      alert("Rejected:&nbsp" + error); // error - аргумент reject\n    }\n  );`</script><code-toolbar></code-toolbar></code-example><p>В результате запуска кода выше – через 1 секунду выведется «Fulfilled: result».</p><p>А если бы вместо <code>resolve("result")</code> был вызов <code>reject("error")</code>, то вывелось бы «Rejected: error». Впрочем, как правило, если при выполнении возникла проблема, то <code>reject</code> вызывают не со строкой, а с объектом ошибки типа <code>new Error</code>:</p><code-example><script>`// Этот promise завершится с ошибкой через 1 секунду\nvar promise = new Promise((resolve, reject) => {\n\n  setTimeout(() => {\nMARK    reject(new Error("время вышло!"));\n  }, 1000);\n\n});\n\npromise\n  .then(\n    result => alert("Fulfilled:&nbsp" + result),\n    error => alert("Rejected:&nbsp" + error.message) // Rejected: время вышло!\n  );`</script><code-toolbar></code-toolbar></code-example><p>Конечно, вместо <code>setTimeout</code> внутри функции промиса может быть и запрос к серверу и ожидание ввода пользователя, или другой асинхронный процесс. Главное, чтобы по своему завершению он вызвал <code>resolve</code> или <code>reject</code>, которые передадут результат обработчикам.</p><important-><h3>Только один аргумент</h3><p>Функции <code>resolve/reject</code> принимают ровно один аргумент – результат/ошибку.</p><p>Именно он передаётся обработчикам в <code>.then</code>, как можно видеть в примерах выше.</p></important-><h2><a name="2" href="#2">Promise после reject/resolve – неизменны</a></h2><p>Заметим, что после вызова <code>resolve/reject</code> промис уже не может «передумать».</p><p>Когда промис переходит в состояние «выполнен» – с результатом (resolve) или ошибкой (reject) – это навсегда.</p><p>Например:</p><code-example><script>`'use strict';\n\nlet promise = new Promise((resolve, reject) => {\n\nMARK  // через 1 секунду готов результат: result\n  setTimeout(() => resolve("result"), 1000);\n\nMARK  // через 2 секунды — reject с ошибкой, он будет проигнорирован\n  setTimeout(() => reject(new Error("ignored")), 2000);\n\n});\n\npromise\n  .then(\n    result => alert("Fulfilled:&nbsp" + result), // сработает\n    error => alert("Rejected:&nbsp" + error) // не сработает\n  );`</script><code-toolbar></code-toolbar></code-example><p>В результате вызова этого кода сработает только первый обработчик <code>then</code>, так как после вызова <code>resolve</code> промис уже получил состояние (с результатом), и в дальнейшем его уже ничто не изменит.</p><p>Последующие вызовы resolve/reject будут просто проигнорированы.</p><p>А так – наоборот, ошибка будет раньше:</p><code-example><script>`'use strict';\n\nlet promise = new Promise((resolve, reject) => {\n\n  // reject вызван раньше, resolve будет проигнорирован\n  setTimeout(() => reject(new Error("error")), 1000);\n\n  setTimeout(() => resolve("ignored"), 2000);\n\n});\n\npromise\n  .then(\n    result => alert("Fulfilled:&nbsp" + result), // не сработает\n    error => alert("Rejected:&nbsp" + error) // сработает\n  );`</script><code-toolbar></code-toolbar></code-example><h2><a name="3" href="#3">Промисификация</a></h2><p><em>Промисификация</em> – это когда берут асинхронный функционал и делают для него обёртку, возвращающую промис.</p><p>После промисификации использование функционала зачастую становится гораздо удобнее.</p><p>В качестве примера сделаем такую обёртку для запросов при помощи XMLHttpRequest.</p><p>Функция <code>httpGet(url)</code> будет возвращать промис, который при успешной загрузке данных с <code>url</code> будет переходить в <code>fulfilled</code> с этими данными, а при ошибке – в <code>rejected</code> с информацией об ошибке:</p><code-example><script>`function httpGet(url) {\n\n  return new Promise(function(resolve, reject) {\n\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n\n    xhr.onload = function() {\n      if (this.status == 200) {\nMARK        resolve(this.response);\n      } else {\nMARK        var error = new Error(this.statusText);\nMARK        error.code = this.status;\nMARK        reject(error);\n      }\n    };\n\n    xhr.onerror = function() {\nMARK      reject(new Error("Network Error"));\n    };\n\n    xhr.send();\n  });\n}\n
httpGet("user.json")
  .then(
    response => alert('GREEN_Fulfilled:_GREEN&nbsp' +\n     JSON.stringify(JSON.parse(BROWN_\`\${response}\`_BROWN), null, 2)),
    error => alert(\`GREEN_Rejected:_GREEN \${error}\`)
  );`</script><code-toolbar></code-toolbar></code-example><p>Как видно, внутри функции объект <code>XMLHttpRequest</code> создаётся и отсылается как обычно, при <code>onload/onerror</code> вызываются, соответственно, <code>resolve</code> (при статусе 200) или <code>reject</code>.</p><important-><h3>Метод <code>fetch</code></h3><p>Заметим, что ряд современных браузеров уже поддерживает <a href="/fetch">fetch</a> – новый встроенный метод для AJAX-запросов, призванный заменить XMLHttpRequest. Он гораздо мощнее, чем <code>httpGet</code>. И – да, этот метод использует промисы. Полифилл для него доступен на <a href="https://github.com/github/fetch">https://github.com/github/fetch</a>.</p></important-><h2><a name="4" href="#4">Цепочки промисов</a></h2><p>«Чейнинг» (chaining), то есть возможность строить асинхронные цепочки из промисов – пожалуй, основная причина, из-за которой существуют и активно используются промисы.</p><p>Например, мы хотим по очереди:</p><ol><li>Загрузить данные посетителя с сервера (асинхронно).</li><li>Затем отправить запрос о нём на github (асинхронно).</li><li>Когда это будет готово, вывести его github-аватар на экран (асинхронно).</li><li>…И сделать код расширяемым, чтобы цепочку можно было легко продолжить.</li></ol><p>Вот код для этого, использующий функцию <code>httpGet</code>, описанную выше:</p><code-example><script>`<script src="http_get.js"><\/script>\n<script>\n'use strict';\n\n// сделать запрос\nhttpGet('user.json')\nMARK  // 1. Получить данные о пользователе в JSON и передать дальше\n  .then(response => {\n    console.log(response);\n    let user = JSON.parse(response);\nMARK    return user;\n  })\nMARK  // 2. Получить информацию с github\n  .then(user => {\n    console.log(user);\nMARK    return httpGet(\`GREEN_https://api.github.com/users/_GREEN\${user.name}\`);\n  })\nMARK  // 3. Вывести аватар на 3 секунды (можно с анимацией)\n  .then(githubUser => {\n    console.log(githubUser);\n    githubUser = JSON.parse(githubUser);\n\n    let img = new Image();\n    img.src = githubUser.avatar_url;\n    img.BLUE_id_BLUE = "removable";\n    img.BLUE_style_BLUE = \"border-radius:50%; position:fixed; right:0px; top:0px; z-index:10;\";\n    window.parent.document.body.appendChild(img);\n\nMARK    setTimeout(() => img.remove(), 3000); // (*)\n  });\n<\/script>`</script><code-toolbar-><a title="показать" data-code_run=""></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><p>Самое главное в этом коде – последовательность вызовов:</p><code-example><script>`httpGet(...)\n  .then(...)\n  .then(...)\n  .then(...)`</script></code-example><p>При чейнинге, то есть последовательных вызовах <code>.then…then…then</code>, в каждый следующий <code>then</code> переходит результат от предыдущего. Вызовы <code>console.log</code> оставлены, чтобы при запуске можно было посмотреть конкретные значения, хотя они здесь и не очень важны.</p><p><strong>Если очередной <code>then</code> вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат.</strong></p><p>В коде выше:</p><ol><li>Функция в первом <code>then</code> возвращает «обычное» значение <code>user</code>. Это значит, что <code>then</code> возвратит промис в состоянии «выполнен» с <code>user</code> в качестве результата. Он станет аргументом в следующем <code>then</code>.</li><li>Функция во втором <code>then</code> возвращает промис (результат нового вызова <code>httpGet</code>). Когда он будет завершён (может пройти какое-то время), то будет вызван следующий <code>then</code> с его результатом.</li><li>Третий <code>then</code> ничего не возвращает.</li></ol><p>Схематично его работу можно изобразить так:</p><figure><img src="promiseUserFlow.png" style="max-width:479px" width="100%"></figure><p>Значком «песочные часы» помечены периоды ожидания, которых всего два: в исходном <code>httpGet</code> и в подвызове далее по цепочке.</p><p>Если <code>then</code> возвращает промис, то до его выполнения может пройти некоторое время, оставшаяся часть цепочки будет ждать.</p><p>То есть, логика довольно проста:</p><ul><li>В каждом <code>then</code> мы получаем текущий результат работы.</li><li>Можно его обработать синхронно и вернуть результат (например, применить <code>JSON.parse</code>). Или же, если нужна асинхронная обработка – инициировать её и вернуть промис.</li></ul><p>Обратим внимание, что последний <code>then</code> в нашем примере ничего не возвращает. Если мы хотим, чтобы после <code>setTimeout</code><code>(*)</code> асинхронная цепочка могла быть продолжена, то последний <code>then</code> тоже должен вернуть промис. Это общее правило: если внутри <code>then</code> стартует новый асинхронный процесс, то для того, чтобы оставшаяся часть цепочки выполнилась после его окончания, мы должны вернуть промис.</p><p>В данном случае промис должен перейти в состояние «выполнен» после срабатывания <code>setTimeout</code>.</p><p>Строку <code>(*)</code> для этого нужно переписать так:</p><code-example><script>`.then(githubUser => {\n  ...\n\n  // вместо setTimeout(() => img.remove(), 3000); (*)\n\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      img.remove();\n      // после таймаута — вызов resolve,\n      // можно без результата, чтобы управление перешло в следующий then\n      // (или можно передать данные пользователя дальше по цепочке)\nMARK      resolve();\n    }, 3000);\n  });\n})`</script></code-example><p>Теперь, если к цепочке добавить ещё <code>then</code>, то он будет вызван после окончания <code>setTimeout</code>.</p><h2><a name="5" href="#5">Перехват ошибок</a></h2><p>Выше мы рассмотрели «идеальный случай» выполнения, когда ошибок нет.</p><p>А что, если github не отвечает? Или JSON.parse бросил синтаксическую ошибку при обработке данных?</p><p>Да мало ли, где ошибка…</p><p>Правило здесь очень простое.</p><p><strong>При возникновении ошибки – она отправляется в ближайший обработчик <code>onRejected</code>.</strong></p><p>Такой обработчик нужно поставить через второй аргумент <code>.then(..., onRejected)</code> или, что то же самое, через <code>.catch(onRejected)</code>.</p><p>Чтобы поймать всевозможные ошибки, которые возникнут при загрузке и обработке данных, добавим <code>catch</code> в конец нашей цепочки:</p><code-example><script>`<script src="http_get.js"><\/script>\n<script>\n'use strict';\n\nMARK// в httpGet обратимся к несуществующей странице\nhttpGet('/page-not-exists')\n  .then(response => JSON.parse(response))\n  .then(user => httpGet(\`GREEN_https://api.github.com/users/_GREEN\${user.name}\`))\n  .then(githubUser => {\n    githubUser = JSON.parse(githubUser);\n\n    let img = new Image();\n    img.src = githubUser.avatar_url;\n    img.className = \"promise-avatar-example\";\n    document.body.appendChild(img);\n\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        img.remove();\n        resolve();\n      }, 3000);\n    });\n  })\nMARK  .catch(error => {\nMARK    alert(error); // Error: Not Found\nMARK  });\n<\/script>`</script><code-toolbar></code-toolbar></code-example><p>В примере выше ошибка возникает в первом же <code>httpGet</code>, но <code>catch</code> с тем же успехом поймал бы ошибку во втором <code>httpGet</code> или в <code>JSON.parse</code>.</p><p>Принцип очень похож на обычный <code>try..catch</code>: мы делаем асинхронную цепочку из <code>.then</code>, а затем, в том месте кода, где нужно перехватить ошибки, вызываем <code>.catch(onRejected)</code>.</p><important-><h3>А что после <code>catch</code>?</h3><p>Обработчик <code>.catch(onRejected)</code> получает ошибку и должен обработать её.</p><p>Есть два варианта развития событий:</p><ol><li>Если ошибка не критичная, то <code>onRejected</code> возвращает значение через <code>return</code>, и управление переходит в ближайший <code>.then(onFulfilled)</code>.</li><li>Если продолжить выполнение с такой ошибкой нельзя, то он делает <code>throw</code>, и тогда ошибка переходит в следующий ближайший <code>.catch(onRejected)</code>.</li></ol><p>Это также похоже на обычный <code>try..catch</code> – в блоке <code>catch</code> ошибка либо обрабатывается, и тогда выполнение кода продолжается как обычно, либо он делает <code>throw</code>. Существенное отличие – в том, что промисы асинхронные, поэтому при отсутствии внешнего <code>.catch</code> ошибка не «вываливается» в консоль и не «убивает» скрипт.</p><p>Ведь возможно, что новый обработчик <code>.catch</code> будет добавлен в цепочку позже.</p></important-><h2><a name="6" href="#6">Промисы в деталях</a></h2><p>Самым основным источником информации по промисам является, разумеется, <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise-objects">стандарт</a>.</p><p>Чтобы наше понимание промисов было полным, и мы могли с лёгкостью разрешать сложные ситуации, посмотрим внимательнее, что такое промис и как он работает, но уже не в общих словах, а детально, в соответствии со стандартом ECMAScript.</p><p>Согласно стандарту, у объекта <code>new Promise(executor)</code> при создании есть четыре внутренних свойства:</p><ul><li><code>PromiseState</code> – состояние, вначале «pending».</li><li><code>PromiseResult</code> – результат, при создании значения нет.</li><li><code>PromiseFulfillReactions</code> – список функций-обработчиков успешного выполнения.</li><li><code>PromiseRejectReactions</code> – список функций-обработчиков ошибки.</li></ul><figure><img src="promise/promiseEcma.png" style="max-width:333px" width="100%"></figure><p>Когда функция-executor вызывает <code>reject</code> или <code>resolve</code>, то <code>PromiseState</code> становится <code>"resolved"</code> или <code>"rejected"</code>, а все функции-обработчики из соответствующего списка перемещаются в специальную системную очередь <code>"PromiseJobs"</code>.</p><p>Эта очередь автоматически выполняется, когда интерпретатору «нечего делать». Иначе говоря, все функции-обработчики выполнятся асинхронно, одна за другой, по завершении текущего кода, примерно как <code>setTimeout(..,0)</code>.</p><p>Исключение из этого правила – если <code>resolve</code> возвращает другой <code>Promise</code>. Тогда дальнейшее выполнение ожидает его результата (в очередь помещается специальная задача), и функции-обработчики выполняются уже с ним.</p><p>Добавляет обработчики в списки один метод: <code>.then(onResolved, onRejected)</code>. Метод <code>.catch(onRejected)</code> – всего лишь сокращённая запись <code>.then(null, onRejected)</code>.</p><p>Он делает следующее:</p><ul><li>Если <code>PromiseState == "pending"</code>, то есть промис ещё не выполнен, то обработчики добавляются в соответствующие списки.</li><li>Иначе обработчики сразу помещаются в очередь на выполнение.</li></ul><p>Здесь важно, что обработчики можно добавлять в любой момент. Можно до выполнения промиса (они подождут), а можно – после (выполнятся в ближайшее время, через асинхронную очередь).</p><p>Например:</p><code-example><script>`// Промис выполнится сразу же\nvar promise = new Promise((resolve, reject) => resolve(1));\n\n// PromiseState = "resolved"\n// PromiseResult = 1\n\n// Добавили обработчик к выполненному промису\npromise.then(alert); // ...он сработает тут же`</script><code-toolbar></code-toolbar></code-example><p>Разумеется, можно добавлять и много обработчиков на один и тот же промис:</p><code-example><script>`// Промис выполнится сразу же\nvar promise = new Promise((resolve, reject) => resolve(1));\n\npromise.then( function f1(result) {\nMARK  alert(result); // 1\n  return 'f1';\n})\n\npromise.then( function f2(result) {\nMARK  alert(result); // 1\n  return 'f2';\n})`</script><code-toolbar></code-toolbar></code-example><p>Вид объекта <code>promise</code> после этого:</p><figure><img src="promiseTwo.png" style="max-width:409px" width="100%"></figure><p>На этой иллюстрации можно увидеть добавленные нами обработчики <code>f1</code>, <code>f2</code>, а также – автоматически добавленные обработчики ошибок <code>"Thrower"</code>.</p><p>Дело в том, что <code>.then</code>, если один из обработчиков не указан, добавляет его «от себя», следующим образом:</p><ul><li>Для успешного выполнения – функция <code>Identity</code>, которая выглядит как <code>arg =&gt; arg</code>, то есть возвращает аргумент без изменений.</li><li>Для ошибки – функция <code>Thrower</code>, которая выглядит как <code>arg =&gt; throw arg</code>, то есть генерирует ошибку.</li></ul><p>Это, по сути дела, формальность, но без неё некоторые особенности поведения промисов могут «не сойтись» в общую логику, поэтому мы упоминаем о ней здесь.</p><p>Обратим внимание, в этом примере намеренно <em>не используется чейнинг</em>. То есть, обработчики добавляются именно на один и тот же промис.</p><p>Поэтому оба <code>alert</code> выдадут одно значение <code>1</code>.</p><p>Все функции из списка обработчиков вызываются с результатом промиса, одна за другой. Никакой передачи результатов между обработчиками в рамках одного промиса нет, а сам результат промиса ( <code>PromiseResult</code>) после установки не меняется.</p><p>Поэтому, чтобы продолжить работу с результатом, используется чейнинг.</p><p><strong>Для того, чтобы результат обработчика передать следующей функции, <code>.then</code> создаёт новый промис и возвращает его.</strong></p><p>В примере выше создаётся два таких промиса (т.к. два вызова <code>.then</code>), каждый из которых даёт свою ветку выполнения:</p><figure><img src="promiseTwoThen.png" style="max-width:566px" width="100%"></figure><p>Изначально эти новые промисы – «пустые», они ждут. Когда в будущем выполнятся обработчики <code>f1, f2</code>, то их результат будет передан в новые промисы по стандартному принципу:</p><ul><li>Если вернётся обычное значение (не промис), новый промис перейдёт в <code>"resolved"</code> с ним.</li><li>Если был <code>throw</code>, то новый промис перейдёт в состояние <code>"rejected"</code> с ошибкой.</li><li>Если вернётся промис, то используем его результат (он может быть как <code>resolved</code>, так и <code>rejected</code>).</li></ul><figure><img src="promise/promiseHandlerVariants.png" style="max-width:665px" width="100%"></figure><p>Дальше выполнятся уже обработчики на новом промисе, и так далее.</p><p>Чтобы лучше понять происходящее, посмотрим на цепочку, которая получается в процессе написания кода для показа github-аватара.</p><p>Первый промис и обработка его результата:</p><code-example><script>`httpGet('/promise/user.json')\n  .then(JSON.parse)`</script></code-example><figure><img src="promiseLoadAvatarChain-1.png" style="max-width:641px" width="100%"></figure><p>Если промис завершился через <code>resolve</code>, то результат – в <code>JSON.parse</code>, если <code>reject</code> – то в Thrower.</p><p>Как было сказано выше, <code>Thrower</code> – это стандартная внутренняя функция, которая автоматически используется, если второй обработчик не указан.</p><p>Можно считать, что второй обработчик выглядит так:</p><code-example><script>`httpGet('/promise/user.json')\n  .then(JSON.parse, HIGHerr => throw errLIGHT)`</script></code-example><p>Заметим, что когда обработчик в промисах делает <code>throw</code> – в данном случае, при ошибке запроса, то такая ошибка не «валит» скрипт и не выводится в консоли. Она просто будет передана в ближайший следующий обработчик <code>onRejected</code>.</p><p>Добавим в код ещё строку:</p><code-example><script>`httpGet('user.json')\n  .then(JSON.parse)\nMARK  .then(user => httpGet(\`GREEN_https://api.github.com/users/_GREEN\${user.name}\`))`</script></code-example><p>Цепочка «выросла вниз»:</p><figure><img src="promiseLoadAvatarChain-2.png" style="max-width:641pz" width="100%"></figure><p>Функция <code>JSON.parse</code> либо возвращает объект с данными, либо генерирует ошибку (что расценивается как <code>reject</code>).</p><p>Если всё хорошо, то <code>then(user =&gt; httpGet(…))</code> вернёт новый промис, на который стоят уже два обработчика:</p><code-example><script>`httpGet('user.json')\n  .then(JSON.parse)\n  .then(user => httpGet(\`GREEN_https://api.github.com/users/_GREEN\${user.name}\`))\n  .then(\nMARK    JSON.parse,\nMARK    function avatarError(error) {\nMARK      if (error.code == 404) {\nMARK        return {name: "NoGithub", avatar_url: 'anon.png'};\nMARK      } else {\nMARK        throw error;\nMARK      }\nMARK    }\n  })`</script></code-example><figure><img src="promiseLoadAvatarChain-3.png" style="max-width:641px" width="100%"></figure><p>Наконец-то хоть какая-то обработка ошибок!</p><p>Обработчик <code>avatarError</code> перехватит ошибки, которые были ранее. Функция <code>httpGet</code> при генерации ошибки записывает её HTTP-код в свойство <code>error.code</code>, так что мы легко можем понять – что это:</p><ul><li>Если страница на Github не найдена – можно продолжить выполнение, используя «аватар по умолчанию»</li><li>Иначе – пробрасываем ошибку дальше.</li></ul><p>Итого, после добавления оставшейся части цепочки, картина получается следующей:</p><code-example><script>`<script src="http_get.js"><\/script>\n<script>\n'use strict';\n\nhttpGet('userNoGithub.json')\n  .then(JSON.parse)\n  .then(user => httpGet(\`GREEN_https://api.github.com/users/_GREEN\${user.name}\`))\n  .then(\n    JSON.parse,\n    function githubError(error) {\n      if (error.code == 404) {\n        return {name: "NoGithub", avatar_url: 'anon.png'};\n      } else {\n        throw error;\n      }\n    }\n  )\n  .then(function showAvatar(githubUser) {\n    let img = new Image();\n    img.src = githubUser.avatar_url;\n    img.BLUE_id_BLUE = "removable";\n    img.BLUE_style_BLUE = "position:fixed; right:0px; top:0px; z-index:10;";\n    window.parent.document.body.appendChild(img);\n    setTimeout(() => img.remove(), 3000);\n  })\n  .catch(function genericError(error) {\n    alert(error); // Error: Not Found\n  });<\/script>`</script><code-toolbar></code-toolbar></code-example><figure><img src="promiseLoadAvatarChain-4.png" stylel="max-width:641px" width="100%"></figure><p>В конце срабатывает общий обработчик <code>genericError</code>, который перехватывает любые ошибки. В данном случае ошибки, которые в него попадут, уже носят критический характер, что-то серьёзно не так. Чтобы посетитель не удивился отсутствию информации, мы показываем ему сообщение об этом.</p><p>Можно и как-то иначе вывести уведомление о проблеме, главное – не забыть обработать ошибки в конце. Если последнего <code>catch</code> не будет, а цепочка завершится с ошибкой, то посетитель об этом не узнает.</p><p>В консоли тоже ничего не будет, так как ошибка остаётся «внутри» промиса, ожидая добавления следующего обработчика <code>onRejected</code>, которому будет передана.</p><p>Итак, мы рассмотрели основные приёмы использования промисов. Далее – посмотрим некоторые полезные вспомогательные методы.</p><h2><a name="7" href="#7">Параллельное выполнение</a></h2><p>Что, если мы хотим осуществить несколько асинхронных процессов одновременно и обработать их результат?</p><p>В классе <code>Promise</code> есть следующие статические методы.</p><h3><a name="18" href="#18">Promise.all(iterable)</a></h3><p>Вызов <code>Promise.all(iterable)</code> получает массив (или другой итерируемый объект) промисов и возвращает промис, который ждёт, пока все переданные промисы завершатся, и переходит в состояние «выполнено» с массивом их результатов.</p><p>Например:</p><code-example><script>`<script src = "http_get.js"><\/script>\n<script>\nPromise.all([\n  httpGet('user.json'),\n  httpGet('guest.json')\n]).then(results => {\n  alert(JSON.stringify(JSON.parse(results[0]), null, 2) + ',\\n' +\n   JSON.stringify(JSON.parse(results[1]), null, 2));\n});\n<\/script>`</script><code-toolbar></code-toolbar></code-example><p>Допустим, у нас есть массив с URL.</p><code-example><script>`let urls = [\n  '/promise/user.json',\n  '/promise/guest.json'\n];`</script></code-example><p>Чтобы загрузить их параллельно, нужно:</p><ol><li>Создать для каждого URL соответствующий промис.</li><li>Обернуть массив таких промисов в <code>Promise.all</code>.</li></ol><p>Получится так:</p><code-example><script>`<script src = "http_get.js"><\/script>\n<script>\n'use strict';\n\nlet urls = [\n  'user.json',\n  'guest.json'\n];\n\nMARKPromise.all( urls.map(httpGet) )\n  .then(results => {\n    alert(JSON.stringify(JSON.parse(results[0]), null, 2) + ',\\n' +\n   JSON.stringify(JSON.parse(results[1]), null, 2));\n});\n<\/script>`</script><code-toolbar></code-toolbar></code-example><p>Заметим, что если какой-то из промисов завершился с ошибкой, то результатом <code>Promise.all</code> будет эта ошибка. При этом остальные промисы игнорируются.</p><p>Например:</p><code-example><script>`<script src = "http_get.js"><\/script>\n<script>\nPromise.all([\n  httpGet('user.json'),\n  httpGet('guest.json'),\n  httpGet('no-such-page.json') // (нет такой страницы)\n]).then(\n  result => alert("не сработает"),\n  error => alert("Ошибка:&nbsp" + error.message) // Ошибка: Not Found\n);\n<\/script>`</script><code-toolbar></code-toolbar></code-example><h3><a name="19" href="#19">Promise.race(iterable)</a></h3><p>Вызов <code>Promise.race</code>, как и <code>Promise.all</code>, получает итерируемый объект с промисами, которые нужно выполнить, и возвращает новый промис.</p><p>Но, в отличие от <code>Promise.all</code>, результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются.</p><p>Например:</p><code-example><script>`<script src = "http_get.js"><\/script>\n<script>\nPromise.race([\n  httpGet('user.json'),\n  httpGet('guest.json')\n]).then(firstResult => {\n  firstResult = JSON.parse(firstResult);\n  alert( firstResult.name ); // iliakan или guest, смотря что загрузится раньше\n});\n<\/script>`</script><code-toolbar></code-toolbar></code-example><h2><a name="8" href="#8">Promise.resolve(value)</a></h2><p>Вызов <code>Promise.resolve(value)</code> создаёт успешно выполнившийся промис с результатом <code>value</code>.</p><p>Он аналогичен конструкции:</p><code-example><script>`new Promise((resolve) => resolve(value))`</script></code-example><p><code>Promise.resolve</code> используют, когда хотят построить асинхронную цепочку, и начальный результат уже есть.</p><p>Например:</p><code-example><script>`<script src = "http_get.js"><\/script>\n<script>\n  Promise.resolve(window.location) // начать с этого значения\n   .then(httpGet) // вызвать для него httpGet\n   .then(alert) // и вывести результат\n<\/script>`</script><code-toolbar></code-toolbar></code-example><h2><a name="9" href="#9">Promise.reject(error)</a></h2><p>Аналогично <code>Promise.resolve(value)</code> создаёт уже выполнившийся промис, но не с успешным результатом, а с ошибкой <code>error</code>.</p><p>Например:</p><code-example><script>`Promise.reject(new Error("..."))\n  .catch(alert) // Error: ...`</script><code-toolbar></code-toolbar></code-example><p>Метод <code>Promise.reject</code> используется очень редко, гораздо реже чем <code>resolve</code>, потому что ошибка возникает обычно не в начале цепочки, а в процессе её выполнения.</p><h2><a name="10" href="#10">Итого</a></h2><ul><li>Промис – это специальный объект, который хранит своё состояние, текущий результат (если есть) и коллбэки.</li><li>При создании <code>new Promise((resolve, reject) =&gt; ...)</code> автоматически запускается функция-аргумент, которая должна вызвать <code>resolve(result)</code> при успешном выполнении и <code>reject(error)</code> – при ошибке.</li><li>Аргумент <code>resolve/reject</code> (только первый, остальные игнорируются) передаётся обработчикам на этом промисе.</li><li>Обработчики назначаются вызовом <code>.then/catch</code>.</li><li>Для передачи результата от одного обработчика к другому используется чейнинг.</li></ul><p>У промисов есть некоторые ограничения. В частности, стандарт не предусматривает какой-то метод для «отмены» промиса, хотя в ряде ситуаций (http-запросы) это было бы довольно удобно. Возможно, он появится в следующей версии стандарта JavaScript.</p><p>В современной JavaScript-разработке сложные цепочки с промисами используются редко, так как они куда проще описываются при помощи генераторов с библиотекой <code>co</code>, которые рассмотрены в <a data-load_page="95">соответствующей главе</a>. Можно сказать, что промисы лежат в основе более продвинутых способов асинхронной разработки.</p><h2 id="tasks"><a href="#11" name="11">Задачи (2)</a></h2><task-content><h3><a href="#20" name="20">Промисифицировать setTimeout</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><p>Напишите функцию <code>delay(ms)</code>, которая возвращает промис, переходящий в состояние <code>"resolved"</code> через <code>ms</code> миллисекунд.</p><p>Пример использования:</p><code-example><script>`delay(1000)\n  .then(() => alert("Hello!"))`</script></code-example><p>Такая функция полезна для использования в других промис-цепочках.</p><p>Вот такой вызов:</p><code-example><script>`return new Promise((resolve, reject) => {\n  setTimeout(() => {\n    doSomeThing();\n    resolve();\n  }, ms)\n});`</script></code-example><p>Станет возможным переписать так:</p><code-example><script>`return delay(ms).then(doSomething);`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`function delay(ms) {\n  return new Promise((resolve, reject) => {\n    setTimeout(resolve, ms);\n  });\n}`</script></code-example></task-answer></task-content><task-content><h3><a href="#21" name="21">Загрузить массив последовательно</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><p>Есть массив URL:</p><code-example><script>`'use strict';\n\nlet urls = [\n  'user.json',\n  'guest.json'\n];`</script></code-example><p>Напишите код, который все URL из этого массива загружает – один за другим (последовательно), и сохраняет результаты в массиве <code>results</code>, а потом выводит.</p><p>Вариант с параллельной загрузкой выглядел бы так:</p><code-example><script>`Promise.all( urls.map(httpGet) )\n  .then(alert);`</script></code-example><p>В этой задаче загрузку нужно реализовать последовательно.</p><p><a href="http://plnkr.co/edit/u1fYDw9KyRW5tl5qMzbc?p=preview" target="_blank" data-plunk-id="u1fYDw9KyRW5tl5qMzbc">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Для последовательной загрузки нужно организовать промисы в цепочку, чтобы они выполнялись строго – один после другого.</p><p>Вот код, который это делает:</p><code-example><script>`// начало цепочки\nlet chain = Promise.resolve();\n\nlet results = [];\n\n// в цикле добавляем задачи в цепочку\nurls.forEach(function(url) {\n  chain = chain\n    .then(() => httpGet(url))\n    .then((result) => {\n      results.push(result);\n    });\n});\n\n// в конце — выводим результаты\nchain.then(() => {\n  alert(results);\n});`</script></code-example><p>Использование <code>Promise.resolve()</code> как начала асинхронной цепочки – очень распространённый приём.</p><p><a href="http://plnkr.co/edit/pzWpd9418pnVJxlvK4SV?p=preview" target="_blank" data-plunk-id="pzWpd9418pnVJxlvK4SV">Открыть решение в песочнице.</a></p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Set, Map, WeakSet и WeakMap; Генераторы"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/promise",disqus_identifier="promise",disqus_title="Promise";</script></page-content></main>