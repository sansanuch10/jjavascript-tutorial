<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="83">Современные возможности ES-2015</a></nav-up><h1>Переменные: let и const</h1><p>В ES-2015 предусмотрены новые способы объявления переменных: через <code>let</code> и <code>const</code> вместо <code>var</code>.</p><p>Например:</p><code-example><script>`let a = 5;`</script></code-example><h2><a name="0" href="#0">let</a></h2><p>У объявлений переменной через <code>let</code> есть три основных отличия от <code>var</code>:</p><ol><li><p><strong>Область видимости переменной <code>let</code> – блок <code>{...}</code>.</strong></p><p>Как мы помним, переменная, объявленная через <code>var</code>, видна везде в функции.</p><p>Переменная, объявленная через <code>let</code>, видна только в рамках блока <code>{...}</code>, в котором объявлена.</p><p>Это, в частности, влияет на объявления внутри <code>if</code>, <code>while</code> или <code>for</code>.</p><p>Например, переменная через <code>var</code>:</p><code-example><script>`var apples = 5;\n\nif (true) {\n  var apples = 10;\n\n  alert(apples); // 10 (внутри блока)\n}\n\nalert(apples); // 10 (снаружи блока то же самое)`</script><code-toolbar></code-toolbar></code-example><p>В примере выше <code>apples</code> – одна переменная на весь код, которая модифицируется в <code>if</code>.</p><p>То же самое с <code>let</code> будет работать по-другому:</p><code-example><script>`let apples = 5; // (*)\n\nif (true) {\n  let apples = 10;\n\n  alert(apples); // 10 (внутри блока)\n}\n\nMARKalert(apples); // 5 (снаружи блока значение не изменилось)`</script><code-toolbar></code-toolbar></code-example><p>Здесь, фактически, две независимые переменные <code>apples</code>, одна – глобальная, вторая – в блоке <code>if</code>.</p><p>Заметим, что если объявление <code>let apples</code> в первой строке <code>(*)</code> удалить, то в последнем <code>alert</code> будет ошибка: переменная не определена:</p><code-example><script>`if (true) {\n  let apples = 10;\n\n  alert(apples); // 10 (внутри блока)\n}\n\nMARKalert(apples); // ошибка!`</script><code-toolbar></code-toolbar></code-example><p>Это потому что переменная <code>let</code> всегда видна именно в том блоке, где объявлена, и не более.</p></li><li><p><strong>Переменная <code>let</code> видна только после объявления.</strong></p><p>Как мы помним, переменные <code>var</code> существуют и до объявления. Они равны <code>undefined</code>:</p><code-example><script>`alert(a); // undefined\n\nvar a = 5;`</script><code-toolbar></code-toolbar></code-example><p>С переменными <code>let</code> всё проще. До объявления их вообще нет.</p><p>Такой доступ приведёт к ошибке:</p><code-example><script>`MARKalert(a); // ошибка, нет такой переменной\n\nlet a = 5;`</script><code-toolbar></code-toolbar></code-example><p>Заметим также, что переменные <code>let</code> нельзя повторно объявлять. То есть, такой код выведет ошибку:</p><code-example><script>`let x;\nlet x; // ошибка: переменная x уже объявлена`</script><code-toolbar></code-toolbar></code-example><p>Это – хоть и выглядит ограничением по сравнению с <code>var</code>, но на самом деле проблем не создаёт. Например, два таких цикла совсем не конфликтуют:</p><code-example><script>`// каждый цикл имеет свою переменную i\nfor(let i = 0; i<10; i++) { /* … */ }\nfor(let i = 0; i<10; i++) { /* … */ }\n\nalert( i ); // ошибка: глобальной i нет`</script><code-toolbar></code-toolbar></code-example><p>При объявлении внутри цикла переменная <code>i</code> будет видна только в блоке цикла. Она не видна снаружи, поэтому будет ошибка в последнем <code>alert</code>.</p></li><li><p><strong>При использовании в цикле, для каждой итерации создаётся своя переменная.</strong></p><p>Переменная <code>var</code> – одна на все итерации цикла и видна даже после цикла:</p><code-example><script>`for(var i=0; i<10; i++) { /* … */ }\n\nalert(i); // 10`</script><code-toolbar></code-toolbar></code-example><p>С переменной <code>let</code> – всё по-другому.</p><p>Каждому повторению цикла соответствует своя независимая переменная <code>let</code>. Если внутри цикла есть вложенные объявления функций, то в замыкании каждой будет та переменная, которая была при соответствующей итерации.</p><p>Это позволяет легко решить классическую проблему с замыканиями, описанную в задаче <a href="/task/make-army">Армия функций</a>.</p><code-example><script>`function makeArmy() {\n\n  let shooters = [];\n\n  for (HIGHletLIGHT i = 0; i < 10; i++) {\n shooters.push(function() {\n alert( i ); // выводит свой номер\n });\n  }\n\n  return shooters;\n}\nvar army = makeArmy();\n\narmy[0](); // 0\narmy[5](); // 5`</script><code-toolbar></code-toolbar></code-example><p>Если бы объявление было <code>var i</code>, то была бы одна переменная <code>i</code> на всю функцию, и вызовы в последних строках выводили бы <code>10</code> (подробнее – см. задачу <a href="/task/make-army">Армия функций</a>).</p><p>А выше объявление <code>let i</code> создаёт для каждого повторения блока в цикле свою переменную, которую функция и получает из замыкания в последних строках.</p></li></ol><h2><a name="1" href="#1">const</a></h2><p>Объявление <code>const</code> задаёт константу, то есть переменную, которую нельзя менять:</p><code-example><script>`const apple = 5;\napple = 10; // ошибка`</script><code-toolbar></code-toolbar></code-example><p>В остальном объявление <code>const</code> полностью аналогично <code>let</code>.</p><p>Заметим, что если в константу присвоен объект, то от изменения защищена сама константа, но не свойства внутри неё:</p><code-example><script>`const user = {\n  name: "Вася"\n};\n\nuser.name = "Петя"; // допустимо\nuser = 5; // нельзя, будет ошибка`</script></code-example><p>То же самое верно, если константе присвоен массив или другое объектное значение.</p><important-><h3>константы и КОНСТАНТЫ</h3><p>Константы, которые жёстко заданы всегда, во время всей программы, обычно пишутся в верхнем регистре. Например: <code>const ORANGE = "#ffa500"</code>.</p><p>Большинство переменных – константы в другом смысле: они не меняются после присвоения. Но при разных запусках функции это значение может быть разным. Для таких переменных можно использовать <code>const</code> и обычные строчные буквы в имени.</p></important-><h2><a name="2" href="#2">Итого</a></h2><p>Переменные <code>let</code>:</p><ul><li>Видны только после объявления и только в текущем блоке.</li><li>Нельзя переобъявлять (в том же блоке).</li><li>При объявлении переменной в цикле <code>for(let …)</code> – она видна только в этом цикле. Причём каждой итерации соответствует своя переменная <code>let</code>.</li></ul><p>Переменная <code>const</code> – это константа, в остальном – как <code>let</code>.</p><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="ES-2015 сейчас; Деструктуризация"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/let-const", disqus_identifier = "let-const", disqus_title = "\u041f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435: let \u0438 const";</script></page-content></main>