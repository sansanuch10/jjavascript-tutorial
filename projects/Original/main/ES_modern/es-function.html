<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="83">Современные возможности ES-2015</a></nav-up><h1>Функции</h1><p>В функциях основные изменения касаются передачи параметров, плюс введена дополнительная короткая запись через стрелочку <code>=&gt;</code>.</p><h2><a name="0" href="#0">Параметры по умолчанию</a></h2><p>Можно указывать параметры по умолчанию через равенство <code>=</code>, например:</p><code-example><script>`function showMenu(title = "Без заголовка", width = 100, height = 200) {\n  alert(title + '&nbsp' + width + '&nbsp' + height);\n}\n\nshowMenu("Меню"); // Меню 100 200`</script><code-toolbar></code-toolbar></code-example><p>Параметр по умолчанию используется при отсутствующем аргументе или равном <code>undefined</code>, например:</p><code-example><script>`function showMenu(title = "Заголовок", width = 100, height = 200) {\n  alert(' title =&nbsp' + title + ', width =&nbsp' + width + ', height =&nbsp' + height);\n}\n\n// По умолчанию будут взяты 1 и 3 параметры\n// title=Заголовок width=null height=200\nshowMenu(undefined, null);`</script><code-toolbar></code-toolbar></code-example><p>При передаче любого значения, кроме <code>undefined</code>, включая пустую строку, ноль или <code>null</code>, параметр считается переданным, и значение по умолчанию не используется.</p><p><strong>Параметры по умолчанию могут быть не только значениями, но и выражениями.</strong></p><p>Например:</p><code-example><script>`function sayHi(who = getCurrentUser().toUpperCase()) {\n  alert('Привет,&nbsp' + who);\n}\n\nfunction getCurrentUser() {\n  return 'Вася';\n}\n\nsayHi(); // Привет, ВАСЯ`</script><code-toolbar></code-toolbar></code-example><p>Заметим, что значение выражения <code>getCurrentUser().toUpperCase()</code> будет вычислено, и соответствующие функции вызваны – лишь в том случае, если это необходимо, то есть когда функция вызвана без параметра.</p><p>В частности, выражение по умолчанию не вычисляется при объявлении функции. В примере выше функция <code>getCurrentUser()</code> будет вызвана именно в последней строке, так как не передан параметр.</p><h2><a name="1" href="#1">Оператор spread вместо arguments</a></h2><p>Чтобы получить массив аргументов, можно использовать оператор <code>…</code>, например:</p><code-example><script>`function showName(firstName, lastName, HIGH...restLIGHT) {\n  alert(firstName + '&nbsp' + lastName + ' -&nbsp' + rest);\n}\n\n// выведет: Юлий Цезарь - Император,Рима\nshowName("Юлий", "Цезарь", "Император", "Рима");`</script><code-toolbar></code-toolbar></code-example><p>В <code>rest</code> попадёт массив всех аргументов, начиная с третьего.</p><p>Заметим, что <code>rest</code> – настоящий массив, с методами <code>map</code>, <code>forEach</code> и другими, в отличие от <code>arguments</code>.</p><important-warn><h3>Оператор … должен быть в конце</h3><p>Оператор <code>…</code> собирает «все оставшиеся» аргументы, поэтому такое объявление не имеет смысла:</p><code-example><script>`function f(arg1, ...rest, arg2) { // arg2 после ...rest ?!\n  // будет ошибка\n}`</script></code-example><p>Параметр <code>...rest</code> должен быть в конце функции.</p></important-warn><p>Выше мы увидели использование <code>...</code> для чтения параметров в объявлении функции. Но этот же оператор можно использовать и при вызове функции, для передачи массива параметров как списка, например:</p><code-example><script>`'use strict';\n\nlet numbers = [2, 3, 15];\n\n// Оператор ... в вызове передаст массив как список аргументов\n// Этот вызов аналогичен Math.max(2, 3, 15)\nlet max = Math.max(HIGH...numbersLIGHT);\n\nalert( max ); // 15`</script><code-toolbar></code-toolbar></code-example><p>Формально говоря, эти два вызова делают одно и то же:</p><code-example><script>`Math.max(...numbers);\nMath.max.apply(Math, numbers);`</script></code-example><p>Похоже, что первый – короче и красивее.</p><h2><a name="2" href="#2">Деструктуризация в параметрах</a></h2><p>Если функция получает объект, то она может его тут же разбить в переменные:</p><code-example><script>`'use strict';\n\nlet options = {\n  BLUE_title_BLUE: "Меню",\n  width: 100,\n  height: 200\n};\n\nMARKfunction showMenu({title, width, height}) {\n  alert(title + '&nbsp' + width + '&nbsp' + height); // Меню 100 200\n}\n\nshowMenu(options);`</script><code-toolbar></code-toolbar></code-example><p>Можно использовать и более сложную деструктуризацию, с соответствиями и значениями по умолчанию:</p><code-example><script>`'use strict';\n\nlet options = {\n  title: "Меню"\n};\n\nMARKfunction showMenu({title= "Заголовок", width:w=100, height:h=200}) {\n  alert(title + '&nbsp' + w + '&nbsp' + h);\n}\n\n// объект options будет разбит на переменные\nshowMenu(options); // Меню 100 200`</script><code-toolbar></code-toolbar></code-example><p>Заметим, что в примере выше какой-то аргумент у <code>showMenu()</code> обязательно должен быть, чтобы разбить его на переменные.</p><p>Если хочется, чтобы функция могла быть вызвана вообще без аргументов – нужно добавить ей параметр по умолчанию – уже не внутрь деструктуризации, а в самом списке аргументов:</p><code-example><script>`'use strict';\n\nfunction showMenu({title= "Заголовок", width:w=100, height:h=200} = {}) {\n  alert(title + '&nbsp' + w + '&nbsp' + h);\n}\n\nshowMenu(); // Заголовок 100 200`</script><code-toolbar></code-toolbar></code-example><p>В коде выше весь объект аргументов по умолчанию равен пустому объекту <code>{}</code>, поэтому всегда есть что деструктурировать.</p><h2><a name="3" href="#3">Имя «name»</a></h2><p>В свойстве <code>name</code> у функции находится её имя.</p><p>Например:</p><code-example><script>`'use strict';\n\nfunction f() {} // f.name == "f"\n\nlet g = function g() {}; // g.name == "g"\n\nalert(f.name + '&nbsp' + g.name) // f g`</script><code-toolbar></code-toolbar></code-example><p>В примере выше показаны Function Declaration и Named Function Expression. В синтаксисе выше довольно очевидно, что у этих функций есть имя <code>name</code>. В конце концов, оно указано в объявлении.</p><p>Но современный JavaScript идёт дальше, он старается даже анонимным функциям дать разумные имена.</p><p>Например, при создании анонимной функции с одновременной записью в переменную или свойство – её имя равно названию переменной (или свойства).</p><p>Например:</p><code-example><script>`'use strict';\n\n// свойство g.name = "g"\nlet g = function() {};\n\nlet user = {\n  // свойство user.sayHi.name == "sayHi"\n  sayHi: function() {}\n};`</script></code-example><h2><a name="4" href="#4">Функции в блоке</a></h2><p>Объявление функции Function Declaration, сделанное в блоке, видно только в этом блоке.</p><p>Например:</p><code-example><script>`"use strict";\n\nif (true) {\n\n  sayHi(); // работает\n\n  function sayHi() {\n    alert("Привет!");\n  }\n\n}\nsayHi(); // ошибка, функции не существует`</script><code-toolbar></code-toolbar></code-example><p>То есть, иными словами, такое объявление – ведёт себя в точности как если бы <code>let sayHi = function() {…}</code> было сделано в начале блока.</p><h2><a name="5" href="#5">Функции через =&gt;</a></h2><p>Появился новый синтаксис для задания функций через «стрелку» <code>=&gt;</code>.</p><p>Его простейший вариант выглядит так:</p><code-example><script>`'use strict';\n\nMARKlet inc = x => x+1;\n\nalert( inc(1) ); // 2`</script><code-toolbar></code-toolbar></code-example><p>Эти две записи – примерно аналогичны:</p><code-example><script>`let inc = x => x+1;\n\nlet inc = function(x) { return x + 1; };`</script></code-example><p>Как видно, <code>"x =&gt; x+1"</code> – это уже готовая функция. Слева от <code>=&gt;</code> находится аргумент, а справа – выражение, которое нужно вернуть.</p><p>Если аргументов несколько, то нужно обернуть их в скобки, вот так:</p><code-example><script>`'use strict';\n\nMARKlet sum = (a,b) => a + b;\n\n// аналог с function\n// let sum = function(a, b) { return a + b; };\n\nalert( sum(1, 2) ); // 3`</script><code-toolbar></code-toolbar></code-example><p>Если нужно задать функцию без аргументов, то также используются скобки, в этом случае – пустые:</p><code-example><script>`'use strict';\n\nMARK// вызов getTime() будет возвращать текущее время\nMARKlet getTime = () => new Date().getHours() + ':' + new Date().getMinutes();\n\nalert( getTime() ); // текущее время`</script><code-toolbar></code-toolbar></code-example><p>Когда тело функции достаточно большое, то можно его обернуть в фигурные скобки <code>{…}</code>:</p><code-example><script>`'use strict';\n\nMARKlet getTime = () => {\nMARK  let date = new Date();\nMARK  let hours = date.getHours();\nMARK  let minutes = date.getMinutes();\nMARK  return hours + ':' + minutes;\nMARK};\n\nalert( getTime() ); // текущее время`</script><code-toolbar></code-toolbar></code-example><p>Заметим, что как только тело функции оборачивается в <code>{…}</code>, то её результат уже не возвращается автоматически. Такая функция должна делать явный <code>return</code>, как в примере выше, если конечно хочет что-либо возвратить.</p><p>Функции-стрелки очень удобны в качестве коллбеков, например:</p><code-example><script>`'use strict';\n\nlet arr = [5, 8, 3];\n\nMARKlet sorted = arr.sort( (a,b) => a - b );\n\nalert(sorted); // 3, 5, 8`</script><code-toolbar></code-toolbar></code-example><p>Такая запись – коротка и понятна. Далее мы познакомимся с дополнительными преимуществами использования функций-стрелок для этой цели.</p><h2><a name="6" href="#6">Функции-стрелки не имеют своего this</a></h2><p>Внутри функций-стрелок – тот же <code>this</code>, что и снаружи.</p><p>Это очень удобно в обработчиках событий и коллбэках, например:</p><code-example><script>`'use strict';\n\nlet group = {\n  title: "Наш курс",\n  students: ["Вася", "Петя", "Даша"],\n\n  showList: function() {\nMARK    this.students.forEach(\nMARK      student => alert(this.title + ':&nbsp' + student)\nMARK    )\n  }\n}\n\ngroup.showList();\n// Наш курс: Вася\n// Наш курс: Петя\n// Наш курс: Даша`</script><code-toolbar></code-toolbar></code-example><p>Здесь в <code>forEach</code> была использована функция-стрелка, поэтому <code>this.title</code> в коллбэке – тот же, что и во внешней функции <code>showList</code>. То есть, в данном случае – <code>group.title</code>.</p><p>Если бы в <code>forEach</code> вместо функции-стрелки была обычная функция, то была бы ошибка:</p><code-example><script>`'use strict';\n\nlet group = {\n  title: "Наш курс",\n  students: ["Вася", "Петя", "Даша"],\n\n  showList: function() {\nMARK    this.students.forEach(function(student) {\nMARK      alert(this.title + ':&nbsp' + student); // будет ошибка\nMARK    })\n  }\n}\n\ngroup.showList();`</script><code-toolbar></code-toolbar></code-example><p>При запуске будет "попытка прочитать свойство <code>title</code> у <code>undefined</code>", так как <code>.forEach(f)</code> при запуске <code>f</code> не ставит <code>this</code>. То есть, <code>this</code> внутри <code>forEach</code> будет <code>undefined</code>.</p><important-warn><h3>Функции стрелки нельзя запускать с <code>new</code></h3><p>Отсутствие у функции-стрелки "своего <code>this</code>" влечёт за собой естественное ограничение: такие функции нельзя использовать в качестве конструктора, то есть нельзя вызывать через <code>new</code>.</p></important-warn><important-><h3>=&gt; это не то же самое, что <code>.bind(this)</code></h3><p>Есть тонкое различие между функцией стрелкой <code>=&gt;</code> и обычной функцией, у которой вызван <code>.bind(this)</code>:</p><ul><li>Вызовом <code>.bind(this)</code> мы передаём текущий <code>this</code>, привязывая его к функции.</li><li>При <code>=&gt;</code> привязки не происходит, так как функция стрелка вообще не имеет контекста <code>this</code>. Поиск <code>this</code> в ней осуществляется так же, как и поиск обычной переменной, то есть, выше в замыкании. До появления стандарта ES-2015 такое было невозможно.</li></ul></important-><h2><a name="7" href="#7">Функции-стрелки не имеют своего arguments</a></h2><p>В качестве <code>arguments</code> используются аргументы внешней «обычной» функции.</p><p>Например:</p><code-example><script>`'use strict';\n\nfunction f() {\n  let showArg = () => alert(arguments[0]);\n  showArg();\n}\n\nf(1); // 1`</script><code-toolbar></code-toolbar></code-example><p>Вызов <code>showArg()</code> выведет <code>1</code>, получив его из аргументов функции <code>f</code>. Функция-стрелка здесь вызвана без параметров, но это не важно: <code>arguments</code> всегда берутся из внешней «обычной» функции.</p><p>Сохранение внешнего <code>this</code> и <code>arguments</code> удобно использовать для форвардинга вызовов и создания декораторов.</p><p>Например, декоратор <code>defer(f, ms)</code> ниже получает функцию <code>f</code> и возвращает обёртку вокруг неё, откладывающую вызов на <code>ms</code> миллисекунд:</p><code-example><script>`'use strict';\n\nMARKfunction defer(f, ms) {\nMARK  return function() {\nMARK    setTimeout(() => f.apply(this, arguments), ms)\nMARK  }\nMARK}\n\nfunction sayHi(who) {\n  alert('Привет,&nbsp' + who);\n}\n\nlet sayHiDeferred = defer(sayHi, 2000);\nsayHiDeferred("Вася"); // Привет, Вася через 2 секунды`</script><code-toolbar></code-toolbar></code-example><p>Аналогичная реализация без функции-стрелки выглядела бы так:</p><code-example><script>`function defer(f, ms) {\n  return function() {\nMARK    let args = arguments;\nMARK    let ctx = this;\n    setTimeout(function() {\n      return f.apply(ctx, args);\n    }, ms);\n  }\n}`</script></code-example><p>В этом коде пришлось создавать дополнительные переменные <code>args</code> и <code>ctx</code> для передачи внешних аргументов и контекста через замыкание.</p><h2><a name="8" href="#8">Итого</a></h2><p>Основные улучшения в функциях:</p><ul><li>Можно задавать параметры по умолчанию, а также использовать деструктуризацию для чтения приходящего объекта.</li><li>Оператор spread (троеточие) в объявлении позволяет функции получать оставшиеся аргументы в массив: <code>function f(arg1, arg2, ...rest)</code>.</li><li>Тот же оператор spread в вызове функции позволяет передать в неё массив как список аргументов (вместо <code>apply</code>).</li><li>У функции есть свойство <code>name</code>, оно содержит имя, указанное при объявлении функции, либо, если его нет, то имя свойства или переменную, в которую она записана. Есть и некоторые другие ситуации, в которых интерпретатор подставляет «самое подходящее» имя.</li><li>Объявление Function Declaration в блоке <code>{...}</code> видно только в этом блоке.</li><li>Появились функции-стрелки:<ul><li>Без фигурных скобок возвращают выражение <code>expr</code>: <code>(args) =&gt; expr</code>.</li><li>С фигурными скобками требуют явного <code>return</code>.</li><li>Не имеют своих <code>this</code> и <code>arguments</code>, при обращении получают их из окружающего контекста.</li><li>Не могут быть использованы как конструкторы, с <code>new</code>.</li></ul></li></ul><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Деструктуризация; Строки"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/es-function", disqus_identifier = "es-function", disqus_title = "\u0424\u0443\u043d\u043a\u0446\u0438\u0438";</script></page-content></main>