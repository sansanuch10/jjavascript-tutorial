<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="83">Современные возможности ES-2015</a></nav-up><h1>Классы</h1><p>В современном JavaScript появился новый, «более красивый» синтаксис для классов.</p><p>Новая конструкция <code>class</code> – удобный «синтаксический сахар» для задания конструктора вместе с прототипом.</p><h2><a name="0" href="#0">Class</a></h2><p>Синтаксис для классов выглядит так:</p><code-example><script>`class Название [extends Родитель]  {\n  constructor\n  методы\n}`</script></code-example><p>Например:</p><code-example><script>`'use strict';\n\nclass User {\n\n  constructor(name) {\n    this.name = name;\n  }\n\n  sayHi() {\n    alert(this.name);\n  }\n\n}\n\nlet user = new User("Вася");\nuser.sayHi(); // Вася`</script><code-toolbar></code-toolbar></code-example><p>Функция <code>constructor</code> запускается при создании <code>new User</code>, остальные методы записываются в <code>User.prototype</code>.</p><p>Это объявление примерно аналогично такому:</p><code-example><script>`function User(name) {\n  this.name = name;\n}\n\nUser.prototype.sayHi = function() {\n  alert(this.name);\n};`</script></code-example><p>В обоих случаях <code>new User</code> будет создавать объекты. Метод <code>sayHi</code> также в обоих случаях находится в прототипе.</p><p>Но при объявлении через <code>class</code> есть и ряд отличий:</p><ul><li><code>User</code> нельзя вызывать без <code>new</code>, будет ошибка.</li><li>Объявление класса с точки зрения области видимости ведёт себя как <code>let</code>. В частности, оно видно только в текущем блоке и только в коде, который находится ниже объявления (Function Declaration видно и до объявления).</li></ul><p>Методы, объявленные внутри <code>class</code>, также имеют ряд особенностей:</p><ul><li>Метод <code>sayHi</code> является именно методом, то есть имеет доступ к <code>super</code>.</li><li>Все методы класса работают в строгом режиме <code>use strict</code>, даже если он не указан.</li><li>Все методы класса не перечислимы. То есть в цикле <code>for..in</code> по объекту их не будет.</li></ul><h2><a name="1" href="#1">Class Expression</a></h2><p>Также, как и Function Expression, классы можно задавать «инлайн», в любом выражении и внутри вызова функции.</p><p>Это называется Class Expression:</p><code-example><script>`'use strict';\n\nlet User = class {\n  sayHi() { alert('Привет!'); }\n};\n\nnew User().sayHi();`</script><code-toolbar></code-toolbar></code-example><p>В примере выше у класса нет имени, что один-в-один соответствует синтаксису функций. Но имя можно дать. Тогда оно, как и в Named Function Expression, будет доступно только внутри класса:</p><code-example><script>`'use strict';\n\nlet SiteGuest = class User {\n  sayHi() { alert('Привет!'); }\n};\n\nnew SiteGuest().sayHi(); // Привет\nMARKnew User(); // ошибка`</script><code-toolbar></code-toolbar></code-example><p>В примере выше имя <code>User</code> будет доступно только внутри класса и может быть использовано, например, для создания новых объектов данного типа.</p><p>Наиболее очевидная область применения этой возможности – создание вспомогательного класса прямо при вызове функции.</p><p>Например, функция <code>createModel</code> в примере ниже создаёт объект по классу и данным, добавляет ему <code>_id</code> и пишет в «реестр» <code>allModels</code>:</p><code-example><script>`'use strict';\n\nlet allModels = {};\n\nfunction createModel(Model, ...args) {\n  let model = new Model(...args);\n\n  model._id = Math.random().toString(36).slice(2);\n  allModels[model._id] = model;\n\n  return model;\n}\n\nlet user = createModel(class User {\n  constructor(name) {\n    this.name = name;\n  }\n  sayHi() {\n    alert(this.name);\n  }\n}, "Вася");\n\nuser.sayHi(); // Вася\n\nalert( allModels[user._id].name ); // Вася`</script><code-toolbar></code-toolbar></code-example><h2><a name="2" href="#2">Геттеры, сеттеры и вычисляемые свойства</a></h2><p>В классах, как и в обычных объектах, можно объявлять геттеры и сеттеры через <code>get/set</code>, а также использовать <code>[…]</code> для свойств с вычисляемыми именами:</p><code-example><script>`'use strict';\n\nclass User {\n  constructor(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n\nMARK  // геттер\n  get fullName() {\n    return \`\${this.firstName} \${this.lastName}\`;\n  }\n\nMARK  // сеттер\n  set fullName(newValue) {\n    [this.firstName, this.lastName] = newValue.split(' ');\n  }\n\nMARK  // вычисляемое название метода\n  ["test".toUpperCase()]() {\n    alert("PASSED!");\n  }\n\n};\n\nlet user = new User("Вася", "Пупков");\nalert( user.fullName ); // Вася Пупков\nuser.fullName = "Иван Петров";\nalert( user.fullName ); // Иван Петров\nuser.TEST(); // PASSED!`</script><code-toolbar></code-toolbar></code-example><p>При чтении <code>fullName</code> будет вызван метод <code>get fullName()</code>, при присвоении – метод <code>set fullName</code> с новым значением.</p><important-warn><h3><code>class</code> не позволяет задавать свойства-значения</h3><p>В синтаксисе классов, как мы видели выше, можно создавать методы. Они будут записаны в прототип, как например <code>User.prototype.sayHi</code>.</p><p>Однако, нет возможности задать в прототипе обычное значение (не функцию), такое как <code>User.prototype.key = "value"</code>.</p><p>Конечно, никто не мешает после объявления класса в прототип дописать подобные свойства, однако предполагается, что в прототипе должны быть только методы.</p><p>Если свойство-значение, всё же, необходимо, то можно создать геттер, который будет нужное значение возвращать.</p></important-warn><h2><a name="3" href="#3">Статические свойства</a></h2><p>Класс, как и функция, является объектом. Статические свойства класса <code>User</code> – это свойства непосредственно <code>User</code>, то есть доступные из него «через точку».</p><p>Для их объявления используется ключевое слово <code>static</code>.</p><p>Например:</p><code-example><script>`'use strict';\n\nclass User {\n  constructor(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n\nMARK  static createGuest() {\nMARK    return new User("Гость", "Сайта");\nMARK  }\n};\n\nlet user = User.createGuest();\n\nalert( user.firstName ); // Гость\n\nalert( User.createGuest ); // createGuest ... (функция)`</script><code-toolbar></code-toolbar></code-example><p>Как правило, они используются для операций, не требующих наличия объекта, например – для фабричных, как в примере выше, то есть как альтернативные варианты конструктора. Или же, можно добавить метод <code>User.compare</code>, который будет сравнивать двух пользователей для целей сортировки.</p><p>Также статическими удобно делать константы:</p><code-example><script>`'use strict';\n\nclass Menu {\n  static get elemClass() {\n    return "menu"\n  }\n}\n\nalert( Menu.elemClass ); // menu`</script><code-toolbar></code-toolbar></code-example><h2><a name="4" href="#4">Наследование</a></h2><p>Синтаксис:</p><code-example><script>`class Child extends Parent {\n  ...\n}`</script></code-example><p>Посмотрим как это выглядит на практике. В примере ниже объявлено два класса: <code>Animal</code> и наследующий от него <code>Rabbit</code>:</p><code-example><script>`'use strict';\n\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  walk() {\n    alert("I walk:&nbsp" + this.name);\n  }\n}\n\nMARKclass Rabbit extends Animal {\n  walk() {\n    super.walk();\n    alert("...and jump!");\n  }\n}\n\nnew Rabbit("Вася").walk();\n// I walk: Вася\n// and jump!`</script><code-toolbar></code-toolbar></code-example><p>Как видим, в <code>new Rabbit</code> доступны как свои методы, так и (через <code>super</code>) методы родителя.</p><p>Это потому, что при наследовании через <code>extends</code> формируется стандартная цепочка прототипов: методы <code>Rabbit</code> находятся в <code>Rabbit.prototype</code>, методы <code>Animal</code> – в <code>Animal.prototype</code>, и они связаны через <code>__proto__</code>:</p><code-example><script>`'use strict';\n\nclass Animal { }\nclass Rabbit extends Animal { }\n\nalert( Rabbit.prototype.__proto__ == Animal.prototype ); // true`</script><code-toolbar></code-toolbar></code-example><p>Как видно из примера выше, методы родителя (<code>walk</code>) можно переопределить в наследнике. При этом для обращения к родительскому методу используют <code>super.walk()</code>.</p><p>С конструктором – немного особая история.</p><p>Конструктор <code>constructor</code> родителя наследуется автоматически. То есть, если в потомке не указан свой <code>constructor</code>, то используется родительский. В примере выше <code>Rabbit</code>, таким образом, использует <code>constructor</code> от <code>Animal</code>.</p><p>Если же у потомка свой <code>constructor</code>, то, чтобы в нём вызвать конструктор родителя – используется синтаксис <code>super()</code> с аргументами для родителя.</p><p>Например, вызовем конструктор <code>Animal</code> в <code>Rabbit</code>:</p><code-example><script>`'use strict';\n\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  walk() {\n    alert("I walk:&nbsp" + this.name);\n  }\n}\n\nclass Rabbit extends Animal {\nMARK  constructor() {\nMARK    // вызвать конструктор Animal с аргументом "Кроль"\nMARK    super("Кроль"); // то же, что и Animal.call(this, "Кроль")\nMARK  }\n}\n\nnew Rabbit().walk(); // I walk: Кроль`</script><code-toolbar></code-toolbar></code-example><p>Для такого вызова есть небольшие ограничения:</p><ul><li>Вызвать конструктор родителя можно только изнутри конструктора потомка. В частности, <code>super()</code> нельзя вызвать из произвольного метода.</li><li>В конструкторе потомка мы обязаны вызвать <code>super()</code> до обращения к <code>this</code>. До вызова <code>super</code> не существует <code>this</code>, так как по спецификации в этом случае именно <code>super</code> инициализирует <code>this</code>.</li></ul><p>Второе ограничение выглядит несколько странно, поэтому проиллюстрируем его примером:</p><code-example><script>`'use strict';\n\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nclass Rabbit extends Animal {\nMARK  constructor() {\nMARK    alert(this); // ошибка, this не определён!\nMARK    // обязаны вызвать super() до обращения к this\nMARK    super();\nMARK    // а вот здесь уже можно использовать this\nMARK  }\n}\n\nnew Rabbit();`</script><code-toolbar></code-toolbar></code-example><h2><a name="5" href="#5">Итого</a></h2><ul><li>Классы можно объявлять как в основном потоке кода, так и «инлайн», по аналогии с Function Declaration и Expression.</li><li>В объявлении классов можно использовать методы, геттеры/сеттеры и вычислимые названия методов.</li><li>При наследовании вызов конструктора родителя осуществляется через <code>super(...args)</code>, вызов родительских методов – через <code>super.method(...args)</code>.</li></ul><p>Концепция классов, которая после долгих обсуждений получилась в стандарте ECMAScript, носит название «максимально минимальной». То есть, в неё вошли только те возможности, которые уж точно необходимы.</p><p>В частности, не вошли «приватные» и «защищённые» свойства. То есть, все свойства и методы класса технически доступны снаружи. Возможно, они появятся в будущих редакциях стандарта.</p><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Объекты и прототипы; Тип данных Symbol"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/es-class", disqus_identifier = "es-class", disqus_title = "\u041a\u043b\u0430\u0441\u0441\u044b";</script></page-content></main>