<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="83">Современные возможности ES-2015</a></nav-up><h1>Тип данных Symbol</h1><p>Новый примитивный тип данных Symbol служит для создания уникальных идентификаторов.</p><p>Мы вначале рассмотрим объявление и особенности символов, а затем – их использование.</p><h2><a name="0" href="#0">Объявление</a></h2><p>Синтаксис:</p><code-example><script>`let sym = Symbol();`</script></code-example><p>Обратим внимание, не <code>new Symbol</code>, а просто <code>Symbol</code>, так как это – примитив.</p><p>У символов есть и соответствующий <code>typeof</code>:</p><code-example><script>`'use strict';\n\nlet sym = Symbol();\nalert( typeof sym ); // symbol`</script><code-toolbar></code-toolbar></code-example><p>Каждый символ – уникален. У функции <code>Symbol</code> есть необязательный аргумент «имя символа». Его можно использовать для описания символа, в целях отладки:</p><code-example><script>`'use strict';\n\nlet sym = Symbol("name");\nalert( sym.toString() ); // Symbol(name)`</script><code-toolbar></code-toolbar></code-example><p>…Но при этом, если у двух символов одинаковое имя, то это не значит, что они равны:</p><code-example><script>`alert( Symbol("name") == Symbol("name") ); // false`</script><code-toolbar></code-toolbar></code-example><p>Если хочется из разных частей программы использовать именно одинаковый символ, то можно передавать между ними объект символа или же – использовать «глобальные символы» и «реестр глобальных символов», которые мы рассмотрим далее.</p><h2><a name="1" href="#1">Глобальные символы</a></h2><p>Существует «глобальный реестр» символов, который позволяет, при необходимости, иметь общие «глобальные» символы, которые можно получить из реестра по имени.</p><p>Для чтения (или создания, при отсутствии) «глобального» символа служит вызов <code>Symbol.for(имя)</code>.</p><p>Например:</p><code-example><script>`'use strict';\n\n// создание символа в реестре\nlet name = Symbol.for("name");\n\n// символ уже есть, чтение из реестра\nalert( Symbol.for("name") == name ); // true`</script><code-toolbar></code-toolbar></code-example><p>Таким образом, можно из разных частей программы, обратившись к реестру, получить единый глобальный символ с именем <code>"name"</code>.</p><important-><h3>На заметку:</h3><p>В некоторых языках программирования, например Ruby, имя однозначно идентифицирует символ. В JavaScript, как мы видим, это верно для глобальных символов.</p></important-><p>У вызова <code>Symbol.for</code>, который возвращает символ по имени, есть обратный вызов – <code>Symbol.keyFor(sym)</code>. Он позволяет получить по глобальному символу его имя:</p><code-example><script>`'use strict';\n\n// создание символа в реестре\nlet test = Symbol.for("name");\n\n// получение имени символа\nalert( Symbol.keyFor(test) ); // name`</script><code-toolbar></code-toolbar></code-example><important-warn><h3><code>Symbol.keyFor</code> возвращает <code>undefined</code>, если символ не глобальный</h3><p>Заметим, что <code>Symbol.keyFor</code> работает <em>только для глобальных символов</em>, для остальных будет возвращено <code>undefined</code>:</p><code-example><script>`'use strict';\n\nalert( Symbol.keyFor(Symbol.for("name")) ); // name, глобальный\nalert( Symbol.keyFor(Symbol("name2")) ); // undefined, обычный символ`</script><code-toolbar></code-toolbar></code-example><p>Таким образом, имя символа, если этот символ не глобальный, не имеет особого применения, оно полезно лишь в целях вывода и отладки.</p></important-warn><h2><a name="2" href="#2">Использование символов</a></h2><p>Символы можно использовать в качестве имён для свойств объекта следующим образом:</p><code-example><script>`'use strict';\n\nlet isAdmin = Symbol("isAdmin");\n\nlet user = {\n  name: "Вася",\n  [isAdmin]: true\n};\n\nalert(user[isAdmin]); // true`</script><code-toolbar></code-toolbar></code-example><p>Особенность символов в том, что если в объект записать свойство-символ, то оно не участвует в итерации:</p><code-example><script>`'use strict';\n\nlet user = {\n  name: "Вася",\n  age: 30,\n  [Symbol.for("isAdmin")]: true\n};\n\n// в цикле for..in также не будет символа\nalert( Object.keys(user) ); // name, age\n\n// доступ к свойству через глобальный символ — работает\nalert( user[Symbol.for("isAdmin")] );`</script><code-toolbar></code-toolbar></code-example><p>Кроме того, свойство-символ недоступно, если обратиться к его названию: <code>user.isAdmin</code> не существует.</p><p>Зачем всё это, почему просто не использовать строки?</p><p>Резонный вопрос. На ум могут прийти соображения производительности, так как символы – это по сути специальные идентификаторы, они компактнее, чем строка. Но при современных оптимизациях объектов это редко имеет значение.</p><p>Самое широкое применение символов предусмотрено внутри самого стандарта JavaScript. В современном стандарте есть много системных символов. Их список есть в спецификации, в таблице <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#table-1">Well-known Symbols</a>. В спецификации для краткости символы принято обозначать как „@@имя“, например <code>@@iterator</code>, но доступны они как свойства <code>Symbol</code>.</p><p>Например:</p><ul><li><code>Symbol.toPrimitive</code> – идентификатор для свойства, задающего функцию преобразования объекта в примитив.</li><li><code>Symbol.iterator</code> – идентификатор для свойства, задающего функцию итерации по объекту.</li><li>…и т.п.</li></ul><p><strong>Мы легко поймём смысл введения нового типа «символ», если поставим себя на место создателей языка JavaScript.</strong></p><p>Допустим, в новом стандарте нам надо добавить к объекту «особый» функционал, например, функцию, которая задаёт преобразование объекта к примитиву. Как <code>obj.toString</code>, но для преобразования в примитивы.</p><p>Мы ведь не можем просто сказать, что «свойство obj.toPrimitive теперь будет задавать преобразование к примитиву и автоматически вызываться в таких-то ситуациях». Это опасно. Мы не можем так просто взять и придать особый смысл свойству. Мало ли, вполне возможно, что свойство с таким именем уже используется в существующем коде, и если сделать его особым, то он сломается.</p><p>Нельзя просто взять и зарезервировать какие-то свойства существующих объектов для нового функционала.</p><p>Поэтому ввели целый тип «символы». Их можно использовать для задания таких свойств, так как они:</p><ul><li>а) уникальны,</li><li>б) не участвуют в циклах,</li><li>в) заведомо не сломают старый код, который о них слыхом не слыхивал.</li></ul><p>Продемонстрируем отсутствие конфликта для нового системного свойства <code>Symbol.iterator</code>:</p><code-example><script>`'use strict';\n\nlet obj = {\n  iterator: 1,\n  [Symbol.iterator]() {}\n}\n\nalert(obj.iterator); // 1\nalert(obj[Symbol.iterator]) // function, символ не конфликтует`</script><code-toolbar></code-toolbar></code-example><p>Выше мы использовали системный символ <code>Symbol.iterator</code>, поскольку он один из самых широко используемых. Мы подробно разберём его смысл в главе про <a data-load_page="92">итераторы</a>, пока же – это просто пример символа.</p><p>Чтобы получить все символы объекта, есть особый вызов <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols</a>.</p><p>Эта функция возвращает все символы в объекте (и только их). Заметим, что старая функция <code>getOwnPropertyNames</code> символы не возвращает, что опять же гарантирует отсутствие конфликтов со старым кодом.</p><code-example><script>`'use strict';\n\nlet obj = {\n  iterator: 1,\n  [Symbol.iterator]: function() {}\n}\n\n// один символ в объекте\nalert( Object.getOwnPropertySymbols(obj)[0].toString() ); // Symbol(Symbol.iterator)\n\n// и одно обычное свойство\nalert( Object.getOwnPropertyNames(obj) ); // iterator`</script><code-toolbar></code-toolbar></code-example><h2><a name="3" href="#3">Итого</a></h2><ul><li>Символы – новый примитивный тип, предназначенный для уникальных идентификаторов.</li><li>Все символы уникальны. Символы с одинаковым именем не равны друг другу.</li><li>Существует глобальный реестр символов, доступных через метод <code>Symbol.for("name")</code>. Для глобального символа можно получить имя вызовом <code>Symbol.keyFor(sym)</code>.</li></ul><p>Основная область использования символов – это системные свойства объектов, которые задают разные аспекты их поведения. Поддержка у них пока небольшая, но она растёт. Системные символы позволяют разработчикам стандарта добавлять новые «особые» свойства объектов, при этом не резервируя соответствующие строковые значения.</p><p>Системные символы доступны как свойства функции <code>Symbol</code>, например <code>Symbol.iterator</code>.</p><p>Мы можем создавать и свои символы, использовать их в объектах. Записывать их как свойства <code>Symbol</code>, разумеется, нельзя. Если нужен глобально доступный символ, то используется <code>Symbol.for(имя)</code>.</p><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Классы; Итераторы"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><!-- <div id="disqus_thread"></div> --><script>disqus_url = "https:\/\/learn.javascript.ru\/symbol", disqus_identifier = "symbol", disqus_title = "\u0422\u0438\u043f \u0434\u0430\u043d\u043d\u044b\u0445 Symbol";</script></page-content></main>