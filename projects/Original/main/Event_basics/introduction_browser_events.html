<main> <page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="119">Основы работы с событиями</a></nav-up><h1>Введение в браузерные события</h1><p>Для реакции на действия посетителя и внутреннего взаимодействия скриптов существуют <em>события</em>.</p><p><em>Событие</em> – это сигнал от браузера о том, что что-то произошло. Существует много видов событий. Посмотрим список самых часто используемых, пока просто для ознакомления:</p><p><strong>События мыши:</strong></p><ul><li><code>click</code> – происходит, когда кликнули на элемент левой кнопкой мыши</li><li><code>contextmenu</code> – происходит, когда кликнули на элемент правой кнопкой мыши</li><li><code>mouseover</code> – возникает, когда на элемент наводится мышь</li><li><code>mousedown</code> и <code>mouseup</code> – когда кнопку мыши нажали или отжали</li><li><code>mousemove</code> – при движении мыши</li></ul><p><strong>События на элементах управления:</strong></p><ul><li><code>submit</code> – посетитель отправил форму <code>&lt;form&gt;</code></li><li><code>focus</code> – посетитель фокусируется на элементе, например нажимает на <code>&lt;input&gt;</code></li></ul><p><strong>Клавиатурные события:</strong></p><ul><li><code>keydown</code> – когда посетитель нажимает клавишу</li><li><code>keyup</code> – когда посетитель отпускает клавишу</li></ul><p><strong>События документа:</strong></p><ul><li><code>DOMContentLoaded</code> – когда HTML загружен и обработан, DOM документа полностью построен и доступен.</li></ul><p><strong>События CSS:</strong></p><ul><li><code>transitionend</code> – когда CSS-анимация завершена.</li></ul><p>Также есть и много других событий.</p><h2><a name="0" href="#0">Назначение обработчиков событий</a></h2><p>Событию можно назначить <em>обработчик</em>, то есть функцию, которая сработает, как только событие произошло.</p><p>Именно благодаря обработчикам JavaScript-код может реагировать на действия посетителя.</p><p>Есть несколько способов назначить событию обработчик. Сейчас мы их рассмотрим, начиная от самого простого.</p><h3><a name="9" href="#9">Использование атрибута HTML</a></h3><p>Обработчик может быть назначен прямо в разметке, в атрибуте, который называется <code>on&lt;событие&gt;</code>.</p><p>Например, чтобы прикрепить <code>click</code>-событие к <code>input</code> кнопке, можно присвоить обработчик <code>onclick</code>, вот так:</p><code-example><script>`<input value="Нажми меня" onclick="alert('Клик!')" type="button">`</script></code-example><p>При клике мышкой на кнопке выполнится код, указанный в атрибуте <code>onclick</code>.</p><p>В действии: <input value="Нажми меня" onclick="alert('Клик!');" type="button"></p><p>Обратите внимание, для содержимого атрибута <code>onclick</code> используются <em>одинарные кавычки</em>, так как сам атрибут находится в двойных.</p><p>Частая ошибка новичков в том, что они забывают, что код находится внутри атрибута. Запись вида <code>onclick="alert("Клик!")"</code>, с двойными кавычками внутри, не будет работать. Если вам действительно нужно использовать именно двойные кавычки, то это можно сделать, заменив их на <code>&amp;quot;</code>, то есть так: <code>onclick="alert(&amp;quot;Клик!&amp;quot;)"</code>.</p><p>Однако, обычно этого не требуется, так как прямо в разметке пишутся только очень простые обработчики. Если нужно сделать что-то сложное, то имеет смысл описать это в функции, и в обработчике вызвать уже её.</p><p>Следующий пример по клику запускает функцию <code>countRabbits()</code>.</p><code-example><script>`<!DOCTYPE HTML>\n<html>\n<head>\n  <meta charset="utf-8">\n\n  <script>\n    function countRabbits() {\n      for(var i=1; i<=3; i++) {\n        alert("Кролик номер&nbsp" + i);\n      }\n    }\n  <\/script>\n</head>\n<body>\n  <input type="button" HIGHonclick="countRabbits()LIGHT" value="Считать кроликов!"/>\n</body>\n</html>`</script><code-toolbar iframe="50"></code-toolbar></code-example><p>Как мы помним, атрибут HTML-тега не чувствителен к регистру, поэтому <code>ONCLICK</code> будет работать так же, как <code>onClick</code> или <code>onCLICK</code>… Но, как правило, атрибуты пишут в нижнем регистре: <code>onclick</code>.</p><h3><a name="10" href="#10">Использование свойства DOM-объекта</a></h3><p>Можно назначать обработчик, используя свойство DOM-элемента <code>on&lt;событие&gt;</code>.</p><p>Пример установки обработчика <code>click</code>:</p><code-example><script>`<input id="elem" type="button" value="Нажми меня" />\n<script>\nMARK  elem.onclick = function() {\nMARK    alert( 'Спасибо' );\nMARK  };\n<\/script>`</script></code-example><p>Если обработчик задан через атрибут, то браузер читает HTML-разметку, создаёт новую функцию из содержимого атрибута и записывает в свойство <code>onclick</code>.</p><p><strong>Этот способ, по сути, аналогичен предыдущему.</strong></p><p>Обработчик хранится именно в DOM-свойстве, а атрибут – лишь один из способов его инициализации.</p><p>Эти два примера кода работают одинаково:</p><ol><li><p>Только HTML:</p><code-example><script>`<input type="button" HIGHonclick="alert('Клик!')"LIGHT value="Кнопка"/>`</script><code-toolbar iframe="50"></code-toolbar></code-example></li><li><p>HTML + JS:</p><code-example><script>`<input type="button" id="button" value="Кнопка" />\n<script>\nMARK  button.onclick = function() {\nMARK    alert( 'Клик!' );\nMARK  };\n<\/script>`</script><code-toolbar iframe="50"></code-toolbar></code-example></li></ol><p><strong>Так как DOM-свойство <code>onclick</code>, в итоге, одно, то назначить более одного обработчика так нельзя.</strong></p><p>В примере ниже назначение через JavaScript перезапишет обработчик из атрибута:</p><code-example><script>`<input type="button" id="elem" onclick="alert('До')" value="Нажми меня" />\n<script>\nMARK  elem.onclick = function() { // перезапишет существующий обработчик\nMARK    alert( 'После' ); // выведется только это\nMARK  };\n<\/script>`</script><code-toolbar iframe="50"></code-toolbar></code-example><p>Кстати, обработчиком можно назначить и уже существующую функцию:</p><code-example><script>`function sayThanks() {\n  alert( 'Спасибо!' );\n}\n\nelem.onclick = sayThanks;`</script></code-example><p>Если обработчик надоел – его всегда можно убрать назначением <code>elem.onclick = null</code>.</p><h2><a name="1" href="#1">Доступ к элементу через this</a></h2><p>Внутри обработчика события <code>this</code> ссылается на текущий элемент, то есть на тот, на котором он сработал.</p><p>Это можно использовать, чтобы получить свойства или изменить элемент.</p><p>В коде ниже <code>button</code> выводит свое содержимое, используя <code>this.innerHTML</code>:</p><code-example><script>`<button onclick="alert(this.innerHTML)">Нажми меня</button>`</script></code-example><p>В действии: <button onclick="alert(this.innerHTML)">Нажми меня</button></p><h2><a name="2" href="#2">Частые ошибки</a></h2><p>Если вы только начинаете работать с событиями – обратите внимание на следующие особенности.</p><p><strong>Функция должна быть присвоена как <code>sayThanks</code>, а не <code>sayThanks()</code>.</strong></p><code-example><script>`button.onclick = sayThanks;`</script></code-example><p>Если добавить скобки, то <code>sayThanks()</code> – будет уже <em>результат</em> выполнения функции (а так как в ней нет <code>return</code>, то в <code>onclick</code> попадёт <code>undefined</code>). Нам же нужна именно функция.</p><p>…А вот в разметке как раз скобки нужны:</p><code-example><script>`<input type="button" id="button" onclick="sayThanks()" />`</script></code-example><p>Это различие просто объяснить. При создании обработчика браузером из атрибута, он автоматически создает функцию из его содержимого. Поэтому последний пример – фактически то же самое, что:</p><code-example><script>`button.onclick = function() {\nMARK  sayThanks(); // содержимое атрибута\n};`</script></code-example><p><strong>Используйте именно функции, а не строки.</strong></p><p>Назначение обработчика строкой <code>elem.onclick = "alert(1)"</code> можно иногда увидеть в древнем коде. Это будет работать, но не рекомендуется, могут быть проблемы при сжатии JavaScript. Да и вообще, передавать код в виде строки по меньшей мере странно в языке, который поддерживает Function Expressions. Это возможно лишь по соображениям совместимости, не делайте так.</p><p><strong>Не используйте <code>setAttribute</code>.</strong></p><p>Такой вызов работать не будет:</p><code-example><script>`// при нажатии на body будут ошибки\n// потому что при назначении в атрибут функция будет преобразована в строку\ndocument.body.setAttribute('onclick', function() { alert(1) })`</script><code-toolbar iframe="60"></code-toolbar></code-example><p><strong>Регистр DOM-свойства имеет значение.</strong></p><p>При назначении через DOM нужно использовать свойство <code>onclick</code>, а не <code>ONCLICK</code>.</p><h2><a name="3" href="#3">Недостаток назначения через свойство</a></h2><p>Фундаментальный недостаток описанных выше способов назначения обработчика – невозможность повесить <em>несколько</em> обработчиков на одно событие.</p><p>Например, одна часть кода хочет при клике на кнопку делать ее подсвеченной, а другая – выдавать сообщение. Нужно в разных местах два обработчика повесить.</p><p>При этом новый обработчик будет затирать предыдущий. Например, следующий код на самом деле назначает один обработчик – последний:</p><code-example><script>`input.onclick = function() { alert(1); }\n// ...\ninput.onclick = function() { alert(2); } // заменит предыдущий обработчик`</script></code-example><p>Разработчики стандартов достаточно давно это поняли и предложили альтернативный способ назначения обработчиков при помощи специальных методов, которые свободны от указанного недостатка.</p><h2><a name="4" href="#4">addEventListener и removeEventListener</a></h2><p>Методы <code>addEventListener</code> и <code>removeEventListener</code> являются современным способом назначить или удалить обработчик, и при этом позволяют использовать сколько угодно любых обработчиков.</p><p>Назначение обработчика осуществляется вызовом <code>addEventListener</code> с тремя аргументами:</p><code-example><script>`element.addEventListener(event, handler[, phase]);`</script></code-example><dl><dt><code>event</code></dt><dd>Имя события, например <code>click</code></dd><dt><code>handler</code></dt><dd>Ссылка на функцию, которую надо поставить обработчиком.</dd><dt><code>phase</code></dt><dd>Необязательный аргумент, «фаза», на которой обработчик должен сработать. Этот аргумент редко нужен, мы его рассмотрим позже.</dd></dl><p>Удаление обработчика осуществляется вызовом <code>removeEventListener</code>:</p><code-example><script>`// передать те же аргументы, что были у addEventListener\nelement.removeEventListener(event, handler[, phase]);`</script></code-example><important-warn><h3>Удаление требует именно ту же функцию</h3><p>Для удаления нужно передать именно ту функцию-обработчик которая была назначена.</p><p>Вот так <code>removeEventListener</code> не сработает:</p><code-example><script>`elem.addEventListener( "click" , function() {alert('Спасибо!')});\n// ....\nelem.removeEventListener( "click", function() {alert('Спасибо!')});`</script></code-example><p>В <code>removeEventListener</code> передана не та же функция, а другая, с одинаковым кодом, но это не важно.</p><p>Вот так правильно:</p><code-example><script>`function handler() {\n  alert( 'Спасибо!' );\n}\n\ninput.addEventListener("click", handler);\n// ....\ninput.removeEventListener("click", handler);`</script></code-example><p>Обратим внимание – если функцию не сохранить где-либо, а просто передать в <code>addEventListener</code>, как в предыдущем коде, то потом получить её обратно, чтобы снять обработчик, будет невозможно. Нет метода, который позволяет считать обработчики событий, назначенные через <code>addEventListener</code>.</p></important-warn><p>Метод <code>addEventListener</code> позволяет добавлять несколько обработчиков на одно событие одного элемента, например:</p><code-example><script>`<input id="elem" type="button" value="Нажми меня"/>\n\n<script>\n  function handler1() {\n    alert('Спасибо!');\n  };\n\n  function handler2() {\n    alert('Спасибо ещё раз!');\n  }\n\nMARK  elem.onclick = function() { alert("Привет"); };\nMARK  elem.addEventListener("click", handler1); // Спасибо!\nMARK  elem.addEventListener("click", handler2); // Спасибо ещё раз!\n<\/script>`</script><code-toolbar iframe="50"></code-toolbar></code-example><p>Как видно из примера выше, можно одновременно назначать обработчики и через DOM-свойство и через <code>addEventListener</code>. Однако, во избежание путаницы, рекомендуется выбрать один способ.</p><important-warn><h3><code>addEventListener</code> работает всегда, а DOM-свойство – нет</h3><p>У специальных методов есть ещё одно преимущество перед DOM-свойствами.</p><p>Есть некоторые события, которые нельзя назначить через DOM-свойство, но можно через <code>addEventListener</code>.</p><p>Например, таково событие <code>transitionend</code>, то есть окончание CSS-анимации. В большинстве браузеров оно требует назначения через <code>addEventListener</code>.</p><p>Вы можете проверить это, запустив код в примере ниже. Как правило, сработает лишь второй обработчик, но не первый.</p><code-example><script>`<style>\n  GOLD_button_GOLD {\n    transition: width 1s;\n    width: 100px;\n  }\n\n  GOLD_.wide_GOLD {\n    width: 300px;\n  }\n</style>\n\n<button id="elem" onclick="this.classList.toggle('wide');">\n  Нажми меня\n</button>\n\n<script>\n  elem.ontransitionend = function() {\n    alert( "ontransitionend" ); // не сработает\n  };\n\nMARK  elem.addEventListener("transitionend", function() {\nMARK    alert( "addEventListener" ); // сработает по окончании анимации\nMARK  });\n<\/script>`</script><code-toolbar iframe="50"><a data-code_run="370" title="показать"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example></important-warn><h2><a name="5" href="#5">Отличия IE8-</a></h2><p>При работе с событиями в IE8- есть много отличий. Как правило, они формальны – некое свойство или метод называются по-другому. Начиная с версии 9, также работают и стандартные свойства и методы.</p><p><strong>В IE8- вместо <code>addEventListener/removeEventListener</code> используются свои методы.</strong></p><p>Назначение обработчика осуществляется вызовом <code>attachEvent</code>:</p><code-example><script>`element.attachEvent("on" + event, handler);`</script></code-example><p>Удаление обработчика – вызовом <code>detachEvent</code>:</p><code-example><script>`element.detachEvent("on" + event, handler);`</script></code-example><p>Например:</p><code-example><script>`function handler() {\n  alert( 'Спасибо!' );\n}\nbutton.attachEvent("onclick", handler) // Назначение обработчика\n  // ....\nbutton.detachEvent("onclick", handler) // Удаление обработчика`</script></code-example><p>Как видите, почти то же самое, только событие должно включать префикс <code>on</code>.</p><important-warn><h3>У обработчиков, назначенных с <code>attachEvent</code>, нет <code>this</code></h3><p>Обработчики, назначенные с <code>attachEvent</code> не получают <code>this</code>!</p><p>Это важная особенность и подводный камень старых IE.</p></important-warn><p>Чтобы ваш код работал в старом IE, нужно либо использовать DOM-свойства, то есть <code>onclick</code>, либо подключить полифилл для современных методов, например <a href="https://gist.github.com/jonathantneal/3748027">такой</a> или с сервиса <a href="http://polyfill.webservices.ft.com/v1/docs/features/">polyfill.io</a> или какой-то другой.</p><h2><a name="6" href="#6">Итого</a></h2><p>Есть три способа назначения обработчиков событий:</p><ol><li>Атрибут HTML: <code>onclick="..."</code>.</li><li>Свойство: <code>elem.onclick = function</code>.</li><li>Специальные методы:</li></ol><ul><li>Современные: <code>elem.addEventListener( событие, handler[, phase])</code>, удаление через <code>removeEventListener</code>.</li><li>Для старых IE8-: <code>elem.attachEvent( on+событие, handler )</code>, удаление через <code>detachEvent</code>.</li></ul><p>Сравнение <code>addEventListener</code> и <code>onclick</code>:</p><balance-><balance-pluses><div>Достоинства</div><ul><li>Некоторые события можно назначить только через <code>addEventListener</code>.</li><li>Метод <code>addEventListener</code> позволяет назначить много обработчиков на одно событие.</li></ul></balance-pluses><balance-minuses><div>Недостатки</div><ul class="balance__list"><li>Обработчик, назначенный через <code>onclick</code>, проще удалить или заменить.</li><li>Метод <code>onclick</code> кросс-браузерный.</li></ul></balance-minuses></balance-><p>Этим введением мы только открываем работу с событиями, но вы уже можете решать разнообразные задачи с их использованием.</p><h2 id="tasks"><a href="#7" name="7">Задачи (6)</a></h2><task-content><h3><a href="#14" name="14">Спрятать при клике</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Используя JavaScript, сделайте так, чтобы при клике на кнопку исчезал элемент с <code>id="text"</code>.</p><p>Демо:</p><p><iframe style="height:80px" src="https://js.cx/task/hide-other/solution/"></iframe></p><p><a data-click="task_1">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`<input type="button" id="hider" value="Нажмите, чтобы спрятать текст" />\n\n<div id="text">Текст</div>\n\n<script>\n  // в этой задаче неважно, как именно прятать элемент\n  // например через style.display:\n  document.getElementById('hider').onclick = function() {\n    document.getElementById('text').style.display = 'none';\n  }\n<\/script>`</script><code-toolbar iframe="100"></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#15" name="15">Спрятаться</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Создайте кнопку, при клике на которую, она будет скрывать сама себя.</p><p>Как эта: <input type="button" onclick="this.style.display='none'" value="Нажми, чтобы меня спрятать"></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Решение задачи заключается в использовании <code>this</code> в обработчике.</p><code-example><script>`<input type="button" onclick="this.style.display='none'" value="Нажми, чтобы меня спрятать" />`</script><code-toolbar iframe="50"></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#16" name="16">Какие обработчики сработают?</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>В переменной <code>button</code> находится кнопка.</p><p>Изначально обработчиков на ней нет.</p><p>Что будет выведено при клике после выполнения кода?</p><code-example><script>`button.addEventListener("click", function() { alert("1"); });\n\nbutton.removeEventListener("click", function() { alert("1"); });\n\nbutton.onclick = function() { alert(2); };`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer style=""><close- title="закрыть" data-close_answer=""></close-><p>Ответ: будет выведено <code>1</code> и <code>2</code>.</p><p>Первый обработчик сработает, так как он не убран вызовом <code>removeEventListener</code>. Для удаления обработчика нужно передать в точности ту же функцию (ссылку на нее), что была назначена, а в коде передается такая же с виду функция, но, тем не менее, это другой объект.</p><p>Для того, чтобы удалить функцию-обработчик, нужно где-то сохранить ссылку на неё, например так:</p><code-example><script>`function handler() {\n   alert( "1" );\n}\n\nbutton.addEventListener("click", handler);\nbutton.removeEventListener("click", handler);`</script></code-example><p>Обработчик <code>button.onclick</code> сработает независимо и в дополнение к назначенному в <code>addEventListener</code>.</p></task-answer></task-content><task-content><h3><a href="#17" name="17">Раскрывающееся меню</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Создайте меню, которое раскрывается/сворачивается при клике:</p><figure- style="height:90px" changeable=""><style>sweeties-{margin-left:10px;display:block;}sweeties- ul{margin:0;list-style-type:none;padding-left:30px;display:none;} sweeties- title-1{font-size:18px;cursor:pointer;} sweeties- title-1::before{content:'▶ ';font-size:80%;color:green;} sweeties-.open title-1::before{content:'▼ ';} sweeties-.open ul{display:block;} </style><sweeties- class=""><title-1>Сладости (нажми меня)!</title-1><ul><li>Торт</li><li>Пончик</li><li>Пирожное</li></ul></sweeties-><script> var menuElem=document.querySelector('sweeties-');var titleElem=menuElem.querySelector('title-1');titleElem.onclick=function(){menuElem.classList.toggle('open');};</script><code-toolbar-><a id="answer_4" style="display:none" data-code_edit=""></a><a id="task_4" title="открыть в песочнице" data-code_edit="?"></a></code-toolbar-></figure-><p></p><p>P.S. HTML/CSS исходного документа понадобится изменить.</p><p><a data-click="task_4">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Для начала, зададим структуру HTML/CSS.</p><p>Меню является отдельным графическим компонентом, его лучше поместить в единый DOM-элемент.</p><p>Элементы меню с точки зрения семантики являются списком <code>UL/LI</code>. Заголовок должен быть отдельным кликабельным элементом.</p><p>Получаем структуру:</p><code-example><script>`<RED_sweeties-_RED>
  <title-1>Сладости (нажми меня)!</title-1>
  <ul>
    <li>Торт</li>
    <li>Пончик</li>
    <li>Пирожное</li>
  </ul>
</RED_sweeties-_RED>`</script></code-example><p>Раскрытие/закрытие сделаем путём добавления/удаления класса <code>.open</code> к меню, который отвечает за стрелочку и отображение <code>UL</code>.</p><p>Обычно меню будет закрыто:</p><code-example><script>`GOLD_sweeties- ul_GOLD {
  margin: 0;
  list-style: none;
  padding: 0 0 0 30px;
MARK  display: none;
}

GOLD_sweeties- title-1::before_GOLD {
  content:'▶ ';
  font-size:80%;
  color:green;
}`</script></code-example><p>Если же меню раскрыто, то есть имеет класс <code>.open</code>, то стрелочка слева заголовка меняется и список детей показывается:</p><code-example><script>`GOLD_sweeties-.open title-1::before_GOLD {
  content: '▼ ';
}
GOLD_sweeties-.open ul_GOLD {
  display: block;
}`</script></code-example><p>Для JavaScript остался минимум работы – только добавить/удалить класс при клике.</p><code-example><script>`<script>\n  var menuElem = document.querySelector('sweeties-');\n  var titleElem = menuElem.querySelector('title-1');\n\n  titleElem.onclick = function() {\n    menuElem.classList.toggle('open');\n  };\n<\/script>`</script></code-example><p><a data-click="answer_4">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#18" name="18">Удалить сообщение</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Есть список сообщений. Добавьте каждому сообщению по кнопке для его удаления .</p><p>Результат:</p><iframe- id="hide_message" src="hide_message.html" changeable=""><code-toolbar- id="remove_message"><a data-show_messages="" title="показать" onclick="for (i = 0, l = pane_.length; i < l; i++) {document.querySelector('messages-').appendChild(pane_.pop());}"></a><a id="answer_5" style="display:none" title="открыть в песочнице" data-code_edit=""></a><a id="task_5" title="открыть в песочнице" data-code_edit="?"></a></code-toolbar-><script> function on(){var buttons=document.querySelector('messages-').querySelectorAll('button');window.pane_=[];for (var i=0,el;i<buttons.length;i++){buttons[i].onclick=function(){var el=document.getElementById('remove_message');el=this.parentNode;pane_.push(el.parentNode.removeChild(el));}}}</script></iframe-><p></p><p>P.S. Как лучше отобразить кнопку справа-сверху: через <code>position:absolute</code> или <code>float:right</code>? Почему?</p><p><a data-click="task_5">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><ol><li><p>Изменим HTML/CSS, чтобы кнопка была в нужном месте сообщения. Кнопка – это тег <code>&lt;button&gt;</code>, поэтому понадобится несколько стилей.</p><p>Расположить кнопку справа можно при помощи <code>position:relative</code> для <code>pane</code>, а для кнопки <code>position:absolute + right/top</code>. Так как <code>position:absolute</code> вынимает элемент из потока, то кнопка может частично оказаться «сверху» текста заголовка, перекрыв его конец. Чтобы этого не произошло, можно добавить <code>padding-right</code> к заголовку.</p><p>Если использовать <code>float:right</code>, то кнопка никогда не перекроет текст. Это, пожалуй хорошо.</p><p>С другой стороны, потенциальным преимуществом способа с <code>position</code> по сравнению с <code>float</code> в данном случае является возможность поместить элемент кнопки в HTML <em>после текста</em>, а не до него.</p></li><li><p>Для того, чтобы получить кнопку из контейнера, используем <code>querySelectorAll</code>. На каждую кнопку повесим обработчик, который будет убирать родителя. Найти родителя можно через <code>parentNode</code>.</p></li></ol><p><a data-click="answer_5">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#19" name="19">Карусель</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>Напишите «Карусель» – ленту изображений, которую можно листать влево-вправо нажатием на стрелочки.</p><figure- style="padding: 10px;"><code-toolbar-><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-><style> carousel-{display:block;position:relative;width:398px;padding:10px 40px;border:1px solid #CCC;border-radius:15px;background:#eee;} carousel- img{width:130px;height:130px;/* по умолчанию inline,в ряде браузеров это даст лишнее пространство вокруг элементов */ display:block;} carousel- button{position:absolute;top:60px;padding:0;background:#ddd;border-radius:15px;border:1px solid gray;font-size:24px;line-height:24px;color:#444;display:block;} carousel- button:focus{outline:none;} carousel- button:hover{background:#ccc;cursor:pointer;} .prev{left:7px;} .next{right:7px;} carousel- div{width:390px;overflow:hidden;} carousel- ul{height:130px;width:9999px;margin:0;padding:0;list-style:none;transition:margin-left 250ms;/* remove white-space between inline-block'ed li */ /* http://davidwalsh.name/remove-whitespace-inline-block */ font-size: 0;} carousel- li{display: inline-block;position: relative;} </style><carousel-><button class="prev">⇦</button><div><ul style="margin-left: 0px;"><li><img src="smiley1.png"></li><li><img src="smiley2.png"></li><li><img src="smiley3.png"></li><li><img src="smiley4.png"></li><li><img src="smiley5.png"></li><li><img src="smiley6.png"></li><li><img src="smiley7.png"></li><li><img src="smiley8.png"></li><li><img src="smiley9.png"></li><li><img src="smiley10.png"></li></ul></div><button class="next">⇨</button></carousel-><script>showSmiley();function showSmiley(){/* конфигурация */ var width=130;/* ширина изображения */ var count=3;/* количество изображений */ var carousel=document.querySelector('carousel-');var list=carousel.querySelector('ul');var listElems=carousel.querySelectorAll('li');var position=0;/* текущий сдвиг влево */ carousel.querySelector('.prev').onclick=function(){position=Math.min(position+width * count,0);/* сдвиг влево последнее передвижение влево может быть не на 3,а на 2 или 1 элемент */ list.style.marginLeft=position+'px';};carousel.querySelector('.next').onclick=function(){position=Math.max(position-width * count,-width * (listElems.length-count));/* сдвиг вправо последнее передвижение вправо может быть не на 3,а на 2 или 1 элемент */ list.style.marginLeft=position+'px';};}</script></figure-><!-- <p><iframe style="height:200px" src="https://js.cx/task/carousel/solution/"></iframe></p> --><p>В дальнейшем к ней можно легко добавить анимацию, динамическую подгрузку и другие возможности.</p><p>P.S. В этой задаче разработка HTML/CSS-структуры составляет 90% решения.</p><p><a data-click="task_6">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Лента изображений в разметке должна быть представлена как список <code>&lt;ul&gt;</code> тегов <code>&lt;img&gt;</code>.</p><p>Нужно расположить его внутри <code>&lt;div&gt;</code> фиксированного размера, так чтобы в один момент была видна только нужная часть списка:</p><figure><img src="carousel1.png" alt="" width="100%" style="max-width:488px"></figure><p>Чтобы список был длинный и элементы не переходили вниз, ему ставится <code>width: 9999px</code>, а элементам <code>&lt;li&gt;</code>, соответственно, <code>float:left</code>, либо для элементов используется <code>display: inline-block</code>, как в этом решении.</p><p>Главное – не использовать <code>display:inline</code>, так как такие элементы имеют дополнительные отступы снизу для возможных «хвостов букв».</p><p>В частности, для <code>&lt;img&gt;</code> нужно поставить в стилях явно <code>display:block</code>, чтобы пространства под ними не оставалось.</p><p>Для «прокрутки» будем сдвигать <code>&lt;ul&gt;</code>. Это можно делать по-разному, например, назначением CSS-свойства <code>transform: translateX()</code> или <code>margin-left</code>:</p><figure><img src="carousel2.png" alt="" width="100%" style="max-width:639px"></figure><p>У внешнего <code>&lt;div&gt;</code> фиксированная ширина, поэтому «лишние» изображения обрезаются.</p><p>Снаружи окошка находятся стрелки и внешний контейнер.</p><code-example><script>`<style>\n  GOLD_body_GOLD {\n    padding: 10px;\n  }  \n  GOLD_.carousel_GOLD {\n    position: relative;\n    width: 398px;\n    padding: 10px 40px;\n    border: 1px solid #CCC;\n    border-radius: 15px;\n    background: #eee;\n  }  \n  GOLD_.carousel img_GOLD {\n    width: 130px;\n    height: 130px;\n    /* по умолчанию inline, в ряде браузеров это даст лишнее пространство вокруг элементов */  \n    display: block;\n  }  \n  GOLD_.arrow_GOLD {\n    position: absolute;\n    top: 60px;\n    padding: 0;\n    background: #ddd;\n    border-radius: 15px;\n    border: 1px solid gray;\n    font-size: 24px;\n    line-height: 24px;\n    color: #444;\n    display: block;\n  }  \n  GOLD_.arrow:focus_GOLD {\n    outline: none;\n  }  \n  GOLD_.arrow:hover_GOLD {\n    background: #ccc;\n    cursor: pointer;\n  }  \n  GOLD_.prev_GOLD {\n    left: 7px;\n  }  \n  GOLD_.next_GOLD {\n    right: 7px;\n  }  \n  GOLD_.gallery_GOLD {\n    width: 390px;\n    overflow: hidden;\n  }  \n  GOLD_.gallery ul_GOLD {\n    height: 130px;\n    width: 9999px;\n    margin: 0;\n    padding: 0;\n    list-style: none;\n    transition: margin-left 250ms;\n    font-size: 0;\n  }  \n  GOLD_.gallery li_GOLD {\n    display: inline-block;\n  }\n</style>\n<div id="carousel" class="carousel">\n  <button class="arrow prev">⇦</button>\n  <div class="gallery">\n    <ul class="images">\n      <li><img src="smiley1.png"></li>\n      <li><img src="smiley2.png"></li>\n      <li><img src="smiley3.png"></li>\n      <li><img src="smiley4.png"></li>\n      <li><img src="smiley5.png"></li>\n      <li><img src="smiley6.png"></li>\n      <li><img src="smiley7.png"></li>\n      <li><img src="smiley8.png"></li>\n      <li><img src="smiley9.png"></li>\n      <li><img src="smiley10.png"></li>\n    </ul>\n  </div>\n  <button class="arrow next">⇨</button>\n</div>\n\n<script>\n  /* этот код помечает картинки, для удобства разработки */\n  var lis = document.getElementsByTagName('li');\n  for (var i = 0; i < lis.length; i++) {\n    lis[i].style.position = 'relative';\n    var span = document.createElement('span');\n    // обычно лучше использовать CSS-классы,\n    // но этот код - для удобства разработки, так что не будем трогать стили\n    span.style.cssText = 'position:absolute;left:0;top:0';\n    span.innerHTML = i + 1;\n    lis[i].appendChild(span);\n  }\n\n  /* конфигурация */\n  var width = 130; // ширина изображения\n  var count = 3; // количество изображений\n\n  var carousel = document.getElementById('carousel');\n  var list = carousel.querySelector('ul');\n  var listElems = carousel.querySelectorAll('li');\n\n  var position = 0; // текущий сдвиг влево\n\n  carousel.querySelector('.prev').onclick = function() {\n    // сдвиг влево\n    // последнее передвижение влево может быть не на 3, а на 2 или 1 элемент\n    position = Math.min(position + width * count, 0)\n    list.style.marginLeft = position + 'px';\n  };\n\n  carousel.querySelector('.next').onclick = function() {\n    // сдвиг вправо\n    // последнее передвижение вправо может быть не на 3, а на 2 или 1 элемент\n    position = Math.max(position - width * count, -width * (listElems.length - count));\n    list.style.marginLeft = position + 'px';\n  };\n<\/script>`</script><code-toolbar iframe="630"><a data-code_run="0" title="показать"></a><a id="task_6" data-code_edit="?" style="display:none"></a><a id="answer_6" title="открыть в песочнице" data-code_edit_run=""></a></code-toolbar></code-example><p><a data-click="answer_6">Открыть решение в песочнице.</a></p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Основы работы с событиями; Порядок обработки событий"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/introduction-browser-events",disqus_identifier="introduction-browser-events",disqus_title="\u0412\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u0432 \u0431\u0440\u0430\u0443\u0437\u0435\u0440\u043d\u044b\u0435 \u0441\u043e\u0431\u044b\u0442\u0438\u044f";</script></page-content></main>