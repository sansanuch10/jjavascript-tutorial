<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="119">Основы работы с событиями</a></nav-up><h1>Порядок обработки событий</h1><p>События могут возникать не только по очереди, но и «пачкой» по много сразу. Возможно и такое, что во время обработки одного события возникают другие, например пока выполнялся код для <code>onclick</code> – посетитель нажал кнопку на клавиатуре (событие <code>keydown</code>).</p><p>Здесь мы разберём, как браузер обычно работает с одновременно возникающими событиями и какие есть исключения из общего правила.</p><h2><a name="0" href="#0">Главный поток</a></h2><p>В каждом окне выполняется только один <em>главный</em> поток, который занимается выполнением JavaScript, отрисовкой и работой с DOM.</p><p>Он выполняет команды последовательно, может делать только одно дело одновременно и блокируется при выводе модальных окон, таких как <code>alert</code>.</p><important-><h3>Дополнительные потоки тоже есть</h3><p>Есть и другие, служебные потоки, например, для сетевых коммуникаций.</p><p>Поэтому скачивание файлов может продолжаться пока главный поток ждёт реакции на <code>alert</code>. Но управлять служебными потоками мы не можем.</p></important-><important-><h3>Web Workers</h3><p>Существует спецификация <a href="http://www.w3.org/TR/workers/">Web Workers</a>, которая позволяет запускать дополнительные JavaScript-процессы(workers).</p><p>Они могут обмениваться сообщениями с главным процессом, но у них свои переменные, и работают они также сами по себе.</p><p>Такие дополнительные процессы не имеют доступа к DOM, поэтому они полезны, преимущественно, при вычислениях, чтобы загрузить несколько ядер/процессоров одновременно.</p></important-><h2><a name="1" href="#1">Очередь событий</a></h2><p>Произошло одновременно несколько событий или во время работы одного случилось другое – как главному потоку обработать это?</p><p>Если главный поток прямо сейчас занят, то он не может срочно выйти из середины одной функции и прыгнуть в другую. А потом третью. Отладка при этом могла бы превратиться в кошмар, потому что пришлось бы разбираться с совместным состоянием нескольких функций сразу.</p><p>Поэтому используется альтернативный подход.</p><p><strong>Когда происходит событие, оно попадает в очередь.</strong></p><p>Внутри браузера непрерывно работает «главный внутренний цикл», который следит за состоянием очереди и обрабатывает события, запускает соответствующие обработчики и т.п.</p><p><strong>Иногда события добавляются в очередь сразу пачкой.</strong></p><p>Например, при клике на элементе генерируется несколько событий:</p><ol><li>Сначала <code>mousedown</code> – нажата кнопка мыши.</li><li>Затем <code>mouseup</code> – кнопка мыши отпущена и, так как это было над одним элементом, то дополнительно генерируется <code>click</code> (два события сразу).</li></ol><p>В действии:</p><code-example><script>`<textarea BLUE_rows_BLUE="8" BLUE_cols_BLUE="40" id="area">Кликни меня\n</textarea>\n\n<script>\n  area.onmousedown = function(e) { this.value += "mousedown\\n"; this.scrollTop = this.scrollHeight; };\n  area.onmouseup = function(e) { this.value += "mouseup\\n"; this.scrollTop = this.scrollHeight; };\n  area.onclick = function(e) { this.value += "click\\n"; this.scrollTop = this.scrollHeight; };\n<\/script>`</script><code-toolbar- iframe="150"><a title="показать" data-code_run="0"></a><div></div></code-toolbar-></code-example><p>Таким образом, при нажатии кнопки мыши в очередь попадёт событие <code>mousedown</code>, а при отпускании – сразу два события: <code>mouseup</code> и <code>click</code>. Браузер обработает их строго одно за другим: <code>mousedown</code> → <code>mouseup</code> → <code>click</code>.</p><p>При этом каждое событие из очереди обрабатывается полностью отдельно от других.</p><h2><a name="2" href="#2">Вложенные (синхронные) события</a></h2><p>Обычно возникающие события «становятся в очередь».</p><p>Но в тех случаях, когда событие инициируется не посетителем, а кодом, то оно, как правило, обрабатывается синхронно, то есть прямо сейчас.</p><p>Рассмотрим в качестве примера событие <code>onfocus</code>.</p><h3><a name="8" href="#8">Пример: событие onfocus</a></h3><p>Когда посетитель фокусируется на элементе, возникает событие <code>onfocus</code>. Обычно оно происходит, когда посетитель кликает на поле ввода, например:</p><code-example><script>`<p>При фокусе на поле оно изменит значение.</p>\n<input type="text" onfocus="this.value = 'Фокус!'" value="Кликни меня">`</script><code-toolbar iframe="80"></code-toolbar></code-example><p>Но ту же фокусировку можно вызвать и явно, вызовом метода <code>elem.focus()</code>:</p><code-example><script>`<input type="text" id="elem" onfocus="this.value = 'Фокус!'">\n\n<script>\nMARK  // сфокусируется на input и вызовет обработчик onfocus\nMARK  elem.focus();\n<\/script>`</script><code-toolbar iframe="40"></code-toolbar></code-example><p>В главе <a data-load_page="142">Фокусировка: focus/blur</a> мы познакомимся с этим событием подробнее, а пока – нажмите на кнопку в примере ниже.</p><p>При этом обработчик <code>onclick</code> вызовет метод <code>focus()</code> на текстовом поле <code>text</code>. Код обработчика <code>onfocus</code>, который при этом запустится, сработает синхронно, прямо сейчас, до завершения <code>onclick</code>.</p><code-example><script>`<input type="button" id="button" value="Нажми меня">\n<input type="text" id="text" BLUE_size_BLUE="60">\n\n<script>\n\n  button.onclick = function() {\n    text.value += ' ->в onclick ';\n\n    text.focus(); // вызов инициирует событие onfocus\n\n    text.value += ' из onclick-> ';\n  };\n\n  text.onfocus = function() {\n    text.value += ' !focus! ';\n  };\n<\/script>`</script><code-toolbar- iframe="70"><a data-code_run="" title="показать"></a><div></div></code-toolbar-></code-example><p>При клике на кнопке в примере выше будет видно, что управление вошло в <code>onclick</code>, затем перешло в <code>onfocus</code>, затем вышло из <code>onclick</code>.</p><important-warn><h3>Исключение в IE</h3><p>Так ведут себя все браузеры, кроме IE.</p><p>В нём событие <code>onfocus</code> – всегда асинхронное, так что будет сначала полностью обработан клик, а потом – фокус. В остальных – фокус вызовется посередине клика. Попробуйте кликнуть в IE и в другом браузере, чтобы увидеть разницу.</p></important-warn><h2><a name="3" href="#3">Делаем события асинхронными через setTimeout(…,0)</a></h2><p>А что, если мы хотим, чтобы <em>сначала</em> закончилась обработка <code>onclick</code>, а потом уже произошла обработка <code>onfocus</code> и связанные с ней действия?</p><p>Можно добиться и этого.</p><p>Один вариант – просто переместить строку <code>text.focus()</code> вниз кода обработчика <code>onclick</code>.</p><p>Если это неудобно, можно запланировать <code>text.focus()</code> чуть позже через <code>setTimeout(..., 0)</code>, вот так</p><code-example><script>`<input type="button" id="button" value="Нажми меня">\n<input type="text" id="text" BLUE_size_BLUE="60">\n\n<script>\n  button.onclick = function() {\n    text.value += ' ->в onclick ';\n\nMARK    setTimeout(function() {\nMARK      text.focus(); // сработает после onclick\nMARK    }, 0);\n\n    text.value += ' из onclick-> ';\n  };\n\n  text.onfocus = function() {\n    text.value += ' !focus! ';\n  };\n<\/script>`</script><code-toolbar iframe="50"></code-toolbar></code-example><p>Такой вызов обеспечит фокусировку через минимальный «тик» таймера, по стандарту равный 4 мс. Обычно такая задержка не играет роли, а необходимую асинхронность мы получили.</p><h2><a name="4" href="#4">Итого</a></h2><ul><li>JavaScript выполняется в едином потоке. Современные браузеры позволяют порождать подпроцессы <a href="http://www.w3.org/TR/workers/">Web Workers</a>, они выполняются параллельно и могут отправлять/принимать сообщения, но не имеют доступа к DOM.</li><li>Обычно события становятся в очередь и обрабатываются в порядке поступления, асинхронно, независимо друг от друга.</li><li>Синхронными являются вложенные события, инициированные из кода.</li><li>Чтобы сделать событие гарантированно асинхронным, используется вызов через <code>setTimeout(func, 0)</code>.</li></ul><p>Отложенный вызов через <code>setTimeout(func, 0)</code> используется не только в событиях, а вообще – всегда, когда мы хотим, чтобы некая функция <code>func</code> сработала после того, как текущий скрипт завершится.</p><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Введение в браузерные события; Объект события"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/events-and-timing-depth",disqus_identifier="events-and-timing-depth",disqus_title="\u041f\u043e\u0440\u044f\u0434\u043e\u043a \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0441\u043e\u0431\u044b\u0442\u0438\u0439";</script></page-content></main>