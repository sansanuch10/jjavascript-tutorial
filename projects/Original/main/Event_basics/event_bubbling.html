<main> <page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="119">Основы работы с событиями</a></nav-up><h1>Всплытие и перехват</h1><p>Давайте сразу начнём с примера.</p><p>Этот обработчик для <code>&lt;div&gt;</code> сработает, если вы кликните по вложенному тегу <code>&lt;em&gt;</code> или <code>&lt;code&gt;</code>:</p><code-example><script>`<div onclick="alert('Обработчик для Div сработал!')">\n  <em>Кликните на <code>EM</code>, сработает обработчик на <code>DIV</code></em>\n</div>`</script><code-toolbar- iframe="60"><a title="показать" data-code_run=""></a><div></div></code-toolbar-></code-example><p>Вам не кажется это странным? Почему же сработал обработчик на <code>&lt;div&gt;</code>, если клик произошёл на <code>&lt;em&gt;</code>?</p><h2><a name="0" href="#0">Всплытие</a></h2><p>Основной принцип всплытия:</p><p><strong>При наступлении события обработчики сначала срабатывают на самом вложенном элементе, затем на его родителе, затем выше и так далее, вверх по цепочке вложенности.</strong></p><p>Например, есть 3 вложенных элемента <code>FORM &gt; DIV &gt; P</code>, с обработчиком на каждом:</p><code-example><script>`<style>\n  body * {\n    margin: 10px;\n    border: 1px solid blue;\n  }\n</style>\n\n<form onclick="alert('form')">FORM\n  <div onclick="alert('div')">DIV\n    <p onclick="alert('p')">P</p>\n  </div>\n</form>`</script><code-toolbar iframe="123"></code-toolbar></code-example><p>Всплытие гарантирует, что клик по внутреннему <code>&lt;p&gt;</code> вызовет обработчик <code>onclick</code> (если есть) сначала на самом <code>&lt;p&gt;</code>, затем на элементе <code>&lt;div&gt;</code> далее на элементе <code>&lt;form&gt;</code>, и так далее вверх по цепочке родителей до самого <code>document</code>.</p><figure><img src="event-order-bubbling.png" alt="Порядок всплытия событий" width="100%" style="max-width:352px"></figure><p>Поэтому если в примере выше кликнуть на <code>P</code>, то последовательно выведутся <code>alert</code>: <code>p</code> → <code>div</code> → <code>form</code>.</p><p>Этот процесс называется <em>всплытием</em>, потому что события «всплывают» от внутреннего элемента вверх через родителей, подобно тому, как всплывает пузырек воздуха в воде.</p><important-warn><h3>Всплывают <em>почти</em> все события.</h3><p>Ключевое слово в этой фразе – «почти».</p><p>Например, событие <code>focus</code> не всплывает. В дальнейших главах мы будем детально знакомиться с различными событиями и увидим ещё примеры.</p></important-warn><h2><a name="1" href="#1">Целевой элемент event.target</a></h2><p>На каком бы элементе мы ни поймали событие, всегда можно узнать, где конкретно оно произошло.</p><p><strong>Самый глубокий элемент, который вызывает событие, называется <em>«целевым»</em> или <em>«исходным»</em> элементом и доступен как <code>event.target</code>.</strong></p><p>Отличия от <code>this</code> (= <code>event.currentTarget</code>):</p><ul><li><code>event.target</code> – это <strong>исходный элемент</strong>, на котором произошло событие, в процессе всплытия он неизменен.</li><li><code>this</code> – это <strong>текущий элемент</strong>, до которого дошло всплытие, на нём сейчас выполняется обработчик.</li></ul><p>Например, если стоит только один обработчик <code>form.onclick</code>, то он «поймает» все клики внутри формы. Где бы ни был клик внутри – он всплывёт до элемента <code>&lt;form&gt;</code>, на котором сработает обработчик.</p><p>При этом:</p><ul><li><code>this</code> ( <code>=event.currentTarget</code>) всегда будет сама форма, так как обработчик сработал на ней.</li><li><code>event.target</code> будет содержать ссылку на конкретный элемент внутри формы, самый вложенный, на котором произошёл клик.</li></ul><code-tabs data-code_switch=""><tools-><button-0 class="current">index.html</button-0><button-1>script.js</button-1><button-2>example.css</button-2></tools-><code-example style="display: block;"><script>`<!DOCTYPE HTML>\n<html>\n  \n<head>\n  <meta charset="utf-8">\n  <style>\n    GOLD_form_GOLD {\n      background: green;\n      position: relative;\n      width: 150px;\n      height: 150px;\n      text-align: center;\n      cursor: pointer;\n    }\n    \n    GOLD_div_GOLD {\n      background: blue;\n      position: absolute;\n      top: 25px;\n      left: 25px;\n      width: 100px;\n      height: 100px;\n    }\n    \n    GOLD_p_GOLD {\n      background: red;\n      position: absolute;\n      top: 25px;\n      left: 25px;\n      width: 50px;\n      height: 50px;\n      line-height: 50px;\n      margin: 0;\n    }\n    \n    GOLD_body_GOLD {\n      line-height: 25px;\n      font-size: 16px;\n    }\n  </style>\n</head>\n\n<body>    \n  <form>FORM\n    <div>DIV\n      <p>P</p>\n    </div>\n  </form>\n  \n  <script>\n    var form = document.querySelector('form');\n    form.onclick = function(event) {\n      event.target.style.backgroundColor = 'yellow';\n      setTimeout(() => {\n          alert("target =&nbsp" + event.target.tagName + ",  this =&nbsp"  + this.tagName);\n          event.target.style.backgroundColor = '';\n      }, 100)\n    };\n  <\/script>\n</body>\n</html>`</script><code-toolbar iframe="200"><a id="result_1" title="показать" data-code_run="0"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><code-example><script>`var form = document.querySelector('form');\n\nform.onclick = function(event) {\n  event.target.style.backgroundColor = 'yellow';\n  setTimeout(() => {\n      alert("target =&nbsp" + event.target.tagName + ", this =&nbsp" + this.tagName);\n      event.target.style.backgroundColor = '';\n  }, 100)\n};`</script></code-example><code-example><script>`GOLD_form_GOLD {\n  background: green;\n  position: relative;\n  width: 150px;\n  height: 150px;\n  text-align: center;\n  cursor: pointer;\n}\n\nGOLD_div_GOLD {\n  background: blue;\n  position: absolute;\n  top: 25px;\n  left: 25px;\n  width: 100px;\n  height: 100px;\n}\n\nGOLD_p_GOLD {\n  background: red;\n  position: absolute;\n  top: 25px;\n  left: 25px;\n  width: 50px;\n  height: 50px;\n  line-height: 50px;\n  margin: 0;\n}\n\nGOLD_body_GOLD {\n  line-height: 25px;\n  font-size: 16px;\n}`</script></code-example></code-tabs><p>Возможна и ситуация, когда <code>event.target</code> и <code>this</code> – один и тот же элемент, например если в форме нет других тегов и клик был на самом элементе <code>&lt;form&gt;</code>.</p><h2><a name="2" href="#2">Прекращение всплытия</a></h2><p>Всплытие идёт прямо наверх. Обычно событие будет всплывать наверх и наверх, до элемента <code>&lt;html&gt;</code>, а затем до <code>document</code>, а иногда даже до <code>window</code>, вызывая все обработчики на своем пути.</p><p><strong>Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.</strong></p><p>Для остановки всплытия нужно вызвать метод <code>event.stopPropagation()</code>.</p><p>Например, здесь при клике на кнопку обработчик <code>body.onclick</code> не сработает:</p><code-example><script>`<body onclick="alert('сюда обработка не дойдёт')">\n  <button onclick="event.stopPropagation()">Кликни меня</button>\n</body>`</script><code-toolbar iframe="60"></code-toolbar></code-example><important-><h3>event.stopImmediatePropagation()</h3><p>Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены.</p><p>То есть, <code>stopPropagation</code> препятствует продвижению события дальше, но на текущем элементе все обработчики отработают.</p><p>Для того, чтобы полностью остановить обработку, современные браузеры поддерживают метод <code>event.stopImmediatePropagation()</code>. Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.</p></important-><important-warn><h3>Не прекращайте всплытие без необходимости!</h3><p>Всплытие – это удобно. Не прекращайте его без явной нужды, очевидной и архитектурно прозрачной.</p><p>Зачастую прекращение всплытия создаёт свои подводные камни, которые потом приходится обходить.</p><p>Например:</p><ol><li>Мы делаем меню. Оно обрабатывает клики на своих элементах и делает для них <code>stopPropagation</code>. Вроде бы, всё работает.</li><li>Позже мы решили отслеживать все клики в окне, для какой-то своей функциональности, к примеру, для статистики – где вообще у нас кликают люди. Например, Яндекс.Метрика так делает, если включить соответствующую опцию.</li><li>Над областью, где клики убиваются <code>stopPropagation</code>, статистика работать не будет! Получилась «мёртвая зона».</li></ol><p>Проблема в том, что <code>stopPropagation</code> убивает всякую возможность отследить событие сверху, а это бывает нужно для реализации чего-нибудь «эдакого», что к меню отношения совсем не имеет.</p></important-warn><h2><a name="3" href="#3">Погружение</a></h2><p>В современном стандарте, кроме «всплытия» событий, предусмотрено ещё и «погружение».</p><p>Оно гораздо менее востребовано, но иногда, очень редко, знание о нём может быть полезным.</p><p>Строго говоря, стандарт выделяет целых три стадии прохода события:</p><ol><li>Событие сначала идет сверху вниз. Эта стадия называется <em>«стадия перехвата»</em> (capturing stage).</li><li>Событие достигло целевого элемента. Это – <em>«стадия цели»</em> (target stage).</li><li>После этого событие начинает всплывать. Это – <em>«стадия всплытия»</em> (bubbling stage).</li></ol><p>В <a href="http://www.w3.org/TR/DOM-Level-3-Events/">стандарте DOM Events 3</a> это продемонстрировано так:</p><figure><img src="eventflow.png" alt="" width="100%" style="max-width:641px"></figure><p>То есть, при клике на <code>TD</code> событие путешествует по цепочке родителей сначала вниз к элементу («погружается»), а потом наверх («всплывает»), по пути задействуя обработчики.</p><p><strong>Ранее мы говорили только о всплытии, потому что другие стадии, как правило, не используются и проходят незаметно для нас.</strong></p><p>Обработчики, добавленные через <code>on...</code>-свойство, ничего не знают о стадии перехвата, а начинают работать со всплытия.</p><p>Чтобы поймать событие на стадии перехвата, нужно использовать третий аргумент <code>addEventListener</code>:</p><ul><li>Если аргумент <code>true</code>, то событие будет перехвачено по дороге вниз.</li><li>Если аргумент <code>false</code>, то событие будет поймано при всплытии.</li></ul><p>Стадия цели, обозначенная на рисунке цифрой <code>(2)</code>, особо не обрабатывается, так как обработчики, назначаемые обоими этими способами, срабатывают также на целевом элементе.</p><important-><h3>Есть события, которые не всплывают, но которые можно перехватить</h3><p style="">Бывают события, которые можно поймать только на стадии перехвата, а на стадии всплытия – нельзя…</p><p>Например, таково событие фокусировки на элементе <a data-load_page="142">onfocus</a>. Конечно, это большая редкость, такое исключение существует по историческим причинам.</p></important-><h2><a name="4" href="#4">Примеры</a></h2><p style="">В примере ниже на <code>&lt;form&gt;</code>, <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code> стоят те же обработчики, что и раньше, но на этот раз – на стадии погружения. Чтобы увидеть перехват в действии, кликните в нём на элементе <code>&lt;p&gt;</code>:</p><code-tabs data-code_switch=""><tools-><button-0 class="current">index.html</button-0><button-1>script.js</button-1></tools-><code-example style="display: block;"><script>`<!DOCTYPE HTML>\n<html>\n  \n<head>\n  <meta charset="utf-8">\n  <style>\n    GOLD_form_GOLD {\n      background: green;\n      position: relative;\n      width: 150px;\n      height: 150px;\n      text-align: center;\n      cursor: pointer;\n    }\n    \n    GOLD_div_GOLD {\n      background: blue;\n      position: absolute;\n      top: 25px;\n      left: 25px;\n      width: 100px;\n      height: 100px;\n    }\n    \n    GOLD_p_GOLD {\n      background: red;\n      position: absolute;\n      top: 25px;\n      left: 25px;\n      width: 50px;\n      height: 50px;\n      line-height: 50px;\n      margin: 0;\n    }\n    \n    GOLD_body_GOLD {\n      line-height: 25px;\n      font-size: 16px;\n    }\n  </style>\n</head>\n\n<body>    \n  <form>FORM\n    <div>DIV\n      <p>P</p>\n    </div>\n  </form>\n  \n  <script>\n    var elems = document.querySelectorAll('form,div,p');\n\n    for (var i = 0; i < elems.length; i++) {\n      elems[i].addEventListener("click", highlightThis, true);\n    }\n    \n    function highlightThis() {\n      alert(this.tagName);\n    }\n  <\/script>\n</body>\n</html>`</script><code-toolbar iframe="200"><a id="result_1" title="показать" data-code_run="0"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><code-example><script>`var elems = document.querySelectorAll('form,div,p');\n\nfor (var i = 0; i < elems.length; i++) {\n  elems[i].addEventListener("click", highlightThis, true);\n}\n\nfunction highlightThis() {\n  alert(this.tagName);\n}`</script></code-example></code-tabs><p>Обработчики сработают в порядке «сверху-вниз»: <code>FORM</code> → <code>DIV</code> → <code>P</code>.</p><p>JS-код здесь такой:</p><code-example><script>`var elems = document.querySelectorAll('form,div,p');\n\n// на каждый элемент повесить обработчик на стадии перехвата\nfor (var i = 0; i < elems.length; i++) {\n  elems[i].addEventListener("click", highlightThis, true);\n}`</script></code-example><p>Никто не мешает назначить обработчики для обеих стадий, вот так:</p><code-example><script>`var elems = document.querySelectorAll('form,div,p');\n\nfor (var i = 0; i < elems.length; i++) {\n  elems[i].addEventListener("click", highlightThis, true);\n  elems[i].addEventListener("click", highlightThis, false);\n}`</script></code-example><p>Кликните по внутреннему элементу <code>&lt;p&gt;</code>, чтобы увидеть порядок прохода события:</p><code-tabs data-code_switch=""><tools-><button-0 class="current">index.html</button-0><button-1>script.js</button-1></tools-><code-example style="display: block;"><script>`<!DOCTYPE HTML>\n<html>\n  \n<head>\n  <meta charset="utf-8">\n  <style>\n    GOLD_form_GOLD {\n      background: green;\n      position: relative;\n      width: 150px;\n      height: 150px;\n      text-align: center;\n      cursor: pointer;\n    }\n    \n    GOLD_div_GOLD {\n      background: blue;\n      position: absolute;\n      top: 25px;\n      left: 25px;\n      width: 100px;\n      height: 100px;\n    }\n    \n    GOLD_p_GOLD {\n      background: red;\n      position: absolute;\n      top: 25px;\n      left: 25px;\n      width: 50px;\n      height: 50px;\n      line-height: 50px;\n      margin: 0;\n    }\n    \n    GOLD_body_GOLD {\n      line-height: 25px;\n      font-size: 16px;\n    }\n  </style>\n</head>\n\n<body>    \n  <form>FORM\n    <div>DIV\n      <p>P</p>\n    </div>\n  </form>\n  \n  <script>\n    var elems = document.querySelectorAll('form,div,p');\n\n    for (var i = 0; i < elems.length; i++) {\n      elems[i].addEventListener("click", highlightThis, true);\n      elems[i].addEventListener("click", highlightThis, false);\n    }\n    \n    function highlightThis() {\n      alert(this.tagName);\n    }\n  <\/script>\n</body>\n</html>`</script><code-toolbar iframe="200"><a id="result_1" title="показать" data-code_run="0"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><code-example style=""><script>`var elems = document.querySelectorAll('form,div,p');\n\nfor (var i = 0; i < elems.length; i++) {\n  elems[i].addEventListener("click", highlightThis, true);\n  elems[i].addEventListener("click", highlightThis, false);\n}\n\nfunction highlightThis() {\n  alert(this.tagName);\n}`</script></code-example></code-tabs><p>Должно быть <code>FORM</code> → <code>DIV</code> → <code>P</code> → <code>P</code> → <code>DIV</code> → <code>FORM</code>. Заметим, что элемент <code>&lt;p&gt;</code> участвует в обоих стадиях.</p><p>Как видно из примера, один и тот же обработчик можно назначить на разные стадии. При этом номер текущей стадии он, при необходимости, может получить из свойства <code>event.eventPhase</code> (=1, если погружение, =3, если всплытие).</p><h2><a name="5" href="#5">Отличия IE8-</a></h2><p>Чтобы было проще ориентироваться, я собрал отличия IE8-, которые имеют отношение ко всплытию, в одну секцию.</p><p>Их знание понадобится, если вы решите писать на чистом JS, без фреймворков и вам понадобится поддержка IE8-.</p><dl><dt>Нет свойства <code>event.currentTarget</code></dt><dd><p>Обратим внимание, что при назначении обработчика через <code>onсвойство</code> у нас есть <code>this</code>, поэтому <code>event.currentTarget</code>, как правило, не нужно, а вот при назначении через <code>attachEvent</code> обработчик не получает <code>this</code>, так что текущий элемент, если нужен, можно будет взять лишь из замыкания.</p></dd><dt>Вместо <code>event.target</code> в IE8- используется <code>event.srcElement</code></dt><dd><p>Если мы пишем обработчик, который будет поддерживать и IE8- и современные браузеры, то можно начать его так:</p><code-example><script>`elem.onclick = function(event) {\n  event = event || window.event;\n  var target = event.target || event.srcElement;\n\n  // ... теперь у нас есть объект события и target\n  ...\n}`</script></code-example></dd><dt>Для остановки всплытия используется код <code>event.cancelBubble=true</code>.</dt><dd><p>Кросс-браузерно остановить всплытие можно так:</p><code-example><script>`event.stopPropagation ? event.stopPropagation() : (event.cancelBubble=true);`</script></code-example></dd></dl><p>Далее в учебнике мы будем использовать стандартные свойства и вызовы, поскольку добавление этих строк, обеспечивающих совместимость – достаточно простая и очевидная задача. Кроме того, никто не мешает подключить полифилл.</p><p>Ещё раз хотелось бы заметить – эти отличия нужно знать при написании JS-кода с поддержкой IE8- без фреймворков. Почти все JS-фреймворки обеспечивают кросс-браузерную поддержку <code>target</code>, <code>currentTarget</code> и <code>stopPropagation()</code>.</p><h2><a name="6" href="#6">Итого</a></h2><p>Алгоритм:</p><ul><li>При наступлении события – элемент, на котором оно произошло, помечается как «целевой» ( <code>event.target</code>).</li><li>Далее событие сначала двигается вниз от корня документа к <code>event.target</code>, по пути вызывая обработчики, поставленные через <code>addEventListener(...., true)</code>.</li><li>Далее событие двигается от <code>event.target</code> вверх к корню документа, по пути вызывая обработчики, поставленные через <code>on*</code> и <code>addEventListener(...., false)</code>.</li></ul><p>Каждый обработчик имеет доступ к свойствам события:</p><ul><li><code>event.target</code> – самый глубокий элемент, на котором произошло событие.</li><li><code>event.currentTarget</code> (= <code>this</code>) – элемент, на котором в данный момент сработал обработчик (до которого «доплыло» событие).</li><li><code>event.eventPhase</code> – на какой фазе он сработал (погружение =1, всплытие = 3).</li></ul><p>Любой обработчик может остановить событие вызовом <code>event.stopPropagation()</code>, но делать это не рекомендуется, так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.</p><p>В современной разработке стадия погружения используется очень редко.</p><p>Этому есть две причины:</p><ol><li><p>Историческая – так как IE лишь с версии 9 в полной мере поддерживает современный стандарт.</p></li><li><p>Разумная – когда происходит событие, то разумно дать возможность первому сработать обработчику на самом элементе, поскольку он наиболее конкретен. Код, который поставил обработчик именно на этот элемент, знает максимум деталей о том, что это за элемент, чем он занимается.</p><p>Далее имеет смысл передать обработку события родителю – он тоже понимает, что происходит, но уже менее детально, далее – выше, и так далее, до самого объекта <code>document</code>, обработчик на котором реализовывает самую общую функциональность уровня документа.</p></li></ol><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Объект события; Делегирование событий"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/event-bubbling",disqus_identifier="event-bubbling",disqus_title="\u0412\u0441\u043f\u043b\u044b\u0442\u0438\u0435 \u0438 \u043f\u0435\u0440\u0435\u0445\u0432\u0430\u0442";</script></page-content></main>