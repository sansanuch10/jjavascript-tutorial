<main> <page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="119">Основы работы с событиями</a></nav-up><h1>Делегирование событий</h1><p>Всплытие событий позволяет реализовать один из самых важных приёмов разработки – <em>делегирование</em>.</p><p>Он заключается в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому – мы ставим один обработчик на их общего предка. Из него можно получить целевой элемент <code>event.target</code>, понять на каком именно потомке произошло событие и обработать его.</p><h2><a name="0" href="#0">Пример «Ба Гуа»</a></h2><p>Рассмотрим пример – <a href="http://en.wikipedia.org/wiki/Ba_gua">диаграмму «Ба Гуа»</a>. Это таблица, отражающая древнюю китайскую философию.</p><p>Вот она:</p><iframe- src="bagua.html"><script> function on(){var selectedTd;bagua.onclick=function(event){var target=event.target;while (target != this){if (target.tagName == 'TD'){highlight(target);return;}target=target.parentNode;}};function highlight(node){if (selectedTd){selectedTd.style.background=selectedTd.background;}selectedTd=node;selectedTd.background=selectedTd.style.background;selectedTd.style.background='red';}}</script><code-toolbar-><div></div><a title="открыть в новом окне" data-new_window=""></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></iframe-><p>Её HTML (схематично):</p><code-example><script>`<table>\n  <tr>\n    <th colspan="3"><em>Bagua</em> Chart: Direction, Element, Color, Meaning</th>\n  </tr>\n  <tr>\n    <td>...<strong>Northwest</strong>...</td>\n    <td>...</td>\n    <td>...</td>\n  </tr>\n  <tr>...еще 2 строки такого же вида...</tr>\n  <tr>...еще 2 строки такого же вида...</tr>\n</table>`</script></code-example><p>В этой таблице всего 9 ячеек, но могло быть и 99, и даже 9999, не важно.</p><p><strong>Наша задача – реализовать подсветку ячейки <code>&lt;td&gt;</code> при клике.</strong></p><p>Вместо того, чтобы назначать обработчик для каждой ячейки, которых может быть очень много – мы повесим <em>единый обработчик</em> на элемент <code>&lt;table&gt;</code>.</p><p>Он будет использовать <code>event.target</code>, чтобы получить элемент, на котором произошло событие, и подсветить его.</p><p>Код будет таким:</p><code-example><script>`var selectedTd;\n\nMARKtable.onclick = function(event) {\nMARK  var target = event.target; // где был клик?\nMARK&nbsp\nMARK  if (target.tagName != 'TD') return; // не на TD? тогда не интересует\nMARK&nbsp\nMARK  highlight(target); // подсветить TD\nMARK};\n\nfunction highlight(node) {\n  if (selectedTd) {\n    selectedTd.classList.remove('highlight');\n  }\n  selectedTd = node;\n  selectedTd.classList.add('highlight');\n}`</script></code-example><p>Такому коду нет разницы, сколько ячеек в таблице. Обработчик всё равно один. Я могу добавлять, удалять <code>&lt;td&gt;</code> из таблицы, менять их количество – моя подсветка будет стабильно работать, так как обработчик стоит на <code>&lt;table&gt;</code>.</p><p>Однако, у текущей версии кода есть недостаток.</p><p><strong>Клик может быть не на том теге, который нас интересует, а внутри него.</strong></p><p>В нашем случае, если взглянуть на HTML таблицы внимательно, видно, что ячейка содержит вложенные теги, например <code>&lt;strong&gt;</code>:</p><code-example><script>`<td>\nMARK  <strong>Northwest</strong>\n  ...Metal..Silver..Elders...\n</td>`</script></code-example><p>Естественно, клик может произойти внутри <code>&lt;td&gt;</code>, на элементе <code>&lt;strong&gt;</code>. Такой клик будет пойман единым обработчиком, но <code>target</code> у него будет не <code>&lt;td&gt;</code>, а <code>&lt;strong&gt;</code>:</p><figure><img src="bagua-bubble.png" alt="" width="100%" style="max-width:320px"></figure><p>Внутри обработчика <code>table.onclick</code> мы должны по <code>event.target</code> разобраться, в каком именно <code>&lt;td&gt;</code> был клик.</p><p>Для этого мы, используя ссылку <code>parentNode</code>, будем идти вверх по иерархии родителей от <code>event.target</code> и выше и проверять:</p><ul><li>Если нашли <code>&lt;td&gt;</code>, значит это то что нужно.</li><li>Если дошли до элемента <code>table</code> и при этом <code>&lt;td&gt;</code> не найден, то наверное клик был вне <code>&lt;td&gt;</code>, например на элементе заголовка таблицы.</li></ul><p>Улучшенный обработчик <code>table.onclick</code> с циклом <code>while</code>, который это делает:</p><code-example><script>`table.onclick = function(event) {\n  var target = event.target;\n\n  // цикл двигается вверх от target к родителям до table\n  while (target != table) {\n    if (target.tagName == 'TD') {\n      // нашли элемент, который нас интересует!\n      highlight(target);\n      return;\n    }\n    target = target.parentNode;\n  }\n\n  // возможна ситуация, когда клик был вне <td>\n  // если цикл дошёл до table и ничего не нашёл,\n  // то обработчик просто заканчивает работу\n}`</script></code-example><important-><h3>На заметку:</h3><p>Кстати, в проверке <code>while</code> можно бы было использовать <code>this</code> вместо <code>table</code>:</p><code-example><script>`while (target != this) {\n  // ...\n}`</script></code-example><p>Это тоже будет работать, так как в обработчике <code>table.onclick</code> значением <code>this</code> является текущий элемент, то есть <code>table</code>.</p></important-><p>Можно для этого использовать и метод <code>closest</code>, при поддержке браузером:</p><code-example><script>`table.onclick = function(event) {\n  var target = event.target;\n\n  var td = target.closest('td');\n  if (!td) return; // клик вне <td>, не интересует\n\n  // если клик на td, но вне этой таблицы (возможно при вложенных таблицах)\n  // то не интересует\n  if (!table.contains(td)) return;\n\n  // нашли элемент, который нас интересует!\n  highlight(td);\n}`</script></code-example><h2><a name="1" href="#1">Применение делегирования: действия в разметке</a></h2><p>Обычно делегирование – это средство оптимизации интерфейса. Мы используем один обработчик для <em>схожих</em> действий на однотипных элементах.</p><p>Выше мы это делали для обработки кликов на <code>&lt;td&gt;</code>.</p><p><strong>Но делегирование позволяет использовать обработчик и для абсолютно разных действий.</strong></p><p>Например, нам нужно сделать меню с разными кнопками: «Сохранить», «Загрузить», «Поиск» и т.д. И есть объект с соответствующими методами: <code>save</code>, <code>load</code>, <code>search</code> и т.п…</p><p>Первое, что может прийти в голову – это найти каждую кнопку и назначить ей свой обработчик среди методов объекта.</p><p>Но более изящно решить задачу можно путем добавления одного обработчика на всё меню, а для каждой кнопки в специальном атрибуте, который мы назовем <code>data-action</code> (можно придумать любое название, но <code>data-*</code> является валидным в HTML5), укажем, что она должна вызывать:</p><code-example><script>`<button BLUE_data-action_BLUE="save">Нажмите, чтобы Сохранить</button>`</script></code-example><p>Обработчик считывает содержимое атрибута и выполняет метод. Взгляните на рабочий пример:</p><code-example><script>`<div id="menu">\n  <button data-action="save">Сохранить</button>\n  <button data-action="load">Загрузить</button>\n  <button data-action="search">Поиск</button>\n</div>\n\n<script>\n  function Menu(elem) {\n    this.save = function() {\n      alert( 'сохраняю' );\n    };\n    this.load = function() {\n      alert( 'загружаю' );\n    };\n    this.search = function() {\n      alert( 'ищу' );\n    };\n\n    var self = this;\n\n    elem.onclick = function(e) {\n      var target = e.target;\nMARK      var action = target.getAttribute('data-action');\nMARK      if (action) {\nMARK        self[action]();\nMARK      }\n    };\n  }\n\n  new Menu(menu);\n<\/script>`</script><code-toolbar- iframe="60"><a onclick="this.parentElement.nextElementSibling.style.height='200px'" title="показать" data-code_run=""></a><div></div></code-toolbar-></code-example><p>Обратите внимание, как используется трюк с <code>var self = this</code>, чтобы сохранить ссылку на объект <code>Menu</code>. Иначе обработчик просто бы не смог вызвать методы <code>Menu</code>, потому что его собственный <code>this</code> ссылается на элемент.</p><p>Что в этом случае нам дает использование делегирования событий?</p><balance-><balance-pluses-single><ul><li>Не нужно писать код, чтобы присвоить обработчик каждой кнопке. Меньше кода, меньше времени, потраченного на инициализацию.</li><li>Структура HTML становится по-настоящему гибкой. Мы можем добавлять/удалять кнопки в любое время.</li><li>Данный подход является семантичным. Также можно использовать классы <code>.action-save</code>, <code>.action-load</code> вместо атрибута <code>data-action</code>.</li></ul></balance-pluses-single></balance-><h2><a name="2" href="#2">Итого</a></h2><p>Делегирование событий – это здорово! Пожалуй, это один из самых полезных приёмов для работы с DOM. Он отлично подходит, если есть много элементов, обработка которых очень схожа.</p><p>Алгоритм:</p><ol><li>Вешаем обработчик на контейнер.</li><li>В обработчике: получаем <code>event.target</code>.</li><li>В обработчике: если <code>event.target</code> или один из его родителей в контейнере ( <code>this</code>) – интересующий нас элемент – обработать его.</li></ol><p>Зачем использовать:</p><balance-><balance-pluses-single><ul><li>Упрощает инициализацию и экономит память: не нужно вешать много обработчиков.</li><li>Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.</li><li>Удобство изменений: можно массово добавлять или удалять элементы путём изменения <code>innerHTML</code>.</li></ul></balance-pluses-single></balance-><p>Конечно, у делегирования событий есть свои ограничения.</p><balance-><balance-minuses-single><ul><li>Во-первых, событие должно всплывать. Нельзя, чтобы какой-то промежуточный обработчик вызвал <code>event.stopPropagation()</code> до того, как событие доплывёт до нужного элемента.</li><li>Во-вторых, делегирование создает дополнительную нагрузку на браузер, ведь обработчик запускается, когда событие происходит в любом месте контейнера, не обязательно на элементах, которые нам интересны. Но обычно эта нагрузка настолько пустяковая, что её даже не стоит принимать во внимание.</li></ul></balance-minuses-single></balance-><h2 id="tasks"><a href="#3" name="3">Задачи (3)</a></h2><task-content><h3><a href="#6" name="6">Скрытие сообщения с помощью делегирования</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Дан список сообщений. Добавьте каждому сообщению кнопку для его скрытия.</p><p><strong>Используйте делегирование событий. Один обработчик для всего.</strong></p><p>В результате, должно работать вот так(кликните на крестик):</p><iframe- id="hide_message" src="hide_message.html" changeable=""><code-toolbar- id="remove_message"><a data-show_messages="" title="показать" onclick="var divs= hide_message.querySelectorAll('div'); for (i = 0, l = divs.length; i < l; i++) {if(divs[i].hidden)divs[i].hidden=false;}"></a><a id="answer_1" style="display:none" title="открыть в песочнице" data-code_edit=""></a><a id="task_1" title="открыть в песочнице" data-code_edit="?"></a></code-toolbar-><script> function on(){var container=document.querySelector('messages-');container.onclick=function(event){if (event.target.tagName==="BUTTON");event.target.parentNode.hidden=true;}}</script></iframe-><p><a data-click="task_1">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Поставьте обработчик <code>click</code> на контейнере. Он должен проверять, произошел ли клик на кнопке удаления ( <code>target</code>), и если да, то скрыть соответствующий ей <code>DIV</code>.</p><p><a data-click="answer_1">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#7" name="7">Раскрывающееся дерево</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Создайте дерево, которое по клику на заголовок скрывает-показывает детей:</p><iframe- id="tree_hide" src="tree.html" changeable=""><code-toolbar-><a id="answer_2" style="display:none" title="открыть в песочнице" data-code_edit=""></a><a title="открыть в новом окне" data-new_window=""></a><a id="task_2" title="открыть в песочнице" data-code_edit="?"></a></code-toolbar-><style id="tree_style"> ul span:hover{font-weight:bold;}ul span{cursor:pointer;}</style><script> function on(){var tree=tree_hide.querySelector('ul');var treeLis=tree.getElementsByTagName('li');/* wrap all textNodes into spans */ for (var i=0;i<treeLis.length;i++){var li=treeLis[i];var span=document.createElement('span');li.insertBefore(span,li.firstChild);span.appendChild(span.nextSibling);}/* catch clicks on whole tree */ tree.onclick=function(event){var target=event.target;if (target.tagName != 'SPAN'){return;}/* now we know the SPAN is clicked */ var childrenContainer=target.parentNode.getElementsByTagName('ul')[0];if (!childrenContainer) return;/* no children */ childrenContainer.hidden=!childrenContainer.hidden;}}</script></iframe-><p>Требования:</p><ul><li>Использовать делегирование.</li><li>Клик вне текста заголовка (на пустом месте) ничего делать не должен.</li><li>При наведении на заголовок – он становится жирным, реализовать через CSS.</li></ul><p>P.S. При необходимости HTML/CSS дерева можно изменить.</p><p><a data-click="task_2">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="" style="">Схема решения</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Схема решения</h4><p>Дерево устроено как вложенный список.</p><p>Клики на все элементы можно поймать, повесив единый обработчик <code>onclick</code> на внешний <code>UL</code>.</p><p>Как поймать клик на заголовке? Элемент <code>LI</code> является блочным, поэтому нельзя понять, был ли клик на <em>тексте</em>, или справа от него.</p><p>Например, ниже – участок дерева с выделенными рамкой узлами. Кликните справа от любого заголовка. Видите, клик ловится? А лучше бы такие клики (не на тексте) игнорировать.</p><code-example><script>`<style>\n  GOLD_li_GOLD {\n    border: 1px solid green;\n  }\n</style>\n\n<ul onclick="alert(event.target)">\n  <li>Млекопетающие\n    <ul>\n      <li>Коровы</li>\n      <li>Ослы</li>\n      <li>Собаки</li>\n      <li>Тигры</li>\n    </ul>\n  </li>\n</ul>`</script><code-toolbar iframe="170"><a title="показать" data-code_run="0"></a><div></div></code-toolbar></code-example><p>В примере выше видно, что проблема в верстке, в том что <code>LI</code> занимает всю ширину. Можно кликнуть справа от текста, это все еще <code>LI</code>.</p><p>Один из способов это поправить – обернуть заголовки в дополнительный элемент <code>SPAN</code>, и обрабатывать только клики внутри <code>SPAN'ов</code>, получать по <code>SPAN'у</code> его родителя <code>LI</code> и ставить ему класс открыт/закрыт.</p><p>Напишите для этого JavaScript-код.</p></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Оборачиваем заголовки в SPAN</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Оборачиваем заголовки в SPAN</h4><p>Следующий код ищет все <code>LI</code> и оборачивает текстовые узлы в <code>SPAN</code>.</p><code-example><script>`var treeUl = document.getElementsByTagName('ul')[0];\n\nvar treeLis = treeUl.getElementsByTagName('li');\n\nfor (var i = 0; i < treeLis.length; i++) {\n  var li = treeLis[i];\n\n  var span = document.createElement('span');\n  li.insertBefore(span, li.firstChild); // добавить пустой SPAN\n  span.appendChild(span.nextSibling); // переместить в него заголовок\n}`</script></code-example><p>Теперь можно отслеживать клики <em>на заголовках</em>.</p><p>Так выглядит дерево с обёрнутыми в <code>SPAN</code> заголовками и делегированием:</p><code-example><script>`<style>\n  GOLD_span_GOLD {\n    border: 1px solid red;\n  }\n</style>\n\n<ul onclick="alert(event.target.tagName)">\n  <li><span>Млекопетающие</span>\n    <ul>\n      <li><span>Коровы</span></li>\n      <li><span>Ослы</span></li>\n      <li><span>Собаки</span></li>\n      <li><span>Тигры</span></li>\n    </ul>\n  </li>\n</ul>`</script><code-toolbar iframe="170"><a title="показать" data-code_run="0"></a><div></div></code-toolbar></code-example><p>Так как <code>SPAN</code> – инлайновый элемент, он всегда такого же размера как текст. Да здравствует <code>SPAN</code>!</p><p>В реальной жизни дерево, скорее всего, будет сразу со <code>SPAN</code>: если HTML-код дерева генерируется на сервере, то это несложно, если дерево генерируется в JavaScript – тем более просто.</p></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Итоговое решение</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Итоговое решение</h4><p>Для делегирования нужно по клику понять, на каком узле он произошел.</p><p>В нашем случае у <code>SPAN</code> нет детей-элементов, поэтому не нужно подниматься вверх по цепочке родителей. Достаточно просто проверить <code>event.target.tagName == 'SPAN'</code>, чтобы понять, где был клик, и спрятать потомков.</p><code-example><script>`var tree = document.getElementsByTagName('ul')[0];\n\ntree.onclick = function(event) {\n  var target = event.target;\n\n  if (target.tagName != 'SPAN') {\n    return; // клик был не на заголовке\n  }\n\n  var li = target.parentNode; // получить родительский LI\n\n  // получить UL с потомками -- это первый UL внутри LI\n  var childrenContainer = li.getElementsByTagName('ul')[0];\n\n  if (!childrenContainer) return; // потомков нет -- ничего не надо делать\n\n  // спрятать/показать (можно и через CSS-класс)\n  childrenContainer.hidden = !childrenContainer.hidden;\n}`</script></code-example><p>Выделение узлов жирным при наведении делается при помощи CSS-селектора <code>:hover</code>.</p><p><a data-click="answer_2">Открыть решение в песочнице.</a></p></task-answer></task-answer-ext></task-content><task-content><h3><a href="#8" name="8">Сортировка таблицы</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>Сделать сортировку таблицы при клике на заголовок.</p><p>Демо:</p><figure-><code-toolbar-><a id="answer_3" style="display:none" title="открыть в песочнице" data-code_edit=""></a><a id="task_3" title="открыть в песочнице" data-code_edit="task"></a></code-toolbar-><style> #grid th{cursor:pointer;}#grid th:hover{background:yellow;}</style><table id="grid"><thead><tr><th data-type="number">Возраст</th><th data-type="string">Имя</th></tr></thead><tbody><tr><td>5</td><td>Вася</td></tr><tr><td>12</td><td>Женя</td></tr><tr><td>1</td><td>Илья</td></tr><tr><td>9</td><td>Маша</td></tr><tr><td>2</td><td>Петя</td></tr></tbody></table><script> /* сортировка таблицы,использовать делегирование! должно быть масштабируемо:код работает без изменений при добавлении новых столбцов и строк */ var grid=document.getElementById('grid');grid.onclick=function(e){if (e.target.tagName != 'TH') return;sortGrid(e.target.cellIndex,e.target.getAttribute('data-type'));/* Если TH -- сортируем */};function sortGrid(colNum,type){var tbody=grid.getElementsByTagName('tbody')[0];var rowsArray=[].slice.call(tbody.rows);/* Составить массив из TR */ /* определить функцию сравнения,в зависимости от типа */ var compare;switch (type){case 'number':compare=function(rowA,rowB){return rowA.cells[colNum].innerHTML-rowB.cells[colNum].innerHTML;};break;case 'string':compare=function(rowA,rowB){return rowA.cells[colNum].innerHTML>rowB.cells[colNum].innerHTML;};break;}rowsArray.sort(compare);grid.removeChild(tbody);/* Убрать tbody из большого DOM документа для лучшей производительности */ /* добавить результат в нужном порядке в TBODY,они автоматически будут убраны со старых мест и вставлены в правильном порядке */ for (var i=0;i<rowsArray.length;i++){tbody.appendChild(rowsArray[i]);}grid.appendChild(tbody);}</script></figure-><p>Требования:</p><ul><li>Использовать делегирование.</li><li>Код не должен меняться при увеличении количества столбцов или строк.</li></ul><p>P.S. Обратите внимание, тип столбца задан атрибутом у заголовка. Это необходимо, ведь числа сортируются иначе чем строки. Соответственно, код это может использовать.</p><p>P.P.S. Вам помогут дополнительные <a data-load_page="103#5">навигационные ссылки по таблицам</a>.</p><p><a data-click="task_3">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="" style="">Подсказка (обработчик)</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Подсказка (обработчик)</h4><ol><li>Обработчик <code>onclick</code> можно повесить один, на всю таблицу или <code>THEAD</code>. Он будет игнорировать клики не на <code>TH</code>.</li><li>При клике на <code>TH</code> обработчик будет получать номер из <code>TH</code>, на котором кликнули ( <code>TH.cellIndex</code>) и вызывать функцию <code>sortColumn</code>, передавая ей номер колонки и тип.</li><li>Функция <code>sortColumn(colNum, type)</code> будет сортировать.</li></ol></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Подсказка (сортировка)</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Подсказка (сортировка)</h4><p>Функция сортировки:</p><ol><li>Переносит все <code>TR</code> из <code>TBODY</code> в массив <code>rowsArr</code></li><li>Сортирует массив, используя <code>rowsArr.sort(compare)</code>, функция <code>compare</code> зависит от типа столбца.</li><li>Добавляет <code>TR</code> из массива обратно в <code>TBODY</code></li></ol><p><a data-click="answer_3">Открыть решение в песочнице.</a></p></task-answer></task-answer-ext></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Всплытие и перехват; Приём проектирования 'поведение'"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script> disqus_url="https:\/\/learn.javascript.ru\/event-delegation",disqus_identifier="event-delegation",disqus_title="\u0414\u0435\u043b\u0435\u0433\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u043e\u0431\u044b\u0442\u0438\u0439";</script></page-content></main>