<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="119">Основы работы с событиями</a></nav-up><h1>Генерация событий на элементах</h1><p>Можно не только назначать обработчики на события, но и генерировать их самому.</p><p>Мы будем использовать это позже для реализации компонентной архитектуры, при которой элемент, представляющий собой, к примеру, меню, генерирует события, к этому меню относящиеся – <code>select</code> (выбран пункт меню) или <code>open</code> (меню раскрыто), и другие.</p><p>Кроме того, события можно генерировать для целей автоматического тестирования.</p><h2><a name="0" href="#0">Конструктор Event</a></h2><p>Вначале рассмотрим современный способ генерации событий, по стандарту <a href="http://www.w3.org/TR/dom/#introduction-to-dom-events">DOM 4</a>. Он поддерживается всеми браузерами, кроме IE11-. А далее рассмотрим устаревшие варианты, поддерживаемые IE.</p><p>Объект события в нём создаётся при помощи встроенного конструктора <a href="http://www.w3.org/TR/dom/#event">Event</a>.</p><p>Синтаксис:</p><code-example><script>`var event = new Event(тип события[, флаги]);`</script></code-example><p>Где:</p><ul><li><p><em>Тип события</em> – может быть как своим, так и встроенным, к примеру <code>"click"</code>.</p></li><li><p><em>Флаги</em> – объект вида <code>{ bubbles: true/false, cancelable: true/false }</code>, где свойство <code>bubbles</code> указывает, всплывает ли событие, а <code>cancelable</code> – можно ли отменить действие по умолчанию.</p><p>Флаги по умолчанию: <code>{bubbles: false, cancelable: false}</code>.</p></li></ul><h2><a name="1" href="#1">Метод dispatchEvent</a></h2><p>Затем, чтобы инициировать событие, запускается <code>elem.dispatchEvent(event)</code>.</p><p>При этом событие срабатывает наравне с браузерными, то есть обычные браузерные обработчики на него отреагируют. Если при создании указан флаг <code>bubbles</code>, то оно будет всплывать.</p><p>При просмотре примера ниже обработчик <code>onclick</code> на кнопке сработает сам по себе, событие генерируется скриптом:</p><code-example><script>`<button id="elem" onclick="alert('Клик');">Автоклик</button>\n\n<script>\n  var event = new Event("click");\n  elem.dispatchEvent(event);\n<\/script>`</script><code-toolbar iframe="38"></code-toolbar></code-example><h2><a name="2" href="#2">Отмена действия по умолчанию</a></h2><p>На сгенерированном событии, как и на встроенном браузерном, обработчик может вызвать метод <code>event.preventDefault()</code>. Тогда <code>dispatchEvent</code> возвратит <code>false</code>.</p><p>Остановимся здесь подробнее. Обычно вызов <code>preventDefault()</code> предотвращает действие браузера. В случае, если событие придумано нами, имеет нестандартное имя – никакого действия браузера, конечно, нет.</p><p>Но код, который генерирует событие, может предусматривать какие-то ещё действия после <code>dispatchEvent</code>.</p><p>Вызов <code>event.preventDefault()</code> является возможностью для обработчика события сообщить в сгенерировавший событие код, что эти действия продолжать не надо.</p><p>В примере ниже есть функция <code>hide()</code>, которая при вызове генерирует событие <code>hide</code> на элементе <code>#rabbit</code>, уведомляя всех интересующихся, что кролик собирается спрятаться.</p><p>Любой обработчик может узнать об этом, подписавшись на событие через <code>rabbit.addEventListener('hide',...)</code> и, при желании, отменить действие по умолчанию через <code>event.preventDefault()</code>. Тогда кролик не исчезнет:</p><code-example><script>`<pre id="rabbit">\n  |\\   /|\n   \\|_|/\n   /. .\\\n  =\\_Y_/=\n   {>o<}\n</pre>\n\n<script>\n\n  function hide() {\n    var event = new Event("hide", {\n      cancelable: true\n    });\n    if (!rabbit.dispatchEvent(event)) {\n      alert( 'действие отменено обработчиком' );\n    } else {\n      rabbit.hidden = true;\n    }\n  }\n\n  rabbit.addEventListener('hide', function(event) {\n    if (confirm("Вызвать preventDefault?")) {\n      event.preventDefault();\n    }\n  });\n\n  // прячемся через 2 секунды\n  setTimeout(hide, 2000);\n\n<\/script>`</script><code-toolbar- iframe="125"><a title="показать" data-code_run="0"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><important-><h3>Как отличить реальное нажатие от скриптового?</h3><p>В целях безопасности иногда хорошо бы знать – инициировано ли действие посетителем или это кликнул скрипт.</p><p>Единственный способ, которым код может отличить реальное нажатие от программного, является проверка свойства <code>event.isTrusted</code>.</p><p>Оно на момент написания статьи поддерживается IE и Firefox и равно <code>true</code>, если посетитель кликнул сам, и всегда <code>false</code> – если событие инициировал скрипт.</p></important-><h2><a name="3" href="#3">Другие свойства событий</a></h2><p>При создании события браузер автоматически ставит следующие свойства:</p><ul><li><code>isTrusted: false</code> – означает, что событие сгенерировано скриптом, это свойство изменить невозможно.</li><li><code>target: null</code> – это свойство ставится автоматически позже при <code>dispatchEvent</code>.</li><li><code>type: тип события</code> – первый аргумент <code>new Event</code>.</li><li><code>bubbles</code>, <code>cancelable</code> – по второму аргументу <code>new Event</code>.</li></ul><p>Другие свойства события, если они нужны, например координаты для события мыши – можно присвоить в объект события позже, например:</p><code-example><script>`var event = new Event("click", {bubbles: true, cancelable: false});\nevent.clientX = 100;\nevent.clientY = 100;`</script></code-example><h2><a name="4" href="#4">Пример со всплытием</a></h2><p>Сгенерируем совершенно новое событие <code>"hello"</code> и поймаем его на <code>document</code>.</p><p>Всё, что для этого нужно – это флаг <code>bubbles</code>:</p><code-example><script>`<h1 id="elem">Привет от скрипта!</h1>\n\n<script>\n  document.addEventListener("hello", function(event) { // (1)\n    alert("Привет");\n    event.preventDefault();  // (2)\n  }, false);\n\n  var event = new Event("hello", {bubbles: true, cancelable: true}); // (3)\n  if (elem.dispatchEvent(event) === false) {\n    alert('Событие было отменено preventDefault');\n  }\n<\/script>`</script><code-toolbar iframe="80"></code-toolbar></code-example><p>Обратите внимание:</p><ol><li>Обработчик события <code>hello</code> стоит на <code>document</code>. Мы его поймаем на всплытии.</li><li>Вызов <code>event.preventDefault()</code> приведёт к тому, что <code>dispatchEvent</code> вернёт <code>false</code>.</li><li>Чтобы событие всплывало и его можно было отменить, указан второй аргумент <code>new Event</code>.</li></ol><p>Никакой разницы между встроенными событиями (<code>click</code>) и своими (<code>hello</code>) здесь нет, их можно сгенерировать и запустить совершенно одинаково.</p><h2><a name="5" href="#5">Конструкторы MouseEvent, KeyboardEvent и другие</a></h2><p>Для некоторых конкретных типов событий есть свои, специфические, конструкторы.</p><p>Вот список конструкторов для различных событий интерфейса которые можно найти в спецификации <a href="http://www.w3.org/TR/uievents/">UI Event</a>:</p><ul><li><code>UIEvent</code></li><li><code>FocusEvent</code></li><li><code>MouseEvent</code></li><li><code>WheelEvent</code></li><li><code>KeyboardEvent</code></li><li><code>CompositionEvent</code></li></ul><p>Вместо <code>new Event("click")</code> можно вызвать <code>new MouseEvent("click")</code>.</p><p><strong>Специфический конструктор позволяет указать стандартные свойства для данного типа события.</strong></p><p>Например, <code>clientX/clientY</code> для события мыши:</p><code-example><script>`var e = new MouseEvent("click", {\n  bubbles: true,\n  cancelable: true,\n  clientX: 100,\n  clientY: 100\n});\n\nMARKalert( e.clientX ); // 100`</script><code-toolbar></code-toolbar></code-example><p>Это нельзя было бы сделать с обычным конструктором <code>Event</code>:</p><code-example><script>`var e = new Event("click", {\n  bubbles: true,\n  cancelable: true,\n  clientX: 100,\n  clientY: 100\n});\n\nMARKalert( e.clientX ); // undefined, свойство не присвоено!`</script><code-toolbar></code-toolbar></code-example><p>Обычный конструктор <code>Event</code> не знает про «мышиные» свойства, поэтому их игнорирует.</p><p>Впрочем, использование конкретного конструктора не является обязательным, можно обойтись <code>Event</code>, а свойства записать в объект отдельно, после конструктора. Здесь это скорее вопрос удобства и желания следовать правилам. События, которые генерирует браузер, всегда имеют правильный тип.</p><p>Полный список свойств по типам событий вы найдёте в спецификации, например для <code>MouseEvent</code>: <a href="http://www.w3.org/TR/uievents/#constructor-mouseevent">MouseEvent Constructor</a>.</p><h2><a name="6" href="#6">Свои события</a></h2><p>Для генерации своих, нестандартных, событий, хоть и можно использовать конструктор <code>Event</code>, но существует и специфический конструктор <a href="http://www.w3.org/TR/dom/#customevent">CustomEvent</a>.</p><p>Технически, он абсолютно идентичен <code>Event</code>, кроме небольшой детали: у второго аргумента-объекта есть дополнительное свойство <code>detail</code>, в котором можно указывать информацию для передачи в событие.</p><p>Например:</p><code-example><script>`<h1 id="elem">Привет для Васи!</h1>\n\n<script>\n  elem.addEventListener("hello", function(event) {\n    alert( HIGHevent.detail.nameLIGHT );\n  }, false);\n\n  var event = new CustomEvent("hello", {\nMARK    detail: { name: "Вася" }\n  });\n\n  elem.dispatchEvent(event);\n<\/script>`</script><code-toolbar iframe="80"></code-toolbar></code-example><p>Надо сказать, что никто не мешает и в обычное <code>Event</code> записать любые свойства. Но <code>CustomEvent</code> более явно говорит, что событие не встроенное, а своё, и выделяет отдельно «информационное» поле <code>detail</code>, в которое можно записать что угодно без конфликта со стандартными свойствами объекта.</p><h2><a name="7" href="#7">Старое API для IE9+</a></h2><p>Способ генерации событий, описанный выше, не поддерживается в IE11-, там нужен другой, более старый способ, описанный в стандарте <a href="http://www.w3.org/TR/DOM-Level-3-Events">DOM 3 Events</a>.</p><p>В нём была предусмотрена <a href="http://www.w3.org/TR/DOM-Level-3-Events/#event-interfaces">иерархия событий</a>, с различными методами инициализации.</p><p>Она поддерживается как современными браузерами, так и IE9+. Там используется немного другой синтаксис, но по возможностям – всё то же самое, что и в современном стандарте.</p><p>Можно использовать этот немного устаревший способ, если нужно поддерживать IE9+. Далее мы на его основе создадим полифилл.</p><p>Объект события создаётся вызовом <code>document.createEvent</code>:</p><code-example><script>`var event = document.createEvent(eventInterface);`</script></code-example><p>Аргументы:</p><ul><li><code>eventInterface</code> – это тип события, например <code>MouseEvent</code>, <code>FocusEvent</code>, <code>KeyboardEvent</code>. В <a href="http://www.w3.org/TR/DOM-Level-3-Events/#events-module">секции 5 DOM 3 Events</a> есть подробный список, какое событие к какому интерфейсу относится.</li></ul><p>На практике можно всегда использовать самый общий интерфейс: <code>document.createEvent("Event")</code>.</p><p>Далее событие нужно инициализировать:</p><code-example><script>`event.initEvent(type, boolean bubbles, boolean cancelable);`</script></code-example><p>Аргументы:</p><ul><li><code>type</code> – тип события, например <code>"click"</code>.</li><li><code>bubbles</code> – всплывает ли событие.</li><li><code>cancelable</code> – можно ли отменить событие.</li></ul><p>Эти два кода аналогичны:</p><code-example><script>`// современный стандарт\nvar event = new Event("click", {\n  bubbles: true,\n  cancelable: true\n});\n\n// старый стандарт\nvar event = document.createEvent("Event");\nevent.initEvent("click", true, true);`</script></code-example><p>Единственная разница – старый стандарт поддерживается IE9+.</p><p>Этот пример с событием <code>hello</code> будет работать во всех браузерах, кроме IE8-:</p><code-example><script>`<h1 id="elem">Привет от скрипта!</h1>\n\n<script>\n  document.addEventListener("hello", function(event) {\n    alert( "Привет" );\n    event.preventDefault();\n  }, false);\n\nMARK  var event = document.createEvent("Event");\nMARK  event.initEvent("hello", true, true);\n\n  if (elem.dispatchEvent(event) === false) {\n    alert( 'Событие было отменено preventDefault' );\n  }\n<\/script>`</script><code-toolbar iframe="80"></code-toolbar></code-example><important-><h3><code>initMouseEvent</code>, <code>initKeyboardEvent</code> и другие…</h3><p>У конкретных типов событий, например <code>MouseEvent</code>, <code>KeyboardEvent</code>, есть методы, которые позволяют указать стандартные свойства.</p><p>Они называются по аналогии: <code>initMouseEvent</code>, <code>initKeyboardEvent</code>.</p><p>Их можно использовать вместо базового <code>initEvent</code>, если хочется, чтобы свойства событий соответствовали встроенным браузерным.</p><p>Выглядят они немного страшновато, например (взято из <a href="http://www.w3.org/TR/DOM-Level-3-Events/#idl-interface-MouseEvent-initializers">спецификации</a>):</p><code-example><script>`BLUE_void_BLUE initMouseEvent(\n  DOMString typeArg, // тип\n  boolean bubblesArg, // всплывает?\n  boolean cancelableArg, // можно отменить?\n  AbstractView ? viewArg, // объект window, null означает текущее окно\n  long detailArg, // свойство detail и другие...\n  long screenXArg,\n  long screenYArg,\n  long clientXArg,\n  long clientYArg,\n  boolean ctrlKeyArg,\n  boolean altKeyArg,\n  boolean shiftKeyArg,\n  boolean metaKeyArg,\n  unsigned short buttonArg,\n  EventTarget ? relatedTargetArg);\n};`</script></code-example><p>Для инициализации мышиного события нужно обязательно указать <em>все</em> аргументы, например:</p><code-example><script>`<button id="elem">Автоклик</button>\n\n<script>\n  elem.onclick = function(e) {\n    alert( 'Клик на координатах&nbsp' + e.clientX + ':' + e.clientY );\n  };\n\n  var event = document.createEvent("MouseEvent");\nMARK  event.initMouseEvent("click", true, true, null, 0, 0, 0, 100, 100, true, true, true, null, 1, null);\n  elem.dispatchEvent(event);\n<\/script>`</script><code-toolbar iframe="38"></code-toolbar></code-example><p>Браузер, по стандарту, может сгенерировать отсутствующие свойства самостоятельно, например <code>pageX</code>, но это нужно проверять в конкретных случаях, иногда это не работает или работает некорректно, так что лучше указать все.</p></important-><h2><a name="8" href="#8">Полифилл CustomEvent</a></h2><p>Для поддержки <code>CustomEvent</code> в IE9+ можно сделать небольшой полифилл:</p><code-example><script>`try {\n  new CustomEvent("IE has CustomEvent, but doesnGREEN_'t support constructor");\n} catch (e) {\n\n  window.CustomEvent = function(event, params) {\n    var evt;\n    params = params || {\n      bubbles: false,\n      cancelable: false,\n      detail: undefined\n    };\n    evt = document.createEvent("CustomEvent");\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    return evt;\n  };\n\n  CustomEvent.prototype = Object.create(window.Event.prototype);\n}`</script></code-example><p>Здесь мы сначала проверяем – в IE9-11 есть <code>CustomEvent</code>, но его нельзя создать через <code>new</code>, будет ошибка. В этом случае заменяем браузерную реализацию на свою, совместимую.</p><h2><a name="9" href="#9">Антистандарт: IE8-</a></h2><p>В совсем старом IE были «свои» методы <code>document.createEventObject()</code> и <code>elem.fireEvent()</code>.</p><p>Пример с ними для IE8:</p><code-example><script>`<button id="elem">Автоклик</button>\n\n<script>\n  document.body.onclick = function() {\n    alert( "Клик, event.type =&nbsp" + event.type );\n    return false;\n  };\n\nMARK  var event = document.createEventObject();\nMARK  if (!elem.fireEvent("onclick", event)) {\nMARK    alert( 'Событие было отменено' );\nMARK  }\n<\/script>`</script><code-toolbar iframe="38"></code-toolbar></code-example><p><strong>При помощи <code>fireEvent</code> можно сгенерировать только встроенные события.</strong></p><p>Если указать <code>"hello"</code> вместо <code>"onclick"</code> в примере выше – будет ошибка.</p><p>Параметры <code>bubbles</code> и <code>cancelable</code> настраивать нельзя, браузер использует стандартные для данного типа событий.</p><p>Существуют полифиллы для генерации произвольных событий и для IE8-, но они, по сути, полностью подменяют встроенную систему обработки событий браузером. И кода это требует тоже достаточно много.</p><p>Альтернатива – фреймворк, например jQuery, который также реализует свою мощную систему работы с событиями, доступную через методы jQuery.</p><h2><a name="10" href="#10">Итого</a></h2><ul><li>Все браузеры, кроме IE9-11, позволяют генерировать любые события, следуя стандарту DOM4.</li><li>В IE9+ поддерживается более старый стандарт, можно легко сделать полифилл, например для <code>CustomEvent</code> он рассмотрен в этой главе.</li><li>IE8- может генерировать только встроенные события.</li></ul><p>Несмотря на техническую возможность генерировать встроенные браузерные события типа <code>click</code> или <code>keydown</code> – пользоваться ей стоит с большой осторожностью.</p><p>В 98% случаев, когда разработчик начинающего или среднего уровня хочет сгенерировать <em>встроенное</em> событие – это вызвано «кривой» архитектурой кода, и взаимодействие нужно на уровне выше.</p><p>Как правило события имеет смысл генерировать:</p><ul><li>Либо как явный и грубый хак, чтобы заставить работать сторонние библиотеки, в которых не предусмотрены другие средства взаимодействия.</li><li>Либо для автоматического тестирования, чтобы скриптом «нажать на кнопку» и посмотреть, произошло ли нужное действие.</li><li>Либо при создании своих «элементов интерфейса». Например, никто не мешает при помощи JavaScript создать из <code>&lt;div class="calendar"&gt;</code> красивый календарь и генерировать на нём событие <code>change</code> при выборе даты. Эту тему мы разовьём позже.</li></ul><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Действия браузера по умолчанию; События в деталях"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/dispatch-events",disqus_identifier="dispatch-events",disqus_title="\u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u0441\u043e\u0431\u044b\u0442\u0438\u0439 \u043d\u0430 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u0445";</script></page-content></main>