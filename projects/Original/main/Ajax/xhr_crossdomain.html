<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="160">AJAX и COMET</a></nav-up><h1>XMLHttpRequest: кросс-доменные запросы</h1><p>Обычно запрос <code>XMLHttpRequest</code> может делать запрос только в рамках текущего сайта. При попытке использовать другой домен/порт/протокол – браузер выдаёт ошибку.</p><p>Существует современный стандарт <a href="http://www.w3.org/TR/XMLHttpRequest/">XMLHttpRequest</a>, он ещё в состоянии черновика, но предусматривает кросс-доменные запросы и многое другое.</p><p>Большинство возможностей этого стандарта уже поддерживаются всеми браузерами, но увы, не в IE9-.</p><p>Впрочем, частично кросс-доменные запросы поддерживаются, начиная с IE8, только вместо <code>XMLHttpRequest</code> нужно использовать объект <a href="http://msdn.microsoft.com/en-us/library/ie/cc288060.aspx">XDomainRequest</a>.</p><h2><a name="0" href="#0">Кросс-доменные запросы</a></h2><p>Разберём кросс-доменные запросы на примере кода:</p><code-example><script>`// (1)\nvar XHR = ("onload" in new XMLHttpRequest()) ? XMLHttpRequest : XDomainRequest;\n\nvar xhr = new XHR();\n\n// (2) запрос на другой домен :)\nxhr.open('GET', 'http://anywhere.com/request', true);\n\nxhr.onload = function() {\n  alert( this.responseText );\n}\n\nxhr.onerror = function() {\n  alert( 'Ошибка&nbsp' + this.status );\n}\n\nxhr.send();`</script></code-example><ol><li>Мы создаём <code>XMLHttpRequest</code> и проверяем, поддерживает ли он событие <code>onload</code>. Если нет, то это старый <code>XMLHttpRequest</code>, значит это IE8,9, и используем <code>XDomainRequest</code>.</li><li>Запрос на другой домен отсылается просто указанием соответствующего URL в <code>open</code>. Он обязательно должен быть асинхронным, в остальном – никаких особенностей.</li></ol><h2><a name="1" href="#1">Контроль безопасности</a></h2><p>Кросс-доменные запросы проходят специальный контроль безопасности, цель которого – не дать злым хакерам™ завоевать интернет.</p><p>Серьёзно. Разработчики стандарта предусмотрели все заслоны, чтобы «злой хакер» не смог, воспользовавшись новым стандартом, сделать что-то принципиально отличное от того, что и так мог раньше и, таким образом, «сломать» какой-нибудь сервер, работающий по-старому стандарту и не ожидающий ничего принципиально нового.</p><p>Давайте, на минуточку, вообразим, что появился стандарт, который даёт, без ограничений, возможность делать любой странице HTTP-запросы куда угодно, какие угодно.</p><p>Как сможет этим воспользоваться злой хакер?</p><p>Он сделает свой сайт, например <code>http://evilhacker.com</code> и заманит туда посетителя (а может посетитель попадёт на «злонамеренную» страницу и по ошибке – не так важно).</p><p>Когда посетитель зайдёт на <code>http://evilhacker.com</code>, он автоматически запустит JS-скрипт на странице. Этот скрипт сделает HTTP-запрос на почтовый сервер, к примеру, <code>http://gmail.com</code>. А ведь обычно HTTP-запросы идут с куками посетителя и другими авторизующими заголовками.</p><p>Поэтому хакер сможет написать на <code>http://evilhacker.com</code> код, который, сделав GET-запрос на <code>http://gmail.com</code>, получит информацию из почтового ящика посетителя. Проанализирует её, сделает ещё пачку POST-запросов для отправки писем от имени посетителя. Затем настанет очередь онлайн-банка и так далее.</p><p>Спецификация <a href="http://www.w3.org/TR/cors/">CORS</a> налагает специальные ограничения на запросы, которые призваны не допустить подобного апокалипсиса.</p><p>Запросы в ней делятся на два вида.</p><p><a href="http://www.w3.org/TR/cors/#terminology">Простыми</a> считаются запросы, если они удовлетворяют следующим двум условиям:</p><ol><li><a href="http://www.w3.org/TR/cors/#simple-method">Простой метод</a>: GET, POST или HEAD</li><li><a href="http://www.w3.org/TR/cors/#simple-header">Простые заголовки</a> – только из списка:</li></ol><ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code> со значением <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code> или <code>text/plain</code>.</li></ul><p>«Непростыми» считаются все остальные, например, запрос с методом <code>PUT</code> или с заголовком <code>Authorization</code> не подходит под ограничения выше.</p><p>Принципиальная разница между ними заключается в том, что «простой» запрос можно сформировать и отправить на сервер и без XMLHttpRequest, например при помощи HTML-формы.</p><p>То есть, злой хакер на странице <code>http://evilhacker.com</code> и до появления CORS мог отправить произвольный GET-запрос куда угодно. Например, если создать и добавить в документ элемент <code>&lt;script src="любой url"&gt;</code>, то браузер сделает GET-запрос на этот URL.</p><p>Аналогично, злой хакер и ранее мог на своей странице объявить и, при помощи JavaScript, отправить HTML-форму с методом GET/POST и кодировкой <code>multipart/form-data</code>. А значит, даже старый сервер наверняка предусматривает возможность таких атак и умеет от них защищаться.</p><p>А вот запросы с нестандартными заголовками или с методом <code>DELETE</code> таким образом не создать. Поэтому старый сервер может быть к ним не готов. Или, к примеру, он может полагать, что такие запросы веб-страница в принципе не умеет присылать, значит они пришли из привилегированного приложения, и дать им слишком много прав.</p><p>Поэтому при посылке «непростых» запросов нужно специальным образом спросить у сервера, согласен ли он в принципе на подобные кросс-доменные запросы или нет? И, если сервер не ответит, что согласен – значит, нет.</p><div class="summary"><div class="summary__content"><p>В спецификации CORS, как мы увидим далее, есть много деталей, но все они объединены единым принципом: новые возможности доступны только с явного согласия сервера (по умолчанию – нет).</p></div></div><h2><a name="2" href="#2">CORS для простых запросов</a></h2><p>В кросс-доменный запрос браузер автоматически добавляет заголовок <code>Origin</code>, содержащий домен, с которого осуществлён запрос.</p><p>В случае запроса на <code>http://anywhere.com/request</code> с <code>http://javascript.ru/page</code> заголовки будут примерно такие:</p><code-example><script>`GET /request\nHost:anywhere.com\nMARKOrigin:http://javascript.ru\n...`</script></code-example><p>Сервер должен, со своей стороны, ответить специальными заголовками, разрешает ли он такой запрос к себе.</p><p>Если сервер разрешает кросс-доменный запрос с этого домена – он должен добавить к ответу заголовок <code>Access-Control-Allow-Origin</code>, содержащий домен запроса (в данном случае «javascript.ru») или  звёздочку <code>*</code>.</p><p><strong>Только при наличии такого заголовка в ответе – браузер сочтёт запрос успешным, а иначе JavaScript получит ошибку.</strong></p><figure><img src="xhr-another-domain.png" alt="" width="100%" style="max-width:610px"></figure><p>То есть, ответ сервера может быть примерно таким:</p><code-example><script>`HTTP/1.1 200 OK\nContent-Type:text/html; charset=UTF-8\nMARKAccess-Control-Allow-Origin: http://javascript.ru`</script></code-example><p>Если <code>Access-Control-Allow-Origin</code> нет, то браузер считает, что разрешение не получено, и завершает запрос с ошибкой.</p><p>При таких запросах не передаются куки и заголовки HTTP-авторизации. Параметры <code>user</code> и <code>password</code> в методе <code>open</code> игнорируются. Мы рассмотрим, как разрешить их передачу, чуть далее.</p><important-warn><h3>Что может сделать хакер, используя такие запросы?</h3><p>Описанные выше ограничения приводят к тому, что запрос полностью безопасен.</p><p>Действительно, злая страница может сформировать любой GET/POST-запрос и отправить его, но без разрешения сервера ответа она не получит.</p><p>А без ответа такой запрос, по сути, эквивалентен отправке формы GET/POST, причём без авторизации.</p></important-warn><h2><a name="3" href="#3">Ограничения IE9-</a></h2><p>В IE9- используется <code>XDomainRequest</code>, который представляет собой урезанный <code>XMLHttpRequest</code>.</p><p>На него действуют ограничения:</p><ul><li>Протокол нужно сохранять: запросы допустимы с HTTP на HTTP, с HTTPS на HTTPS. Другие протоколы запрещены.</li><li>Метод <code>open(method, url)</code> имеет только два параметра. Он всегда асинхронный.</li><li>Ряд возможностей современного стандарта недоступны, в частности:<ul><li>Недоступны методы, кроме GET или POST.</li><li>Нельзя добавлять свои заголовки, даже нельзя указать свой <code>Content-Type</code> для запроса, он всегда <code>text/plain</code>.</li><li>Нельзя включить передачу кук и данных HTTP-авторизации.</li></ul></li><li>В IE8 в режиме просмотра InPrivate кросс-доменные запросы не работают.</li></ul><p>Современный стандарт <a href="http://www.w3.org/TR/XMLHttpRequest/">XMLHttpRequest</a> предусматривает средства для преодоления этих ограничений, но на момент выхода IE8 они ещё не были проработаны, поэтому их не реализовали. А IE9 исправил некоторые ошибки, но в общем не добавил ничего нового.</p><p>Поэтому на сайтах, которые хотят поддерживать IE9-, то на практике кросс-доменные запросы редко используют, предпочитая другие способы кросс-доменной коммуникации. Например, динамически создаваемый тег <code>SCRIPT</code> или вспомогательный <code>IFRAME</code> с другого домена. Мы разберём эти подходы в последующих главах.</p><important-><h3>Как разрешить кросс-доменные запросы от доверенного сайта в IE9-?</h3><p>Разрешить кросс-доменные запросы для «доверенных» сайтов можно в настройках IE, во вкладке «Безопасность», включив пункт «Доступ к источникам данных за пределами домена».</p><p>Обычно это делается для зоны «Надёжные узлы», после чего в неё вносится доверенный сайт. Теперь он может делать кросс-доменные запросы <code>XMLHttpRequest</code>.</p><p>Этот способ можно применить для корпоративных сайтов, а также в тех случаях, когда посетитель заведомо вам доверяет, но почему-то (компьютер на работе, админ запрещает ставить другой браузер?) хочет использовать именно IE. Например, он может предлагаться в качестве дополнительной инструкции «как заставить этот сервис работать под IE».</p></important-><important-><h3>В IE разрешён другой порт</h3><p>В кросс-доменные ограничения IE не включён порт.</p><p>То есть, можно сделать запрос с <code>http://javascript.ru</code> на <code>http://javascript.ru:8080</code>, и в IE он не будет считаться кросс-доменным.</p><p>Это позволяет решить некоторые задачи, связанные с взаимодействием различных сервисов в рамках одного сайта. Но только для IE.</p></important-><p>Расширенные возможности, описанные далее, поддерживаются всеми современными браузерами, кроме IE9-.</p><h2><a name="4" href="#4">Заголовки ответа</a></h2><p>Чтобы JavaScript мог прочитать HTTP-заголовок ответа, сервер должен указать его имя в <code>Access-Control-Expose-Headers</code>.</p><p>Например:</p><code-example><script>`HTTP/1.1 200 OK\nContent-Type:text/html; charset=UTF-8\nAccess-Control-Allow-Origin: http://javascript.ru\nMARKX-Uid: 123\nMARKX-Authorization: 2c9de507f2c54aa1\nMARKAccess-Control-Expose-Headers: X-Uid, X-Authentication`</script></code-example><p>По умолчанию скрипт может прочитать из ответа только «простые» заголовки:</p><code-example><script>`Cache-Control\nContent-Language\nContent-Type\nExpires\nLast-Modified\nPragma`</script></code-example><p>…То есть, <code>Content-Type</code> получить всегда можно, а доступ к специфическим заголовкам нужно открывать явно.</p><h2><a name="5" href="#5">Запросы от имени пользователя</a></h2><p>По умолчанию браузер не передаёт с запросом куки и авторизующие заголовки.</p><p>Чтобы браузер передал вместе с запросом куки и HTTP-авторизацию, нужно поставить запросу <code>xhr.withCredentials = true</code>:</p><code-example><script>`var xhr = new XMLHttpRequest();\nxhr.withCredentials = true;\n\nxhr.open('POST', 'http://anywhere.com/request', true)\n  ...`</script></code-example><p>Далее – всё как обычно, дополнительных действий со стороны клиента не требуется.</p><p>Такой <code>XMLHttpRequest</code> с куками, естественно, требует от сервера больше разрешений, чем «анонимный».</p><p><strong>Поэтому для запросов с <code>withCredentials</code> предусмотрено дополнительное подтверждение со стороны сервера.</strong></p><p>При запросе с <code>withCredentials</code> сервер должен вернуть уже не один, а два заголовка:</p><ul><li><code>Access-Control-Allow-Origin: домен</code></li><li><code>Access-Control-Allow-Credentials: true</code></li></ul><p>Пример заголовков:</p><code-example><script>`HTTP/1.1 200 OK\nContent-Type:text/html; charset=UTF-8\nMARKAccess-Control-Allow-Origin: http://javascript.ru\nMARKAccess-Control-Allow-Credentials: true`</script></code-example><p>Использование звёздочки <code>*</code> в <code>Access-Control-Allow-Origin</code> при этом запрещено.</p><p>Если этих заголовков не будет, то браузер не даст JavaScript’у доступ к ответу сервера.</p><h2><a name="6" href="#6">«Непростые» запросы</a></h2><p>В кросс-доменном <code>XMLHttpRequest</code> можно указать не только <code>GET/POST</code>, но и любой другой метод, например <code>PUT</code>, <code>DELETE</code>.</p><p>Когда-то никто и не думал, что страница сможет сделать такие запросы. Поэтому ряд веб-сервисов написаны в предположении, что «если метод – нестандартный, то это не браузер». Некоторые веб-сервисы даже учитывают это при проверке прав доступа.</p><p>Чтобы пресечь любые недопонимания, браузер использует предзапрос в случаях, когда:</p><ul><li>Если метод – не GET / POST / HEAD.</li><li>Если заголовок <code>Content-Type</code> имеет значение отличное от <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code> или <code>text/plain</code>, например <code>application/xml</code>.</li><li>Если устанавливаются другие HTTP-заголовки, кроме <code>Accept</code>, <code>Accept-Language</code>, <code>Content-Language</code>.</li></ul><p>…Любое из условий выше ведёт к тому, что браузер сделает два HTTP-запроса.</p><p>Первый запрос называется «предзапрос» (английский термин «preflight»). Браузер делает его целиком по своей инициативе, из JavaScript мы о нём ничего не знаем, хотя можем увидеть в инструментах разработчика.</p><p>Этот запрос использует метод <code>OPTIONS</code>. Он не содержит тела и содержит название желаемого метода в заголовке <code>Access-Control-Request-Method</code>, а если добавлены особые заголовки, то и их тоже – в <code>Access-Control-Request-Headers</code>.</p><p>Его задача – спросить сервер, разрешает ли он использовать выбранный метод и заголовки.</p><p>На этот запрос сервер должен ответить статусом 200, без тела ответа, указав заголовки <code>Access-Control-Allow-Method: метод</code> и, при необходимости, <code>Access-Control-Allow-Headers: разрешённые заголовки</code>.</p><p>Дополнительно он может указать <code>Access-Control-Max-Age: sec</code>, где <code>sec</code> – количество секунд, на которые нужно закэшировать разрешение. Тогда при последующих вызовах метода браузер уже не будет делать предзапрос.</p><figure><img src="xhr-preflight.png" alt="" width="100%" style="max-width:610px"></figure><p>Давайте рассмотрим предзапрос на конкретном примере.</p><h3><a name="11" href="#11">Пример запроса COPY</a></h3><p>Рассмотрим запрос <code>COPY</code>, который используется в протоколе <a href="http://www.webdav.org/specs/rfc2518.html">WebDAV</a> для управления файлами через HTTP:</p><code-example><script>`var xhr = new XMLHttpRequest();\n\nxhr.open('COPY', 'http://site.com/~ilya', true);\nxhr.setRequestHeader('Destination', 'http://site.com/~ilya.bak');\n\nxhr.onload = ...\nxhr.onerror = ...\n\nxhr.send();`</script></code-example><p>Этот запрос «непростой» по двум причинам (достаточно было бы одной из них):</p><ol><li>Метод <code>COPY</code>.</li><li>Заголовок <code>Destination</code>.</li></ol><p>Поэтому браузер, по своей инициативе, шлёт предварительный запрос <code>OPTIONS</code>:</p><code-example><script>`OPTIONS /~ilya HTTP/1.1\nHost: site.com\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Encoding: gzip,deflate\nConnection: keep-alive\nMARKOrigin: http://javascript.ru\nMARKAccess-Control-Request-Method: COPY\nMARKAccess-Control-Request-Headers: Destination`</script></code-example><p>Обратим внимание на детали:</p><ul><li>Адрес – тот же, что и у основного запроса: <code>http://site.com/~ilya</code>.</li><li>Стандартные заголовки запроса <code>Accept</code>, <code>Accept-Encoding</code>, <code>Connection</code> присутствуют.</li><li>Кросс-доменные специальные заголовки запроса:<ul><li><code>Origin</code> – домен, с которого сделан запрос.</li><li><code>Access-Control-Request-Method</code> – желаемый метод.</li><li><code>Access-Control-Request-Headers</code> – желаемый «непростой» заголовок.</li></ul></li></ul><p>На этот запрос сервер должен ответить статусом 200, указав заголовки <code>Access-Control-Allow-Method: COPY</code> и <code>Access-Control-Allow-Headers: Destination</code>.</p><p>Но в протоколе WebDav разрешены многие методы и заголовки, которые имеет смысл сразу перечислить в ответе:</p><code-example><script>`HTTP/1.1 200 OK\nContent-Type: text/plain\nHIGHAccess-Control-Allow-MethodsLIGHT: PROPFIND, PROPPATCH, COPY, MOVE, DELETE, MKCOL, LOCK, UNLOCK, PUT, GETLIB, VERSION-CONTROL, CHECKIN, CHECKOUT, UNCHECKOUT, REPORT, UPDATE, CANCELUPLOAD, HEAD, OPTIONS, GET, POST\nHIGHAccess-Control-Allow-HeadersLIGHT: Overwrite, Destination, Content-Type, Depth, User-Agent, X-File-Size, X-Requested-With, If-Modified-Since, X-File-Name, Cache-Control\nHIGHAccess-Control-Max-AgeLIGHT: 86400`</script></code-example><p>Ответ должен быть без тела, то есть только заголовки.</p><p>Браузер видит, что метод <code>COPY</code> – в числе разрешённых и заголовок <code>Destination</code> – тоже, и дальше он шлёт уже основной запрос.</p><p>При этом ответ на предзапрос он закэширует на 86400 сек (сутки), так что последующие аналогичные вызовы сразу отправят основной запрос, без <code>OPTIONS</code>.</p><p>Основной запрос браузер выполняет уже в «обычном» кросс-доменном режиме:</p><code-example><script>`COPY /~ilya HTTP/1.1\nHost: site.com\nContent-Type: text/html; charset=UTF-8\nMARKDestination: http://site.com/~ilya.bak\nMARKOrigin: http://javascript.ru`</script></code-example><p>Ответ сервера, согласно спецификации <a href="http://www.webdav.org/specs/rfc2518.html#rfc.section.8.8.8">WebDav COPY</a>, может быть примерно таким:</p><code-example><script>`HTTP/1.1 207 Multi-Status\nContent-Type: text/xml; charset="utf-8"\nContent-Length: ...\nMARKAccess-Control-Allow-Origin: http://javascript.ru\n\n<?xml version="1.0" encoding="utf-8" ?>\n<d:multistatus xmlns:d="DAV:">\n  ...\n</d:multistatus>`</script></code-example><p>Так как <code>Access-Control-Allow-Origin</code> содержит правильный домен, то браузер вызовет <code>xhr.onload</code> и запрос будет завершён.</p><h2><a name="7" href="#7">Итого</a></h2><ul><li>Все современные браузеры умеют делать кросс-доменные XMLHttpRequest.</li><li>В IE8,9 для этого используется объект <code>XDomainRequest</code>, ограниченный по возможностям.</li><li>Кросс-доменный запрос всегда содержит заголовок <code>Origin</code> с доменом запроса.</li></ul><p>Порядок выполнения:</p><ol><li><p>Для запросов с «непростым» методом или особыми заголовками браузер делает предзапрос <code>OPTIONS</code>, указывая их в <code>Access-Control-Request-Method</code> и <code>Access-Control-Request-Headers</code>.</p><p>Браузер ожидает ответ со статусом <code>200</code>, без тела, со списком разрешённых методов и заголовков в <code>Access-Control-Allow-Method</code> и <code>Access-Control-Allow-Headers</code>. Дополнительно можно указать <code>Access-Control-Max-Age</code> для кеширования  предзапроса.</p></li><li><p>Браузер делает запрос и проверяет, есть ли в ответе <code>Access-Control-Allow-Origin</code>, равный <code>*</code> или <code>Origin</code>.</p><p>Для запросов с <code>withCredentials</code> может быть только <code>Origin</code> и дополнительно <code>Access-Control-Allow-Credentials: true</code>.</p></li><li><p>Если проверки пройдены, то вызывается <code>xhr.onload</code>, иначе <code>xhr.onerror</code>, без деталей ответа.</p></li><li><p>Дополнительно: названия нестандартных заголовков ответа сервер должен указать в <code>Access-Control-Expose-Headers</code>, если хочет, чтобы клиент мог их прочитать.</p></li></ol><p>Детали и примеры мы разобрали выше.</p><h2 id="tasks"><a href="#8" name="8">Задачи (1)</a></h2><task-content><h3><a href="#12" name="12">Зачем нужен Origin?</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Как вы, наверняка, знаете, существует HTTP-заголовок <code>Referer</code>, в котором обычно указан адрес страницы, с которой инициирован запрос.</p><p>Например, при отправке <code>XMLHttpRequest</code> со страницы <code>http://javascript.ru/some/url</code> на <code>http://google.ru</code>, заголовки будут примерно такими:</p><code-example><script>`Accept:*/*\nAccept-Charset:windows-1251,utf-8;q=0.7,*;q=0.3\nAccept-Encoding:gzip,deflate,sdch\nAccept-Language:ru-RU,ru;q=0.8,en-US;q=0.6,en;q=0.4\nConnection:keep-alive\nHost:google.ru\nMARKOrigin:http://javascript.ru\nMARKReferer:http://javascript.ru/some/url`</script></code-example><p>Как видно, здесь присутствуют и <code>Referer</code> и <code>Origin</code>.</p><p>Итак, вопросы:</p><ol style="margin-bottom: 20px;"><li>Зачем нужен <code>Origin</code>, если <code>Referer</code> содержит даже более полную информацию?</li><li>Может ли быть такое, что заголовка <code>Referer</code> нет или он неправильный?</li></ol><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p><code>Origin</code> нужен, потому что <code>Referer</code> передаётся не всегда. В частности, при запросе с HTTPS на HTTP – нет <code>Referer</code>.</p><p>Политика <a href="http://en.wikipedia.org/wiki/Content_Security_Policy">Content Security Policy</a> может запрещать пересылку <code>Referer</code>.</p><p>По стандарту <code>Referer</code> является необязательным HTTP-заголовком, в некоторых браузерах есть настройки, которые запрещают его слать.</p><p>Именно поэтому, ввиду того, что на <code>Referer</code> полагаться нельзя, и придумали заголовок <code>Origin</code>, который гарантированно присылается при кросс-доменных запросах.</p><p>Что же касается «неправильного» <code>Referer</code> – это из области фантастики. Когда-то, много лет назад, в браузерах были ошибки, которые позволяли подменить <code>Referer</code> из JavaScript, но они давно исправлены. Никакая «злая страница» не может его подменить.</p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="XMLHttpRequest POST, формы и кодировка; XMLHttpRequest: индикация прогресса"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/xhr-crossdomain", disqus_identifier = "xhr-crossdomain", disqus_title = "XMLHttpRequest: \u043a\u0440\u043e\u0441\u0441-\u0434\u043e\u043c\u0435\u043d\u043d\u044b\u0435 \u0437\u0430\u043f\u0440\u043e\u0441\u044b";</script></page-content></main>