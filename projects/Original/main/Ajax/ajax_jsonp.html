<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="160">AJAX и COMET</a></nav-up><h1>Протокол JSONP</h1><p>Если создать тег <code>&lt;script src&gt;</code>, то при добавлении в документ запустится процесс загрузки <code>src</code>. В ответ сервер может прислать скрипт, содержащий нужные данные.</p><p>Таким образом можно запрашивать данные с любого сервера, в любом браузере, без каких-либо разрешений и дополнительных проверок.</p><p>Протокол JSONP – это «надстройка» над таким способом коммуникации. Здесь мы рассмотрим его использование в деталях.</p><h2><a name="0" href="#0">Запрос</a></h2><p>Простейший пример запроса:</p><code-example><script>`function addScript(src) {\n  var elem = document.createElement("script");\n  elem.src = src;\n  document.head.appendChild(elem);\n}\n\naddScript('user?id=123');`</script></code-example><p>Такой вызов добавит в <code>&lt;head&gt;</code> документа тег:</p><code-example><script>`<script src="user?id=123"><\/script>`</script></code-example><p>При добавлении тега <code>&lt;script&gt;</code> с внешним <code>src</code> в документ браузер тут же начинает его скачивать, а затем – выполняет.</p><p>В данном случае браузер запросит скрипт с URL <code>/user?id=123</code> и выполнит.</p><h2><a name="1" href="#1">Обработка ответа, JSONP</a></h2><p>В примере выше рассмотрено создание запроса, но как получить ответ? Допустим, сервер хочет прислать объект с данными.</p><p>Конечно, он может присвоить её в переменную, например так:</p><code-example><script>`// ответ сервера\nvar user = {name: "Вася", age: 25 };`</script></code-example><p>…А браузер по <code>script.onload</code> отловит окончание загрузки и прочитает значение <code>user</code>.</p><p>Но что, если одновременно делается несколько запросов? Получается, нужно присваивать в разные переменные.</p><p>Протокол JSONP как раз и призван облегчить эту задачу.</p><p>Он очень простой:</p><ol><li><p>Вместе с запросом клиент в специальном, заранее оговорённом, параметре передаёт название функции.</p><p>Обычно такой параметр называется <code>callback</code>. Например :</p><code-example><script>`addScript('user?id=123&callback=onUserData');`</script></code-example></li><li><p>Сервер кодирует данные в JSON и оборачивает их в вызов функции, название которой получает из параметра <code>callback</code>:</p><code-example><script>`// ответ сервераonUserData({  name: "Вася",  age: 25});`</script></code-example></li></ol><p>Это и называется JSONP («JSON with Padding»).</p><important-warn><h3>Аспект безопасности</h3><p>Клиентский код должен доверять серверу при таком запросе. Ведь серверу ничего не стоит добавить в скрипт любые команды.</p></important-warn><h2><a name="2" href="#2">Реестр CallbackRegistry</a></h2><p>В примере выше функция <code>onUserData</code> должна быть глобальной, ведь <code>&lt;script src&gt;</code> выполняется в глобальной области видимости.</p><p>Хотелось бы не загрязнять глобальное пространство имён, или по крайней мере свести загрязнение к минимуму.</p><p>Как правило, для этого создают один глобальный объект «реестр», который мы назовём <code>CallbackRegistry</code>. Далее для каждого запроса в нём генерируется временная функция.</p><p>Тег будет выглядеть так:</p><code-example><script>`<script src="user?id=123&callback=CallbackRegistry.func12345"><\/script>`</script></code-example><p>Сервер обернёт ответ в функцию <code>CallbackRegistry.func12345</code>, она вызывает нужный обработчик и очищает память, удаляя себя.</p><p>Далее мы посмотрим более полный код всего этого, но перед этим – важный момент! Нужно предусмотреть обработку ошибок.</p><h2><a name="3" href="#3">Обнаружение ошибок</a></h2><p>При запросе данных при помощи <code>SCRIPT</code> возможны различные ошибки:</p><ol><li>Скрипт может не загрузиться: отказ в соединении, разрыв связи…</li><li>Ошибка HTTP, например 500.</li><li>Скрипт загрузился, но внутри некорректен и не вызывает функцию. Например, на сервере произошла ошибка и в ответе передан её текст, а вовсе не данные.</li></ol><p>Чтобы отловить их все «одним махом», используем следующий алгоритм:</p><ol><li>Создаётся <code>&lt;script&gt;</code>.</li><li>На <code>&lt;script&gt;</code> ставятся обработчики <code>onreadystatechange</code> (для старых IE) и <code>onload/onerror</code> (для остальных браузеров).</li><li>При загрузке скрипт выполняет функцию-коллбэк <code>CallbackRegistry...</code>. Пусть она при запуске ставит флажок «все ок». А мы в обработчиках проверим – если флага нет, то функция не вызывалась – стало быть, ошибка при загрузке или содержимое скрипта некорректно.</li></ol><h2><a name="4" href="#4">Полный пример</a></h2><p>Итак, код функции, которая вызывается с <code>url</code> и коллбэками.</p><p>Он совсем небольшой, а без комментариев был бы ещё меньше:</p><code-example><script>`var CallbackRegistry&nbsp= {}; // реестр\n\n// при успехе вызовет onSuccess, при ошибке onError\nfunction scriptRequest(url, onSuccess, onError) {\n\n  var scriptOk = false; // флаг, что вызов прошел успешно\n\n  // сгенерировать имя JSONP-функции для запроса\n  var callbackName = 'cb'_GREEN + String(Math.random()).slice(-6);\n\n  // укажем это имя в URL запроса\n  url += ~url.indexOf('?') ? '&' : '?';\n  url += 'callback=CallbackRegistry.' + callbackName;\n\n  // ..и создадим саму функцию в реестре\n  CallbackRegistry[callbackName] = function(data) {\n    scriptOk = true; // обработчик вызвался, указать что всё ок\n    delete CallbackRegistry[callbackName]; // можно очистить реестр\n    onSuccess(data); // и вызвать onSuccess\n  };\n\n  // эта функция сработает при любом результате запроса\n  // важно: при успешном результате - всегда после JSONP-обработчика\n  function checkCallback() {\n    if (scriptOk) return; // сработал обработчик?\n    delete CallbackRegistry[callbackName];\n    onError(url); // нет - вызвать onError\n  }\n\n  var script = document.createElement('script');\n\n  // в старых IE поддерживается только событие, а не onload/onerror\n  // в теории 'readyState=loaded' означает "скрипт загрузился",\n  // а 'readyState=complete' -- "скрипт выполнился", но иногда\n  // почему-то случается только одно из них, поэтому проверяем оба\n  script.onreadystatechange = function() {\n    if (this.readyState == 'complete' || this.readyState == 'loaded') {\n      this.onreadystatechange = null;\n      setTimeout(checkCallback, 0); // Вызвать checkCallback - после скрипта\n    }\n  }\n\n  // события script.onload/onerror срабатывают всегда после выполнения скрипта\n  script.onload = script.onerror = checkCallback;\n  script.src = url;\n\n  document.body.appendChild(script);\n}`</script></code-example><p>Пример использования:</p><code-example><script>`function ok(data) {\n  alert( "Загружен пользователь&nbsp" + data.name );\n}\n\nfunction fail(url) {\n  alert( 'Ошибка при запросе&nbsp' + url );\n}\n\n// Внимание! Ответы могут приходить в любой последовательности!\nscriptRequest("user?id=123", ok, fail); // Загружен\nscriptRequest("/badurl.js", ok, fail); // fail, 404\nscriptRequest("/", ok, fail); // fail, 200 но некорректный скрипт`</script></code-example><p>Демо, по нажатию на кнопке запускаются запросы выше:</p><code-tabs data-code_switch=""><tools-><code-download><a-></a-><a href="https://learn.javascript.ru/tutorial/zipview/jsonp.zip?plunkId=MZQgSsj8QhnQ09EIr0xY" hover-style="" target="_blank" title="скачать архив"></a></code-download><button-0 class="current">index.html</button-0><button-1>scriptRequest.js</button-1><button-2>server.js</button-2></tools-><code-example style="display: block;"><script>`<!doctype html>\n<html lang="en">\n\n<head>\n  <meta charset="UTF-8">\n  <script src="scriptRequest.js"><\/script>\n</head>\n\n<body>\n\n  <script>\n    function ok(data) {\n      alert("Загружен пользователь " + data.id + ": " + data.name);\n    }\n\n    function fail(url) {\n      alert('Ошибка при запросе ' + url);\n    }\n\n    function go() {\n      // ответы могут приходить в любой последовательности!\n      scriptRequest("user?id=123", ok, fail); // Загружен\n      scriptRequest("/badurl.js", ok, fail); // fail, 404\n      scriptRequest("index.html", ok, fail); // fail, 200 но некорректный скрипт\n    }\n  <\/script>\n\n  <button onclick='go()'>Сделать запросы</button>\n\n</body>\n\n</html>`</script><code-toolbar- iframe="100"><a title="показать" data-code_run="220"></a><a title="открыть в новом окне" data-new_window="code"></a><a-></a-></code-toolbar-></code-example><code-example><script>`var CallbackRegistry&nbsp= {}; // реестр\n\n// при успехе вызовет onSuccess, при ошибке onError\nfunction scriptRequest(url, onSuccess, onError) {\n\n  var scriptOk = false; // флаг, что вызов прошел успешно\n\n  // сгенерировать имя JSONP-функции для запроса\n  var callbackName = 'cb' + String(Math.random()).slice(-6);\n\n  // укажем это имя в URL запроса\n  url += ~url.indexOf('?') ? '&' : '?';\n  url += 'callback=CallbackRegistry.' + callbackName;\n\n  // ..и создадим саму функцию в реестре\n  CallbackRegistry[callbackName] = function(data) {\n    scriptOk = true; // обработчик вызвался, указать что всё ок\n    delete CallbackRegistry[callbackName]; // можно очистить реестр\n    onSuccess(data); // и вызвать onSuccess\n  };\n\n  // эта функция сработает при любом результате запроса\n  // важно: при успешном результате - всегда после JSONP-обработчика\n  function checkCallback() {\n    if (scriptOk) return; // сработал обработчик?\n    delete CallbackRegistry[callbackName];\n    onError(url); // нет - вызвать onError\n  }\n\n  var script = document.createElement('script');\n\n  // в старых IE поддерживается только событие, а не onload/onerror\n  // в теории 'readyState=loaded' означает "скрипт загрузился",\n  // а 'readyState=complete' -- "скрипт выполнился", но иногда\n  // почему-то случается только одно из них, поэтому проверяем оба\n  script.onreadystatechange = function() {\n    if (this.readyState == 'complete' || this.readyState == 'loaded') {\n      this.onreadystatechange = null;\n      setTimeout(checkCallback, 0); // Вызвать checkCallback - после скрипта\n    }\n  }\n\n  // события script.onload/onerror срабатывают всегда после выполнения скрипта\n  script.onload = script.onerror = checkCallback;\n  script.src = url;\n\n  document.body.appendChild(script);\n}`</script></code-example><code-example><script>`var http = require('http');\nvar url = require('url');\nvar static = require('node-static');\nvar file = new static.Server('.', {\n  cache: 0\n});\n\n\nfunction accept(req, res) {\n\n  var urlParsed = url.parse(req.url, true);\n\n  if (urlParsed.pathname == '/user') {\n    var id = urlParsed.query.id;\n    var callback = urlParsed.query.callback;\n\n    res.setHeader('Content-Type', 'application/javascript; charset=utf-8');\n\n    var user = {\n      name: "Вася",\n      id: id\n    };\n\n    res.end(callback + '(' + JSON.stringify(user) + ')');\n\n  } else {\n    file.serve(req, res);\n  }\n\n}\n\n\n// ------ запустить сервер -------\n\nif (!module.parent) {\n  http.createServer(accept).listen(8080);\n} else {\n  exports.accept = accept;\n}`</script></code-example></code-tabs><h2><a name="5" href="#5">COMET</a></h2><p>COMET через <code>SCRIPT</code> реализуется при помощи длинных опросов, также как мы обсуждали в главе <a data-load_page="168">COMET с XMLHttpRequest: длинные опросы</a>.</p><p>То есть, создаётся тег <code>&lt;script&gt;</code>, браузер запрашивает скрипт у сервера и… Сервер оставляет соединение висеть, пока не появится, что сказать. Когда сервер хочет отправить сообщение – он отвечает, используя формат JSONP. И, тут же, новый запрос…</p><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="WebSocket; Server Side Events -- события с сервера"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/ajax-jsonp",disqus_identifier="ajax-jsonp",disqus_title="\u041f\u0440\u043e\u0442\u043e\u043a\u043e\u043b JSONP";</script></page-content></main>