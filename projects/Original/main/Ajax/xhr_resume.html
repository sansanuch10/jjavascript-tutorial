<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="160">AJAX и COMET</a></nav-up><h1>XMLHttpRequest: возобновляемая закачка</h1><p>Современный <code>XMLHttpRequest</code> даёт возможность загружать файл как угодно: во множество потоков, с догрузкой, с подсчётом контрольной суммы и т.п.</p><p>Здесь мы рассмотрим общий подход к организации загрузки, а его уже можно расширять, адаптировать к своему фреймворку и так далее.</p><p>Поддержка – все браузеры кроме IE9-.</p><h2><a name="0" href="#0">Неточный upload.onprogress</a></h2><p>Ранее мы рассматривали загрузку с индикатором прогресса. Казалось бы, сделать возобновляемую загрузку на его основе очень просто.</p><p>Есть же <code>xhr.upload.onprogress</code> – ставим на него обработчик, по свойству <code>loaded</code> события <code>onprogress</code> смотрим, сколько байт загрузилось. А при обрыве – возобновляем загрузку с последнего байта.</p><p>К счастью, отослать на сервер не весь файл, а только нужную часть его – не проблема, <a href="http://www.w3.org/TR/FileAPI/">File API</a> позволяет прочитать выбранный участок из файла и отправить его.</p><p>Примерно так:</p><code-example><script>`var slice = file.slice(10, 100); // прочитать байты с 10-го по 99-й включительно\n\nxhr.send(slice); // ... и отправить эти байты в запросе.`</script></code-example><p>…Но такая модель не жизнеспособна!</p><p>Всё дело в том, что <code>upload.onprogress</code> срабатывает, когда байты <em>отправлены</em>, но были ли они получены сервером – браузер не знает. Может, их прокси-сервер забуферизовал, может серверный процесс «упал» в процессе обработки, может соединение порвалось и байты так и не дошли до получателя.</p><p><strong>Поэтому <code>onprogress</code> годится лишь для красивенького рисования прогресса.</strong></p><p>Для загрузки нам нужно точно знать количество загруженных байт. Это может сообщить только сервер.</p><h2><a name="1" href="#1">Алгоритм возобновляемой загрузки</a></h2><p>Загрузкой файла будет заведовать объект <code>Uploader</code>, его примерный общий вид:</p><code-example><script>`function Uploader(file, onSuccess, onFail, onProgress) {\n\n  var fileId = file.name + '-' + file.size + '-' + +file.lastModifiedDate;\n\n  var errorCount = 0;\n\n  var MAX_ERROR_COUNT = 6;\n\n  function upload() {\n    ...\n  }\n\n  function pause() {\n    ...\n  }\n\n  this.upload = upload;\n  this.pause = pause;\n}`</script></code-example><ul><li>Аргументы для <code>new Uploader</code>:</li></ul><dl><dt><code>file</code></dt><dd>Объект File API. Может быть получен из формы, либо как результат Drag’n’Drop.</dd><dd><code>onSuccess</code>, <code>onFail</code>, <code>onProgress</code></dd></dl><dd>Функции-коллбэки, которые будут вызываться в процессе (`onProgress`) и при окончании загрузки. <ul><li>Подробнее про важные данные, с которыми мы будем работать в процессе загрузки:</li></ul><dl><dt><code>fileId</code></dt><dd>Уникальный идентификатор файла, генерируется по имени, размеру и дате модификации. По нему мы всегда сможем возобновить загрузку, в том числе и после закрытия и открытия браузера.</dd><dt><code>startByte</code></dt><dd>С какого байта загружать. Изначально – с нулевого.</dd><dt><code>errorCount / MAX_ERROR_COUNT</code></dt><dd>Текущее число ошибок / максимальное число ошибок подряд, после которого загрузка считается проваленной.</dd></dl><p>Алгоритм загрузки:</p><ol><li>Генерируем <code>fileId</code> из названия, размера, даты модификации файла. Можно добавить и идентификатор посетителя.</li><li>Спрашиваем сервер, есть ли уже такой файл, и если да – сколько байт уже загружено?</li><li>Отсылаем файл с позиции, которую сказал сервер.</li></ol><p>При этом загрузку можно прервать в любой момент, просто оборвав все запросы.</p><p>Демо ниже, к сожалению, работает лишь частично, так как на этом сайте Node.JS стоит за сервером Nginx, который буферизует все закачки, не передавая их в Node.JS до полного завершения.</p><p>Вы можете скачать пример и запустить локально для полноценной демонстрации:</p><code-tabs data-code_switch=""><tools-><code-download><a-></a-><a href="https://learn.javascript.ru/tutorial/zipview/progress.zip?plunkId=t1jBEAt4KE8Ns8IJ3csG" hover-style="" target="_blank" title="скачать архив"></a></code-download><button-0 class="current">index.html</button-0><button-1>server.js</button-1><button-2>uploader.js</button-2></tools-><code-example style="display: block;"><script>`<!DOCTYPE HTML>\n<html>\n  <head>\n    <meta charset="utf-8">\n    <script src="uploader.js"><\/script>\n  </head>\n<body>\n\n  <form name="upload" method="POST" enctype="multipart/form-data" action="/upload">\n    <input type="file" name="myfile">\n    <input type="submit" name="submit" value="Загрузить">\n  </form>\n\n  <button onclick="uploader.pause()">Пауза</button>\n\n\n  <div id="log">Индикация прогресса</div>\n\n  <script>\n    function log(html) {\n      document.getElementById('log').innerHTML = html;\n      //console.log(html);\n    }\n\n    function onSuccess() {\n      log('success');\n    }\n\n    function onError() {\n      log('error');\n    }\n\n    function onProgress(loaded, total) {\n      log("progress&nbsp" + loaded + ' /&nbsp' + total);\n    }\n\n    var uploader;\n\n    document.forms.upload.onsubmit = function() {\n      var file = this.elements.myfile.files[0];\n      if (!file) return false;\n\n      uploader = new Uploader(file, onSuccess, onError, onProgress);\n      uploader.upload();\n      return false;\n    }\n  <\/script>\n</body>\n\n</html>`</script><code-toolbar- iframe="80"><a title="показать" data-code_run="220"></a><a title="открыть в новом окне" data-new_window="code"></a><a-></a-></code-toolbar-></code-example><code-example><script>`var http = require('http');\nvar static = require('node-static');\nvar fileServer = new static.Server('.');\nvar path = require('path');\nvar fs = require('fs');\n\nvar uploads = {};\n\nfunction onUpload(req, res) {\n\n  var fileId = req.headers['x-file-id'];\n  var startByte = req.headers['x-start-byte'];\n\n  if (!fileId) {\n    res.writeHead(400, "No file id");\n    res.end();\n  }\n\n  // файлы будем записывать "в никуда"\n  var filePath = '/dev/null';\n  // можно положить файл и в реальное место\n  // var filePath = path.join('/tmp', fileId);\n\n  console.log("onUpload fileId:&nbsp", fileId);\n\n  // инициализация новой загрузки\n  if (!uploads[fileId]) uploads[fileId] = {};\n  var upload = uploads[fileId];\n\n  console.log("GREEN_bytesReceived:_GREEN" + upload.bytesReceived + "GREEN_ startByte:_GREEN" + startByte)\n\n  // если байт 0, то создать новый файл, иначе проверить размер и дописать\n  if (startByte == 0) {\n    upload.bytesReceived = 0;\n    var fileStream = fs.createWriteStream(filePath, {\n      flags: 'w'\n    });\n    console.log("New file created:&nbsp" + filePath);\n  } else {\n    if (upload.bytesReceived != startByte) {\n      res.writeHead(400, "Wrong start byte");\n      res.end(upload.bytesReceived);\n      return;\n    }\n    // добавляем в существующий файл\n    fileStream = fs.createWriteStream(filePath, {\n      flags: 'a'\n    });\n    console.log("File reopened:&nbsp" + filePath);\n  }\n\n\n  req.on('data', function(data) {\n    upload.bytesReceived += data.length;\n  });\n\n  // отправить тело запроса в файл\n  req.pipe(fileStream);\n\n  // в конце -- событие end\n  fileStream.on('close', function() {\n    if (upload.bytesReceived == req.headers['x-file-size']) {\n      // полностью загрузили\n      console.log("File finished");\n      delete uploads[fileId];\n\n      // при необходимости - обработать завершённую загрузку файла\n\n      res.end("Success&nbsp" + upload.bytesReceived);\n    } else {\n      // соединение оборвано, дескриптор закрылся но файл оставляем\n      console.log("File unfinished, stopped at&nbsp" + upload.bytesReceived);\n      res.end();\n    }\n  });\n\n  // при ошибках - завершение запроса\n  fileStream.on('error', function(err) {\n    console.log("fileStream error");\n    res.writeHead(500, "File error");\n    res.end();\n  });\n\n}\n\nfunction onStatus(req, res) {\n  var fileId = req.headers['x-file-id'];\n  var upload = uploads[fileId];\n  console.log("GREEN_onStatus fileId:_GREEN", fileId, "GREEN_ upload:_GREEN", upload);\n  if (!upload) {\n    res.end("0")\n  } else {\n    res.end(String(upload.bytesReceived));\n  }\n}\n\n\nfunction accept(req, res) {\n  if (req.url == '/status') {\n    onStatus(req, res);\n  } else if (req.url == '/upload' && req.method == 'POST') {\n    onUpload(req, res);\n  } else {\n    fileServer.serve(req, res);\n  }\n\n}\n\n\n// -----------------------------------\n\nif (!module.parent) {\n  http.createServer(accept).listen(8080);\n  console.log('Сервер запущен на порту 8080');\n} else {\n  exports.accept = accept;\n}`</script></code-example><code-example><script>`function Uploader(file, onSuccess, onFail, onProgress) {\n\n  // fileId уникальным образом идентифицирует файл\n  // можно добавить идентификатор сессии посетителя, но он и так будет в заголовках\n  var fileId = file.name + '-' + file.size + '-' + +file.lastModifiedDate;\n\n  // сделать из fileId число (хеш, алгоритм неважен), мы будем передавать его в заголовке,\n  // в заголовках разрешены только ASCII-символы\n  fileId = hashCode(fileId);\n\n  var errorCount = 0;\n\n  // если количество ошибок подряд превысит MAX_ERROR_COUNT, то стоп\n  var MAX_ERROR_COUNT = 6;\n\n  var startByte = 0;\n\n  var xhrUpload;\n  var xhrStatus;\n\n  function upload() {\n    console.log("upload: check status");\n    xhrStatus = new XMLHttpRequest();\n\n    xhrStatus.onload = xhrStatus.onerror = function() {\n\n      if (this.status == 200) {\n        startByte = +this.responseText || 0;\n        console.log("GREEN_upload: startByte=_GREEN" + startByte);\n        send();\n        return;\n      }\n\n      // что-то не так\n      if (errorCount++ < MAX_ERROR_COUNT) {\n        setTimeout(upload, 1000 * errorCount); // через 1 сек пробуем ещё раз\n      } else {\n        onError(this.statusText);\n      }\n\n    };\n\n    xhrStatus.open("GET", "status", true);\n    xhrStatus.setRequestHeader('X-File-Id', fileId);\n    xhrStatus.send();\n  }\n\n\n  function send() {\n\n    xhrUpload = new XMLHttpRequest();\n    xhrUpload.onload = xhrUpload.onerror = function() {\n      console.log("GREEN_upload end status:_GREEN" + this.status + "GREEN_ text:_GREEN" + this.statusText);\n\n      if (this.status == 200) {\n        // успешное завершение загрузки\n        onSuccess();\n        return;\n      }\n\n      // что-то не так\n      if (errorCount++ < MAX_ERROR_COUNT) {\n        setTimeout(resume, 1000 * errorCount); // через 1,2,4,8,16 сек пробуем ещё раз\n      } else {\n        onError(this.statusText);\n      }\n    };\n\n    xhrUpload.open("POST", "upload", true);\n    // какой файл догружаем /загружаем\n    xhrUpload.setRequestHeader('X-File-Id', fileId);\n\n    xhrUpload.upload.onprogress = function(e) {\n      errorCount = 0;\n      onProgress(startByte + e.loaded, startByte + e.total);\n    }\n\n    // отослать, начиная с байта startByte\n    xhrUpload.send(file.slice(startByte));\n  }\n\n  function pause() {\n    xhrStatus && xhrStatus.abort();\n    xhrUpload && xhrUpload.abort();\n  }\n\n\n  this.upload = upload;\n  this.pause = pause;\n}\n\n// вспомогательная функция: получение 32-битного числа из строки\n\nfunction hashCode(str) {\n  if (str.length == 0) return 0;\n\n  var hash = 0,\n    i, chr, len;\n  for (i = 0; i < str.length; i++) {\n    chr = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + chr;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return hash;\n};`</script></code-example></code-tabs><p>Полный код включает также сервер на Node.JS с функциям <code>onUpload</code> – начало и возобновление загрузки, а также <code>onStatus</code> – для получения состояния загрузки.</p><h2><a name="2" href="#2">Итого</a></h2><p>Мы рассмотрели довольно простой алгоритм возобновляемой загрузки.</p><p>Его можно усложнить:</p><ul><li>добавить подсчёт контрольных сумм, проверку целостности пересылаемых файлов,</li><li>для индикации прогресса вместо неточного <code>xhr.upload.onprogress</code> – сделать дополнительный запрос к серверу, в который тот будет отдавать текущий прогресс.</li><li>разбивать файл на части и грузить в несколько потоков, несколькими параллельными запросами.</li></ul><p>Как можно видеть, возможности современного XMLHttpRequest в плане загрузки файлов приближаются к полноценному файловому менеджеру – полный контроль над заголовками, индикатор прогресса и т.п.</p></dd><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="XMLHttpRequest: индикация прогресса; COMET с XMLHttpRequest: длинные опросы"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/xhr-resume",disqus_identifier="xhr-resume",disqus_title="XMLHttpRequest: \u0432\u043e\u0437\u043e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c\u0430\u044f \u0437\u0430\u043a\u0430\u0447\u043a\u0430";</script></page-content></main>