<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="160">AJAX и COMET</a></nav-up><h1>Server Side Events -- события с сервера</h1><p>Сразу заметим, что на текущий момент этот способ поддерживают все современные браузеры, кроме IE.</p><p>Современный стандарт <a href="https://html.spec.whatwg.org/multipage/comms.html#the-eventsource-interface">Server-Sent Events</a> позволяет браузеру создавать специальный объект <code>EventSource</code>, который сам обеспечивает соединение с сервером, делает пересоединение в случае обрыва и генерирует события при поступлении данных.</p><p>Он, по дизайну, может меньше, чем WebSocket’ы.</p><p>С другой стороны, Server Side Events проще в реализации, работают по обычному протоколу HTTP и сразу поддерживают ряд возможностей, которые для WebSocket ещё надо реализовать.</p><p>Поэтому в тех случаях, когда нужна преимущественно односторонняя передача данных от сервера к браузеру, они могут быть удачным выбором.</p><h2><a name="0" href="#0">Получение сообщений</a></h2><p>При создании объекта <code>new EventSource(src)</code> браузер автоматически подключается к адресу <code>src</code> и начинает получать с него события:</p><code-example><script>`var eventSource = new EventSource("/events/subscribe");\n\neventSource.onmessage = function(e) {\n  console.log("Пришло сообщение:&nbsp" + e.data);\n};`</script></code-example><p>Чтобы соединение успешно открылось, сервер должен ответить с заголовком <code>Content-Type: text/event-stream</code>, а затем оставить соединение висящим и писать в него сообщения в специальном формате:</p><code-example><script>`data: Сообщение 1\n\ndata: Сообщение 2\n\ndata: Сообщение 3\ndata: из двух строк`</script></code-example><ul><li><p>Каждое сообщение пишется после <code>data:</code>. Если после двоеточия есть пробел, то он игнорируется.</p></li><li><p>Сообщения разделяются двумя строками <code>\n\n</code>.</p></li><li><p>Если нужно переслать перевод строки, то сообщение разделяется. Каждая следующая строка пересылается отдельным <code>data:</code>.</p><p>В частности, две последние строки в примере выше составляют одно сообщение: <code>"Сообщение 3\nиз двух строк"</code>.</p></li></ul><p>Здесь все очень просто и удобно, кроме разделения сообщения при переводе строки. Но, если подумать – это не так уж страшно: на практике сложные сообщения обычно передаются в формате JSON. А перевод строки в нём кодируется как <code>\n</code>.</p><p>Соответственно, многострочные данные будут пересылаться так:</p><code-example><script>`data: {"user":"Вася","message":"Сообщение 3\\n из двух строк"}`</script></code-example><p>…То есть, строка <code>data:</code> будет одна, и никаких проблем с разделением сообщения нет.</p><h2><a name="1" href="#1">Восстановление соединения</a></h2><p>При создании объекта браузер автоматически подключается к серверу, а при обрыве – пытается его возобновить.</p><p>Это очень удобно, никакой другой транспорт не обладает такой встроенной способностью.</p><important-><h3>Как серверу полностью закрыть соединение?</h3><p>При любом закрытии соединения, в том числе если сервер ответит на запрос и закроет соединение сам – браузер через короткое время повторит свой запрос.</p><p>Есть лишь два способа, которыми сервер может «отшить» надоедливый <code>EventSource</code>:</p><ul><li>Ответить со статусом не 200.</li><li>Ответить с <code>Content-Type</code>, не совпадающим с <code>text/event-stream</code>.</li></ul></important-><p>Между попытками возобновить соединение будет пауза, начальное значение которой зависит от браузера (1-3 секунды) и может быть изменено сервером через указание <code>retry:</code> в ответе:</p><code-example><script>`retry: 15000\ndata: Поставлена задержка 15 секунд`</script></code-example><p>Браузер, со своей стороны, может закрыть соединение вызовом <code>close()</code>:</p><code-example><script>`var eventSource = new EventSource(...);\n\neventSource.close();`</script></code-example><p>При этом дальнейших попыток соединения не будет. Открыть обратно этот объект тоже нельзя, можно создать новый <code>EventSource</code>.</p><h3><a name="10" href="#10">Идентификатор id</a></h3><p>Для того, чтобы продолжить получение событий с места разрыва, стандарт предусматривает идентификацию событий через <code>id</code>.</p><p>Сервер может указать его в ответе:</p><code-example><script>`data: Сообщение 1\nid: 1\n\ndata: Сообщение 2\nid: 2\n\ndata: Сообщение 3\ndata: из двух строк\nid: 3`</script></code-example><p>При получении <code>id:</code> браузер:</p><ul><li>Устанавливает свойство <code>eventSource.lastEventId</code> в его значение.</li><li>При пересоединении пошлёт заголовок <code>Last-Event-ID</code> с этим <code>id</code>, так что сервер сможет переслать последующие, пропущенные, сообщения.</li></ul><p>Обратим внимание: <code>id</code> шлётся <em>не перед сообщением, а после него</em>, чтобы обновление <code>lastEventId</code> произошло, когда браузер всё уже точно получил.</p><h2><a name="2" href="#2">Статус соединения readyState</a></h2><p>У объекта <code>EventSource</code> есть свойство <code>readyState</code>, которое содержит одно из значений (выдержка из стандарта):</p><code-example><script>`const unsigned short CONNECTING = 0; // в процессе (пере-)соединения\nconst unsigned short OPEN = 1;       // соединение установлено\nconst unsigned short CLOSED = 2;     // соединение закрыто`</script></code-example><p>При создании объекта и при разрыве оно автоматически равно <code>CONNECTING</code>.</p><h2><a name="3" href="#3">События</a></h2><p>Событий всего три:</p><ul><li><code>onmessage</code> – пришло сообщение, доступно как <code>event.data</code></li><li><code>onopen</code> – при успешном установлении соединения</li><li><code>onerror</code> – при ошибке соединения.</li></ul><p>Например:</p><code-example><script>`var eventSource = new EventSource('digits');\n\neventSource.onopen = function(e) {\n  console.log("Соединение открыто");\n};\n\neventSource.onerror = function(e) {\n  if (this.readyState == EventSource.CONNECTING) {\n    console.log("Соединение порвалось, пересоединяемся...");\n  } else {\n    console.log("Ошибка, состояние:&nbsp" + this.readyState);\n  }\n};\n\neventSource.onmessage = function(e) {\n  console.log("Пришли данные:&nbsp" + e.data);\n};`</script></code-example><h2><a name="4" href="#4">Своё имя события: event</a></h2><p>По умолчанию на события срабатывает обработчик <code>onmessage</code>, но можно сделать и свои события. Для этого сервер должен указать перед событием его имя после <code>event:</code>.</p><p>Например:</p><code-example><script>`event: join\ndata: Вася\n\ndata: Привет\n\nevent: leave\ndata: Вася`</script></code-example><p>Сообщение по умолчанию имеет имя <code>message</code>.</p><p><strong>Для обработки своих имён событий необходимо ставить обработчик при помощи <code>addEventListener</code>.</strong></p><p>Пример кода для обработки:</p><code-example><script>`eventSource.addEventListener('join', function(e) {\n  alert( 'Пришёл&nbsp' + e.data );\n});\n\neventSource.addEventListener('message', function(e) {\n  alert( 'Сообщение&nbsp' + e.data );\n});\n\neventSource.addEventListener('leave', function(e) {\n  alert( 'Ушёл&nbsp' + e.data );\n});`</script></code-example><h2><a name="5" href="#5">Демо</a></h2><p>В примере ниже сервер посылает в соединение числа от 1 до 3, а затем – событие <code>bye</code> и закрывает соединение. Браузер автоматически откроет его заново.</p><code-tabs data-code_switch=""><tools-><code-download><a-></a-><a href="https://learn.javascript.ru/tutorial/zipview/eventsource.zip?plunkId=d1iq5O0WUw0CkMHIsvze" hover-style="" target="_blank" title="скачать архив"></a></code-download><button-0 class="current">index.html</button-0><button-1>server.js</button-1></tools-><code-example style="display: block;"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <script>\n    var eventSource;\n\n    function start() { // при нажатии на Старт\n\n      if (!window.EventSource) {\n        alert('В этом браузере нет поддержки EventSource.');\n        return;\n      }\n\n      eventSource = new EventSource('digits');\n\n      eventSource.onopen = function(e) {\n        log("Соединение открыто");\n      };\n\n      eventSource.onerror = function(e) {\n        if (this.readyState == EventSource.CONNECTING) {\n          log("Соединение порвалось, пересоединяемся...");\n        } else {\n          log("Ошибка, состояние:&nbsp" + this.readyState);\n        }\n      };\n\n      eventSource.addEventListener('bye', function(e) {\n        log("Bye:&nbsp" + e.data);\n      }, false);\n\n      eventSource.onmessage = function(e) {\n        console.log(e);\n        log(e.data);\n      };\n    }\n\n    function stop() { // при нажатии на Стоп\n      eventSource.close();\n      log("Соединение завершено");\n    }\n\n    function log(msg) {\n      logElem.innerHTML += msg + "<br>";\n    }\n  <\/script>\n</head>\n\n<body>\n\n  <button onclick="start()">Старт</button>\n  <button onclick="stop()">Стоп</button>\n\n  Нажмите "Старт" для начала.\n  <div id="logElem"></div>\n\n\n</body>\n\n</html>`</script><code-toolbar- iframe="180"><a title="показать" data-code_run="220"></a><a title="открыть в новом окне" data-new_window="code"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><code-example><script>`var http = require('http');\nvar url = require('url');\nvar querystring = require('querystring');\n\nvar fileServer = new(require('node-static')).Server('.');\n\nfunction onDigits(req, res) {\n  res.writeHead(200, {\n    'Content-Type': 'text/event-stream; charset=utf-8',\n    'Cache-Control': 'no-cache'\n  });\n\n  var i = 0;\n\n  var timer = setInterval(write, 1000);\n  write();\n\n  function write() {\n    i++;\n\n    if (i == 4) {\n      res.write('event: bye\\ndata: до свидания\\n\\n');\n      clearInterval(timer);\n      res.end();\n      return;\n    }\n\n    res.write('data:&nbsp' + i + '\\n\\n');\n\n  }\n}\n\nfunction accept(req, res) {\n\n  if (req.url == '/digits') {\n    onDigits(req, res);\n    return;\n  }\n\n  // всё остальное -- статика\n  fileServer.serve(req, res);\n\n\n}\n\n\n\n// ----- запуск accept как сервера из консоли или как модуля ------\n\nif (!module.parent) {\n  http.createServer(accept).listen(8080);\n} else {\n  exports.accept = accept;\n}`</script></code-example></code-tabs><h2><a name="6" href="#6">Кросс-доменность</a></h2><p><code>EventSource</code> поддерживает кросс-доменные запросы, аналогично <code>XMLHttpRequest</code>. Для этого у конструктора есть второй аргумент – объект, который нужно передать так:</p><code-example><script>`var source = new EventSource("http://pupkin.ru/stream", {\n  withCredentials: true\n});`</script></code-example><p>Второй аргумент сделан объектом с расчётом на будущее. Пока что никаких других свойств там не поддерживается, только <code>withCredentials</code>.</p><p>Сервер при этом получит заголовок <code>Origin</code> с доменом запроса и должен ответить с заголовком <code>Access-Control-Allow-Origin</code> (и <code>Access-Control-Allow-Credentials</code>, если стоит <code>withCredentials</code>), в точности как в главе <a data-load_page="165">XMLHttpRequest: кросс-доменные запросы</a>.</p><p>При кросс-доменных запросах у событий <code>event</code> также появится дополнительное свойство <code>origin</code>, содержащее адрес источника, откуда пришли данные. Его можно использовать для дополнительной проверки со стороны браузера:</p><code-example><script>`eventSource.addEventListener('message', function(e) {\n  if (e.origin != 'http://javascript.ru') return;\n  alert( 'Сообщение&nbsp' + e.data );\n});`</script></code-example><h2><a name="7" href="#7">Итого</a></h2><p>Объект <code>EventSource</code> предназначен для передачи текстовых сообщений с сервера, используя обычный протокол HTTP.</p><p>Он предлагает не только передачу сообщений, но и встроенную поддержку важных вспомогательных функций:</p><ul><li>События <code>event</code>.</li><li>Автоматическое пересоединение, с настраиваемой задержкой <code>retry</code>.</li><li>Проверка текущего состояния подключения по <code>readyState</code>.</li><li>Идентификаторы сообщений <code>id</code> для точного возобновления потока данных, последний полученный идентификатор передаётся в заголовке <code>Last-Event-ID</code>.</li><li>Кросс-доменность CORS.</li></ul><p>Этот набор функций делает EventSource достойной альтернативой WebSocket, которые хоть и потенциально мощнее, но требуют реализации всех этих функций на клиенте и сервере, поверх протокола.</p><p>Поддержка – все браузеры, кроме IE.</p><ul><li><p>Синтаксис:</p><code-example><script>`var source = new EventSource(src[, credentials]); // src - адрес с любого домена`</script></code-example><p>Второй необязательный аргумент, если указан в виде <code>{ withCredentials: true }</code>, инициирует отправку Cookie и данных авторизации при кросс-доменных запросах.</p><p>Безопасность при кросс-доменных запросах обеспечивается аналогично <code>XMLHttpRequest</code>.</p></li><li><p>Свойства объекта:</p><dl><dt><code>readyState</code></dt><dd>Текущее состояние соединения, одно из <code>EventSource.CONNECTING (=0)</code>, <code>EventSource.OPEN (=1)</code> или <code>EventSource.CLOSED (=2)</code>.</dd><dt><code>lastEventId</code></dt><dd>Последнее полученное <code>id</code>, если есть. При возобновлении соединения браузер указывает это значение в заголовке <code>Last-Event-ID</code>.</dd><dt><code>url</code>, <code>withCredentials</code></dt><dd>Параметры, переданные при создании объекта. Менять их нельзя.</dd></dl></li><li><p>Методы:</p><dl><dt><code>close()</code></dt><dd>Закрывает соединение.</dd></dl></li><li><p>События:</p><dl><dt><code>onmessage</code></dt><dd>При сообщении, данные – в <code>event.data</code>.</dd><dt><code>onopen</code></dt><dd>При установлении соединения.</dd><dt><code>onerror</code></dt><dd>При ошибке, в том числе – закрытии соединения по инициативе сервера.</dd></dl><p>Эти события можно ставить напрямую через свойство: <code>source.onmessage = ...</code>.</p><p>Если сервер присылает имя события в <code>event:</code>, то такие события нужно обрабатывать через <code>addEventListener</code>.</p></li><li><p>Формат ответа сервера:</p><p>Сервер присылает пустые строки, либо строки, начинающиеся с:</p><ul><li><code>data:</code> – сообщение, несколько таких строк подряд склеиваются и образуют одно сообщение.</li><li><code>id:</code> – обновляет <code>lastEventId</code>.</li><li><code>retry:</code> – указывает паузу между пересоединениями, в миллисекундах. JavaScript не может указать это значение, только сервер.</li><li><code>event:</code> – имя события, должен быть перед <code>data:</code>.</li></ul></li></ul><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Протокол JSONP; IFRAME для AJAX и COMET"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/server-sent-events",disqus_identifier="server-sent-events",disqus_title="Server Side Events -- \u0441\u043e\u0431\u044b\u0442\u0438\u044f \u0441 \u0441\u0435\u0440\u0432\u0435\u0440\u0430";</script></page-content></main>