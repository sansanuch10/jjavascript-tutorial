<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="160">AJAX и COMET</a></nav-up><h1>COMET с XMLHttpRequest: длинные опросы</h1><p>В этой главе мы рассмотрим способ организации COMET, то есть непрерывного получения данных с сервера, который очень прост и подходит в 90% реальных случаев.</p><h2><a name="0" href="#0">Частые опросы</a></h2><p>Первое решение, которое приходит в голову для непрерывного получения событий с сервера – это «частые опросы» (polling), т.е периодические запросы на сервер: «эй, я тут, изменилось ли что-нибудь?». Например, раз в 10 секунд.</p><p>В ответ сервер во-первых помечает у себя, что клиент онлайн, а во-вторых посылает сообщение, в котором в специальном формате содержится весь пакет событий, накопившихся к данному моменту.</p><p>При этом, однако, возможна задержка между появлением и получением данных, как раз в размере этих 10 секунд между запросами.</p><p>Другой минус – лишний входящий трафик на сервер. При каждом запросе браузер передает множество заголовков и в ответ получает, кроме данных, также заголовки. Для некоторых приложений трафик заголовков может в 10 и более раз превосходить трафик реальных данных.</p><balance-><balance-minuses><div>Недостатки</div><ul><li>Задержки между событием и уведомлением.</li><li>Лишний трафик и запросы на сервер.</li></ul></balance-minuses><balance-pluses><div>Достоинства</div><ul><li>Простота реализации.</li></ul></balance-pluses></balance-><p>Причём, простота реализации тут достаточно условная. Клиентская часть – довольно проста, а вот сервер получает сразу большой поток запросов.</p><p>Даже если клиент ушёл пить чай – его браузер каждые 10 секунд будет «долбить» сервер запросами. Готов ли сервер к такому?</p><h2><a name="1" href="#1">Длинные опросы</a></h2><p>Длинные опросы – отличная альтернатива частым опросам. Они также удобны в реализации, и при этом сообщения доставляются без задержек.</p><p>Схема:</p><ol><li>Отправляется запрос на сервер.</li><li>Соединение не закрывается сервером, пока не появится сообщение.</li><li>Когда сообщение появилось – сервер отвечает на запрос, пересылая данные.</li><li>Браузер тут же делает новый запрос.</li></ol><p>Ситуация, когда браузер отправил запрос и держит соединение с сервером, ожидая ответа, является стандартной и прерывается только доставкой сообщений.</p><p>Схема коммуникации:</p><figure><img src="longpoll.png" alt="" width="100%" style="max-width:500px"></figure><p>При этом если соединение рвётся само, например, из-за ошибки в сети, то браузер тут же отсылает новый запрос.</p><p>Примерный код клиентской части:</p><code-example><script>`function subscribe(url) {\n  var xhr = new XMLHttpRequest();\n\n  xhr.onreadystatechange = function() {\n    if (this.readyState != 4) return;\n\n    if (this.status == 200) {\n      onMessage(this.responseText);\n    } else {\n      onError(this);\n    }\n\n    subscribe(url);\n  }\n  xhr.open("GET", url, true);\n  xhr.send();\n}`</script></code-example><p>Функция <code>subscribe</code> делает запрос, при ответе обрабатывает результат, и тут же запускает процесс по новой.</p><p>Сервер, конечно же, должен уметь работать с большим количеством таких «ожидающих» соединений.</p><h2><a name="2" href="#2">Демо: чат</a></h2><p>Демо:</p><code-tabs data-code_switch=""><tools-><code-download><a-></a-><a href="https://learn.javascript.ru/tutorial/zipview/longpoll.zip?plunkId=ISyNzPt11chFUq9W2nT5" hover-style="" target="_blank" title="скачать архив"></a></code-download><button-0 class="current">index.html</button-0><button-1>browser.js</button-1><button-2>server.js</button-2></tools-><code-example style="display: block;"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <script src="browser.js"><\/script>\n</head>\n\n<body>\n\n  Несколько человек при заходе на эту страницу будут получать сообщения друг друга.\n\n  <form name="publish">\n    <input type="text" name="message" />\n    <input type="submit" value="Отправить" />\n  </form>\n\n  <div id="subscribe">\n  </div>\n\n  <script>\n    new PublishForm(document.forms.publish, 'publish');\n    // random url to fix https://code.google.com/p/chromium/issues/detail?id=46104\n    new SubscribePane(document.getElementById('subscribe'), 'GREEN_subscribe?random=_GREEN' + Math.random());\n  <\/script>\n\n</body>\n\n</html>`</script><code-toolbar- iframe="450"><a title="показать" data-code_run="0"></a><a title="открыть в новом окне" data-new_window="code"></a><a-></a-></code-toolbar-></code-example><code-example><script>`// Посылка запросов -- обычными XHR POST\nfunction PublishForm(form, url) {\n\n  function sendMessage(message) {\n    var xhr = new XMLHttpRequest();\n    xhr.open("POST", url, true);\n    // просто отсылаю сообщение "как есть" без кодировки\n    // если бы было много данных, то нужно было бы отослать JSON из объекта с ними\n    // или закодировать их как-то иначе\n    xhr.send(message);\n  }\n\n  form.onsubmit = function() {\n    var message = form.message.value;\n    if (message) {\n      form.message.value = '';\n      sendMessage(message);\n    }\n    return false;\n  };\n}\n\n// Получение сообщений, COMET\nfunction SubscribePane(elem, url) {\n\n  function showMessage(message) {\n    var messageElem = document.createElement('div');\n    messageElem.appendChild(document.createTextNode(message));\n    elem.appendChild(messageElem);\n  }\n\n  function subscribe() {\n    var xhr = new XMLHttpRequest();\n    xhr.onreadystatechange = function() {\n      if (this.readyState != 4) return;\n\n      if (this.status == 200) {\n        if (this.responseText) {\n          // сервер может закрыть соединение без ответа при перезагрузке\n          showMessage(this.responseText);\n        }\n        subscribe();\n        return;\n      }\n\n      if (this.status != 502) {\n        // 502 - прокси ждал слишком долго, надо пересоединиться, это не ошибка\n        showMessage(this.statusText); // показать ошибку\n      }\n\n      setTimeout(subscribe, 1000); // попробовать ещё раз через 1 сек\n    }\n    xhr.open("GET", url, true);\n    xhr.send();\n  }\n\n  subscribe();\n\n}`</script></code-example><code-example><script>`var http = require('http');\nvar url = require('url');\nvar querystring = require('querystring');\nvar static = require('node-static');\n\nvar fileServer = new static.Server('.');\n\nvar subscribers = {};\n\nfunction onSubscribe(req, res) {\n  var id = Math.random();\n\n  res.setHeader('Content-Type', 'text/plain;charset=utf-8');\n  res.setHeader("Cache-Control", "no-cache, must-revalidate");\n\n  subscribers[id] = res;\n  //console.log("новый клиент&nbsp" + id + ", клиентов:&nbsp" + Object.keys(subscribers).length);\n\n  req.on('close', function() {\n    delete subscribers[id];\n    //console.log("клиент&nbsp" + id + " отсоединился, клиентов:&nbsp" + Object.keys(subscribers).length);\n  });\n\n}\n\nfunction publish(message) {\n\n  //console.log("есть сообщение, клиентов:&nbsp" + Object.keys(subscribers).length);\n\n  for (var id in subscribers) {\n    //console.log("отсылаю сообщение&nbsp" + id);\n    var res = subscribers[id];\n    res.end(message);\n  }\n\n  subscribers = {};\n}\n\nfunction accept(req, res) {\n  var urlParsed = url.parse(req.url, true);\n\n  // новый клиент хочет получать сообщения\n  if (urlParsed.pathname == '/subscribe') {\n    onSubscribe(req, res); // собственно, подписка\n    return;\n  }\n\n  // отправка сообщения\n  if (urlParsed.pathname == '/publish' && req.method == 'POST') {\n    // принять POST-запрос\n    req.setEncoding('utf8');\n    var message = '';\n    req.on('data', function(chunk) {\n      message += chunk;\n    }).on('end', function() {\n      publish(message); // собственно, отправка\n      res.end("ok");\n    });\n\n    return;\n  }\n\n  // всё остальное -- статика\n  fileServer.serve(req, res);\n\n}\n\n\n// -----------------------------------\n\nif (!module.parent) {\n  http.createServer(accept).listen(8080);\n  console.log('Сервер запущен на порту 8080');\n} else {\n  exports.accept = accept;\n\n  process.on('SIGINT', function() {\n    for (var id in subscribers) {\n      var res = subscribers[id];\n      res.end();\n    }\n  });\n}`</script></code-example></code-tabs><h2><a name="3" href="#3">Область применения</a></h2><p>Длинные опросы отлично работают в тех случаях, когда сообщения приходят редко.</p><p>При большом количестве частых сообщений график приёма-отправки, приведённый выше, превращается в «пилу». Каждое сообщение – это новый запрос, дополнительный трафик заголовков.</p><p>В этих случаях используются другие способы получения данных, подразумевающие непрерывное соединение с сервером. Мы рассмотрим их в следующих главах.</p><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="XMLHttpRequest: возобновляемая закачка; WebSocket"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/xhr-longpoll",disqus_identifier="xhr-longpoll",disqus_title="COMET \u0441 XMLHttpRequest: \u0434\u043b\u0438\u043d\u043d\u044b\u0435 \u043e\u043f\u0440\u043e\u0441\u044b";</script></page-content></main>