<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="160">AJAX и COMET</a></nav-up><h1>XMLHttpRequest POST, формы и кодировка</h1><p>Во время обычной отправки формы <code>&lt;form&gt;</code> браузер собирает значения её полей, делает из них строку и составляет тело GET/POST-запроса для посылки на сервер.</p><p>При отправке данных через <code>XMLHttpRequest</code>, это нужно делать самим, в JS-коде. Большинство проблем и вопросов здесь связано с непониманием, где и какое кодирование нужно осуществлять.</p><h2><a name="0" href="#0">Кодировка urlencoded</a></h2><p>Основной способ кодировки запросов – это <em>urlencoded</em>, то есть – стандартное кодирование URL.</p><p>Например, форма:</p><code-example><script>`<form action="/submit" method="GET">\n  <input name="name" value="Ivan">\n  <input name="surname" value="Ivanov">\n</form>`</script></code-example><p>Здесь есть два поля: <code>name=Ivan</code> и <code>surname=Ivanov</code>.</p><p>Браузер перечисляет такие пары «имя=значение» через символ амперсанда <code>&amp;</code> и, так как метод GET, итоговый запрос выглядит как <code>/submit?name=Ivan&amp;surname=Ivanov</code>.</p><p>Все символы, кроме английских букв, цифр и <code>- _ . ! ~ * ' ( )</code> заменяются на их цифровой код в UTF-8 со знаком %.</p><p>Например, пробел заменяется на <code>%20</code>, символ <code>/</code> на <code>%2F</code>, русские буквы кодируются двумя байтами в UTF-8, поэтому, к примеру, <code>Ц</code> заменится на <code>%D0%A6</code>.</p><p>Например, форма:</p><code-example><script>`<form action="/submit" method="GET">\n  <input name="name" value="Виктор">\n  <input name="surname" value="Цой">\n</form>`</script></code-example><p>Будет отправлена так: <code>/submit?name=%D0%92%D0%B8%D0%BA%D1%82%D0%BE%D1%80&amp;surname=%D0%A6%D0%BE%D0%B9</code>.</p><p>в JavaScript есть функция <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent">encodeURIComponent</a> для получения такой кодировки «вручную»:</p><code-example><script>`alert( encodeURIComponent(' ') ); // %20\nalert( encodeURIComponent('/') ); // %2F\nalert( encodeURIComponent('В') ); // %D0%92\nalert( encodeURIComponent('Виктор') ); // %D0%92%D0%B8%D0%BA%D1%82%D0%BE%D1%80`</script><code-toolbar></code-toolbar></code-example><p>Эта кодировка используется в основном для метода GET, то есть для передачи параметра в строке запроса. По стандарту строка запроса не может содержать произвольные Unicode-символы, поэтому они кодируются как показано выше.</p><h2><a name="1" href="#1">GET-запрос</a></h2><p>Формируя XMLHttpRequest, мы должны формировать запрос «руками», кодируя поля функцией <code>encodeURIComponent</code>.</p><p>Например, для посылки GET-запроса с параметрами <code>name</code> и <code>surname</code>, аналогично форме выше, их необходимо закодировать так:</p><code-example><script>`// Передаём name и surname в параметрах запроса\n\nvar xhr = new XMLHttpRequest();\n\nvar params = 'GREEN_name=_GREEN' + encodeURIComponent(name) +\n  'GREEN_&surname=_GREEN' + encodeURIComponent(surname);\n\nxhr.open("GET", '/submit?' + params, true);\n\nxhr.onreadystatechange = ...;\n\nxhr.send();`</script></code-example><important-><h3>Прочие заголовки</h3><p>Браузер автоматически добавит к запросу важнейшие HTTP-заголовки, такие как <code>Content-Length</code> и <code>Connection</code>.</p><p>По спецификации браузер запрещает их явную установку, как и некоторых других низкоуровневых HTTP-заголовков, которые могли бы ввести в заблуждение сервер относительно того, кто и сколько данных ему прислал, например <code>Referer</code>. Это сделано в целях контроля правильности запроса и для безопасности.</p></important-><important-><h3>Сообщаем про AJAX</h3><p>Запрос, отправленный кодом выше через <code>XMLHttpRequest</code>, никак не отличается от обычной отправки формы. Сервер не в состоянии их отличить.</p><p>Поэтому в некоторых фреймворках, чтобы сказать серверу, что это AJAX, добавляют специальный заголовок, например такой:</p><code-example><script>`xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");`</script></code-example></important-><h2><a name="2" href="#2">POST с urlencoded</a></h2><p>В методе POST параметры передаются не в URL, а в теле запроса. Оно указывается в вызове <code>send(body)</code>.</p><p>В стандартных HTTP-формах для метода POST доступны <a href="https://html.spec.whatwg.org/multipage/forms.html#submit-body">три кодировки</a>, задаваемые через атрибут <code>enctype</code>:</p><ul><li><code>application/x-www-form-urlencoded</code></li><li><code>multipart/form-data</code></li><li><code>text-plain</code></li></ul><p>В зависимости от <code>enctype</code> браузер кодирует данные соответствующим способом перед отправкой на сервер.</p><p>В случае с <code>XMLHttpRequest</code> мы, вообще говоря, не обязаны использовать ни один из этих способов. Главное, чтобы сервер наш запрос понял. Но обычно проще всего выбрать какой-то из стандартных.</p><p>В частности, при POST обязателен заголовок <code>Content-Type</code>, содержащий кодировку. Это указание для сервера – как обрабатывать (раскодировать) пришедший запрос.</p><p>Для примера отправим запрос в кодировке <code>application/x-www-form-urlencoded</code>:</p><code-example><script>`var xhr = new XMLHttpRequest();\n\nvar body = 'GREEN_name=_GREEN' + encodeURIComponent(name) +\n  'GREEN_&surname=_GREEN' + encodeURIComponent(surname);\n\nxhr.open("POST", '/submit', true);\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\nxhr.onreadystatechange = ...;\n\nxhr.send(body);`</script></code-example><important-warn><h3>Только UTF-8</h3><p>Всегда используется только кодировка UTF-8, независимо от языка и кодировки страницы.</p><p>Если сервер вдруг ожидает данные в другой кодировке, к примеру windows-1251, то их нужно будет перекодировать.</p></important-warn><h2><a name="3" href="#3">Кодировка multipart/form-data</a></h2><p>Кодировка urlencoded за счёт замены символов на <code>%код</code> может сильно «раздуть» общий объём пересылаемых данных. Поэтому для пересылки файлов используется другая кодировка: <a href="http://ru.wikipedia.org/wiki/Multipart_form-data">multipart/form-data</a>.</p><p>В этой кодировке поля пересылаются одно за другим, через строку-разделитель.</p><p>Чтобы использовать этот способ, нужно указать его в атрибуте <code>enctype</code> и метод должен быть POST:</p><code-example><script>`<form action="/submit" method="POST" BLUE_enctype_BLUE="multipart/form-data">\n  <input name="HIGHnameLIGHT" value="HIGHВикторLIGHT">\n  <input name="HIGHsurnameLIGHT" value="HIGHЦойLIGHT">\n</form>`</script></code-example><p>Форма при такой кодировке будет выглядеть примерно так:</p><code-example><script>`...Заголовки...\nContent-Type: HIGHmultipart/form-data; boundary=RaNdOmDeLiMiTeRLIGHT\n\n--RaNdOmDeLiMiTeR\nContent-Disposition: form-data; name="HIGHnameLIGHT"\n\nHIGHВикторLIGHT\n--RaNdOmDeLiMiTeR\nContent-Disposition: form-data; name="HIGHsurnameLIGHT"\n\nHIGHЦойLIGHT\n--RaNdOmDeLiMiTeR--`</script></code-example><p>…То есть, поля передаются одно за другим, значения не кодируются, а чтобы было чётко понятно, какое значение где – поля разделены случайно сгенерированной строкой, которую называют «boundary» (англ. граница), в примере выше это <code>RaNdOmDeLiMiTeR</code>:</p><p>Сервер видит заголовок <code>Content-Type: multipart/form-data</code>, читает из него границу и раскодирует поля формы.</p><p>Такой способ используется в первую очередь при пересылке файлов, так перекодировка мегабайтов через urlencoded существенно загрузила бы браузер. Да и объём данных после неё сильно вырос бы.</p><p>Однако, никто не мешает использовать эту кодировку всегда для POST запросов. Для GET доступна только urlencoded.</p><h2><a name="4" href="#4">POST с multipart/form-data</a></h2><p>Сделать POST-запрос в кодировке <code>multipart/form-data</code> можно и через XMLHttpRequest.</p><p>Достаточно указать в заголовке <code>Content-Type</code> кодировку и границу, и далее сформировать тело запроса, удовлетворяющее требованиям кодировки.</p><p>Пример кода для того же запроса, что и раньше, теперь в кодировке <code>multipart/form-data</code>:</p><code-example><script>`var data = {\n  name: 'Виктор',\n  surname: 'Цой'\n};\n\nvar boundary = String(Math.random()).slice(2);\nvar boundaryMiddle = '--' + boundary + '\r\n';\nvar boundaryLast = '--' + boundary + '--\\r\\n'\n\nvar body = ['\\r\\n'];\nfor (var key in data) {\n  // добавление поля\n  body.push('Content-Disposition: form-data; name="_GREEN' + key + '"GREEN_\\r\\n\\r\\n' + data[key] + '\\r\\n');\n}\n\nbody = body.join(boundaryMiddle) + boundaryLast;\n\n// Тело запроса готово, отправляем\n\nvar xhr = new XMLHttpRequest();\nxhr.open('POST', '/submit', true);\n\nxhr.setRequestHeader('Content-Type', GREEN_'multipart/form-data; boundary=GREEN' + boundary);\n\nxhr.onreadystatechange = function() {\n  if (this.readyState != 4) return;\n\n  alert( this.responseText );\n}\n\nxhr.send(body);`</script></code-example><p>Тело запроса будет иметь вид, описанный выше, то есть поля через разделитель.</p><important-><h3>Отправка файла</h3><p>Можно создать запрос, который сервер воспримет как загрузку файла.</p><p>Для добавления файла нужно использовать тот же код, что выше, модифицировав заголовки перед полем, которое является файлом, так:</p><code-example><script>`Content-Disposition: form-data; name="myfile"; BLUE_filename_BLUE="pic.jpg"\nContent-Type: image/jpeg\n(пустая строка)\nсодержимое файла`</script></code-example></important-><h2><a name="5" href="#5">FormData</a></h2><p>Современные браузеры, исключая IE9- (впрочем, есть полифилл), поддерживают встроенный объект <a href="https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/FormData/Using_FormData_Objects">FormData</a>, который кодирует формы для отправки на сервер.</p><p>Это очень удобно. Например:</p><code-example><script>`<form name="person">\n  <input name="name" value="Виктор">\n  <input name="surname" value="Цой">\n</form>\n\n<script>\n  // создать объект для формы\nMARK  var formData = new FormData(document.forms.person);\n\n  // добавить к пересылке ещё пару ключ - значение\n  formData.append("patronym", "Робертович");\n\n  // отослать\n  var xhr = new XMLHttpRequest();\n  xhr.open("POST", "/url");\nMARK  xhr.send(formData);\n<\/script>`</script></code-example><p>Этот код отправит на сервер форму с полями <code>name</code>, <code>surname</code> и <code>patronym</code>.</p><p>Интерфейс:</p><ul><li>Конструктор <code>new FormData([form])</code> вызывается либо без аргументов, либо с DOM-элементом формы.</li><li>Метод <code>formData.append(name, value)</code> добавляет данные к форме.</li></ul><p>Объект <code>formData</code> можно сразу отсылать, интеграция <code>FormData</code> с <code>XMLHttpRequest</code> встроена в браузер. Кодировка при этом будет <code>multipart/form-data</code>.</p><h2><a name="6" href="#6">Другие кодировки</a></h2><p>XMLHttpRequest сам по себе не ограничивает кодировку и формат пересылаемых данных.</p><p>Поэтому для обмена данными часто используется формат JSON:</p><code-example><script>`var xhr = new XMLHttpRequest();\n\nvar json = JSON.stringify({\n  name: "Виктор",\n  surname: "Цой"\n});\n\nxhr.open("POST", '/submit', true)\nxhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');\n\nxhr.onreadystatechange = ...;\n\nMARK// Отсылаем объект в формате JSON и с Content-Type application/json\nMARK// Сервер должен уметь такой Content-Type принимать и раскодировать\nxhr.send(json);`</script></code-example><h2><a name="7" href="#7">Итого</a></h2><ul><li>У форм есть две основные кодировки: <code>application/x-www-form-urlencoded</code> – по умолчанию и <code>multipart/form-data</code> – для POST запросов, если явно указана в <code>enctype</code>. Вторая кодировка обычно используется для больших данных и только для тела запроса.</li><li>Для составления запроса в <code>application/x-www-form-urlencoded</code> используется функция <code>encodeURIComponent</code>.</li><li>Для отправки запроса в <code>multipart/form-data</code> – объект <code>FormData</code>.</li><li>Для обмена данными JS ↔ сервер можно использовать и просто JSON, желательно с указанием кодировки в заголовке <code>Content-Type</code>.</li></ul><p>В XMLHttpRequest можно использовать и другие HTTP-методы, например PUT, DELETE, TRACE. К ним применимы все те же принципы, что описаны выше.</p><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Основы XMLHttpRequest; XMLHttpRequest: кросс-доменные запросы"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/xhr-forms", disqus_identifier = "xhr-forms", disqus_title = "XMLHttpRequest POST, \u0444\u043e\u0440\u043c\u044b \u0438 \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0430";</script></page-content></main>