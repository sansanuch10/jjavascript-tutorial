<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="160">AJAX и COMET</a></nav-up><h1>IFRAME для AJAX и COMET</h1><p>Эта глава посвящена <code>IFRAME</code> – самому древнему и кросс-браузерному способу AJAX-запросов.</p><p>Сейчас он используется, разве что, для поддержки кросс-доменных запросов в IE7- и, что чуть более актуально, для реализации COMET в IE9-.</p><p>Для общения с сервером создается невидимый <code>IFRAME</code>. В него отправляются данные, и в него же сервер пишет ответ.</p><h2><a name="0" href="#0">Введение</a></h2><p>Сначала – немного вспомогательных функций и особенности работы с <code>IFRAME</code>.</p><h3><a name="7" href="#7">Двуличность IFRAME: окно+документ</a></h3><p>Что такое IFRAME? На этот вопрос у браузера два ответа</p><ol><li><p>IFRAME – это HTML-тег: <code>&lt;iframe&gt;</code> со стандартным набором свойств.</p><ul><li>Тег можно создавать в JavaScript</li><li>У тега есть стили, можно менять.</li><li>К тегу можно обратиться через <code>document.getElementById</code> и другие методы.</li></ul></li><li><p>IFRAME – это окно браузера, вложенное в основное</p><ul><li>IFRAME – такое же по функционалу окно браузера, как и основное, с адресом и т.п.<ul><li>Если документ в <code>IFRAME</code> и внешнее окно находятся на разных доменах, то прямой вызов методов друг друга невозможен.</li></ul></li><li>Ссылку на это окно можно получить через <code>window.frames['имя фрейма']</code>.</li></ul></li></ol><p>Для достижения цели мы будем работать как с тегом, так и с окном. Они, конечно же, взаимосвязаны.</p><p><strong>В теге <code>&lt;iframe&gt;</code> свойство <code>contentWindow</code> хранит ссылку на окно.</strong></p><p>Окна также содержатся в коллекции <code>window.frames</code>.</p><p>Например:</p><code-example><script>`// Окно из ифрейма\nvar iframeWin = iframe.contentWindow;\n\n// Можно получить и через frames, если мы знаем имя ифрейма (и оно у него есть)\nvar iframeWin = window.frames[iframe.name];\niframeWin.parent == window; // parent из iframe указывает на родительское окно\n\n// Документ не будет доступен, если iframe с другого домена\nvar iframeDoc = iframe.contentWindow.document;`</script></code-example><p>Больше информации об ифреймах вы можете получить в главе <a data-load_page="192">Общение между окнами и фреймами</a>.</p><h3><a name="8" href="#8">IFRAME и история посещений</a></h3><p><code>IFRAME</code> – полноценное окно, поэтому навигация в нём попадает в историю посещений.</p><p>Это означает, что при нажатии кнопки «Назад» браузер вернёт посетителя назад не в основном окне, а в ифрейме. В лучшем случае – браузер возьмёт предыдущее состояние ифрейма из кэша и посетитель просто подумает, что кнопка не сработала. В худшем – в ифрейм будет сделан предыдущий запрос, а это уже точно ни к чему.</p><p><strong>Наши запросы в ифрейм – служебные и для истории не предназначены. К счастью, есть ряд техник, которые позволяют обойти проблему.</strong></p><ul><li><p>Ифрейм нужно создавать динамически, через JavaScript.</p></li><li><p>Когда ифрейм уже создан, то единственный способ поменять его <code>src</code> без попадания запроса в историю посещений:</p><code-example><script>`// newSrc - новый адрес\niframeDoc.location.replace(newSrc);`</script></code-example><p>Вы можете возразить: «но ведь <code>iframeDoc</code> не всегда доступен! <code>iframe</code> может быть с другого домена – как быть тогда?». Ответ: вместо смены <code>src</code> этого ифрейма – создать новый, с новым <code>src</code>.</p></li><li><p>POST-запросы в <code>iframe</code> всегда попадают в историю посещений.</p></li><li><p>… Но если <code>iframe</code> удалить, то лишняя история тоже исчезнет :). Сделать это можно по окончании запроса.</p></li></ul><p><strong>Таким образом, общий принцип использования <code>IFRAME</code>: динамически создать, сделать запрос, удалить.</strong></p><p>Бывает так, что удалить по каким-то причинам нельзя, тогда возможны проблемы с историей, описанные выше.</p><h3><a name="9" href="#9">Функция createIframe</a></h3><p>Приведенная ниже функция <code>createIframe(name, src, debug)</code> кросс-браузерно создаёт ифрейм с данным именем и <code>src</code>.</p><p>Аргументы:</p><dl><dt><code>name</code></dt><dd>Имя и <code>id</code> ифрейма</dd><dt><code>src</code></dt><dd>Исходный адрес ифрейма. Необязательный параметр.</dd><dt><code>debug</code></dt><dd>Если параметр задан, то ифрейм после создания не прячется.</dd></dl><code-example><script>`function createIframe(name, src, debug) {\n  src = src || 'javascript:false'; // пустой src\n\n  var tmpElem = document.createElement('div');\n\n  // в старых IE нельзя присвоить name после создания iframe\n  // поэтому создаём через innerHTML\n  tmpElem.innerHTML = '<iframe name="'_GREEN + name + '"GREEN_ id="'_GREEN + name + '"GREEN_ src="'_GREEN + src + '"GREEN_ >'_GREEN ;\n  var iframe = tmpElem.firstChild;\n\n  if (!debug) {\n    iframe.style.display = 'none';\n  }\n\n  document.body.appendChild(iframe);\n\n  return iframe;\n}`</script></code-example><p>Ифрейм здесь добавляется к <code>document.body</code>. Конечно, вы можете исправить этот код и добавлять его в любое другое место документа.</p><p>Кстати, при вставке, если не указан <code>src</code>, тут же произойдёт событие <code>iframe.onload</code>. Пока обработчиков нет, поэтому оно будет проигнорировано.</p><h3><a name="10" href="#10">Функция postToIframe</a></h3><p>Функция <code>postToIframe(url, data, target)</code> отправляет POST-запрос в ифрейм с именем <code>target</code>, на адрес <code>url</code> с данными <code>data</code>.</p><p>Аргументы:</p><dl><dt><code>url</code></dt><dd>URL, на который отправлять запрос.</dd><dt><code>data</code></dt><dd>Объект содержит пары <code>ключ:значение</code> для полей формы. Значение будет приведено к строке.</dd><dt><code>target</code></dt><dd>Имя ифрейма, в который отправлять данные.</dd></dl><code-example><script>`// Например: postToIframe('/vote', {mark:5}, 'frame1')\n\nfunction postToIframe(url, data, target) {\n  var phonyForm = document.getElementById('phonyForm');\n  if (!phonyForm) {\n    // временную форму создаем, если нет\n    phonyForm = document.createElement("form");\n    phonyForm.id = 'phonyForm';\n    phonyForm.style.display = "none";\n    phonyForm.method = "POST";\n    document.body.appendChild(phonyForm);\n  }\n\n  phonyForm.action = url;\n  phonyForm.target = target;\n\n  // заполнить форму данными из объекта\n  var html = [];\n  for (var key in data) {\n    var value = String(data[key]).replace(/"/g, "&quot;");\n    // в старых IE нельзя указать name после создания input\n    // поэтому используем innerHTML вместо DOM-методов\n    html.push("<input type='hidden' name=\""_GREEN  + key + "GREEN_\" value=\""_GREEN  + value + "GREEN_\">"_GREEN );\n  }\n  phonyForm.innerHTML = html.join('');\n\n  phonyForm.submit();\n}`</script></code-example><p>Эта функция формирует форму динамически, но, конечно, это лишь один из возможных сценариев использования.</p><p>В <code>IFRAME</code> можно отправлять и существующую форму, включающую файловые и другие поля.</p><h2><a name="1" href="#1">Запросы GET и POST</a></h2><p>Общий алгоритм обращения к серверу через ифрейм:</p><ol><li><p>Создаём <code>iframe</code> со случайным именем <code>iframeName</code>.</p></li><li><p>Создаём в основном окне объект <code>CallbackRegistry</code>, в котором в <code>CallbackRegistry[iframeName]</code> сохраняем функцию, которая будет обрабатывать результат.</p></li><li><p>Отправляем GET или POST-запрос в него.</p></li><li><p>Сервер отвечает как-то так:</p><code-example><script>`<script>\n  parent.CallbackRegistry[window.name]({данные});\n<\/script>`</script></code-example><p>…То есть, вызывает из основного окна функцию обработки (<code>window.name</code> в ифрейме – его имя).</p></li><li><p>Дополнительно нужен обработчик <code>iframe.onload</code> – он сработает и проверит, выполнилась ли функция <code>CallbackRegistry[window.name]</code>. Если нет, значит какая-то ошибка. Сервер при нормальном потоке выполнения всегда отвечает её вызовом.</p></li></ol><p>Подробнее можно понять процесс, взглянув на код.</p><p>Мы будем использовать в нём две функции – одну для GET, другую – для POST:</p><ul><li><code>iframeGet(url, onSuccess, onError)</code> – для GET-запросов на <code>url</code>. При успешном запросе вызывается <code>onSuccess(result)</code>, при неуспешном: <code>onError()</code>.</li><li><code>iframePost(url, data, onSuccess, onError)</code> – для POST-запросов на <code>url</code>. Значением <code>data</code> должен быть объект <code>ключ:значение</code> для пересылаемых данных, он конвертируется в поля формы.</li></ul><p>Пример в действии, возвращающий дату сервера при GET и разницу между датами клиента и сервера при POST:</p><code-tabs data-code_switch=""><tools-><code-download><a-></a-><a href="https://learn.javascript.ru/tutorial/zipview/date.zip?plunkId=fLo9KSkLpQTrERq4CCbr" hover-style="" target="_blank" title="скачать архив"></a></code-download><button-0 class="current">index.html</button-0><button-1>iframe.js</button-1><button-2>server.js</button-2></tools-><code-example style="display: block;"><script>`<!DOCTYPE html>\n<html>\n\n<body>\n\n  <script src="iframe.js"><\/script>\n\n  <script>\n    function ok(result) {\n      alert('result:&nbsp' + result);\n    }\n\n    function fail() {\n      alert('fail');\n    }\n  <\/script>\n\n  <button onclick="iframeGet('server', ok, fail)">iframeGet server</button>\n\n  <button onclick="iframePost('diff', {clientDate: +new Date}, ok, fail)">iframePost diff</button>\n\n</body>\n\n</html>`</script><code-toolbar- iframe="80"><a title="показать" data-code_run="220"></a><a title="открыть в новом окне" data-new_window="code"></a><a-></a-></code-toolbar-></code-example><code-example><script>`function createIframe(name, src, debug) {\n  src = src || 'javascript:false'; // пустой src\n\n  var tmpElem = document.createElement('div');\n\n  // в старых IE нельзя присвоить name после создания iframe, поэтому создаём через innerHTML\n  tmpElem.innerHTML = '<iframe name="'_GREEN + name + 'GREEN_" id="'_GREEN + name + 'GREEN_" src="'_GREEN + src + 'GREEN_">'_GREEN;\n  var iframe = tmpElem.firstChild;\n\n  if (!debug) {\n    iframe.style.display = 'none';\n  }\n\n  document.body.appendChild(iframe);\n\n  return iframe;\n}\n\n// функция постит объект-хэш content в виде формы с нужным url , target\n// напр. postToIframe('/count.php', {a:5,b:6}, 'frame1')\n\nfunction postToIframe(url, data, target) {\n  var phonyForm = document.getElementById('phonyForm');\n  if (!phonyForm) {\n    // временную форму создаем, если нет\n    phonyForm = document.createElement("form");\n    phonyForm.id = 'phonyForm';\n    phonyForm.style.display = "none";\n    phonyForm.method = "POST";\n    phonyForm.enctype = "multipart/form-data";\n    document.body.appendChild(phonyForm);\n  }\n\n  phonyForm.action = url;\n  phonyForm.target = target;\n\n  // заполнить форму данными из объекта\n  var html = [];\n  for (var key in data) {\n    var value = String(data[key]).replace(GOLD_/"/g_GOLD, "&ampquot;");\n    html.push("<input type='hidden' name=\""_GREEN + key + "GREEN_\" value=\""_GREEN + value + "GREEN_\">"_GREEN);\n  }\n  phonyForm.innerHTML = html.join('');\n\n  phonyForm.submit();\n}\n\n\nvar CallbackRegistry&nbsp= {}; // реестр\n\nfunction iframeGet(url, onSuccess, onError) {\n\n  var iframeOk = false; // флаг успешного ответа сервера\n\n  var iframeName = Math.random(); // случайное имя для ифрейма\n  var iframe = createIframe(iframeName, url);\n\n  CallbackRegistry[iframeName] = function(data) {\n    iframeOk = true; // сервер ответил успешно\n    onSuccess(data);\n  }\n\n  iframe.onload = function() {\n    iframe.parentNode.removeChild(iframe); // очистка\n    delete CallbackRegistry[iframeName];\n    if (!iframeOk) onError(); // если сервер не ответил как надо - что-то не так\n  }\n\n}\n\n// аналогично iframeGet, но в postToIframe передаются данные data\nfunction iframePost(url, data, onSuccess, onError) {\n\n  var iframeOk = false;\n\n  var iframeName = Math.random();\n  var iframe = createIframe(iframeName);\n\n  CallbackRegistry[iframeName] = function(data) {\n    iframeOk = true;\n    onSuccess(data);\n  }\n\n  iframe.onload = function() {\n    iframe.parentNode.removeChild(iframe); // очистка\n    delete CallbackRegistry[iframeName];\n\n    if (!iframeOk) onError(); // если коллбэк не вызвался - что-то не так\n  }\n\n  postToIframe(url, data, iframeName);\n}`</script><code-toolbar-><a title="посмотреть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><code-example><script>`var http = require('http');\nvar url = require('url');\nvar static = require('node-static');\nvar file = new static.Server('.', {\n  cache: 0\n});\nvar multiparty = require('multiparty');\n\nfunction accept(req, res) {\n\n  var urlParsed = url.parse(req.url, true);\n  res.setHeader('Cache-Control', 'no-cache');\n\n  if (urlParsed.pathname == '/server') {\n    res.end(wrap(new Date()));\n    return;\n  } else if (urlParsed.pathname == '/diff') {\n\n    var form = new multiparty.Form();\n    form.parse(req, function(err, fields, files) {\n      var diff = new Date() - fields.clientDate[0];\n      res.end(wrap(diff));\n    });\n\n  } else {\n    file.serve(req, res);\n  }\n\n}\n\nfunction wrap(data) {\n  return '<script>parent.CallbackRegistry[window.name](&nbsp' + JSON.stringify(data) + ' )<\/script>';\n}\n\n\n// ------ запустить сервер -------\n\nif (!module.parent) {\n  http.createServer(accept).listen(8080);\n} else {\n  exports.accept = accept;\n}`</script><code-toolbar-><a title="посмотреть в песочнице" data-code_edit=""></a></code-toolbar-></code-example></code-tabs><p>Прямой вызов функции внешнего окна из ифрейма отлично работает, потому что они с одного домена. Если с разных, то нужны дополнительные действия, например:</p><ul><li><p>В IE8+ есть интерфейс <a href="https://developer.mozilla.org/en-US/docs/DOM/window.postMessage">postMessage</a> для общения между окнами с разных доменов.</p></li><li><p>В любых, даже самых старых IE, можно обмениваться данными через <code>window.name</code>. Эта переменная хранит «имя» окна или фрейма, которое не меняется при перезагрузке страницы.</p><p>Поэтому если мы сделали <code>POST</code> в <code>&lt;iframe&gt;</code> на другой домен и он поставил <code>window.name = "Вася"</code>, а затем сделал редирект на основной домен, то эти данные станут доступны внешней странице.</p></li><li><p>Также в совсем старых IE можно обмениваться данными через хеш, то есть фрагмент URL после <code>#</code>. Его изменение доступно между ифреймами с разных доменов и не приводит к перезагрузке страницы. Таким образом они могут передавать данные друг другу. Есть готовые библиотеки, которые реализуют этот подход, например <a href="http://ternarylabs.github.io/porthole/">Porthole</a>.</p></li></ul><h2><a name="2" href="#2">IFRAME для COMET</a></h2><p>Бесконечный IFRAME – самый старый способ организации COMET. Когда-то он был основой AJAX-приложений, а сейчас – используется лишь в случаях, когда браузер не поддерживает современный стандарт WebSocket, то есть для IE9-.</p><p>Этот способ основан на том, что браузер читает страницу последовательно и обрабатывает все новые теги по мере того, как сервер их присылает.</p><p>Классическая реализация – это когда клиент создает невидимый IFRAME, ведущий на служебный URL. Сервер, получив соединение на этот URL, не закрывает его, авремя от времени присылает блоки сообщений <code>&lt;script&gt;…javascript…&lt;/script&gt;</code>. Появившийся в IFRAME’е javascript тут же выполняется браузером, передавая информацию на основную страницу.</p><p>Таким образом, для передачи данных используется «бесконечный» ифрейм, через который сервер присылает все новые данные.</p><p>Схема работы:</p><ol><li>Создаётся <code>&lt;iframe src="COMET_URL"&gt;</code>, по адресу <code>COMET_URL</code> расположен сервер.</li><li>Сервер выдаёт начало («шапку») документа и останавливается, оставляя соединение активным.</li><li>Когда сервер хочет что-то отправить – он пишет в соединение <code>&lt;script&gt;parent.onMessage(сообщение)&lt;/script&gt;</code> Браузер тут же выполняет этот скрипт – так сообщение приходит на клиент.</li><li>Ифрейм, в теории, грузится бесконечно. Его завершение означает обрыв канала связи. Его можно поймать по <code>iframe.onload</code> и заново открыть соединение (создать новый <code>iframe</code>).</li></ol><p>Также ифрейм можно пересоздавать время от времени, для очистки памяти от старых сообщений.</p><figure><img src="comet.png" alt="" width="100%" style="max-width:492px"></figure><p>Ифрейм при этом работает только на получение данных с сервера, как альтернатива <a data-load_page="171">Server Sent Events</a>. Для запросов используется обычный <code>XMLHttpRequest</code>.</p><h2><a name="3" href="#3">Обход проблем с IE</a></h2><p>Такое использование ифреймов является хаком. Поэтому есть ряд проблем:</p><ol><li>Показывается индикатор загрузки, «курсор-часики».</li><li>При POST в <code>&lt;iframe&gt;</code> раздаётся звук «клика».</li><li>Браузер буферизует начало страницы.</li></ol><p>Мы должны эти проблемы решить, прежде всего, в IE, поскольку в других браузерах есть <a data-load_page="169">WebSocket</a> и <a data-load_page="171">Server Sent Events</a> .</p><p>Проще всего решить последнюю – IE не начинает обработку страницы, пока она не загрузится до определенного размера.</p><p>Поэтому в таком <code>IFRAME</code> первые несколько сообщений задержатся:</p><code-example><script>`<!DOCTYPE HTML>\n<html>\n  <body>\n  <script>parent.onMessage("привет");<\/script>\n  <script>parent.onMessage("от сервера");<\/script>\n  ...`</script></code-example><p>Решение – забить начало ифрейма чем-нибудь, поставить, например, килобайт пробелов в начале:</p><code-example><script>`<!DOCTYPE HTML>\n<html>\n\n<body>\n  ******* 1 килобайт пробелов, а потом уже сообщения ******\n  <script>\n    parent.onMessage("привет");\n  <\/script>\n  <script>\n    parent.onMessage("от сервера");\n  <\/script>\n  ...`</script></code-example><p>Для решения проблемы с индикацией загрузки и клика мы можем использовать безопасный ActiveX-объект <code>htmlfile</code>. IE не требует разрешений на его создание. Фактически, это независимый HTML-документ.</p><p>Оказывается, если <code>iframe</code> создать в нём, то никакой анимации и звуков не будет.</p><p>Итак, схема:</p><ol><li>Основное окно <code>main</code> создаёт вспомогательный объект: <code>new ActiveXObject("htmlfile")</code>. Это HTML-документ со своим <code>window</code>, похоже на встроенный <code>iframe</code>.</li><li>В <code>htmlfile</code> записывается <code>iframe</code>.</li><li>Цепочка общения: основное окно – <code>htmlfile</code> – ифрейм.</li></ol><h3><a name="11" href="#11">iframeActiveXGet</a></h3><p>На самом деле всё еще проще, если посмотреть на код:</p><p>Метод <code>iframeActiveXGet</code> по существу идентичен обычному <code>iframeGet</code>, которое мы рассмотрели. Единственное отличие – вместо <code>createIframe</code> используется особый метод <code>createActiveXFrame</code>:</p><code-example><script>`function iframeActiveXGet(url, onSuccess, onError) {\n\n  var iframeOk = false;\n\n  var iframeName = Math.random();\nMARK  var iframe = createActiveXFrame(iframeName, url);\n\n  CallbackRegistry[iframeName] = function(data) {\n    iframeOk = true;\n    onSuccess(data);\n  }\n\n  iframe.onload = function() {\n    iframe.parentNode.removeChild(iframe); // очистка\n    delete CallbackRegistry[iframeName];\n    if (!iframeOk) onError(); // если коллбэк не вызвался - что-то не так\n  }\n\n}`</script></code-example><h3><a name="12" href="#12">createActiveXFrame</a></h3><p>В этой функции творится вся IE-магия:</p><code-example><script>`function createActiveXFrame(name, src) {\n  // (1)\n  var htmlfile = window.htmlfile;\n  if (!htmlfile) {\n    htmlfile = window.htmlfile = new ActiveXObject("htmlfile");\n    htmlfile.open();\n    // (2)\n    htmlfile.write("<html><body></body></html>");\n    htmlfile.close();\n    // (3)\n    htmlfile.parentWindow.CallbackRegistry = CallbackRegistry;\n  }\n\n  // (4)\n  src = src || 'javascript:false';\n  htmlfile.body.insertAdjacentHTML('beforeEnd',\n    "<iframe name='"_GREEN + name + "GREEN_' src='"_GREEN + src + "GREEN_'></iframe>"_GREEN);\n  return htmlfile.body.lastChild;\n}`</script></code-example><ol><li><p>Вспомогательный объект <code>htmlfile</code> будет один и он будет глобальным. Можно и спрятать переменную в замыкании. Смысл в том, что в один <code>htmlfile</code> можно записать много ифреймов, так что не будем множить сущности и занимать ими лишнюю память.</p></li><li><p>В <code>htmlfile</code> можно записать любой текст и, при необходимости, через <code>document.write('&lt;script&gt;...&lt;\/script&gt;)</code>. Здесь мы делаем пустой документ.</p></li><li><p>Когда загрузится <code>iframe</code>, он сделает вызов:</p><code-example><script>`<script>\n  parent.CallbackRegistry[window.name](объект с данными);\n<\/script>`</script></code-example><p>Здесь <code>parent'ом</code> для <code>iframe'а</code> будет <code>htmlfile</code>, т.е. <code>CallbackRegistry</code> будет искаться среди переменных соответствующего ему окна, а вовсе не верхнего <code>window</code>.</p><p>Окно для <code>htmlfile</code> доступно как <code>htmlfile.parentWindow</code>, копируем в него ссылку на реестр коллбэков <code>CallbackRegistry</code>. Теперь ифрейм его найдёт.</p></li><li><p>Далее вставляем ифрейм в документ. В старых <code>IE</code> нельзя поменять <code>name</code> ифрейму через DOM, поэтому вставляем строкой через <code>insertAdjacentHTML</code>.</p></li></ol><p>Пример в действии (только IE):</p><code-tabs data-code_switch=""><tools-><code-download><a-></a-><a href="https://learn.javascript.ru/tutorial/zipview/date-activex.zip?plunkId=jQmIG89jlbGKoQftRmHU" hover-style="" target="_blank" title="скачать архив"></a></code-download><button-0 class="current">index.html</button-0><button-1>activex.js</button-1><button-2>server.js</button-2></tools-><code-example style="display: block;"><script>`<!DOCTYPE html>\n<html>\n\n<body>\n\n  <script src="activex.js"><\/script>\n\n  <script>\n    function ok(result) {\n      alert('result:&nbsp' + result);\n    }\n\n    function fail() {\n      alert('fail');\n    }\n\n    function go() {\n      if (!("ActiveXObject" in window)) {\n        alert("Только Internet Explorer");\n        return;\n      }\n      iframeActiveXGet("server", ok, fail);\n    }\n  <\/script>\n\n  <button onclick="go()">iframeActiveXGet server date</button>\n\n</body>\n\n</html>`</script><code-toolbar- iframe="80"><a title="показать" data-code_run="220"></a><a title="открыть в новом окне" data-new_window="code"></a><a-></a-></code-toolbar-></code-example><code-example><script>`var CallbackRegistry&nbsp= {}; // реестр\n\nfunction iframeActiveXGet(url, onSuccess, onError) {\n\n  var iframeOk = false;\n\n  var iframeName = Math.random();\n  var iframe = createActiveXFrame(iframeName, url);\n\n  CallbackRegistry[iframeName] = function(data) {\n    iframeOk = true;\n    onSuccess(data);\n  }\n\n  iframe.onload = function() {\n    iframe.parentNode.removeChild(iframe); // очистка\n    delete CallbackRegistry[iframeName];\n    if (!iframeOk) onError(); // если коллбэк не вызвался - что-то не так\n  }\n\n}\n\n\nfunction createActiveXFrame(name, src) {\n  var htmlfile = window.htmlfile;\n  if (!htmlfile) {\n    htmlfile = window.htmlfile = new ActiveXObject("htmlfile");\n    htmlfile.open();\n    htmlfile.write("<html><body></body></html>");\n    htmlfile.close();\n    htmlfile.parentWindow.CallbackRegistry&nbsp= CallbackRegistry;\n  }\n\n  src = src || 'javascript:false'; // пустой src  \n  htmlfile.body.insertAdjacentHTML('beforeEnd', "<iframe name='"_GREEN + name + "GREEN_' src='"_GREEN + src + "GREEN_'></iframe>"_GREEN);\n  return htmlfile.body.lastChild; // window in .document.parentWindow\n}`</script><code-toolbar-><a title="посмотреть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><code-example><script>`var http = require('http');\nvar url = require('url');\nvar static = require('node-static');\nvar file = new static.Server('.', {\n  cache: 0\n});\nvar multiparty = require('multiparty');\n\nfunction accept(req, res) {\n\n  var urlParsed = url.parse(req.url, true);\n  res.setHeader('Cache-Control', 'no-cache');\n\n  if (urlParsed.pathname == '/server') {\n    res.end(wrap(new Date()));\n    return;\n  } else if (urlParsed.pathname == '/diff') {\n\n    var form = new multiparty.Form();\n    form.parse(req, function(err, fields, files) {\n      var diff = new Date() - fields.clientDate[0];\n      res.end(wrap(diff));\n    });\n\n  } else {\n    file.serve(req, res);\n  }\n\n}\n\nfunction wrap(data) {\n  return '<script>parent.CallbackRegistry[window.name](&nbsp' + JSON.stringify(data) + ' )<\/script>';\n}\n\n\n// ------ запустить сервер -------\n\nif (!module.parent) {\n  http.createServer(accept).listen(8080);\n} else {\n  exports.accept = accept;\n}`</script><code-toolbar-><a title="посмотреть в песочнице" data-code_edit=""></a></code-toolbar-></code-example></code-tabs><p>Запрос, который происходит, полностью незаметен.</p><p>Метод POST делается аналогично, только форму нужно добавлять не в основное окно, а в <code>htmlfile</code>, через вызов <code>htmlfile.appendChild</code>. В остальном – всё так же, как и при обычной отправке через ифрейм.</p><p>Впрочем, для COMET нужен именно GET.</p><p>Можно и сочетать эти способы: если есть ActiveX: <code>if ("ActiveXObject" in window)</code> – используем методы для IE, описанные выше, а иначе – обычные методы.</p><p>Вот мини-приложение с сервером на Node.JS, непрерывно получающее текущее время с сервера через <code>&lt;iframe&gt;</code>, сочетающее эти подходы:</p><code-tabs data-code_switch=""><tools-><code-download><a-></a-><a href="https://learn.javascript.ru/tutorial/zipview/date-comet.zip?plunkId=yw5lT6Zc2mJ4F85mVAfl" hover-style="" target="_blank" title="скачать архив"></a></code-download><button-0 class="current">index.html</button-0><button-1>iframeComet.js</button-1><button-2>server.js</button-2></tools-><code-example style="display: block;"><script>`<!DOCTYPE html>\n<html>\n\n<body>\n\n  <script src="iframeComet.js"><\/script>\n\n  <button onclick="go()">IframeComet.open("comet");</button>\n\n  <div id="showElem"></div>\n\n  <script>\n    IframeComet.onMessage = IframeComet.onError = show;\n\n    function show(msg) {\n      showElem.innerHTML = msg;\n    }\n\n    function go() {\n      IframeComet.open("comet");\n    }\n  <\/script>\n\n</body>\n\n</html>`</script><code-toolbar- iframe="80"><a title="показать" data-code_run="220"></a><a title="открыть в новом окне" data-new_window="code"></a><a-></a-></code-toolbar-></code-example><code-example><script>`var IframeComet = new function() {\n  var self = this;\n\n  var connectTries = 0,\n    reconnectTimer;\n  var htmlfile; // for ie only\n  var iframe;\n\n  this.onConnected = function() {\n    connectTries = 0;\n    clearTimeout(reconnectTimer);\n  };\n\n  this.onMessage = function(message) { /* ... */ };\n\n  this.onError = function(err) { /* ... */ };\n\n  this.open = function(url) {\n    connectTries++;\n\n    if (connectTries > 3) {\n      self.onError("Unable to connect");\n    }\n\n    if ("ActiveXObject" in window) { // IE\n      createActiveXFrame(url);\n    } else {\n      createIframe(url);\n    }\n\n    reconnectTimer = setTimeout(function() {\n      if (!self.isConnected()) {\n        self.open(url);\n      }\n    }, connectTries * 2000);\n\n    // в Chrome не срабатывает при обрыве соединения,\n    // так что используем там другой =) транспорт\n    iframe.onload = function() {\n      self.open(url);\n    };\n\n  };\n\n  this.isConnected = function() {\n    return connectTries == 0; // onConnect обнуляет connectTries\n  }\n\n  function cleanIframe() {\n    if (iframe) {\n      iframe.src = "javascript:false";\n      iframe.parentNode.removeChild(iframe); // очистка\n    }\n  }\n\n  function createIframe(src) {\n    cleanIframe();\n\n    iframe = document.createElement('iframe');\n    iframe.src = src || 'javascript:false';\n    iframe.style.display = 'none';\n\n    document.body.appendChild(iframe);\n  }\n\n\n  function createActiveXFrame(src) {\n    cleanIframe();\n\n    if (!htmlfile) {\n      htmlfile = new ActiveXObject("htmlfile");\n      htmlfile.open();\n      htmlfile.write("<html><body></body></html>");\n      htmlfile.close();\n      htmlfile.parentWindow.IframeComet = self;\n    }\n\n    src = src || 'javascript:false'; // пустой src  \n    htmlfile.body.insertAdjacentHTML('beforeEnd', "<iframe src='"_GREEN + src + "GREEN_'></iframe>"_GREEN);\n    iframe = htmlfile.body.lastChild; // window in .document.parentWindow\n  }\n\n}`</script><code-toolbar-><a title="посмотреть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><code-example><script>`var http = require('http');\nvar url = require('url');\nvar static = require('node-static');\nvar file = new static.Server('.', {\n  cache: 0\n});\n\n\nfunction accept(req, res) {\n\n  if (req.url == '/comet') {\n    res.writeHead(200, {\n      'Content-Type': 'text/html; charset=utf-8'\n    });\n\n    res.write('<!DOCTYPE HTML><html> \\\n   &nbsp   &nbsp   GREEN_<head><meta junk="'_GREEN + new Array(2000).join('*') + 'GREEN_"/> \\_GREEN\n   &nbsp   &nbsp   GREEN_<script> \\_GREEN\n   &nbsp   &nbsp   &nbsp GREEN_var i = parent.IframeComet; \\_GREEN\n   &nbsp   &nbsp   &nbsp GREEN_i.onConnected()<\/script> \\_GREEN\n   &nbsp   &nbsp   GREEN_</head><body>');\n\n    setInterval(function() {\n      var now = new Date();\n      var timeStr = now.getHours() + ':'_GREEN + now.getMinutes() + ':'_GREEN + now.getSeconds();\n      res.write('<script>i.onMessage("'_GREEN + timeStr + 'GREEN_")<\/script>'_GREEN);\n    }, 1000);\n\n    return;\n  } else {\n    file.serve(req, res);\n  }\n\n}\n\n\n// ------ запустить сервер -------\n\nif (!module.parent) {\n  http.createServer(accept).listen(8080);\n} else {\n  exports.accept = accept;\n}`</script><code-toolbar-><a title="посмотреть в песочнице" data-code_edit=""></a></code-toolbar-></code-example></code-tabs><p>Ещё раз заметим, что обычно такое сочетание не нужно, так как если не IE9-, то можно использовать более современные средства для COMET.</p><h2><a name="4" href="#4">Итого</a></h2><ul><li>Iframe позволяет делать «AJAX»-запросы и хитро обходить кросс-доменные ограничения в IE7-. Обычно для этого используют либо <code>window.name</code> с редиректом, либо хеш с библиотекой типа <a href="https://github.com/ternarylabs/porthole">Porthole</a>.</li><li>В IE9- iframe можно использовать для COMET. В IE10 уже есть WebSocket.</li></ul><p>Существует ряд уже готовых клиент-серверных библиотек, которые реализуют AJAX/COMET, в том числе и через iframe, мы рассмотрим их позже. Поэтому совсем не обязательно делать «с нуля». Хотя, как можно видеть из главы, это совсем несложно.</p><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Server Side Events -- события с сервера; Атака CSRF"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/ajax-iframe",disqus_identifier="ajax-iframe",disqus_title="IFRAME \u0434\u043b\u044f AJAX \u0438 COMET";</script></page-content></main>