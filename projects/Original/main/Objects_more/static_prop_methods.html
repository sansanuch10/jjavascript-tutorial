<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="54">Методы объектов и контекст вызова</a></nav-up><h1>Статические и фабричные методы</h1><p>Методы и свойства, которые не привязаны к конкретному экземпляру объекта, называют «статическими». Их записывают прямо в саму функцию-конструктор.</p><h2><a name="0" href="#0">Статические свойства</a></h2><p>В коде ниже используются статические свойства <code>Article.count</code> и <code>Article.DEFAULT_FORMAT</code>:</p><code-example><script>`function Article() {\n  Article.count++;\n}\n\nArticle.count = 0; // статическое свойство-переменная\nArticle.DEFAULT_FORMAT = "html"; // статическое свойство-константа`</script></code-example><p>Они хранят данные, специфичные не для одного объекта, а для всех статей целиком.</p><p>Как правило, это чаще константы, такие как формат «по умолчанию» <code>Article.DEFAULT_FORMAT</code>.</p><h2><a name="1" href="#1">Статические методы</a></h2><p>С примерами статических методов мы уже знакомы: это встроенные методы <a href="http://javascript.ru/String.fromCharCode">String.fromCharCode</a>, <a href="http://javascript.ru/Date.parse">Date.parse</a>.</p><p>Создадим для <code>Article</code> статический метод <code>Article.showCount()</code>:</p><code-example><script>`function Article() {\n  Article.count++;\n\n  //...\n}\n\nArticle.count = 0;\n\nArticle.showCount = function() {\nMARK  alert( this.count ); // (1)\n}\n\n// использование\nnew Article();\nnew Article();\nArticle.showCount(); // (2)`</script><code-toolbar></code-toolbar></code-example><p>Здесь <code>Article.count</code> – статическое свойство, а <code>Article.showCount</code> – статический метод.</p><p>Обратим внимание на использование <code>this</code> в примере выше. Несмотря на то, что переменная и метод – статические, он всё ещё полезен. В строке <code>(1)</code> он равен <code>Article</code>.</p><h2><a name="2" href="#2">Пример: сравнение объектов</a></h2><p>Ещё один хороший способ применения – сравнение объектов.</p><p>Например, у нас есть объект <code>Journal</code> для журналов. Журналы можно сравнивать – по толщине, по весу, по другим параметрам.</p><p>Объявим «стандартную» функцию сравнения, которая будет сравнивать по дате издания. Эта функция сравнения, естественно, не привязана к конкретному журналу, но относится к журналам вообще.</p><p>Поэтому зададим её как статический метод <code>Journal.compare</code>:</p><code-example><script>`function Journal(date) {\n  this.date = date;\n  // ...\n}\n\n// возвращает значение, большее 0, если A больше B, иначе меньшее 0\nJournal.compare = function(journalA, journalB) {\n  return journalA.date - journalB.date;\n};`</script></code-example><p>В примере ниже эта функция используется для поиска самого раннего журнала из массива:</p><code-example><script>`function Journal(date) {\  this.date = date;\n\n  this.formatDate = function(date) {\n    return date.getDate() + '.' + (date.getMonth() + 1) + '.' + date.getFullYear();\n  };\n\n  this.getTitle = function() {\n    return \"Выпуск от&nbsp\" + this.formatDate(this.date);\n  };\n\n}\n\nMARKJournal.compare = function(journalA, journalB) {\nMARK  return journalA.date - journalB.date;\nMARK};\n\n// использование:\nvar journals = [\n  new Journal(new Date(2012, 1, 1)),\n  new Journal(new Date(2012, 0, 1)),\n  new Journal(new Date(2011, 11, 1))\n];\n\nfunction findMin(journals) {\n  var min = 0;\n  for (var i = 0; i < journals.length; i++) {\nMARK    // используем статический метод\nMARK    if (Journal.compare(journals[min], journals[i]) > 0) min = i;\n  }\n  return journals[min];\n}\n\nalert( findMin(journals).getTitle() );`</script><code-toolbar></code-toolbar></code-example><p><strong>Статический метод также можно использовать для функций, которые вообще не требуют наличия объекта.</strong></p><p>Например, метод <code>formatDate(date)</code> можно сделать статическим. Он будет форматировать дату «как это принято в журналах», при этом его можно использовать в любом месте кода, не обязательно создавать журнал.</p><p>Например:</p><code-example><script>`function Journal() { /*...*/ }\n\nJournal.formatDate = function(date) {\n  return date.getDate() + '.' + (date.getMonth()+1) + '.' + date.getFullYear();\n}\n\n// ни одного объекта Journal нет, просто форматируем дату\nalert( HIGHJournal.formatDate(new Date)LIGHT );`</script><code-toolbar></code-toolbar></code-example><h2><a name="3" href="#3">Фабричные методы</a></h2><p>Рассмотрим ситуацию, когда объект нужно создавать различными способами. Например, это реализовано во встроенном объекте <a href="/datetime">Date</a>. Он по-разному обрабатывает аргументы разных типов:</p><ul><li><code>new Date()</code> – создаёт объект с текущей датой,</li><li><code>new Date(milliseconds)</code> – создаёт дату по количеству миллисекунд <code>milliseconds</code>,</li><li><code>new Date(year, month, day ...)</code> – создаёт дату по компонентам год, месяц, день…</li><li><code>new Date(datestring)</code> – читает дату из строки <code>datestring</code></li></ul><p><strong>"Фабричный статический метод" – удобная альтернатива такому конструктору. Так называется статический метод, который служит для создания новых объектов (поэтому и называется «фабричным»).</strong></p><p>Пример встроенного фабричного метода – <a href="http://javascript.ru/String.fromCharCode">String.fromCharCode(code)</a>. Этот метод создает строку из кода символа:</p><code-example><script>`var str = String.fromCharCode(65);\nalert( str ); // 'A'`</script><code-toolbar></code-toolbar></code-example><p>Но строки – слишком простой пример, посмотрим что-нибудь посложнее.</p><p>Допустим, нам нужно создавать объекты <code>User</code>: анонимные <code>new User()</code> и с данными <code>new User({name: 'Вася', age: 25})</code>.</p><p>Можно, конечно, создать полиморфную функцию-конструктор <code>User</code>:</p><code-example><script>`function User(userData) {\n  if (userData) { // если указаны данные -- одна ветка if\n    this.name = userData.name;\n    this.age = userData.age;\n  } else { // если не указаны -- другая\n    this.name = 'Аноним';\n  }\n\n  this.sayHi = function() {\n    alert(this.name)\n  };\n  // ...\n}\n\n// Использование\n\nvar guest = new User();\nguest.sayHi(); // Аноним\n\nvar knownUser = new User({\n  name: 'Вася',\n  age: 25\n});\nknownUser.sayHi(); // Вася`</script><code-toolbar></code-toolbar></code-example><p>Подход с использованием фабричных методов был бы другим. Вместо разбора параметров в конструкторе – делаем два метода: <code>User.createAnonymous</code> и <code>User.createFromData</code>.</p><p>Код:</p><code-example><script>`function User() {\n  this.sayHi = function() {\n    alert(this.name)\n  };\n}\n\nUser.createAnonymous = function() {\n  var user = new User;\n  user.name = 'Аноним';\n  return user;\n}\n\nUser.createFromData = function(userData) {\n  var user = new User;\n  user.name = userData.name;\n  user.age = userData.age;\n  return user;\n}\n\n// Использование\n\nMARKvar guest = User.createAnonymous();\nMARKguest.sayHi(); // Аноним\nMARK&nbsp\nMARKvar knownUser = User.createFromData({\nMARK  name: 'Вася',\nMARK  age: 25\nMARK});\nMARKknownUser.sayHi(); // Вася`</script><code-toolbar></code-toolbar></code-example><p>Преимущества использования фабричных методов:</p><div class="balance balance_single"><div class="balance__pluses"><div class="balance__content"><ul class="balance__list"><li>Лучшая читаемость кода. Как конструктора – вместо одной большой функции несколько маленьких, так и вызывающего кода – явно видно, что именно создаётся.</li><li>Лучший контроль ошибок, т.к. если в <code>createFromData</code> ничего не передали, то будет ошибка, а полиморфный конструктор создал бы анонимного посетителя.</li><li>Удобная расширяемость. Например, нужно добавить создание администратора, без аргументов. Фабричный метод сделать легко: <code>User.createAdmin = function() { ... }</code>. А для полиморфного конструктора вызов без аргумента создаст анонима, так что нужно добавить параметр – «тип посетителя» и усложнить этим код.</li></ul></div></div></div><p><strong>Поэтому полиморфные конструкторы лучше использовать там, где нужен именно полиморфизм</strong>, т.е. когда непонятно, какого типа аргумент передадут, и хочется в одном конструкторе охватить все варианты.</p><p>А в остальных случаях отличная альтернатива – фабричные методы.</p><h2><a name="4" href="#4">Итого</a></h2><p>Статические свойства и методы объекта удобно применять в следующих случаях:</p><ul><li>Общие действия и подсчёты, имеющие отношения ко всем объектам данного типа. В примерах выше это подсчёт количества.</li><li>Методы, не привязанные к конкретному объекту, например сравнение.</li><li>Вспомогательные методы, которые полезны вне объекта, например для форматирования даты.</li><li>Фабричные методы.</li></ul><h2 id="tasks"><a href="#5" name="5">Задачи (1)</a></h2><task-content><h3><a href="#7" name="7">Счетчик объектов</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Добавить в конструктор <code>Article</code>:</p><ul><li>Подсчёт общего количества созданных объектов.</li><li>Запоминание даты последнего созданного объекта.</li></ul><p>Используйте для этого статические свойства.</p><p>Пусть вызов <code>Article.showStats()</code> выводит то и другое.</p><p>Использование:</p><code-example><script>`function Article() {\n  this.created = new Date();\nMARK  // ... ваш код ...\n}\n\nnew Article();\nnew Article();\n\nArticle.showStats(); // Всего: 2, Последняя: (дата)\n\nnew Article();\n\nArticle.showStats(); // Всего: 3, Последняя: (дата)`</script></code-example><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script src="` + window.location.toString().split('#')[0] + `sinon.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    // ...Ваш код...\n\n  <\/script>\n  <script>\n    describe("Article.showStats", function() {\n      before(function() {\n        sinon.stub(window, "alert");\n        this.clock = sinon.useFakeTimers();\n      });\n      after(function() {\n        window.alert.restore();\n        this.clock.restore();\n      });\n      it("Выводит число статей и дату создания последней", function() {\n        new Article();\n        this.clock.tick(100);\n        new Article();\n        Article.showStats();\n        assert(alert.calledWith('Всего: 2, Последняя: ' + new Date()));\n      });\n      it("и ещё одна статья...", function() {\n        this.clock.tick(100);\n        new Article();\n        Article.showStats();\n        assert(alert.calledWith('Всего: 3, Последняя: ' + new Date()));\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="task_1" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="task_1">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Решение (как вариант):</p><code-example><script>`function Article() {\n  this.created = new Date();\n\nMARK  Article.count++; // увеличиваем счетчик при каждом вызове\nMARK  Article.last = this.created; // и запоминаем дату\n}\nArticle.count = 0; // начальное значение\n// (нельзя оставить undefined, т.к. Article.count++ будет NaN)\n\nArticle.showStats = function() {\n  alert( 'Всего:&nbsp' + this.count + ', Последняя:&nbsp' + this.last );\n};\n\nnew Article();\nnew Article();\n\nArticle.showStats(); // Всего: 2, Последняя: (дата)\n\nnew Article();\n\nArticle.showStats(); // Всего: 3, Последняя: (дата)`</script><code-toolbar></code-toolbar></code-example><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script src="` + window.location.toString().split('#')[0] + `sinon.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    function Article() {\n      this.created = new Date;    \n      Article.count++; // увеличиваем счетчик при каждом вызове\n      Article.last = this.created; // и запоминаем дату\n    }\n    Article.count = 0; // начальное значение     \n    Article.showStats = function() {\n      alert('Всего: ' + this.count + ', Последняя: ' + this.last);\n    };\n\n  <\/script>\n  <script>\n    describe("Article.showStats", function() {\n      before(function() {\n        sinon.stub(window, "alert");\n        this.clock = sinon.useFakeTimers();\n      });\n      after(function() {\n        window.alert.restore();\n        this.clock.restore();\n      });\n      it("Выводит число статей и дату создания последней", function() {\n        new Article();\n        this.clock.tick(100);\n        new Article();\n        Article.showStats();\n        assert(alert.calledWith('Всего: 2, Последняя: ' + new Date()));\n      });\n      it("и ещё одна статья...", function() {\n        this.clock.tick(100);\n        new Article();\n        Article.showStats();\n        assert(alert.calledWith('Всего: 3, Последняя: ' + new Date()));\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="answer_1" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="answer_1">Открыть решение с тестами в песочнице.</a></p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Дескрипторы, геттеры и сеттеры свойств; Явное указание this: &quot;call&quot;, &quot;apply&quot;"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/static-properties-and-methods",disqus_identifier="static-properties-and-methods",disqus_title="\u0421\u0442\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u0438 \u0444\u0430\u0431\u0440\u0438\u0447\u043d\u044b\u0435 \u043c\u0435\u0442\u043e\u0434\u044b";</script></page-content></main>