<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="54">Методы объектов и контекст вызова</a></nav-up><h1>Привязка контекста и карринг: "bind"</h1><p>Функции в JavaScript никак не привязаны к своему контексту <code>this</code>, с одной стороны, здорово – это позволяет быть максимально гибкими, одалживать методы и так далее.</p><p>Но с другой стороны – в некоторых случаях контекст может быть потерян. То есть мы вроде как вызываем метод объекта, а на самом деле он получает <code>this = undefined</code>.</p><p>Такая ситуация является типичной для начинающих разработчиков, но бывает и у «зубров» тоже. Конечно, «зубры» при этом знают, что с ней делать.</p><h2><a name="0" href="#0">Пример потери контекста</a></h2><p>В браузере есть встроенная функция <code>setTimeout(func, ms)</code>, которая вызывает выполнение функции <code>func</code> через <code>ms</code> миллисекунд (=1/1000 секунды).</p><p>Мы подробно остановимся на ней и её тонкостях позже, в главе <a data-load_page="66">setTimeout и setInterval</a>, а пока просто посмотрим пример.</p><p>Этот код выведет «Привет» через 1000 мс, то есть 1 секунду:</p><code-example><script>`setTimeout(function() {\n  alert( "Привет" );\n}, 1000);`</script><code-toolbar></code-toolbar></code-example><p>Попробуем сделать то же самое с методом объекта, следующий код должен выводить имя пользователя через 1 секунду:</p><code-example><script>`var user = {\n  firstName: "Вася",\n  sayHi: function() {\n    alert( this.firstName );\n  }\n};\n\nMARKsetTimeout(user.sayHi, 1000); // undefined (не Вася!)`</script><code-toolbar></code-toolbar></code-example><p>При запуске кода выше через секунду выводится вовсе не <code>"Вася"</code>, а <code>undefined</code>!</p><p>Это произошло потому, что в примере выше <code>setTimeout</code> получил функцию <code>user.sayHi</code>, но не её контекст. То есть, последняя строчка аналогична двум таким:</p><code-example><script>`var f = user.sayHi;\nsetTimeout(f, 1000); // контекст user потеряли`</script></code-example><p>Ситуация довольно типична – мы хотим передать метод объекта куда-то в другое место кода, откуда он потом может быть вызван. Как бы прикрепить к нему контекст, желательно, с минимумом плясок с бубном и при этом надёжно?</p><p>Есть несколько способов решения, среди которых мы, в зависимости от ситуации, можем выбирать.</p><h2><a name="1" href="#1">Решение 1: сделать обёртку</a></h2><p>Самый простой вариант решения – это обернуть вызов в анонимную функцию:</p><code-example><script>`var user = {\n  firstName: "Вася",\n  sayHi: function() {\n    alert( this.firstName );\n  }\n};\n\nMARKsetTimeout(function() {\nMARK  user.sayHi(); // Вася\nMARK}, 1000);`</script><code-toolbar></code-toolbar></code-example><p>Теперь код работает, так как <code>user</code> достаётся из замыкания.</p><p>Это решение также позволяет передать дополнительные аргументы:</p><code-example><script>`var user = {\n  firstName: "Вася",\n  sayHi: function(who) {\n    alert( this.firstName + ": Привет,&nbsp" + who );\n  }\n};\n\nMARKsetTimeout(function() {\nMARK  user.sayHi("Петя"); // Вася: Привет, Петя\nMARK}, 1000);`</script><code-toolbar></code-toolbar></code-example><p>Но тут же появляется и уязвимое место в структуре кода!</p><p>А что, если до срабатывания <code>setTimeout</code> (ведь есть целая секунда) в переменную <code>user</code> будет записано другое значение? К примеру, в другом месте кода будет присвоено <code>user=(другой пользователь)</code>… В этом случае вызов неожиданно будет совсем не тот!</p><p>Хорошо бы гарантировать правильность контекста.</p><h2><a name="2" href="#2">Решение 2: bind для привязки контекста</a></h2><p>Напишем вспомогательную функцию <code>bind(func, context)</code>, которая будет жёстко фиксировать контекст для <code>func</code>:</p><code-example><script>`function bind(func, context) {\n  return function() { // (*)\n    return func.apply(context, arguments);\n  };\n}`</script></code-example><p>Посмотрим, что она делает, как работает, на таком примере:</p><code-example><script>`function f() {\n  alert( this );\n}\n\nvar g = bind(f, "Context");\ng(); // Context`</script></code-example><p>То есть, <code>bind(f, "Context")</code> привязывает <code>"Context"</code> в качестве <code>this</code> для <code>f</code>.</p><p>Посмотрим, за счёт чего это происходит.</p><p>Результатом <code>bind(f, "Context")</code>, как видно из кода, будет анонимная функция <code>(*)</code>.</p><p>Вот она отдельно:</p><code-example><script>`function() { // (*)\n  return func.apply(context, arguments);\n};`</script></code-example><p>Если подставить наши конкретные аргументы, то есть <code>f</code> и <code>"Context"</code>, то получится так:</p><code-example><script>`function() { // (*)\n  return f.apply("Context", arguments);\n};`</script></code-example><p>Эта функция запишется в переменную <code>g</code>.</p><p>Далее, если вызвать <code>g</code>, то вызов будет передан в <code>f</code>, причём <code>f.apply("Context", arguments)</code> передаст в качестве контекста <code>"Context"</code>, который и будет выведен.</p><p>Если вызвать <code>g</code> с аргументами, то также будет работать:</p><code-example><script>`function bind(func, context) {\n  return function() { // (*)\n    return func.apply(context, arguments);\n  };\n}\n\nfunction f(a, b) {\n  alert( this );\n  alert( a + b );\n}\n\nvar g = bind(f, "Context");\ng(1, 2); // Context, затем 3`</script><code-toolbar></code-toolbar></code-example><p>Аргументы, которые получила <code>g(...)</code>, передаются в <code>f</code> также благодаря методу <code>.apply</code>.</p><p><strong>Иными словами, в результате вызова <code>bind(func, context)</code> мы получаем «функцию-обёртку», которая прозрачно передаёт вызов в <code>func</code>, с теми же аргументами, но фиксированным контекстом <code>context</code>.</strong></p><p>Вернёмся к <code>user.sayHi</code>. Вариант с <code>bind</code>:</p><code-example><script>`function bind(func, context) {\n  return function() {\n    return func.apply(context, arguments);\n  };\n}\n\nvar user = {\n  firstName: "Вася",\n  sayHi: function() {\n    alert( this.firstName );\n  }\n};\n\nMARKsetTimeout(bind(user.sayHi, user), 1000);`</script><code-toolbar></code-toolbar></code-example><p>Теперь всё в порядке!</p><p>Вызов <code>bind(user.sayHi, user)</code> возвращает такую функцию-обёртку, которая привязывает <code>user.sayHi</code> к контексту <code>user</code>. Она будет вызвана через 1000 мс.</p><p>Полученную обёртку можно вызвать и с аргументами – они пойдут в <code>user.sayHi</code> без изменений, фиксирован лишь контекст.</p><code-example><script>`var user = {\n  firstName: "Вася",\nMARK  sayHi: function(who) { // здесь у sayHi есть один аргумент\n    alert( this.firstName + ": Привет,&nbsp" + who );\n  }\n};\n\nvar sayHi = bind(user.sayHi, user);\n\nMARK// контекст Вася, а аргумент передаётся "как есть"\nMARKsayHi("Петя"); // Вася: Привет, Петя\nMARKsayHi("Маша"); // Вася: Привет, Маша`</script><code-toolbar></code-toolbar></code-example><p>В примере выше продемонстрирована другая частая цель использования <code>bind</code> – «привязать» функцию к контексту, чтобы в дальнейшем «не таскать за собой» объект, а просто вызывать <code>sayHi</code>.</p><p>Результат <code>bind</code> можно передавать в любое место кода, вызывать как обычную функцию, он «помнит» свой контекст.</p><h2><a name="3" href="#3">Решение 3: встроенный метод bind</a></h2><p>В современном JavaScript (или при подключении библиотеки <a href="https://github.com/kriskowal/es5-shim">es5-shim</a> для IE8-) у функций уже есть встроенный метод <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">bind</a>, который мы можем использовать.</p><p>Он работает примерно так же, как <code>bind</code>, который описан выше.</p><p>Изменения очень небольшие:</p><code-example><script>`function f(a, b) {\n  alert( this );\n  alert( a + b );\n}\n\nMARK// вместо\nMARK// var g = bind(f, "Context");\nMARKvar g = f.bind("Context");\ng(1, 2); // Context, затем 3`</script><code-toolbar></code-toolbar></code-example><p>Синтаксис встроенного <code>bind</code>:</p><code-example><script>`var wrapper = func.bind(context[, arg1, arg2...])`</script></code-example><dl><dt><code>func</code></dt><dd>Произвольная функция</dd><dt><code>context</code></dt><dd>Контекст, который привязывается к <code>func</code></dd><dt><code>arg1</code>, <code>arg2</code>, …</dt><dd>Если указаны аргументы <code>arg1, arg2...</code> – они будут прибавлены к каждому вызову новой функции, причем встанут <em>перед</em> теми, которые указаны при вызове.</dd></dl><p>Результат вызова <code>func.bind(context)</code> аналогичен вызову <code>bind(func, context)</code>, описанному выше. То есть, <code>wrapper</code> – это обёртка, фиксирующая контекст и передающая вызовы в <code>func</code>. Также можно указать аргументы, тогда и они будут фиксированы, но об этом чуть позже.</p><p>Пример со встроенным методом <code>bind</code>:</p><code-example><script>`var user = {\n  firstName: "Вася",\n  sayHi: function() {\n    alert( this.firstName );\n  }\n};\n\nMARK//&nbspsetTimeout( bind(user.sayHi, user), 1000 );\nMARKsetTimeout(user.sayHi.bind(user), 1000); // аналог через встроенный метод`</script><code-toolbar></code-toolbar></code-example><p>Получили простой и надёжный способ привязать контекст, причём даже встроенный в JavaScript.</p><p>Далее мы будем использовать именно встроенный метод <code>bind</code>.</p><important-warn><h3>bind не похож на call/apply</h3><p>Методы <code>bind</code> и <code>call/apply</code> близки по синтаксису, но есть важнейшее отличие.</p><p>Методы <code>call/apply</code> вызывают функцию с заданным контекстом и аргументами.</p><p>А <code>bind</code> не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.</p></important-warn><important-><h3>Привязать всё: <code>bindAll</code></h3><p>Если у объекта много методов и мы планируем их активно передавать, то можно привязать контекст для них всех в цикле:</p><code-example><script>`for (var prop in user) {\n  if (typeof user[prop] == 'function') {\n    user[prop] = user[prop].bind(user);\n  }\n}`</script></code-example><p>В некоторых JS-фреймворках есть даже встроенные функции для этого, например <a href="http://lodash.com/docs#bindAll">_.bindAll(obj)</a>.</p></important-><h2><a name="4" href="#4">Карринг</a></h2><p>До этого мы говорили о привязке контекста. Теперь пойдём на шаг дальше. Привязывать можно не только контекст, но и аргументы. Используется это реже, но бывает полезно.</p><p><a href="http://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%80%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Карринг</a> (currying) или <em>каррирование</em> – термин <a href="http://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">функционального программирования</a>, который означает создание новой функции путём фиксирования аргументов существующей.</p><p>Как было сказано выше, метод <code>func.bind(context, ...)</code> может создавать обёртку, которая фиксирует не только контекст, но и ряд аргументов функции.</p><p>Например, есть функция умножения двух чисел <code>mul(a, b)</code>:</p><code-example><script>`function mul(a, b) {\n  return a * b;\n};`</script></code-example><p>При помощи <code>bind</code> создадим функцию <code>double</code>, удваивающую значения. Это будет вариант функции <code>mul</code> с фиксированным первым аргументом:</p><code-example><script>`function mul(a, b) {\n  return a * b;\n};\n\nMARK// double умножает только на два\nMARKvar double = mul.bind(null, 2); // контекст фиксируем null, он не используется\n\nalert( double(3) ); // = mul(2, 3) = 6\nalert( double(4) ); // = mul(2, 4) = 8\nalert( double(5) ); // = mul(2, 5) = 10`</script><code-toolbar></code-toolbar></code-example><p>При вызове <code>double</code> будет передавать свои аргументы исходной функции <code>mul</code> после тех, которые указаны в <code>bind</code>, то есть в данном случае после зафиксированного первого аргумента <code>2</code>.</p><p><strong>Говорят, что <code>double</code> является «частичной функцией» (partial function) от <code>mul</code>.</strong></p><p>Другая частичная функция <code>triple</code> утраивает значения:</p><code-example><script>`function mul(a, b) {\n  return a * b;\n};\n\nMARKvar triple = mul.bind(null, 3); // контекст фиксируем null, он не используется\n\nalert( triple(3) ); // = mul(3, 3) = 9\nalert( triple(4) ); // = mul(3, 4) = 12\nalert( triple(5) ); // = mul(3, 5) = 15`</script><code-toolbar></code-toolbar></code-example><p>При помощи <code>bind</code> мы можем получить из функции её «частный вариант» как самостоятельную функцию и дальше передать в <code>setTimeout</code> или сделать с ней что-то ещё.</p><p>Наш выигрыш состоит в том, что эта самостоятельная функция, во-первых, имеет понятное имя (<code>double</code>, <code>triple</code>), а во-вторых, повторные вызовы позволяют не указывать каждый раз первый аргумент, он уже фиксирован благодаря <code>bind</code>.</p><h2><a name="5" href="#5">Функция ask для задач</a></h2><p>В задачах этого раздела предполагается, что объявлена следующая «функция вопросов» <code>ask</code>:</p><code-example><script>`function ask(question, answer, ok, fail) {\n  var result = prompt(question, '');\n  if (result.toLowerCase() == answer.toLowerCase()) ok();\n  else fail();\n}`</script></code-example><p>Её назначение – задать вопрос <code>question</code> и, если ответ совпадёт с <code>answer</code>, то запустить функцию <code>ok()</code>, а иначе – функцию <code>fail()</code>.</p><p>Несмотря на внешнюю простоту, функции такого вида активно используются в реальных проектах. Конечно, они будут сложнее, вместо <code>alert/prompt</code> – вывод красивого JavaScript-диалога с рамочками, кнопочками и так далее, но это нам сейчас не нужно.</p><p>Пример использования:</p><code-example><script>`function ask(question, answer, ok, fail) {\n  var result = prompt(question, \'\');\n  if (result.toLowerCase() == answer.toLowerCase()) ok();\n  else fail();\n}\n\nMARKask("Выпустить птичку?", "да", fly, die);\n\nfunction fly() {\n  alert( \'улетела :)\' );\n}\n\nfunction die() {\n  alert( \'птичку жалко :(&nbsp\' );\n}`</script><code-toolbar></code-toolbar></code-example><h2><a name="6" href="#6">Итого</a></h2><ul><li><p>Функция сама по себе не запоминает контекст выполнения.</p></li><li><p>Чтобы гарантировать правильный контекст для вызова <code>obj.func()</code>, нужно использовать функцию-обёртку, задать её через анонимную функцию:</p><code-example><script>`setTimeout(function() {\n  obj.func();\n})`</script></code-example></li><li><p>…Либо использовать <code>bind</code>:</p><code-example><script>`setTimeout(obj.func.bind(obj));`</script></code-example></li><li><p>Вызов <code>bind</code> часто используют для привязки функции к контексту, чтобы затем присвоить её в обычную переменную и вызывать уже без явного указания объекта.</p></li><li><p>Вызов <code>bind</code> также позволяет фиксировать первые аргументы функции («каррировать» её), и таким образом из общей функции получить её «частные» варианты – чтобы использовать их многократно без повтора одних и тех же аргументов каждый раз.</p></li></ul><h2 id="tasks"><a href="#7" name="7">Задачи (6)</a></h2><task-content><h3><a href="#11" name="11">Кросс-браузерная эмуляция bind</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 3</span><p>Если вы вдруг захотите копнуть поглубже – аналог <code>bind</code> для IE8- и старых версий других браузеров будет выглядеть следующим образом:</p><code-example><script>`function bind(func, context /*, args*/) {\n  var bindArgs = [].slice.call(arguments, 2); // (1)\n  function wrapper() {                        // (2)\n    var args = [].slice.call(arguments);\n    var unshiftArgs = bindArgs.concat(args);  // (3)\n    return func.apply(context, unshiftArgs);  // (4)\n  }\n  return wrapper;\n}`</script></code-example><p>Использование – вместо <code>mul.bind(null, 2)</code> вызывать <code>bind(mul, null, 2)</code>.</p><p>Не факт, что он вам понадобится, но в качестве упражнения попробуйте разобраться, как это работает.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer style=""><close- title="закрыть" data-close_answer=""></close-><p>Страшновато выглядит, да? Работает так (по строкам):</p><ol><li>Вызов <code>bind</code> сохраняет дополнительные аргументы <code>args</code> (они идут со 2-го номера) в массив <code>bindArgs</code>.</li><li>… и возвращает обертку <code>wrapper</code>.</li><li>Эта обёртка делает из <code>arguments</code> массив <code>args</code> и затем, используя метод <a href="http://javascript.ru/Array/concat">concat</a>, прибавляет их к аргументам <code>bindArgs</code> (карринг).</li><li>Затем передаёт вызов <code>func</code> с контекстом и общим массивом аргументов.</li></ol></task-answer></task-content><task-content><h3><a href="#12" name="12">Запись в объект после bind</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Что выведет функция?</p><code-example><script>`function f() {\n  alert( this );\n}\n\nvar user = {\n  g: f.bind("Hello")\n}\n\nuser.g();`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Ответ: <code>Hello</code>.</p><code-example><script>`function f() {\n  alert( this );\n}\n\nvar user = {\n  g: f.bind("Hello")\n}\n\nuser.g();`</script><code-toolbar></code-toolbar></code-example><p>Так как вызов идёт в контексте объекта <code>user.g()</code>, то внутри функции <code>g</code> контекст <code>this = user</code>.</p><p>Однако, функции <code>g</code> совершенно без разницы, какой <code>this</code> она получила.</p><p>Её единственное предназначение – это передать вызов в <code>f</code> вместе с аргументами и ранее указанным контекстом <code>"Hello"</code>, что она и делает.</p><p>Эта задача демонстрирует, что изменить однажды привязанный контекст уже нельзя.</p></task-answer></task-content><task-content><h3><a href="#13" name="13">Повторный bind</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Что выведет этот код?</p><code-example><script>`function f() {\n  alert(this.name);\n}\n\nf = f.bind( {name: "Вася"} ).bind( {name: "Петя" } );\n\nf();`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Ответ: <code>"Вася"</code>.</p><code-example><script>`function f() {\n  alert(this.name);\n}\n\nf = f.bind( {name: "Вася"} ).bind( {name: "Петя"} );\n\nf(); // Вася`</script><code-toolbar></code-toolbar></code-example><p>Первый вызов <code>f.bind(..Вася..)</code> возвращает «обёртку», которая устанавливает контекст для <code>f</code> и передаёт вызов <code>f</code>.</p><p>Следующий вызов <code>bind</code> будет устанавливать контекст уже для этой обёртки. Это ни на что не повлияет.</p><p>Чтобы это проще понять, используем наш собственный вариант <code>bind</code> вместо встроенного:</p><code-example><script>`function bind(func, context) {\n  return function() {\n    return func.apply(context, arguments);\n  };\n}`</script></code-example><p>Код станет таким:</p><code-example><script>`function f() {\n  alert(this.name);\n}\n\nf = bind(f, {name: "Вася"} ); // (1)\nf = bind(f, {name: "Петя"} ); // (2)\n\nf(); // Вася`</script></code-example><p>Здесь видно, что первый вызов <code>bind</code>, в строке <code>(1)</code>, возвращает обёртку вокруг <code>f</code>, которая выглядит так (выделена):</p><code-example><script>`function bind(func, context) {\nMARK  return function() {\nMARK    // здесь this не используется\nMARK    return func.apply(context, arguments);\nMARK  };\n}`</script></code-example><p>В этой обёртке нигде не используется <code>this</code>, контекст <code>context</code> берётся из замыкания. Посмотрите на код, там нигде нет <code>this</code>.</p><p>Поэтому следующий <code>bind</code> в строке <code>(2)</code>, который выполняется уже над обёрткой и фиксирует в ней <code>this</code>, ни на что не влияет. Какая разница, что будет в качестве <code>this</code> в функции, которая этот <code>this</code> не использует? Контекст <code>context</code>, как видно в коде выше, она получает через замыкание из аргументов первого <code>bind</code>.</p></task-answer></task-content><task-content><h3><a href="#14" name="14">Свойство функции после bind</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>В свойство функции записано значение. Изменится ли оно после применения <code>bind</code>? Обоснуйте ответ.</p><code-example><script>`function sayHi() {\n  alert( this.name );\n}\nsayHi.test = 5;\nalert( sayHi.test ); // 5\n\nMARKvar bound = sayHi.bind({\nMARK  name: "Вася"\nMARK});\nMARK&nbsp\nMARKalert( bound.test ); // что выведет? почему?`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Ответ: <code>undefined</code>.</p><p>Результатом работы <code>bind</code> является функция-обёртка над <code>sayHi</code>. Эта функция – самостоятельный объект, у неё уже нет свойства <code>test</code>.</p></task-answer></task-content><task-content><h3><a href="#15" name="15">Использование функции вопросов</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Вызов <code>user.checkPassword()</code> в коде ниже должен, при помощи <code>ask</code>, спрашивать пароль и вызывать <code>loginOk/loginFail</code> в зависимости от правильности ответа.</p><p>Однако, его вызов приводит к ошибке. Почему?</p><p>Исправьте выделенную строку, чтобы всё работало (других строк изменять не надо).</p><code-example><script>`\"use strict\";\n\nfunction ask(question, answer, ok, fail) {\n  var result = prompt(question, '');\n  if (result.toLowerCase() == answer.toLowerCase()) ok();\n  else fail();\n}\n\nvar user = {\n  login: 'Василий',\n  password: '12345',\n\n  loginOk: function() {\n    alert( this.login + ' вошёл в сайт' );\n  },\n\n  loginFail: function() {\n    alert( this.login + ': ошибка входа' );\n  },\n\n  checkPassword: function() {\nMARK    ask(\"Ваш пароль?\", this.password, this.loginOk,\nthis.loginFail);\n  }\n};\n\nuser.checkPassword();`</script><code-toolbar></code-toolbar></code-example><p>P.S. Ваше решение должно также срабатывать, если переменная <code>user</code> будет перезаписана, например вместо <code>user.checkPassword()</code> в конце будут строки:</p><code-example><script>`var vasya = user;\nuser = null;\nvasya.checkPassword();`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="" style="">Решение с bind</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Решение с bind</h4><p>Ошибка происходит потому, что <code>ask</code> получает только функцию, без объекта-контекста.</p><p>Используем <code>bind</code>, чтобы передать в <code>ask</code> функцию с уже привязанным контекстом:</p><code-example><script>`\"use strict\";\n\nfunction ask(question, answer, ok, fail) {\n  var result = prompt(question, '');\n  if (result.toLowerCase() == answer.toLowerCase()) ok();\n  else fail();\n}\n\nvar user = {\n  login: 'Василий',\n  password: '12345',\n\n  loginOk: function() {\n    alert( this.login + ' вошёл в сайт' );\n  },\n\n  loginFail: function() {\n    alert( this.login + ': ошибка входа' );\n  },\n\n  checkPassword: function() {\nMARK    ask(\"Ваш пароль?\", this.password, this.loginOk.bind(this), this.loginFail.bind(this));\n  }\n};\n\nvar vasya = user;\nuser = null;\nvasya.checkPassword();`</script><code-toolbar></code-toolbar></code-example></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Решение через замыкание</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Решение через замыкание</h4><p>Альтернативное решение – сделать функции-обёртки над <code>user.loginOk/loginFail</code>:</p><code-example><script>`var user = {\n  ...\n  checkPassword: function() {\nMARK    ask("Ваш пароль?", this.password,\nMARK      function() { user.loginOk(); }, function() { user.loginFail(); });\n  }\n}`</script></code-example><p>…Но такой код использует переменную <code>user</code>, так что если объект переместить из неё, к примеру, так, то работать он не будет:</p><code-example><script>`var vasya = user; // переместим user в vasya\nuser = null;\nvasya.checkPassword(); // упс будет ошибка, ведь в коде объекта остался user`</script></code-example><p>Для того, чтобы избежать проблем, можно использовать <code>this</code>. Внутри <code>checkPassword</code> он всегда будет равен текущему объекту, так что скопируем его в переменную, которую назовём <code>self</code>:</p><code-example><script>`\"use strict\";\n\nfunction ask(question, answer, ok, fail) {\n  var result = prompt(question, '');\n  if (result.toLowerCase() == answer.toLowerCase()) ok();\n  else fail();\n}\n\nvar user = {\n  login: 'Василий',\n  password: '12345',\n\n  loginOk: function() {\n    alert( this.login + ' вошёл в сайт' );\n  },\n\n  loginFail: function() {\n    alert( this.login + ': ошибка входа' );\n  },\n\n  checkPassword: function() {\nMARK    var self = this;\nMARK    ask(\"Ваш пароль?\", this.password,\nMARK      function() {\nMARK        self.loginOk();\nMARK      },\nMARK      function() {\nMARK        self.loginFail();\nMARK      }\nMARK    );\n  }\n};\n\nvar vasya = user;\nuser = null;\nvasya.checkPassword();`</script><code-toolbar></code-toolbar></code-example><p>Теперь всё работает. Анонимные функции достают правильный контекст из замыкания, где он сохранён в переменной <code>self</code>.</p></task-answer></task-answer-ext></task-content><task-content><h3><a href="#16" name="16">Использование функции вопросов с каррингом</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Эта задача – усложнённый вариант задачи <a href="/task/question-use-bind">Использование функции вопросов</a>. В ней объект <code>user</code> изменён.</p><p>Теперь заменим две функции <code>user.loginOk()</code> и <code>user.loginFail()</code> на единый метод: <code>user.loginDone(true/false)</code>, который нужно вызвать с <code>true</code> при верном ответе и с <code>false</code> – при неверном.</p><p>Код ниже делает это, соответствующий фрагмент выделен.</p><p><strong>Сейчас он обладает важным недостатком: при записи в <code>user</code> другого значения объект перестанет корректно работать, вы увидите это, запустив пример ниже (будет ошибка).</strong></p><p>Как бы вы написали правильно?</p><p><strong>Исправьте выделенный фрагмент, чтобы код заработал.</strong></p><code-example><script>`\"use strict\";\n\nfunction ask(question, answer, ok, fail) {\n  var result = prompt(question, '');\n  if (result.toLowerCase() == answer.toLowerCase()) ok();\n  else fail();\n}\n\nvar user = {\n  login: 'Василий',\n  password: '12345',\n\n  // метод для вызова из ask\n  loginDone: function(result) {\n    alert( this.login + (result ? ' вошёл в сайт' : ' ошибка входа') );\n  },\n\n  checkPassword: function() {\nMARK    ask(\"Ваш пароль?\", this.password,\nMARK      function() {\nMARK        user.loginDone(true);\nMARK      },\nMARK      function() {\nMARK        user.loginDone(false);\nMARK      }\nMARK    );\n  }\n};\n\nvar vasya = user;\nuser = null;\nvasya.checkPassword();`</script><code-toolbar></code-toolbar></code-example><p>Изменения должны касаться только выделенного фрагмента.</p><p>Если возможно, предложите два решения, одно – с использованием <code>bind</code>, другое – без него. Какое решение лучше?</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><button-answer-ext data-toggle_answer_ext="" style="">Решение с bind</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Решение с bind</h4><p>Первое решение – передать в <code>ask</code> функции с привязанным контекстом и аргументами.</p><code-example><script>`\"use strict\";\n\nfunction ask(question, answer, ok, fail) {\n  var result = prompt(question, '');\n  if (result.toLowerCase() == answer.toLowerCase()) ok();\n  else fail();\n}\n\nvar user = {\n  login: 'Василий',\n  password: '12345',\n\n  loginDone: function(result) {\n    alert( this.login + (result ? ' вошёл в сайт' : ' ошибка входа') );\n  },\n\n  checkPassword: function() {\nMARK    ask(\"Ваш пароль?\", this.password, this.loginDone.bind(this, true), this.loginDone.bind(this, false));\n  }\n};\n\nuser.checkPassword();`</script><code-toolbar></code-toolbar></code-example></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Решение с локальной переменной</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Решение с локальной переменной</h4><p>Второе решение – это скопировать <code>this</code> в локальную переменную (чтобы внешняя перезапись не повлияла):</p><code-example><script>`\"use strict\";\n\nfunction ask(question, answer, ok, fail) {\n  var result = prompt(question, '');\n  if (result.toLowerCase() == answer.toLowerCase()) ok();\n  else fail();\n}\n\nvar user = {\n  login: 'Василий',\n  password: '12345',\n\n  loginDone: function(result) {\n    alert( this.login + (result ? ' вошёл в сайт' : ' ошибка входа') );\n  },\n\n  checkPassword: function() {\n    var self = this;\nMARK    ask(\"Ваш пароль?\", this.password,\nMARK      function() {\nMARK        self.loginDone(true);\nMARK      },\nMARK      function() {\nMARK        self.loginDone(false);\nMARK      }\nMARK    );\n  }\n};\n\nuser.checkPassword();`</script><code-toolbar></code-toolbar></code-example><p>Оба решения хороши, вариант с <code>bind</code> короче.</p></task-answer></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Явное указание this: 'call', 'apply'; Функции-обёртки, декораторы"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/bind",disqus_identifier="bind",disqus_title="\u041f\u0440\u0438\u0432\u044f\u0437\u043a\u0430 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0430 \u0438 \u043a\u0430\u0440\u0440\u0438\u043d\u0433: \"bind\"";</script></page-content></main>