<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="54">Методы объектов и контекст вызова</a></nav-up><h1>Дескрипторы, геттеры и сеттеры свойств</h1><p>В этой главе мы рассмотрим возможности, которые позволяют очень гибко и мощно управлять всеми свойствами объекта, включая их аспекты – изменяемость, видимость в цикле <code>for..in</code> и даже незаметно делать их функциями.</p><p>Они поддерживаются всеми современными браузерами, но не IE8-. Впрочем, даже IE8 их поддерживает, но только для DOM-объектов (используются при работе со страницей, это сейчас вне нашего рассмотрения).</p><h2><a name="0" href="#0">Дескрипторы в примерах</a></h2><p>Основной метод для управления свойствами – <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a>.</p><p>Он позволяет объявить свойство объекта и, что самое главное, тонко настроить его особые аспекты, которые никак иначе не изменить.</p><p>Синтаксис:</p><code-example><script>`Object.defineProperty(obj, prop, descriptor)`</script></code-example><p>Аргументы:</p><dl><dt><code>obj</code></dt><dd>Объект, в котором объявляется свойство.</dd><dt><code>prop</code></dt><dd>Имя свойства, которое нужно объявить или модифицировать.</dd><dt><code>descriptor</code></dt><dd>Дескриптор – объект, который описывает поведение свойства.</dd></dl><p>В нём могут быть следующие поля:</p><ul><li><code>value</code> – значение свойства, по умолчанию <code>undefined</code></li><li><code>writable</code> – значение свойства можно менять, если <code>true</code>. По умолчанию <code>false</code>.</li><li><code>configurable</code> – если <code>true</code>, то свойство можно удалять, а также менять его в дальнейшем при помощи новых вызовов <code>defineProperty</code>. По умолчанию <code>false</code>.</li><li><code>enumerable</code> – если <code>true</code>, то свойство просматривается в цикле <code>for..in</code> и методе <code>Object.keys()</code>. По умолчанию <code>false</code>.</li><li><code>get</code> – функция, которая возвращает значение свойства. По умолчанию <code>undefined</code>.</li><li><code>set</code> – функция, которая записывает значение свойства. По умолчанию <code>undefined</code>.</li></ul><p>Чтобы избежать конфликта, запрещено одновременно указывать значение <code>value</code> и функции <code>get/set</code>. Либо значение, либо функции для его чтения-записи, одно из двух. Также запрещено и не имеет смысла указывать <code>writable</code> при наличии <code>get/set</code>-функций.</p><p>Далее мы подробно разберём эти свойства на примерах.</p><h2><a name="1" href="#1">Обычное свойство</a></h2><p>Два таких вызова работают одинаково:</p><code-example><script>`var user = {};\n\n// 1. простое присваивание\nuser.name = "Вася";\n\n// 2. указание значения через дескриптор\nObject.defineProperty(user, "name", { value: "Вася", configurable: true, writable: true, enumerable: true });`</script></code-example><p>Оба вызова выше добавляют в объект <code>user</code> обычное (удаляемое, изменяемое, перечисляемое) свойство.</p><h2><a name="2" href="#2">Свойство-константа</a></h2><p>Для того, чтобы сделать свойство неизменяемым, изменим его флаги <code>writable</code> и <code>configurable</code>:</p><code-example><script>`MARK"use strict";\n\nvar user = {};\n\nObject.defineProperty(user, "name", {\n  value: "Вася",\nMARK  writable: false, // запретить присвоение "user.name="\nMARK  configurable: false // запретить удаление "delete user.name"\n});\n\n// Теперь попытаемся изменить это свойство.\n\n// в strict mode присвоение "user.name=" вызовет ошибку\nMARKuser.name = "Петя";`</script><code-toolbar></code-toolbar></code-example><p>Заметим, что без <code>use strict</code> операция записи «молча» не сработает. Лишь если установлен режим <code>use strict</code>, то дополнительно сгенерируется ошибка.</p><h2><a name="3" href="#3">Свойство, скрытое для for…in</a></h2><p>Встроенный метод <code>toString</code>, как и большинство встроенных методов, не участвует в цикле <code>for..in</code>. Это удобно, так как обычно такое свойство является «служебным».</p><p>К сожалению, свойство <code>toString</code>, объявленное обычным способом, будет видно в цикле <code>for..in</code>, например:</p><code-example><script>`var user = {\n  name: "Вася",\n  toString: function() { return this.name; }\n};\n\nMARKfor(var key in user) alert(key);  // name, toString`</script><code-toolbar></code-toolbar></code-example><p>Мы бы хотели, чтобы поведение нашего метода <code>toString</code> было таким же, как и стандартного.</p><p><code>Object.defineProperty</code> может исключить <code>toString</code> из списка итерации, поставив ему флаг <code>enumerable: false</code>. По стандарту, у встроенного <code>toString</code> этот флаг уже стоит.</p><code-example><script>`var user = {\n  name: "Вася",\n  toString: function() { return this.name; }\n};\n\nMARK// помечаем toString как не подлежащий перебору в for..in\nMARKObject.defineProperty(user, "toString", {enumerable: false});\nMARK&nbsp\nMARKfor(var key in user) alert(key);  // name`</script><code-toolbar></code-toolbar></code-example><p>Обратим внимание, вызов <code>defineProperty</code> не перезаписал свойство, а просто модифицировал настройки у существующего <code>toString</code>.</p><h2><a name="4" href="#4">Свойство-функция</a></h2><p>Дескриптор позволяет задать свойство, которое на самом деле работает как функция. Для этого в нём нужно указать эту функцию в <code>get</code>.</p><p>Например, у объекта <code>user</code> есть обычные свойства: имя <code>firstName</code> и фамилия <code>surname</code>.</p><p>Создадим свойство <code>fullName</code>, которое на самом деле является функцией:</p><code-example><script>`var user = {\n  firstName: "Вася",\n  surname: "Петров"\n}\n\nObject.defineProperty(user, "fullName", {\n HIGH get:LIGHT function() {\n    return this.firstName + \'&nbsp\' + this.surname;\n  }\n});\n\nMARKalert(user.fullName); // Вася Петров`</script><code-toolbar></code-toolbar></code-example><p>Обратим внимание, снаружи <code>fullName</code> – это обычное свойство <code>user.fullName</code>. Но дескриптор указывает, что на самом деле его значение возвращается функцией.</p><p>Также можно указать функцию, которая используется для записи значения, при помощи дескриптора <code>set</code>.</p><p>Например, добавим возможность присвоения <code>user.fullName</code> к примеру выше:</p><code-example><script>`var user = {\n  firstName: "Вася",\n  surname: "Петров"\n}\n\nObject.defineProperty(user, "fullName", {\n\n  get: function() {\n    return this.firstName + \'&nbsp\' + this.surname;\n  },\n\nMARK  set: function(value) {\nMARK      var split = value.split(\' \');\nMARK      this.firstName = split[0];\nMARK      this.surname = split[1];\nMARK    }\n});\n\nMARKuser.fullName = "Петя Иванов";\nalert( user.firstName ); // Петя\nalert( user.surname ); // Иванов`</script><code-toolbar></code-toolbar></code-example><h2><a name="5" href="#5">Указание get/set в литералах</a></h2><p>Если мы создаём объект при помощи синтаксиса <code>{ ... }</code>, то задать свойства-функции можно прямо в его определении.</p><p>Для этого используется особый синтаксис: <code>get свойство</code> или <code>set свойство</code>.</p><p>Например, ниже объявлен геттер-сеттер <code>fullName</code>:</p><code-example><script>`var user = {\n  firstName: "Вася",\n  surname: "Петров",\n\nMARK  get fullName() {\n    return this.firstName + \'&nbsp\' + this.surname;\n  },\n\nMARK  set fullName(value) {\n    var split = value.split(\' \');\n    this.firstName = split[0];\n    this.surname = split[1];\n  }\n};\n\nMARKalert( user.fullName ); // Вася Петров (из геттера)\nMARK&nbsp\nMARKuser.fullName = "Петя Иванов";\nMARKalert( user.firstName ); // Петя  (поставил сеттер)\nMARKalert( user.surname ); // Иванов (поставил сеттер)`</script><code-toolbar></code-toolbar></code-example><h2><a name="6" href="#6">Да здравствуют get/set!</a></h2><p>Казалось бы, зачем нам назначать get/set для свойства через всякие хитрые вызовы, когда можно сделать просто функции с самого начала? Например, <code>getFullName</code>, <code>setFullName</code>…</p><p>Конечно, в ряде случаев свойства выглядят короче, такое решение просто может быть красивым. Но основной бонус – это гибкость, возможность получить контроль над свойством в любой момент!</p><p>Например, в начале разработки мы используем обычные свойства, например у <code>User</code> будет имя <code>name</code> и возраст <code>age</code>:</p><code-example><script>`function User(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nvar pete = new User("Петя", 25);\n\nalert( pete.age ); // 25`</script></code-example><p>С обычными свойствами в коде меньше букв, они удобны, причины использовать функции пока нет.</p><p>…Но рано или поздно могут произойти изменения. Например, в <code>User</code> может стать более целесообразно вместо возраста <code>age</code> хранить дату рождения <code>birthday</code>:</p><code-example><script>`function User(name, birthday) {\n  this.name = name;\n  this.birthday = birthday;\n}\n\nvar pete = new User("Петя", new Date(1987, 6, 1));`</script></code-example><p>Что теперь делать со старым кодом, который выводит свойство <code>age</code>?</p><p>Можно, конечно, найти все места и поправить их, но это долго, а иногда и невозможно, скажем, если вы взаимодействуете со сторонней библиотекой, код в которой – чужой и влезать в него нежелательно.</p><p>Добавление <code>get</code>-функции <code>age</code> позволяет обойти проблему легко и непринуждённо:</p><code-example><script>`function User(name, birthday) {\n  this.name = name;\n  this.birthday = birthday;\n\nMARK  // age будет высчитывать возраст по birthday\nMARK  Object.defineProperty(this, "age", {\nMARK    get: function() {\nMARK      var todayYear = new Date().getFullYear();\nMARK      return todayYear - this.birthday.getFullYear();\nMARK    }\nMARK  });\n}\n\nvar pete = new User("Петя", new Date(1987, 6, 1));\n\nalert( pete.birthday ); // и дата рождения доступна\nalert( pete.age );      // и возраст`</script><code-toolbar></code-toolbar></code-example><p>Заметим, что <code>pete.age</code> снаружи как было свойством, так и осталось. То есть, переписывать внешний код на вызов функции <code>pete.age()</code> не нужно.</p><p>Таким образом, <code>defineProperty</code> позволяет нам начать с обычных свойств, а в будущем, при необходимости, можно в любой момент заменить их на функции, реализующие более сложную логику.</p><h2><a name="7" href="#7">Другие методы работы со свойствами</a></h2><dl><dt><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineProperties">Object.defineProperties(obj, descriptors)</a></dt><dd><p>Позволяет объявить несколько свойств сразу:</p><code-example><script>`var user = {}\n\nObject.defineProperties(user, {\nMARK  firstName: {\n    value: "Петя"\n  },\n\nMARK  surname: {\n    value: "Иванов"\n  },\n\nMARK  fullName: {\n    get: function() {\n      return this.firstName + \'&nbsp\' + this.surname;\n    }\n  }\n});\n\nalert( user.fullName ); // Петя Иванов`</script><code-toolbar></code-toolbar></code-example></dd><dt><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys">Object.keys(obj)</a>, <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames">Object.getOwnPropertyNames(obj)</a></dt><dd><p>Возвращают массив – список свойств объекта.</p><p><code>Object.keys</code> возвращает только <code>enumerable</code>-свойства.</p><p><code>Object.getOwnPropertyNames</code> – возвращает все:</p><code-example><script>`var obj = {\n  a: 1,\n  b: 2,\n  internal: 3\n};\n\nObject.defineProperty(obj, "internal", {\n  enumerable: false\n});\n\nMARKalert( Object.keys(obj) ); // a,b\nMARKalert( Object.getOwnPropertyNames(obj) ); // a, internal, b`</script><code-toolbar></code-toolbar></code-example></dd><dt><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">Object.getOwnPropertyDescriptor(obj, prop)</a></dt><dd><p>Возвращает дескриптор для свойства <code>obj[prop]</code>.</p><p>Полученный дескриптор можно изменить и использовать <code>defineProperty</code> для сохранения изменений, например:</p><code-example><script>`var obj = {\n  test: 5\n};\nMARKvar descriptor = Object.getOwnPropertyDescriptor(obj, 'test');\n\nMARK// заменим value на геттер, для этого...\ndelete descriptor.value; // ..нужно убрать value/writable\ndelete descriptor.writable;\ndescriptor.get = function() { // и поставить get\n  alert( \"Preved :)\" );\n};\n\nMARK// поставим новое свойство вместо старого\n\n// если не удалить - defineProperty объединит старый дескриптор с новым\ndelete obj.test;\n\nObject.defineProperty(obj, 'test', descriptor);\n\nobj.test; // Preved :)`</script><code-toolbar></code-toolbar></code-example></dd></dl><p>…И несколько методов, которые используются очень редко:</p><dl><dt><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions">Object.preventExtensions(obj)</a></dt><dd>Запрещает добавление свойств в объект.</dd><dt><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/seal">Object.seal(obj)</a></dt><dd>Запрещает добавление и удаление свойств, все текущие свойства делает <code>configurable: false</code>.</dd><dt><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/freeze">Object.freeze(obj)</a></dt><dd>Запрещает добавление, удаление и изменение свойств, все текущие свойства делает <code>configurable: false, writable: false</code>.</dd><dt><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/isExtensible">Object.isExtensible(obj)</a></dt><dd>Возвращает <code>false</code>, если добавление свойств объекта было запрещено вызовом метода <code>Object.preventExtensions</code>.</dd><dt><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/isSealed">Object.isSealed(obj)</a></dt><dd>Возвращает <code>true</code>, если добавление и удаление свойств объекта запрещено, и все текущие свойства являются <code>configurable: false</code>.</dd><dt><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/isFrozen">Object.isFrozen(obj)</a></dt><dd>Возвращает <code>true</code>, если добавление, удаление и изменение свойств объекта запрещено, и все текущие свойства являются <code>configurable: false, writable: false</code>.</dd></dl><h2 id="tasks"><a href="#8" name="8">Задачи (1)</a></h2><task-content><h3><a href="#10" name="10">Добавить get/set-свойства</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Вам попал в руки код объекта <code>User</code>, который хранит имя и фамилию в свойстве <code>this.fullName</code>:</p><code-example><script>`function User(fullName) {\n  this.fullName = fullName;\n}\n\nvar vasya = new User("Василий Попкин");`</script></code-example><p>Имя и фамилия всегда разделяются пробелом.</p><p>Сделайте, чтобы были доступны свойства <code>firstName</code> и <code>lastName</code>, причём не только на чтение, но и на запись, вот так:</p><code-example><script>`var vasya = new User("Василий Попкин");\n\n// чтение firstName/lastName\nalert( vasya.firstName ); // Василий\nalert( vasya.lastName ); // Попкин\n\n// запись в lastName\nvasya.lastName = \'Сидоров\';\n\nalert( vasya.fullName ); // Василий Сидоров`</script></code-example><p>Важно: в этой задаче <code>fullName</code> должно остаться свойством, а <code>firstName/lastName</code> – реализованы через <code>get/set</code>. Лишнее дублирование здесь ни к чему.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`function User(fullName) {\n  this.fullName = fullName;\n\n  Object.defineProperties(this, {\n\n    firstName: {\n\n      get: function() {\n        return this.fullName.split(' ')[0];\n      },\n\n      set: function(newFirstName) {\n        this.fullName = newFirstName + '&nbsp' + this.lastName;\n      }\n\n    },\n\n    lastName: {\n\n      get: function() {\n        return this.fullName.split(' ')[1];\n      },\n\n      set: function(newLastName) {\n        this.fullName = this.firstName + '&nbsp' + newLastName;\n      }\n\n    }\n\n  });\n}\n\nvar vasya = new User(\"Василий Попкин\");\n\n// чтение firstName/lastName\nalert( vasya.firstName ); // Василий\nalert( vasya.lastName ); // Попкин\n\n// запись в lastName\nvasya.lastName = 'Сидоров';\n\nalert( vasya.fullName ); // Василий Сидоров`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Создание объектов через 'new'; Статические и фабричные методы"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/descriptors-getters-setters",disqus_identifier="descriptors-getters-setters",disqus_title="\u0414\u0435\u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0440\u044b, \u0433\u0435\u0442\u0442\u0435\u0440\u044b \u0438 \u0441\u0435\u0442\u0442\u0435\u0440\u044b \u0441\u0432\u043e\u0439\u0441\u0442\u0432";</script></page-content></main>