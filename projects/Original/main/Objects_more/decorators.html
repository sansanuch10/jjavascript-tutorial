<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="54">Методы объектов и контекст вызова</a></nav-up><h1>Функции-обёртки, декораторы</h1><p>JavaScript предоставляет удивительно гибкие возможности по работе с функциями: их можно передавать, в них можно записывать данные как в объекты, у них есть свои встроенные методы…</p><p>Конечно, этим нужно уметь пользоваться. В этой главе, чтобы более глубоко понимать работу с функциями, мы рассмотрим создание функций-обёрток или, иначе говоря, «декораторов».</p><p><a href="http://en.wikipedia.org/wiki/Decorator_pattern">Декоратор</a> – приём программирования, который позволяет взять существующую функцию и изменить/расширить ее поведение.</p><p><em>Декоратор</em> получает функцию и возвращает обертку, которая делает что-то своё «вокруг» вызова основной функции.</p><h2><a name="0" href="#0">bind – привязка контекста</a></h2><p>Один простой декоратор вы уже видели ранее – это функция <a data-load_page="61">bind</a>:</p><code-example><script>`function bind(func, context) {\n  return function() { // (*)\n    return func.apply(context, arguments);\n  };\n}`</script></code-example><p>Вызов <code>bind(func, context)</code> возвращает обёртку, которая ставит <code>this</code> и передаёт основную работу функции <code>func</code>.</p><h2><a name="1" href="#1">Декоратор-таймер</a></h2><p>Создадим более сложный декоратор, замеряющий время выполнения функции.</p><p>Он будет называться <code>timingDecorator</code> и получать функцию вместе с «названием таймера», а возвращать – функцию-обёртку, которая измеряет время и прибавляет его в специальный объект <code>timer</code> по свойству-названию.</p><p>Использование:</p><code-example><script>`function f(x) {} // любая функция\n\nvar timers = {}; // объект для таймеров\n\n// отдекорировали\nf = timingDecorator(f, "myFunc");\n\n// запускаем\nf(1);\nf(2);\nf(3); // функция работает как раньше, но время подсчитывается\n\nalert( timers.myFunc ); // общее время выполнения всех вызовов f`</script></code-example><p>При помощи декоратора <code>timingDecorator</code> мы сможем взять произвольную функцию и одним движением руки прикрутить к ней измеритель времени.</p><p>Его реализация:</p><code-example><script>`var timers = {};\n\n// прибавит время выполнения f к таймеру timers[timer]\nfunction timingDecorator(f, timer) {\n  return function() {\n    var start = performance.now();\n\n    var result = f.apply(this, arguments); // (*)\n\n    if (!timers[timer]) timers[timer] = 0;\n    timers[timer] += performance.now() - start;\n\n    return result;\n  }\n}\n\n// функция может быть произвольной, например такой:\nvar fibonacci = function f(n) {\n  return (n > 2) ? f(n - 1) + f(n - 2) : 1;\n}\n\nMARK// использование: завернём fibonacci в декоратор\nMARKfibonacci = timingDecorator(fibonacci, \"fibo\");\n\n// неоднократные вызовы...\nalert( fibonacci(10) ); // 55\nalert( fibonacci(20) ); // 6765\n// ...\n\nMARK// в любой момент можно получить общее количество времени на вызовы\nMARKalert( timers.fibo + 'мс' );`</script><code-toolbar></code-toolbar></code-example><p>Обратим внимание на строку <code>(*)</code> внутри декоратора, которая и осуществляет передачу вызова:</p><code-example><script>`var result = f.apply(this, arguments); // (*)`</script></code-example><p>Этот приём называется «форвардинг вызова» (от англ. forwarding): текущий контекст и аргументы через <code>apply</code> передаются в функцию <code>f</code>, так что изнутри <code>f</code> всё выглядит так, как была вызвана она напрямую, а не декоратор.</p><h2><a name="2" href="#2">Декоратор для проверки типа</a></h2><p>В JavaScript, как правило, пренебрегают проверками типа. В функцию, которая должна получать число, может быть передана строка, булево значение или даже объект.</p><p>Например:</p><code-example><script>`function sum(a, b) {\n  return a + b;\n}\n\n// передадим в функцию для сложения чисел нечисловые значения\nalert( sum(true, { name: "Вася", age: 35 }) ); // true[Object object]`</script></code-example><p>Функция «как-то» отработала, но в реальной жизни передача в <code>sum</code> подобных значений, скорее всего, будет следствием программной ошибки. Всё-таки <code>sum</code> предназначена для суммирования чисел, а не объектов.</p><p>Многие языки программирования позволяют прямо в объявлении функции указать, какие типы данных имеют параметры. И это удобно, поскольку повышает надёжность кода.</p><p>В JavaScript же проверку типов приходится делать дополнительным кодом в начале функции, который во-первых обычно  лень писать, а во-вторых он увеличивает общий объем текста, тем самым ухудшая читаемость.</p><p><strong>Декораторы способны упростить рутинные, повторяющиеся задачи, вынести их из кода функции.</strong></p><p>Например, создадим декоратор, который принимает функцию и массив, который описывает для какого аргумента какую проверку типа применять:</p><code-example><script>`// вспомогательная функция для проверки на число\nfunction checkNumber(value) {\n  return typeof value == \'number\';\n}\n\n// декоратор, проверяющий типы для f\n// второй аргумент checks - массив с функциями для проверки\nfunction typeCheck(f, checks) {\n  return function() {\n    for (var i = 0; i < arguments.length; i++) {\n      if (!checks[i](arguments[i])) {\n        alert( "Некорректный тип аргумента номер&nbsp" + i );\n        return;\n      }\n    }\n    return f.apply(this, arguments);\n  }\n}\n\nfunction sum(a, b) {\n  return a + b;\n}\n\nMARK// обернём декоратор для проверки\nMARKsum = typeCheck(sum, [checkNumber, checkNumber]); // оба аргумента - числа\n\n// пользуемся функцией как обычно\nalert( sum(1, 2) ); // 3, все хорошо\n\nMARK// а вот так - будет ошибка\nMARKsum(true, null); // некорректный аргумент номер 0\nMARKsum(1, ["array", "in", "sum?!?"]); // некорректный аргумент номер 1`</script><code-toolbar></code-toolbar></code-example><p>Конечно, этот декоратор можно ещё расширять, улучшать, дописывать проверки, но… Вы уже поняли принцип, не правда ли?</p><p><strong>Один раз пишем декоратор и дальше просто применяем этот функционал везде, где нужно.</strong></p><h2><a name="3" href="#3">Декоратор проверки доступа</a></h2><p>И наконец посмотрим ещё один, последний пример.</p><p>Предположим, у нас есть функция <code>isAdmin()</code>, которая возвращает <code>true</code>, если у посетителя есть права администратора.</p><p>Можно создать декоратор <code>checkPermissionDecorator</code>, который добавляет в любую функцию проверку прав:</p><p>Например, создадим декоратор <code>checkPermissionDecorator(f)</code>. Он будет возвращать обертку, которая передает вызов <code>f</code> в том случае, если у посетителя достаточно прав:</p><code-example><script>`function checkPermissionDecorator(f) {\n  return function() {\n    if (isAdmin()) {\n      return f.apply(this, arguments);\n    }\n    alert( 'Недостаточно прав' );\n  }\n}`</script></code-example><p>Использование декоратора:</p><code-example><script>`function save() { ... }\n\nsave = checkPermissionDecorator(save);\n// Теперь вызов функции save() проверяет права`</script></code-example><h2><a name="4" href="#4">Итого</a></h2><p>Декоратор – это обёртка над функцией, которая модифицирует её поведение. При этом основную работу по-прежнему выполняет функция.</p><p><strong>Декораторы можно не только повторно использовать, но и комбинировать!</strong></p><p>Это кардинально повышает их выразительную силу. Декораторы можно рассматривать как своего рода «фичи» или возможности, которые можно «нацепить» на любую функцию. Можно один, а можно несколько.</p><p>Скажем, используя декораторы, описанные выше, можно добавить к функции возможности по проверке типов данных, замеру времени и проверке доступа буквально одной строкой, не залезая при этом в её код, то есть (!) не увеличивая его сложность.</p><p>Предлагаю вашему вниманию задачи, которые помогут выяснить, насколько вы разобрались в декораторах. Далее в учебнике мы ещё встретимся с ними.</p><h2 id="tasks"><a href="#5" name="5">Задачи (3)</a></h2><task-content><h3><a href="#7" name="7">Логирующий декоратор (1 аргумент)</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Создайте декоратор <code>makeLogging(f, log)</code>, который берет функцию <code>f</code> и массив <code>log</code>.</p><p>Он должен возвращать обёртку вокруг <code>f</code>, которая при каждом вызове записывает («логирует») аргументы в <code>log</code>, а затем передает вызов в <code>f</code>.</p><p><strong>В этой задаче можно считать, что у функции <code>f</code> ровно один аргумент.</strong></p><p>Работать должно так:</p><code-example><script>`function work(a) {\n  /* ... */ // work - произвольная функция, один аргумент\n}\n\nfunction makeLogging(f, log) { /* ваш код */ }\n\nvar log = [];\nwork = makeLogging(work, log);\n\nwork(1); // 1, добавлено в log\nwork(5); // 5, добавлено в log\n\nfor (var i = 0; i < log.length; i++) {\nMARK  alert( 'Лог:' + log[i] ); // \"Лог:1\", затем \"Лог:5\"\n}`</script></code-example><p><a href="http://plnkr.co/edit/XgcMCDSlAeuAnM9YAAJ9?p=preview" target="_blank" data-plunk-id="XgcMCDSlAeuAnM9YAAJ9">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Возвратим декоратор <code>wrapper</code> который будет записывать аргумент в <code>log</code> и передавать вызов в <code>f</code>:</p><code-example><script>`function work(a) {\n  /*...*/ // work - произвольная функция, один аргумент\n}\n\nfunction makeLogging(f, log) {\n\nMARK  function wrapper(a) {\nMARK      log.push(a);\nMARK      return f.call(this, a);\nMARK    }\n\n  return wrapper;\n}\n\nvar log = [];\nwork = makeLogging(work, log);\n\nwork(1); // 1\nwork(5); // 5\n\nfor (var i = 0; i < log.length; i++) {\n  alert( \'Лог:\' + log[i] ); // "Лог:1", затем "Лог:5"\n}`</script><code-toolbar></code-toolbar></code-example><p><strong>Обратите внимание, вызов функции осуществляется как <code>f.call(this, a)</code>, а не просто <code>f(a)</code>.</strong></p><p>Передача контекста необходима, чтобы декоратор корректно работал с методами объекта. Например:</p><code-example><script>`user.method = makeLogging(user.method, log);`</script></code-example><p>Теперь при вызове <code>user.method(...)</code> в декоратор будет передаваться контекст <code>this</code>, который надо передать исходной функции через <code>call/apply</code>.</p><p><a href="http://plnkr.co/edit/ndvqPD82NolUJGAdnVxo?p=preview" target="_blank" data-plunk-id="ndvqPD82NolUJGAdnVxo">Открыть решение с тестами в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#8" name="8">Логирующий декоратор (много аргументов)</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 3</span><p>Создайте декоратор <code>makeLogging(func, log)</code>, для функции <code>func</code> возвращающий обёртку, которая при каждом вызове добавляет её аргументы в массив <code>log</code>.</p><p>Условие аналогично задаче <a data-load_page="62-1" style="">Логирующий декоратор (1 аргумент)</a>, но допускается <code>func</code> с любым набором аргументов.</p><p>Работать должно так:</p><code-example><script>`function work(a, b) {\n  alert( a + b ); // work - произвольная функция\n}\n\nfunction makeLogging(f, log) { /* ваш код */ }\n\nvar log = [];\nwork = makeLogging(work, log);\n\nwork(1, 2); // 3\nwork(4, 5); // 9\n\nfor (var i = 0; i < log.length; i++) {\n  var args = log[i]; // массив из аргументов i-го вызова\n  alert( \'Лог:\' + args.join() ); // "Лог:1,2", "Лог:4,5"\n}`</script></code-example><p><a href="http://plnkr.co/edit/WNnKln40Ttn4B17WP7oE?p=preview" target="_blank" data-plunk-id="WNnKln40Ttn4B17WP7oE">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Решение аналогично задаче <a data-load_page="62-1" style="">Логирующий декоратор (1 аргумент)</a>, разница в том, что в лог вместо одного аргумента идет весь объект <code>arguments</code>.</p><p>Для передачи вызова с произвольным количеством аргументов используем <code>f.apply(this, arguments)</code>.</p><code-example><script>`function work(a, b) {\n  alert( a + b ); // work - произвольная функция\n}\n\nfunction makeLogging(f, log) {\n\nMARK  function wrapper() {\nMARK      log.push([].slice.call(arguments));\nMARK      return f.apply(this, arguments);\nMARK    }\n\n  return wrapper;\n}\n\nvar log = [];\nwork = makeLogging(work, log);\n\nwork(1, 2); // 3\nwork(4, 5); // 9\n\nfor (var i = 0; i < log.length; i++) {\n  var args = log[i]; // массив из аргументов i-го вызова\n  alert( \'Лог:\' + args.join() ); // "Лог:1,2", "Лог:4,5"\n}`</script><code-toolbar></code-toolbar></code-example><p><a href="http://plnkr.co/edit/yc6E0NO4MAcle7JAjSTy?p=preview" target="_blank" data-plunk-id="yc6E0NO4MAcle7JAjSTy">Открыть решение с тестами в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#9" name="9">Кеширующий декоратор</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Создайте декоратор <code>makeCaching(f)</code>, который берет функцию <code>f</code> и возвращает обертку, которая кеширует её результаты.</p><p><strong>В этой задаче функция <code>f</code> имеет только один аргумент, и он является числом.</strong></p><ol><li>При первом вызове обертки с определенным аргументом – она вызывает <code>f</code> и запоминает значение.</li><li>При втором и последующих вызовах с тем же аргументом возвращается запомненное значение.</li></ol><p>Должно работать так:</p><code-example><script>`function f(x) {\n  return Math.random() * x; // random для удобства тестирования\n}\n\nfunction makeCaching(f) { /* ваш код */ }\n\nf = makeCaching(f);\n\nvar a, b;\n\na = f(1);\nb = f(1);\nalert( a == b ); // true (значение закешировано)\n\nb = f(2);\nalert( a == b ); // false, другой аргумент => другое значение`</script></code-example><p><a href="http://plnkr.co/edit/F2aA4cSTOwlR7BSFT9Np?p=preview" target="_blank" data-plunk-id="F2aA4cSTOwlR7BSFT9Np">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Запоминать результаты вызова функции будем в замыкании, в объекте <code>cache: { ключ:значение }</code>.</p><code-example><script>`function f(x) {\n  return Math.random()*x;\n}\n\nMARKfunction makeCaching(f) {\nMARK  var cache = {};\nMARK&nbsp\nMARK  return function(x) {\nMARK    if (!(x in cache)) {\nMARK      cache[x] = f.call(this, x);\nMARK    }\nMARK    return cache[x];\nMARK  };\nMARK&nbsp\nMARK}\n\nf = makeCaching(f);\n\nvar a = f(1);\nvar b = f(1);\nalert( a == b ); // true (значение закешировано)\n\nb = f(2);\nalert( a == b ); // false, другой аргумент => другое значение`</script><code-toolbar></code-toolbar></code-example><p>Обратите внимание: проверка на наличие уже подсчитанного значения выглядит так: <code>if (x in cache)</code>. Менее универсально можно проверить так: <code>if (cache[x])</code>, это если мы точно знаем, что <code>cache[x]</code> никогда не будет <code>false</code>, <code>0</code> и т.п.</p><p><a href="http://plnkr.co/edit/3uOIJhJ8Tegf9rc7SuHn?p=preview" target="_blank" data-plunk-id="3uOIJhJ8Tegf9rc7SuHn">Открыть решение с тестами в песочнице.</a></p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Привязка контекста и карринг: 'bind'; Некоторые другие возможности"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/decorators", disqus_identifier = "decorators", disqus_title = "\u0424\u0443\u043d\u043a\u0446\u0438\u0438-\u043e\u0431\u0451\u0440\u0442\u043a\u0438, \u0434\u0435\u043a\u043e\u0440\u0430\u0442\u043e\u0440\u044b";</script></page-content></main>