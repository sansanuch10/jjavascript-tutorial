<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="54">Методы объектов и контекст вызова</a></nav-up><h1>Преобразование объектов: toString и valueOf</h1><p>Ранее, в главе <a data-load_page="21">Преобразование типов для примитивов</a> мы рассматривали преобразование типов для примитивов. Теперь добавим в нашу картину мира объекты.</p><p>Бывают операции, при которых объект должен быть преобразован в примитив.</p><p>Например:</p><ul><li>Строковое преобразование – если объект выводится через <code>alert(obj)</code>.</li><li>Численное преобразование – при арифметических операциях, сравнении с примитивом.</li><li>Логическое преобразование – при <code>if(obj)</code> и других логических операциях.</li></ul><p>Рассмотрим эти преобразования по очереди.</p><h2><a name="0" href="#0">Логическое преобразование</a></h2><p>Проще всего – с логическим преобразованием.</p><p><strong>Любой объект в логическом контексте – <code>true</code>, даже если это пустой массив <code>[]</code> или объект <code>{}</code>.</strong></p><code-example><script>`if ({} && []) {\n  alert( "Все объекты - true!" ); // alert сработает\n}`</script><code-toolbar></code-toolbar></code-example><h2><a name="1" href="#1">Строковое преобразование</a></h2><p>Строковое преобразование проще всего увидеть, если вывести объект при помощи <code>alert</code>:</p><code-example><script>`var user = {\n  firstName: 'Василий'\n};\n\nalert( user ); // [object Object]`</script><code-toolbar></code-toolbar></code-example><p>Как видно, содержимое объекта не вывелось. Это потому, что стандартным строковым представлением пользовательского объекта является строка <code>"[object Object]"</code>.</p><p>Такой вывод объекта не содержит интересной информации. Поэтому имеет смысл его поменять на что-то более полезное.</p><p><strong>Если в объекте присутствует метод <code>toString</code>, который возвращает примитив, то он используется для преобразования.</strong></p><code-example><script>`var user = {\n\n  firstName: 'Василий',\n\n  HIGHtoStringLIGHT: function() {\n    return 'Пользователь&nbsp' + this.firstName;\n  }\n};\n\nalert( user );  // Пользователь Василий`</script><code-toolbar></code-toolbar></code-example><important-><h3>Результатом <code>toString</code> может быть любой примитив</h3><p>Метод <code>toString</code> не обязан возвращать именно строку.</p><p>Его результат может быть любого примитивного типа. Например, это может быть число, как в примере ниже:</p><code-example><script>`var obj = {\n  toString: function() {\n    return 123;\n  }\n};\n\nalert( obj ); // 123`</script><code-toolbar></code-toolbar></code-example><p>Поэтому мы и называем его здесь <em>«строковое преобразование»</em>, а не «преобразование к строке».</p></important-><p>Все объекты, включая встроенные, имеют свои реализации метода <code>toString</code>, например:</p><code-example><script>`alert( [1, 2] ); // toString для массивов выводит список элементов "1,2"\nalert( new Date ); // toString для дат выводит дату в виде строки\nalert( function() {} ); // toString для функции выводит её код`</script><code-toolbar></code-toolbar></code-example><h2><a name="2" href="#2">Численное преобразование</a></h2><p>Для численного преобразования объекта используется метод <code>valueOf</code>, а если его нет – то <code>toString</code>:</p><code-example><script>`var room = {\n  number: 777,\n\n  valueOf: function() { return this.number; },\n  toString: function() { return this.number; }\n};\n\nalert( +room );  // 777, HIGHвызвался valueOfLIGHT\n\ndelete room.valueOf; // HIGHvalueOf удалёнLIGHT\n\nalert( +room );  // 777, HIGHвызвался toStringLIGHT`</script><code-toolbar></code-toolbar></code-example><p>Метод <code>valueOf</code> обязан возвращать примитивное значение, иначе его результат будет проигнорирован. При этом – не обязательно числовое.</p><important-><h3>У большинства объектов нет <code>valueOf</code></h3><p>У большинства встроенных объектов такого <code>valueOf</code> нет, поэтому численное и строковое преобразования для них работают одинаково.</p><p>Исключением является объект <code>Date</code>, который поддерживает оба типа преобразований:</p><code-example><script>`alert( new Date() ); // toString: Дата в виде читаемой строки\Nalert( +new Date() ); // valueOf: кол-во миллисекунд, прошедших с 01.01.1970`</script><code-toolbar></code-toolbar></code-example></important-><important-><h3>Детали спецификации</h3><p>Если посмотреть в стандарт, то в пункте <a href="http://es5.github.com/x15.2.html#x15.2.4.4">15.2.4.4</a> говорится о том, что <code>valueOf</code> есть у любых объектов. Но он ничего не делает, просто возвращает сам объект (не-примитивное значение!), а потому игнорируется.</p></important-><h2><a name="3" href="#3">Две стадии преобразования</a></h2><p>Итак, объект преобразован в примитив при помощи <code>toString</code> или <code>valueOf</code>.</p><p>Но на этом преобразования не обязательно заканчиваются. Вполне возможно, что в процессе вычислений этот примитив будет преобразован во что-то другое.</p><p>Например, рассмотрим применение к объекту операции <code>==</code>:</p><code-example><script>`var obj = {\n  valueOf: function() {\n    return 1;\n  }\n};\n\nalert( obj == true ); // true`</script><code-toolbar></code-toolbar></code-example><p>Объект <code>obj</code> был сначала преобразован в примитив, используя численное преобразование, получилось <code>1 == true</code>.</p><p>Далее, так как значения всё ещё разных типов, применяются правила преобразования примитивов, результат: <code>true</code>.</p><p>То же самое – при сложении с объектом при помощи <code>+</code>:</p><code-example><script>`var obj = {\n  valueOf: function() {\n    return 1;\n  }\n};\n\nalert( obj + "test" ); // 1test`</script><code-toolbar></code-toolbar></code-example><p>Или вот, для разности объектов:</p><code-example><script>`var a = {\n  valueOf: function() {\n    return "1";\n  }\n};\nvar b = {\n  valueOf: function() {\n    return "2";\n  }\n};\n\nalert( a + b ); // "12"\nalert( a - b ); // "1" - "2" = -1`</script><code-toolbar></code-toolbar></code-example><important-warn><h3>Исключение: <code>Date</code></h3><p>Объект <code>Date</code>, по историческим причинам, является исключением.</p><p>Бинарный оператор плюс <code>+</code> обычно использует численное преобразование и метод <code>valueOf</code>. Как мы уже знаем, если подходящего <code>valueOf</code> нет (а его нет у большинства объектов), то используется <code>toString</code>, так что в итоге преобразование происходит к строке. Но если есть <code>valueOf</code>, то используется <code>valueOf</code>. Выше в примере как раз <code>a + b</code> это демонстрируют.</p><p>У объектов <code>Date</code> есть и <code>valueOf</code> – возвращает количество миллисекунд, и <code>toString</code> – возвращает строку с датой.</p><p>…Но оператор <code>+</code> для <code>Date</code> использует именно <code>toString</code> (хотя должен бы <code>valueOf</code>).</p><p>Это и есть исключение:</p><code-example><script>`// бинарный плюс для даты toString, для остальных объектов valueOf\nalert( new Date + "" ); // "строка даты"`</script><code-toolbar></code-toolbar></code-example><p>Других подобных исключений нет.</p></important-warn><important-warn><h3>Как испугать Java-разработчика</h3><p>В языке Java (это не JavaScript, другой язык, здесь приведён для примера) логические значения можно создавать, используя синтаксис <code>new Boolean(true/false)</code>, например <code>new Boolean(true)</code>.</p><p>В JavaScript тоже есть подобная возможность, которая возвращает «объектную обёртку» для логического значения.</p><p>Эта возможность давно существует лишь для совместимости, она и не используется на практике, поскольку приводит к странным результатам. Некоторые из них могут сильно удивить человека, не привыкшего к JavaScript, например:</p><code-example><script>`var value = new Boolean(false);\nif (value) {\n  alert( true ); // сработает!\n}`</script><code-toolbar></code-toolbar></code-example><p>Почему запустился <code>alert</code>? Ведь в <code>if</code> находится <code>false</code>… Проверим:</p><code-example><script>`var value = new Boolean(false);\n\nMARKalert( value ); // выводит false, все ок..\n\nif (value) {\n  alert( true ); // ..но тогда почему выполняется alert в if ?!?\n}`</script><code-toolbar></code-toolbar></code-example><p>Дело в том, что <code>new Boolean</code> – это не примитивное значение, а объект. Поэтому в логическом контексте он преобразуется к <code>true</code>, в результате работает первый пример.</p><p>А второй пример вызывает <code>alert</code>, который преобразует объект к строке, и он становится <code>"false"</code>.</p><p><strong>В JavaScript вызовы <code>new Boolean/String/Number</code> не используются, а используются простые вызовы соответствующих функций, они преобразуют значение в примитив нужного типа, например <code>Boolean(val) === !!val</code>.</strong></p></important-warn><h2><a name="4" href="#4">Итого</a></h2><ul><li>В логическом контексте объект – всегда <code>true</code>.</li><li>При строковом преобразовании объекта используется его метод <code>toString</code>. Он должен возвращать примитивное значение, причём не обязательно именно строку.</li><li>Для численного преобразования используется метод <code>valueOf</code>, который также может возвратить любое примитивное значение. У большинства объектов <code>valueOf</code> не работает (возвращает сам объект и потому игнорируется), при этом для численного преобразования используется <code>toString</code>.</li></ul><p>Полный алгоритм преобразований есть в спецификации ECMAScript, смотрите пункты <a href="http://es5.github.com/x11.html#x11.8.5">11.8.5</a>, <a href="http://es5.github.com/x11.html#x11.9.3">11.9.3</a>, а также <a href="http://es5.github.com/x9.html#x9.1">9.1</a> и <a href="http://es5.github.com/x9.html#x9.3">9.3</a>.</p><p>Заметим, для полноты картины, что некоторые тесты знаний в интернет предлагают вопросы типа:</p><code-example><script>`{}[0]  // чему равно?\n{} + {} // а так?`</script></code-example><p>Если вы запустите эти выражения в консоли, то результат может показаться странным. Подвох здесь в том, что если фигурные скобки <code>{...}</code> идут не в выражении, а в основном потоке кода, то JavaScript считает, что это не объект, а «блок кода» (как <code>if</code>, <code>for</code>, но без оператора, просто группировка команд вместе, используется редко).</p><p>Вот блок кода с командой:</p><code-example><script>`{\n  alert("Блок")\n}`</script><code-toolbar></code-toolbar></code-example><p>А если команду изъять, то будет пустой блок <code>{}</code>, который ничего не делает. Два примера выше как раз содержат пустой блок в начале, который ничего не делает. Иначе говоря:</p><code-example><script>`{}[0]   // то же что и: [0]\n{} + {} // то же что и: + {}`</script></code-example><p>То есть, такие вопросы – не на преобразование типов, а на понимание, что если <code>{ ... }</code> находится вне выражений, то это не объект, а блок.</p><h2 id="tasks"><a href="#5" name="5">Задачи (5)</a></h2><task-content><h3><a href="#12" name="12">['x'] == 'x'</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Почему результат <code>true</code> ?</p><code-example><script>`alert( ['x'] == 'x' );`</script><code-toolbar></code-toolbar></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Если с одной стороны – объект, а с другой – нет, то сначала приводится объект.</p><p>В данном случае сравнение означает численное приведение. У массивов нет <code>valueOf</code>, поэтому вызывается <code>toString</code>, который возвращает список элементов через запятую.</p><p>В данном случае, элемент только один – он и возвращается. Так что <code>['x']</code> становится <code>'x'</code>. Получилось <code>'x' == 'x'</code>, верно.</p><p>P.S.По той же причине верны равенства:</p><code-example><script>`alert( ['x', 'y'] == 'x,y' ); // true\nalert( [] == '' ); // true`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#13" name="13">Преобразование</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Объявлен объект с <code>toString</code> и <code>valueOf</code>.</p><p>Какими будут результаты <code>alert</code>?</p><code-example><script>`var foo = {\n  toString: function() {\n    return 'foo';\n  },\n  valueOf: function() {\n    return 2;\n  }\n};\n\nalert( foo );\nalert( foo + 1 );\nalert( foo + \"3\" );`</script><code-toolbar></code-toolbar></code-example><p>Подумайте, прежде чем ответить.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="" style="">Первый alert(foo)</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Первый alert(foo)</h4><p>Возвращает строковое представление объекта, используя <code>toString</code>, т.е. <code>"foo"</code>.</p></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Второй alert(foo + 1)</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Второй alert(foo + 1)</h4><p>Оператор <code>'+'</code> преобразует объект к примитиву, используя <code>valueOf</code>, так что результат: <code>3</code>.</p></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Третий alert(foo + „3“)</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Третий alert(foo + „3“)</h4><p>То же самое, что и предыдущий случай, объект превращается в примитив <code>2</code>. Затем происходит сложение <code>2 + '3'</code>. Оператор <code>'+'</code> при сложении чего-либо со строкой приводит и второй операнд к строке, а затем применяет конкатенацию, так что результат – строка <code>"23"</code>.</p></task-answer></task-answer-ext></task-content><task-content><h3><a href="#14" name="14">Почему [] == [] неверно, а [ ] == ![ ] верно?</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Почему первое равенство – неверно, а второе – верно?</p><code-example><script>`alert( [] == [] ); // false\nalert( [] == ![] ); // true`</script><code-toolbar></code-toolbar></code-example><p>Какие преобразования происходят при вычислении?</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="" style="">Ответ по первому равенству</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Ответ по первому равенству</h4><p>Два объекта равны только тогда, когда это один и тот же объект.</p><p>В первом равенстве создаются два массива, это разные объекты, так что они неравны.</p></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Ответ по второму равенству</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Ответ по второму равенству</h4><ol><li><p>Первым делом, обе части сравнения вычисляются. Справа находится <code>![]</code>. Логическое НЕ <code>'!'</code> преобразует аргумент к логическому типу. Массив является объектом, так что это <code>true</code>. Значит, правая часть становится <code>![] = !true = false</code>. Так что получили:</p><code-example><script>`alert( [] == false );`</script></code-example></li><li><p>Проверка равенства между объектом и примитивом вызывает численное преобразование объекта.</p><p>У массива нет <code>valueOf</code>, сработает <code>toString</code> и преобразует массив в список элементов, то есть – в пустую строку:</p><code-example><script>`alert( '' == false );`</script></code-example></li><li><p>Сравнение различных типов вызывает численное преобразование слева и справа:</p><code-example><script>`alert( 0 == 0 );`</script></code-example><p>Теперь результат очевиден.</p></li></ol></task-answer></task-answer-ext></task-content><task-content><h3><a href="#15" name="15">Вопросник по преобразованиям, для объектов</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Подумайте, какой результат будет у выражений ниже. Когда закончите – сверьтесь с решением.</p><code-example><script>`new Date(0) - 0\nnew Array(1)[0] + ""\n({})[0]\n[1] + 1\n[1,2] + [3,4]\n[] + null + 1\n[[0]][0][0]\n({} + {})`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`new Date(0) - 0 = 0 // (1)\nnew Array(1)[0] + "" = "undefined" // (2)\n({})[0] = undefined // (3)\n[1] + 1 = "11" // (4)\n[1,2] + [3,4] = "1,23,4" // (5)\n[] + null + 1 = "null1" // (6)\n[[0]][0][0] = 0 // (7)\n({} + {}) = "[object Object][object Object]" // (8)`</script><code-toolbar></code-toolbar></code-example><ol><li><p><code>new Date(0)</code> – дата, созданная по миллисекундам и соответствующая 0 мс от 1 января 1970 года 00:00:00 UTC. Оператор минус <code>-</code> преобразует дату обратно в число миллисекунд, то есть в <code>0</code>.</p></li><li><p><code>new Array(num)</code> при вызове с единственным аргументом-числом создаёт массив данной длины, без элементов. Поэтому его нулевой элемент равен <code>undefined</code>, при сложении со строкой получается строка <code>"undefined"</code>.</p></li><li><p>Фигурные скобки – это создание пустого объекта, у него нет свойства <code>'0'</code>. Так что значением будет <code>undefined</code>.Обратите внимание на внешние, круглые скобки. Если их убрать и запустить <code>{}[0]</code> в отладочной консоли браузера – будет <code>0</code>, т.к. скобки <code>{}</code> будут восприняты как пустой блок кода, после которого идёт массив.</p></li><li><p>Массив преобразуется в строку <code>"1"</code>. Оператор <code>"+"</code> при сложении со строкой приводит второй аргумент к строке – значит будет <code>"1" + "1" = "11"</code>.</p></li><li><p>Массивы приводятся к строке и складываются.</p></li><li><p>Массив преобразуется в пустую строку <code>"" + null + 1</code>, оператор <code>"+"</code> видит, что слева строка и преобразует <code>null</code> к строке, получается <code>"null" + 1</code>, и в итоге <code>"null1"</code>.</p></li><li><p><code>[[0]]</code> – это вложенный массив <code>[0]</code> внутри внешнего <code>[ ]</code>. Затем мы берём от него нулевой элемент, и потом еще раз.</p><p>Если это непонятно, то посмотрите на такой пример:</p><code-example><script>`alert( [1,[0],2][1] );`</script></code-example><p>Квадратные скобки после массива/объекта обозначают не другой массив, а взятие элемента.</p></li><li><p>Каждый объект преобразуется к примитиву. У встроенных объектов <code>Object</code> нет подходящего <code>valueOf</code>, поэтому используется <code>toString</code>, так что складываются в итоге строковые представления объектов.</p></li></ol></task-answer></task-content><task-content><h3><a href="#16" name="16">Сумма произвольного количества скобок</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 2</span><p>Напишите функцию <code>sum</code>, которая будет работать так:</p><code-example><script>`sum(1)(2) == 3; // 1 + 2\nsum(1)(2)(3) == 6; // 1 + 2 + 3\nsum(5)(-1)(2) == 6\nsum(6)(-1)(-2)(-3) == 0\nsum(0)(1)(2)(3)(4)(5) == 15`</script></code-example><p>Количество скобок может быть любым.</p><p>Пример такой функции для двух аргументов – есть в решении задачи <a data-load_page="50-1">Сумма через замыкание</a>.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><button-answer-ext data-toggle_answer_ext="" style="">Подсказка</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Подсказка</h4><p>Чтобы <code>sum(1)</code>, а также <code>sum(1)(2)</code> можно было вызвать новыми скобками – результатом <code>sum</code> должна быть функция.</p><p>Но эта функция также должна уметь превращаться в число. Для этого нужно дать ей соответствующий <code>valueOf</code>. А если мы хотим, чтобы и в строковом контексте она вела себя так же – то <code>toString</code>.</p></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Решение</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Решение</h4><p>Функция, которая возвращается <code>sum</code>, должна накапливать значение при каждом вызове.</p><p>Удобнее всего хранить его в замыкании, в переменной <code>currentSum</code>. Каждый вызов прибавляет к ней очередное значение:</p><code-example><script>`function sum(a) {\n\n  var currentSum = a;\n\n  function f(b) {\n    currentSum += b;\n    return f;\n  }\n\n  f.toString = function() {\n    return currentSum;\n  };\n\n  return f;\n}\n\nalert( sum(1)(2) ); // 3\nalert( sum(5)(-1)(2) ); // 6\nalert( sum(6)(-1)(-2)(-3) ); // 0\nalert( sum(0)(1)(2)(3)(4)(5) ); // 15`</script><code-toolbar></code-toolbar></code-example><p>При внимательном взгляде на решение легко заметить, что функция <code>sum</code> срабатывает только один раз. Она возвращает функцию <code>f</code>.</p><p>Затем, при каждом запуске функция <code>f</code> добавляет параметр к сумме <code>currentSum</code>, хранящейся в замыкании, и возвращает сама себя.</p><p><strong>В последней строчке <code>f</code> нет рекурсивного вызова.</strong></p><p>Вот так была бы рекурсия:</p><code-example><script>`function f(b) {\n  currentSum += b;\n  return f(); // <-- подвызов\n}`</script></code-example><p>А в нашем случае, мы просто возвращаем саму функцию, ничего не вызывая.</p><code-example><script>`function f(b) {\n  currentSum += b;\n  return f; // <-- не вызывает сама себя, а возвращает ссылку на себя\n}`</script></code-example><p>Эта <code>f</code> используется при следующем вызове, опять возвратит себя, и так сколько нужно раз. Затем, при использовании в строчном или численном контексте – сработает <code>toString</code>, который вернет текущую сумму <code>currentSum</code>.</p></task-answer></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Методы объектов, this; Создание объектов через 'new'"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/editor",disqus_identifier="editor",disqus_title="\u0420\u0435\u0434\u0430\u043a\u0442\u043e\u0440\u044b \u0434\u043b\u044f \u043a\u043e\u0434\u0430";</script></page-content></main>