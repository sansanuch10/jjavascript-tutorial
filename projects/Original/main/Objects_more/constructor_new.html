<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="54">Методы объектов и контекст вызова</a></nav-up><h1>Создание объектов через "new"</h1><p>Обычный синтаксис <code>{...}</code> позволяет создать один объект. Но зачастую нужно создать много однотипных объектов.</p><p>Для этого используют «функции-конструкторы», запуская их при помощи специального оператора <code>new</code>.</p><h2><a name="0" href="#0">Конструктор</a></h2><p>Конструктором становится любая функция, вызванная через <code>new</code>.</p><p>Например:</p><code-example><script>`function Animal(name) {\n  this.name = name;\n  this.canWalk = true;\n}\n\nMARKvar animal = new Animal("ёжик");`</script></code-example><p>Заметим, что, технически, любая функция может быть использована как конструктор. То есть, любую функцию можно вызвать при помощи <code>new</code>. Как-то особым образом указывать, что она – конструктор – не надо.</p><p>Но, чтобы выделить функции, задуманные как конструкторы, их называют с большой буквы: <code>Animal</code>, а не <code>animal</code>.</p><p>Детальнее – функция, запущенная через <code>new</code>, делает следующее:</p><ol><li>Создаётся новый пустой объект.</li><li>Ключевое слово <code>this</code> получает ссылку на этот объект.</li><li>Функция выполняется. Как правило, она модифицирует <code>this</code> (т.е. этот новый объект), добавляет методы, свойства.</li><li>Возвращается <code>this</code>.</li></ol><p>В результате вызова <code>new Animal("ёжик");</code> получаем такой объект:</p><code-example><script>`animal = {\n  name: "ёжик",\n  canWalk: true\n}`</script></code-example><p>Иными словами, при вызове <code>new Animal</code> происходит что-то в таком духе (первая и последняя строка – это то, что делает интерпретатор):</p><code-example><script>`function Animal(name) {\nMARK  // this = {};\n\n  // в this пишем свойства, методы\n  this.name = name;\n  this.canWalk = true;\n\nMARK  // return this;\n}`</script></code-example><p>Теперь многократными вызовами <code>new Animal</code> с разными параметрами мы можем создать столько объектов, сколько нужно. Поэтому такую функцию и называют <em>конструктором</em> – она предназначена для «конструирования» объектов.</p><important-><h3>new function() { … }</h3><p>Иногда функцию-конструктор объявляют и тут же используют, вот так:</p><code-example><script>`var animal = new function() {\n  this.name = "Васька";\n  this.canWalk = true;\n};`</script></code-example><p>Так делают, когда хотят создать единственный объект данного типа. Пример выше с тем же успехом можно было бы переписать как:</p><code-example><script>`var animal = {\n  name: "Васька",\n  canWalk: true\n}`</script></code-example><p>…Но обычный синтаксис <code>{...}</code> не подходит, когда при создании свойств объекта нужны более сложные вычисления. Их можно проделать в функции-конструкторе и записать результат в <code>this</code>.</p></important-><h2><a name="1" href="#1">Правила обработки return</a></h2><p>Как правило, конструкторы ничего не возвращают. Их задача – записать всё, что нужно, в <code>this</code>, который автоматически станет результатом.</p><p>Но если явный вызов <code>return</code> всё же есть, то применяется простое правило:</p><ul><li>При вызове <code>return</code> с объектом, будет возвращён он, а не <code>this</code>.</li><li>При вызове <code>return</code> с примитивным значением, оно будет отброшено.</li></ul><p>Иными словами, вызов <code>return</code> с объектом вернёт объект, а с чем угодно, кроме объекта – возвратит, как обычно, <code>this</code>.</p><p>Например, возврат объекта:</p><code-example><script>`function BigAnimal() {\n\n  this.name = "Мышь";\n\n  return { name: "Годзилла" };  // <-- возвратим объект\n}\n\nalert( new BigAnimal().name );  // Годзилла, получили объект вместо this`</script><code-toolbar></code-toolbar></code-example><p>А вот пример с возвратом строки:</p><code-example><script>`function BigAnimal() {\n\n  this.name = "Мышь";\n\n  return "Годзилла"; // <-- возвратим примитив\n}\n\nalert( new BigAnimal().name ); // Мышь, получили this (а Годзилла пропал)`</script><code-toolbar></code-toolbar></code-example><p>Эта особенность работы <code>new</code> прописана в стандарте, но используется она весьма редко.</p><important-><h3>Можно без скобок</h3><p>Кстати, при вызове <code>new</code> без аргументов скобки можно не ставить:</p><code-example><script>`var animal = new BigAnimal; // <-- без скобок\n// то же самое что\nvar animal = new BigAnimal();`</script></code-example><p>Не сказать, что выбрасывание скобок – «хороший стиль», но такой синтаксис допустим стандартом.</p></important-><h2><a name="2" href="#2">Создание методов в конструкторе</a></h2><p>Использование функций для создания объекта дает большую гибкость. Можно передавать конструктору параметры,  определяющие как его создавать, и он будет «клепать» объекты заданным образом.</p><p>Добавим в создаваемый объект ещё и метод.</p><p>Например, <code>new User(name)</code> создает объект с заданным значением свойства <code>name</code> и методом <code>sayHi</code>:</p><code-example><script>`function User(name) {\n  this.name = name;\n\n  this.sayHi = function() {\n    alert( "Моё имя:&nbsp" + this.name );\n  };\n}\n\nMARKvar ivan = new User("Иван");\nMARK&nbsp\nMARKivan.sayHi(); // Моё имя: Иван\n\n/*\nivan = {\n   name: "Иван",\n   sayHi: функция\n}\n*/`</script><code-toolbar></code-toolbar></code-example><h2><a name="3" href="#3">Локальные переменные</a></h2><p>В функции-конструкторе бывает удобно объявить вспомогательные локальные переменные и вложенные функции, которые будут видны только внутри:</p><code-example><script>`function User(firstName, lastName) {\nMARK  // вспомогательная переменная\nMARK  var phrase = "Привет";\nMARK&nbsp\nMARK  //  вспомогательная вложенная функция\nMARK  function getFullName() {\nMARK      return firstName + "&nbsp" + lastName;\nMARK    }\n\n  this.sayHi = function() {\n    alert( phrase + ",&nbsp" + getFullName() ); // использование\n  };\n}\n\nvar vasya = new User("Вася", "Петров");\nvasya.sayHi(); // Привет, Вася Петров`</script><code-toolbar></code-toolbar></code-example><p>Мы уже говорили об этом подходе ранее, в главе <a data-load_page="50">Локальные переменные для объекта</a>.</p><p>Те функции и данные, которые должны быть доступны для внешнего кода, мы пишем в <code>this</code> – и к ним можно будет обращаться, как например <code>vasya.sayHi()</code>, а вспомогательные, которые нужны только внутри самого объекта, сохраняем в локальной области видимости.</p><h2><a name="4" href="#4">Итого</a></h2><p>Объекты могут быть созданы при помощи функций-конструкторов:</p><ul><li>Любая функция может быть вызвана с <code>new</code>, при этом она получает новый пустой объект в качестве <code>this</code>, в который она добавляет свойства. Если функция не решит возвратить свой объект, то её результатом будет <code>this</code>.</li><li>Функции, которые предназначены для создания объектов, называются <em>конструкторами</em>. Их названия пишут с большой буквы, чтобы отличать от обычных.</li></ul><h2 id="tasks"><a href="#5" name="5">Задачи (4)</a></h2><task-content><h3><a href="#9" name="9">Две функции один объект</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 2</span><p>Возможны ли такие функции <code>A</code> и <code>B</code> в примере ниже, что соответствующие объекты <code>a,b</code> равны (см. код ниже)?</p><code-example><script>`function A() { ... }\nfunction B() { ... }\n\nvar a = new A;\nvar b = new B;\n\nalert( a == b ); // true`</script></code-example><p>Если да – приведите пример кода с такими функциями.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer style=""><close- title="закрыть" data-close_answer=""></close-><p>Да, возможны.</p><p>Они должны возвращать одинаковый объект. При этом если функция возвращает объект, то <code>this</code> не используется.</p><p>Например, они могут вернуть один и тот же объект <code>obj</code>, определённый снаружи:</p><code-example><script>`var obj = {};\n\nfunction A() { return obj; }\nfunction B() { return obj; }\n\nvar a = new A;\nvar b = new B;\n\nalert( a == b ); // true`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#10" name="10">Создать Calculator при помощи конструктора</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Напишите <em>функцию-конструктор</em><code>Calculator</code>, которая создает объект с тремя методами:</p><ul><li>Метод <code>read()</code> запрашивает два значения при помощи <code>prompt</code> и запоминает их в свойствах объекта.</li><li>Метод <code>sum()</code> возвращает сумму запомненных свойств.</li><li>Метод <code>mul()</code> возвращает произведение запомненных свойств.</li></ul><p>Пример использования:</p><code-example><script>`var calculator = new Calculator();\ncalculator.read();\n\nalert( "Сумма =&nbsp" + calculator.sum() );\nalert( "Произведение =&nbsp" + calculator.mul() );`</script></code-example><p><a data-run_demo="">Запустить демо</a></p><p><a href="http://plnkr.co/edit/M942Wb9VlGCECpyNVkUc?p=preview" target="_blank" data-plunk-id="M942Wb9VlGCECpyNVkUc">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`function Calculator() {\n\n  this.read = function() {\n    this.a = +prompt(\'a?\', 0);\n    this.b = +prompt(\'b?\', 0);\n  };\n\n  this.sum = function() {\n    return this.a + this.b;\n  };\n\n  this.mul = function() {\n    return this.a * this.b;\n  };\n}\n\nvar calculator = new Calculator();\ncalculator.read();\n\nalert( "Сумма =&nbsp" + calculator.sum() );\nalert( "Произведение =&nbsp" + calculator.mul() );`</script><code-toolbar></code-toolbar></code-example><p><a href="http://plnkr.co/edit/H3LbAZLRWAK1SSLhhelt?p=preview" target="_blank" data-plunk-id="H3LbAZLRWAK1SSLhhelt">Открыть решение с тестами в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#11" name="11">Создать Accumulator при помощи конструктора</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Напишите <em>функцию-конструктор</em><code>Accumulator(startingValue)</code>.Объекты, которые она создает, должны хранить текущую сумму и прибавлять к ней то, что вводит посетитель.</p><p>Более формально, объект должен:</p><ul><li>Хранить текущее значение в своём свойстве <code>value</code>. Начальное значение свойства <code>value</code> ставится конструктором равным <code>startingValue</code>.</li><li>Метод <code>read()</code> вызывает <code>prompt</code>, принимает число и прибавляет его к свойству <code>value</code>.</li></ul><p>Таким образом, свойство <code>value</code> является текущей суммой всего, что ввел посетитель при вызовах метода <code>read()</code>, с учетом начального значения <code>startingValue</code>.</p><p>Ниже вы можете посмотреть работу кода:</p><code-example><script>`var accumulator = new Accumulator(1); // начальное значение 1\naccumulator.read(); // прибавит ввод prompt к текущему значению\naccumulator.read(); // прибавит ввод prompt к текущему значению\nalert( accumulator.value ); // выведет текущее значение`</script></code-example><p><a data-run_demo="">Запустить демо</a></p><p><a href="http://plnkr.co/edit/q9GvjV9VewLMVTT2qxjt?p=preview" target="_blank" data-plunk-id="q9GvjV9VewLMVTT2qxjt">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`function Accumulator(startingValue) {\n  this.value = startingValue;\n\n  this.read = function() {\n    this.value += +prompt('Сколько добавлять будем?', 0);\n  };\n\n}\n\nvar accumulator = new Accumulator(1);\naccumulator.read();\naccumulator.read();\nalert( accumulator.value );`</script><code-toolbar></code-toolbar></code-example><p><a href="http://plnkr.co/edit/7K379UAzQqjb5z0bN2aK?p=preview" target="_blank" data-plunk-id="7K379UAzQqjb5z0bN2aK">Открыть решение с тестами в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#12" name="12">Создайте калькулятор</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Напишите конструктор <code>Calculator</code>, который создаёт расширяемые объекты-калькуляторы.</p><p>Эта задача состоит из двух частей, которые можно решать одна за другой.</p><ol><li><p>Первый шаг задачи: вызов <code>calculate(str)</code> принимает строку, например «1 + 2», с жёстко заданным форматом «ЧИСЛО операция ЧИСЛО» (по одному пробелу вокруг операции), и возвращает результат. Понимает плюс <code>+</code> и минус <code>-</code>.</p><p>Пример использования:</p><code-example><script>`var calc = new Calculator;\n\nalert( calc.calculate("3 + 7") ); // 10`</script></code-example></li><li><p>Второй шаг – добавить калькулятору метод <code>addMethod(name, func)</code>, который учит калькулятор новой операции. Он получает имя операции <code>name</code> и функцию от двух аргументов <code>func(a,b)</code>, которая должна её реализовывать.</p><p>Например, добавим операции умножить <code>*</code>, поделить <code>/</code> и возвести в степень <code>**</code>:</p><code-example><script>`var powerCalc = new Calculator;\npowerCalc.addMethod("*", function(a, b) {\n  return a * b;\n});\npowerCalc.addMethod("/", function(a, b) {\n  return a / b;\n});\npowerCalc.addMethod("**", function(a, b) {\n  return Math.pow(a, b);\n});\n\nvar result = powerCalc.calculate("2 ** 3");\nalert( result ); // 8`</script></code-example></li></ol><ul><li>Поддержка скобок и сложных математических выражений в этой задаче не требуется.</li><li>Числа и операции могут состоять из нескольких символов. Между ними ровно один пробел.</li><li>Предусмотрите обработку ошибок. Какая она должна быть – решите сами.</li></ul><p><a href="http://plnkr.co/edit/146ePHt25MEYQCWweXGy?p=preview" target="_blank" data-plunk-id="146ePHt25MEYQCWweXGy">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`function Calculator() {\n\n  var methods = {\n    "-": function(a, b) {\n      return a - b;\n    },\n    "+": function(a, b) {\n      return a + b;\n    }\n  };\n\n  this.calculate = function(str) {\n\n    var split = str.split(\' \'),\n      a = +split[0],\n      op = split[1],\n      b = +split[2]\n\n    if (!methods[op] || isNaN(a) || isNaN(b)) {\n      return NaN;\n    }\n\n    return methods[op](a, b);\n  }\n\n  this.addMethod = function(name, func) {\n    methods[name] = func;\n  };\n}\n\nvar calc = new Calculator;\n\ncalc.addMethod("*", function(a, b) {\n  return a * b;\n});\ncalc.addMethod("/", function(a, b) {\n  return a / b;\n});\ncalc.addMethod("**", function(a, b) {\n  return Math.pow(a, b);\n});\n\nvar result = calc.calculate("2 ** 3");\nalert( result ); // 8`</script><code-toolbar></code-toolbar></code-example><ul><li>Обратите внимание на хранение методов. Они просто добавляются к внутреннему объекту.</li><li>Все проверки и преобразование к числу производятся в методе <code>calculate</code>. В дальнейшем он может быть расширен для поддержки более сложных выражений.</li></ul><p><a href="http://plnkr.co/edit/GXNJ3JYeNScD1vGgkgsP?p=preview" target="_blank" data-plunk-id="GXNJ3JYeNScD1vGgkgsP">Открыть решение с тестами в песочнице.</a></p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Преобразование объектов: toString и valueOf; Дескрипторы, геттеры и сеттеры свойств"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/constructor-new", disqus_identifier = "constructor-new", disqus_title = "\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 \u0447\u0435\u0440\u0435\u0437 \"new\"";</script></page-content></main>