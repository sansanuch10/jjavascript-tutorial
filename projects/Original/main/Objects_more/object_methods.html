<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="54">Методы объектов и контекст вызова</a></nav-up><h1>Методы объектов, this</h1><p>До этого мы говорили об объекте лишь как о хранилище значений. Теперь пойдём дальше и поговорим об объектах как о сущностях со своими функциями («методами»).</p><h2><a name="0" href="#0">Методы у объектов</a></h2><p>При объявлении объекта можно указать свойство-функцию, например:</p><code-example><script>`var user = {\n  name: 'Василий',\n\n\nMARK  // метод\n  sayHi: function() {\n    alert( 'Привет!' );\n  }\n\n};\n\nMARK// Вызов\nMARKuser.sayHi();`</script><code-toolbar></code-toolbar></code-example><p>Свойства-функции называют «методами» объектов. Их можно добавлять и удалять в любой момент, в том числе и явным присваиванием:</p><code-example><script>`var user = {\n  name: 'Василий'\n};\n\nMARKuser.sayHi = function() { // присвоили метод после создания объекта\nMARK  alert('Привет!');\nMARK};\n\n// Вызов метода:\nMARKuser.sayHi();`</script><code-toolbar></code-toolbar></code-example><h2><a name="1" href="#1">Доступ к объекту через this</a></h2><p>Для полноценной работы метод должен иметь доступ к данным объекта. В частности, вызов <code>user.sayHi()</code> может захотеть вывести имя пользователя.</p><p><strong>Для доступа к текущему объекту из метода используется ключевое слово <code>this</code></strong>.</p><p>Значением <code>this</code> является объект перед «точкой», в контексте которого вызван метод, например:</p><code-example><script>`var user = {\n  name: 'Василий',\n\n  sayHi: function() {\n    alert( HIGHthis.nameLIGHT );\n  }\n};\n\nuser.sayHi(); // sayHi в контексте user`</script><code-toolbar></code-toolbar></code-example><p>Здесь при выполнении функции <code>user.sayHi()</code> в <code>this</code> будет храниться ссылка на текущий объект <code>user</code>.</p><p>Вместо <code>this</code> внутри <code>sayHi</code> можно было бы обратиться к объекту, используя переменную <code>user</code>:</p><code-example><script>`...\n  sayHi: function() {\n    alert( HIGHuser.nameLIGHT );\n  }\n...`</script></code-example><p>…Однако, такое решение нестабильно. Если мы решим скопировать объект в другую переменную, например <code>admin = user</code>, а в переменную <code>user</code> записать что-то другое – обращение будет совсем не по адресу:</p><code-example><script>`var user = {\n  name: 'Василий',\n\n  sayHi: function() {\n    alert( HIGHuser.nameLIGHT ); // приведёт к ошибке\n  }\n};\n\nvar admin = user;\nuser = null;\n\nadmin.sayHi(); // упс! внутри sayHi обращение по старому имени, ошибка!`</script><code-toolbar></code-toolbar></code-example><p>Использование <code>this</code> гарантирует, что функция работает именно с тем объектом, в контексте которого вызвана.</p><p>Через <code>this</code> метод может не только обратиться к любому свойству объекта, но и передать куда-то ссылку на сам объект целиком:</p><code-example><script>`var user = {\n  name: 'Василий',\n\nMARK  sayHi: function() {\nMARK    showName(this); // передать текущий объект в showName\nMARK  }\n};\n\nfunction showName(namedObj) {\n  alert( namedObj.name );\n}\n\nuser.sayHi(); // Василий`</script><code-toolbar></code-toolbar></code-example><h2><a name="2" href="#2">Подробнее про this</a></h2><p>Любая функция может иметь в себе <code>this</code>. Совершенно неважно, объявлена ли она в объекте или отдельно от него.</p><p>Значение <code>this</code> называется <em>контекстом вызова</em> и будет определено в момент вызова функции.</p><p>Например, такая функция, объявленная без объекта, вполне допустима:</p><code-example><script>`function sayHi() {\n  alert( HIGHthis.firstNameLIGHT );\n}`</script></code-example><p>Эта функция ещё не знает, каким будет <code>this</code>. Это выяснится при выполнении программы.</p><p><strong>Если одну и ту же функцию запускать в контексте разных объектов, она будет получать разный <code>this</code>:</strong></p><code-example><script>`var user = { firstName: "Вася" };\nvar admin = { firstName: "Админ" };\n\nfunction func() {\n  alert( this.firstName );\n}\n\nuser.f = func;\nadmin.g = func;\n\nMARK// this равен объекту перед точкой:\nMARKuser.f(); // Вася\nMARKadmin.g(); // Админ\nMARKadmin[\'g\'](); // Админ (не важно, доступ к объекту через точку или квадратные скобки)`</script><code-toolbar></code-toolbar></code-example><p>Итак, значение <code>this</code> не зависит от того, как функция была создана, оно определяется исключительно в момент вызова.</p><h2><a name="3" href="#3">Значение this при вызове без контекста</a></h2><p>Если функция использует <code>this</code> – это подразумевает работу с объектом. Но и прямой вызов <code>func()</code> технически возможен.</p><p>Как правило, такая ситуация возникает при ошибке в разработке.</p><p>При этом <code>this</code> получает значение <code>window</code>, глобального объекта:</p><code-example><script>`function func() {\n  alert(this); // выведет [object Window] или [object global]\n}\n\nfunc();`</script><code-toolbar></code-toolbar></code-example><p>Таково поведение в старом стандарте.</p><p>А в режиме <code>use strict</code> вместо глобального объекта <code>this</code> будет <code>undefined</code>:</p><code-example><script>`function func() {\n  "use strict";\n  alert(this); // выведет undefined (кроме IE9-)\n}\n\nfunc();`</script><code-toolbar></code-toolbar></code-example><p>Обычно если в функции используется <code>this</code>, то она, всё же, служит для вызова в контексте объекта, так что такая ситуация – скорее исключение.</p><h2><a name="4" href="#4">Ссылочный тип</a></h2><p>Контекст <code>this</code> никак не привязан к функции, даже если она создана в объявлении объекта. Чтобы <code>this</code> передался, нужно вызвать функцию именно через точку (или квадратные скобки).</p><p>Любой более хитрый вызов приведёт к потере контекста, например:</p><code-example><script>`var user = {\n  name: "Вася",\n  hi: function() { alert(this.name); },\n  bye: function() { alert("Пока"); }\n};\n\nuser.hi(); // Вася (простой вызов работает)\n\nMARK// а теперь вызовем user.hi или user.bye в зависимости от имени\nMARK(user.name == "Вася" ? user.hi : user.bye)(); // undefined`</script><code-toolbar></code-toolbar></code-example><p>В последней строке примера метод получен в результате выполнения тернарного оператора и тут же вызван. Но <code>this</code> при этом теряется.</p><p>Если хочется понять, почему, то причина кроется в деталях работы вызова <code>obj.method()</code>.</p><p>Он ведь, на самом деле, состоит из двух независимых операций: точка <code>.</code> – получение свойства и скобки <code>()</code> – его вызов (предполагается, что это функция).</p><p>Функция, как мы говорили раньше, сама по себе не запоминает контекст. Чтобы «донести его» до скобок, JavaScript применяет «финт ушами» – точка возвращает не функцию, а значение специального «ссылочного» типа <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-reference-specification-type">Reference Type</a>.</p><p>Этот тип представляет собой связку «base-name-strict», где:</p><ul><li><em>base</em> – как раз объект,</li><li><em>name</em> – имя свойства,</li><li><em>strict</em> – вспомогательный флаг для передачи <code>use strict</code>.</li></ul><p>То есть, ссылочный тип (Reference Type) – это своеобразное «три-в-одном». Он существует исключительно для целей спецификации, мы его не видим, поскольку любой оператор тут же от него избавляется:</p><ul><li>Скобки <code>()</code> получают из <code>base</code> значение свойства <code>name</code> и вызывают в контексте base.</li><li>Другие операторы получают из <code>base</code> значение свойства <code>name</code> и используют, а остальные компоненты игнорируют.</li></ul><p>Поэтому любая операция над результатом операции получения свойства, кроме вызова, приводит к потере контекста.</p><p>Аналогично работает и получение свойства через квадратные скобки <code>obj[method]</code>.</p><h2 id="tasks"><a href="#5" name="5">Задачи (8)</a></h2><task-content><h3><a href="#7" name="7">Вызов в контексте массива</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Каким будет результат? Почему?</p><code-example><script>`var arr = ["a", "b"];\n\narr.push(function() {\n  alert(this);\n})\n\narr[2](); // ?`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer style=""><close- title="закрыть" data-close_answer=""></close-><p>Вызов <code>arr[2]()</code> – это обращение к методу объекта <code>obj[method]()</code>, в роли <code>obj</code> выступает <code>arr</code>, а в роли метода: <code>2</code>.</p><p>Поэтому, как это бывает при вызове функции как метода, функция <code>arr[2]</code> получит <code>this = arr</code> и выведет массив:</p><code-example><script>`var arr = ["a", "b"];\n\narr.push(function() {\n  alert(this);\n})\n\narr[2](); // "a","b",function`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#8" name="8">Проверка синтаксиса</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 2</span><p>Каков будет результат этого кода?</p><code-example><script>`var obj = {\n  go: function() { alert(this) }\n}\n\n(obj.go)()`</script></code-example><p>P.S. Есть подвох :)</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p><strong>Ошибка</strong>!</p><p>Попробуйте:</p><code-example><script>`var obj = {\n  go: function() {\n    alert(this)\n  }\n}\n\n(obj.go)() // error!`</script><code-toolbar></code-toolbar></code-example><p>Причем сообщение об ошибке в большинстве браузеров не даёт понять, что на самом деле не так.</p><p><strong>Ошибка возникла из-за того, что после объявления <code>obj</code> пропущена точка с запятой.</strong></p><p>JavaScript игнорирует перевод строки перед скобкой <code>(obj.go)()</code> и читает этот код как:</p><code-example><script>`var obj = { go:... }(obj.go)()`</script></code-example><p>Интерпретатор попытается вычислить это выражение, которое обозначает вызов объекта <code>{ go: ... }</code> как функции с аргументом <code>(obj.go)</code>. При этом, естественно, возникнет ошибка.</p></task-answer></task-content><task-content><h3><a href="#9" name="9">Почему this присваивается именно так?</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 3</span><p>Вызовы <code>(1)</code> и <code>(2)</code> в примере ниже работают не так, как <code>(3)</code> и <code>(4)</code>:</p><code-example><script>`"use strict"\n\nvar obj, method;\n\nobj = {\  go: function() { alert(this); }\n};\n\nobj.go();            // (1) object\n\n(obj.go)();          // (2) object\n\n(method = obj.go)();      // (3) undefined\n\n(obj.go || obj.stop)(); // (4) undefined`</script></code-example><p>В чём дело? Объясните логику работы <code>this</code>.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><ol><li><p>Обычный вызов функции в контексте объекта.</p></li><li><p>То же самое, скобки ни на что не влияют.</p></li><li><p>Здесь не просто вызов <code>obj.method()</code>, а более сложный вызов вида <code>(выражение).method()</code>. Такой вызов работает, как если бы он был разбит на две строки:</p><code-example><script>`f = obj.go; // сначала вычислить выражение\nf();  // потом вызвать то, что получилось`</script></code-example><p>При этом <code>f()</code> выполняется как обычная функция, без передачи <code>this</code>.</p></li><li><p>Здесь также слева от точки находится выражение, вызов аналогичен двум строкам.</p></li></ol><p>В спецификации это объясняется при помощи специального внутреннего типа <a href="http://es5.github.com/x8.html#x8.7">Reference Type</a>.</p><p>Если подробнее – то <code>obj.go()</code> состоит из двух операций:</p><ol><li>Сначала получить свойство <code>obj.go</code>.</li><li>Потом вызвать его как функцию.</li></ol><p>Но откуда на шаге 2 получить <code>this</code>? Как раз для этого операция получения свойства <code>obj.go</code> возвращает значение особого типа <code>Reference Type</code>, который в дополнение к свойству <code>go</code> содержит информацию об <code>obj</code>. Далее, на втором шаге, вызов его при помощи скобок <code>()</code> правильно устанавливает <code>this</code>.</p><p><strong>Любые другие операции, кроме вызова, превращают <code>Reference Type</code> в обычный тип, в данном случае – функцию <code>go</code> (так уж этот тип устроен).</strong></p><p>Поэтому получается, что <code>(method = obj.go)</code> присваивает в переменную <code>method</code> функцию <code>go</code>, уже без всякой информации об объекте <code>obj</code>.</p><p>Аналогичная ситуация и в случае <code>(4)</code>: оператор ИЛИ <code>||</code> делает из <code>Reference Type</code> обычную функцию.</p></task-answer></task-content><task-content><h3><a href="#10" name="10">Значение this в объявлении объекта</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Что выведет <code>alert</code> в этом коде? Почему?</p><code-example><script>`var user = {\n  firstName: "Василий",\n\n  export: this\n};\n\nalert( user.export.firstName );`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p><strong>Ответ: <code>undefined</code>.</strong></p><code-example><script>`var user = {\n  firstName: "Василий",\n\nMARK  export: this // (*)\n};\n\nalert( user.export.firstName );`</script><code-toolbar></code-toolbar></code-example><p>Объявление объекта само по себе не влияет на <code>this</code>. Никаких функций, которые могли бы повлиять на контекст, здесь нет.</p><p>Так как код находится вообще вне любых функций, то <code>this</code> в нём равен <code>window</code> (в браузере так всегда для кода вне функций, вне зависимости от <code>use strict</code>).</p><p>Получается, что в строке <code>(*)</code> мы имеем <code>export: window</code>, так что далее <code>alert(user.export.firstName)</code> выводит свойство <code>window.firstName</code>, которое не определено.</p></task-answer></task-content><task-content><h3><a href="#11" name="11">Возврат this</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Что выведет <code>alert</code> в этом коде? Почему?</p><code-example><script>`var name = "";\n\nvar user = {\n  name: "Василий",\n\n  export: function() {\n    return this;\n  }\n\n};\n\nalert( user.export().name );`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer style=""><close- title="закрыть" data-close_answer=""></close-><p><strong>Ответ: <code>Василий</code>.</strong></p><p>Вызов <code>user.export()</code> использует <code>this</code>, который равен объекту до точки, то есть внутри <code>user.export()</code> строка <code>return this</code> возвращает объект <code>user</code>.</p><p>В итоге выводится свойство <code>name</code> объекта <code>user</code>, равное <code>"Василий"</code>.</p></task-answer></task-content><task-content><h3><a href="#12" name="12">Возврат объекта с this</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Что выведет <code>alert</code> в этом коде? Почему?</p><code-example><script>`var name = "";\n\nvar user = {\n  name: "Василий",\n\  export: function() {\n    return {\n      value: this\n    };\n  }\n\n};\n\nalert( user.export().value.name );`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p><strong>Ответ: <code>Василий</code>.</strong></p><p>Во время выполнения <code>user.export()</code> значение <code>this = user</code>.</p><p>При создании объекта <code>{ value: this }</code>, в свойство <code>value</code> копируется ссылка на текущий контекст, то есть на <code>user</code>.</p><p>Получается что <code>user.export().value == user</code>.</p><code-example><script>`var name = "";\n\nvar user = {\n  name: "Василий",\n\n  export: function() {\n    return {\n      value: this\n    };\n  }\n\n};\n\nalert( user.export().value == user ); // true`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#13" name="13">Создайте калькулятор</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Создайте объект <code>calculator</code> с тремя методами:</p><ul><li><code>read()</code> запрашивает <code>prompt</code> два значения и сохраняет их как свойства объекта</li><li><code>sum()</code> возвращает сумму этих двух значений</li><li><code>mul()</code> возвращает произведение этих двух значений</li></ul><code-example><script>`var calculator = {\n  ...ваш код...\n}\n\ncalculator.read();\nalert( calculator.sum() );\nalert( calculator.mul() );`</script></code-example><p><a data-run_demo="">Запустить демо</a></p><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script src="` + window.location.toString().split('#')[0] + `sinon.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    // ...Ваш код...\n\n  <\/script>\n  <script>\n    sinon.stub(window, "prompt");\n\n    prompt.onCall(0).returns("2");\n    prompt.onCall(1).returns("3");\n\n    describe("calculator", function() {\n      before(function() {\n        calculator.read();\n      });\n\n      it("при вводе 2 и 3 сумма равна 5", function() {\n        assert.equal(calculator.sum(), 5);\n      });\n\n      it("при вводе 2 и 3 произведение равно 6", function() {\n        assert.equal(calculator.mul(), 6);\n      });\n    });\n\n    after(function() {\n      prompt.restore();\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="task_7" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="task_7">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`var calculator = {\n  sum: function() {\n    return this.a + this.b;\n  },\n\n  mul: function() {\n    return this.a * this.b;\n  },\n\n  read: function() {\n    this.a = +prompt('a?', 0);\n    this.b = +prompt('b?', 0);\n  }\n}\n\ncalculator.read();\nalert( calculator.sum() );\nalert( calculator.mul() );`</script><code-toolbar></code-toolbar></code-example><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script src="` + window.location.toString().split('#')[0] + `sinon.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    var calculator = {\n      sum: function() {\n        return this.a + this.b;\n      },\n    \n      mul: function() {\n        return this.a * this.b;\n      },\n    \n      read: function() {\n        this.a = +prompt('a?', 0);\n        this.b = +prompt('b?', 0);\n      }\n    }\n\n  <\/script>\n  <script>\n    sinon.stub(window, "prompt");\n\n    prompt.onCall(0).returns("2");\n    prompt.onCall(1).returns("3");\n\n    describe("calculator", function() {\n      before(function() {\n        calculator.read();\n      });\n\n      it("при вводе 2 и 3 сумма равна 5", function() {\n        assert.equal(calculator.sum(), 5);\n      });\n\n      it("при вводе 2 и 3 произведение равно 6", function() {\n        assert.equal(calculator.mul(), 6);\n      });\n    });\n\n    after(function() {\n      prompt.restore();\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="answer_7" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="answer_7">Открыть решение с тестами в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#14" name="14">Цепочка вызовов</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 2</span><p>Есть объект «лестница» ladder:</p><code-example><script>`var ladder = {\n  step: 0,\n  up: function() { // вверх по лестнице\n    this.step++;\n  },\n  down: function() { // вниз по лестнице\n    this.step--;\n  },\n  showStep: function() { // вывести текущую ступеньку\n    alert( this.step );\n  }\n};`</script></code-example><p>Сейчас, если нужно последовательно вызвать несколько методов объекта, это можно сделать так:</p><code-example><script>`ladder.up();\nladder.up();\nladder.down();\nladder.showStep(); // 1`</script></code-example><p>Модифицируйте код методов объекта, чтобы вызовы можно было делать цепочкой, вот так:</p><code-example><script>`ladder.up().up().down().up().down().showStep(); // 1`</script></code-example><p>Как видно, такая запись содержит «меньше букв» и может быть более наглядной.</p><p>Такой подход называется «чейнинг» (chaining) и используется, например, во фреймворке jQuery.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Решение состоит в том, чтобы каждый раз возвращать текущий объект. Это делается добавлением <code>return this</code> в конце каждого метода:</p><code-example><script>`var ladder = {\n  step: 0,\n  up: function() {\n    this.step++;\n    return this;\n  },\n  down: function() {\n    this.step--;\n    return this;\n  },\n  showStep: function() {\n    alert( this.step );\n    return this;\n  }\n}\n\nladder.up().up().down().up().down().showStep(); // 1`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Методы объектов и контекст вызова; Преобразование объектов: toString и valueOf"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/object-methods",disqus_identifier="object-methods",disqus_title="\u041c\u0435\u0442\u043e\u0434\u044b \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432, this";</script></page-content></main>