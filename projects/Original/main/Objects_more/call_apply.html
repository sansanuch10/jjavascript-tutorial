<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="54">Методы объектов и контекст вызова</a></nav-up><h1>Явное указание this: "call", "apply"</h1><p>Итак, мы знаем, что <code>this</code> – это текущий объект при вызове «через точку» и новый объект при конструировании через <code>new</code>.</p><p>В этой главе наша цель получить окончательное и полное понимание <code>this</code> в JavaScript. Для этого не хватает всего одного элемента: способа явно указать <code>this</code> при помощи методов <code>call</code> и <code>apply</code>.</p><h2><a name="0" href="#0">Метод call</a></h2><p>Синтаксис метода <code>call</code>:</p><code-example><script>`func.call(context, arg1, arg2, ...)`</script></code-example><p>При этом вызывается функция <code>func</code>, первый аргумент <code>call</code> становится её <code>this</code>, а остальные передаются «как есть».</p><p><strong>Вызов <code>func.call(context, a, b...)</code> – то же, что обычный вызов <code>func(a, b...)</code>, но с явно указанным <code>this(=context)</code>.</strong></p><p>Например, у нас есть функция <code>showFullName</code>, которая работает с <code>this</code>:</p><code-example><script>`function showFullName() {\n  alert( this.firstName + "&nbsp" + this.lastName );\n}`</script></code-example><p>Пока объекта нет, но это нормально, ведь JavaScript позволяет использовать <code>this</code> везде. Любая функция может в своём коде упомянуть <code>this</code>, каким будет это значение – выяснится в момент запуска.</p><p>Вызов <code>showFullName.call(user)</code> запустит функцию, установив <code>this = user</code>, вот так:</p><code-example><script>`function showFullName() {\n  alert( this.firstName + "&nbsp" + this.lastName );\n}\n\nvar user = {\n  firstName: "Василий",\n  lastName: "Петров"\n};\n\nMARK// функция вызовется с this=user\nMARKshowFullName.call(user) // "Василий Петров"`</script><code-toolbar></code-toolbar></code-example><p>После контекста в <code>call</code> можно передать аргументы для функции. Вот пример с более сложным вариантом <code>showFullName</code>, который конструирует ответ из указанных свойств объекта:</p><code-example><script>`var user = {\n  firstName: "Василий",\n  surname: "Петров",\n  patronym: "Иванович"\n};\n\nfunction showFullName(firstPart, lastPart) {\n  alert( this[firstPart] + "&nbsp" + this[lastPart] );\n}\n\nMARK// f.call(контекст, аргумент1, аргумент2, ...)\nMARKshowFullName.call(user, \'firstName\', \'surname\') // "Василий Петров"\nMARKshowFullName.call(user, \'firstName\', \'patronym\') // "Василий Иванович"`</script><code-toolbar></code-toolbar></code-example><h2><a name="1" href="#1">«Одалживание метода»</a></h2><p>При помощи <code>call</code> можно легко взять метод одного объекта, в том числе встроенного, и вызвать в контексте другого.</p><p>Это называется «одалживание метода» (на англ. <em>method borrowing</em>).</p><p><strong>Используем эту технику для упрощения манипуляций с <code>arguments</code>.</strong></p><p>Как мы знаем, <code>arguments</code> не массив, а обычный объект, поэтому таких полезных методов как <code>push</code>, <code>pop</code>, <code>join</code> и других у него нет. Но иногда так хочется, чтобы были…</p><p>Нет ничего проще! Давайте скопируем метод <code>join</code> из обычного массива:</p><code-example><script>`function printArgs() {\n  arguments.join = [].join; // одолжили метод (1)\n\n  var argStr = arguments.join(':'); // (2)\n\n  alert( argStr ); // сработает и выведет 1:2:3\n}\n\nprintArgs(1, 2, 3);`</script><code-toolbar></code-toolbar></code-example><ol><li>В строке <code>(1)</code> объявлен пустой массив <code>[]</code> и скопирован его метод <code>[].join</code>. Обратим внимание, мы не вызываем его, а просто копируем. Функция, в том числе встроенная – обычное значение, мы можем скопировать любое свойство любого объекта, и <code>[].join</code> здесь не исключение.</li><li>В строке <code>(2)</code> запустили <code>join</code> в контексте <code>arguments</code>, как будто он всегда там был.</li></ol><important-><h3>Почему вызов сработает?</h3><p>Здесь метод <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/join">join</a> массива скопирован и вызван в контексте <code>arguments</code>. Не произойдёт ли что-то плохое от того, что <code>arguments</code> – не массив? Почему он, вообще, сработал?</p><p>Ответ на эти вопросы простой. В соответствии <a href="http://es5.github.com/x15.4.html#x15.4.4.5">со спецификацией</a>, внутри <code>join</code> реализован примерно так:</p><code-example><script>`function join(separator) {\n  if (!this.length) return '';\n\n  var str = this[0];\n\n  for (var i = 1; i < this.length; i++) {\n    str += separator + this[i];\n  }\n\n  return str;\n}`</script></code-example><p>Как видно, используется <code>this</code>, числовые индексы и свойство <code>length</code>. Если эти свойства есть, то все в порядке. А больше ничего и не нужно.</p><p>В качестве <code>this</code> подойдёт даже обычный объект:</p><code-example><script>`var obj = { // обычный объект с числовыми индексами и length\n  0: "А",\n  1: "Б",\n  2: "В",\n  length: 3\n};\n\nMARKobj.join = [].join;\nMARKalert( obj.join(\';\') ); // "A;Б;В"`</script><code-toolbar></code-toolbar></code-example></important-><p>…Однако, копирование метода из одного объекта в другой не всегда приемлемо!</p><p>Представим на минуту, что вместо <code>arguments</code> у нас – произвольный объект. У него тоже есть числовые индексы, <code>length</code> и мы хотим вызвать в его контексте метод <code>[].join</code>. То есть, ситуация похожа на <code>arguments</code>, но (!) вполне возможно, что у объекта есть <em>свой</em> метод <code>join</code>.</p><p>Поэтому копировать <code>[].join</code>, как сделано выше, нельзя: если он перезапишет собственный <code>join</code> объекта, то будет страшный бардак и путаница.</p><p>Безопасно вызвать метод нам поможет <code>call</code>:</p><code-example><script>`function printArgs() {\n  var join = [].join; // скопируем ссылку на функцию в переменную\n\nMARK  // вызовем join с this=arguments,\nMARK  // этот вызов эквивалентен arguments.join(':') из примера выше\nMARK  var argStr = join.call(arguments, ':');\n\n  alert( argStr ); // сработает и выведет 1:2:3\n}\n\nprintArgs(1, 2, 3);`</script><code-toolbar></code-toolbar></code-example><p>Мы вызвали метод без копирования. Чисто, безопасно.</p><h2><a name="2" href="#2">Ещё пример: [].slice.call(arguments)</a></h2><p>В JavaScript есть очень простой способ сделать из <code>arguments</code> настоящий массив. Для этого возьмём метод массива: <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice">slice</a>.</p><p>По стандарту вызов <code>arr.slice(start, end)</code> создаёт новый массив и копирует в него элементы массива <code>arr</code> от <code>start</code> до <code>end</code>. А если <code>start</code> и <code>end</code> не указаны, то копирует весь массив.</p><p>Вызовем его в контексте <code>arguments</code>:</p><code-example><script>`function printArgs() {\n  // вызов arr.slice() скопирует все элементы из this в новый массив\nMARK  var args = [].slice.call(arguments);\n  alert( args.join(',&nbsp') ); // args - полноценный массив из аргументов\n}\n\nprintArgs('Привет', 'мой', 'мир'); // Привет, мой, мир`</script><code-toolbar></code-toolbar></code-example><p>Как и в случае с <code>join</code>, такой вызов технически возможен потому, что <code>slice</code> для работы требует только нумерованные свойства и <code>length</code>. Всё это в <code>arguments</code> есть.</p><h2><a name="3" href="#3">Метод apply</a></h2><p>Если нам неизвестно, с каким количеством аргументов понадобится вызвать функцию, можно использовать более мощный метод: <code>apply</code>.</p><p><strong>Вызов функции при помощи <code>func.apply</code> работает аналогично <code>func.call</code>, но принимает массив аргументов вместо списка.</strong></p><code-example><script>`func.call(context, arg1, arg2);\n// идентичен вызову\nfunc.apply(context, [arg1, arg2]);`</script></code-example><p>В частности, эти две строчки сработают одинаково:</p><code-example><script>`showFullName.call(user, 'firstName', 'surname');\n\nshowFullName.apply(user, ['firstName', 'surname']);`</script></code-example><p>Преимущество <code>apply</code> перед <code>call</code> отчётливо видно, когда мы формируем массив аргументов динамически.</p><p>Например, в JavaScript есть встроенная функция <code>Math.max(a, b, c...)</code>, которая возвращает максимальное значение из аргументов:</p><code-example><script>`alert( Math.max(1, 5, 2) ); // 5`</script><code-toolbar></code-toolbar></code-example><p>При помощи <code>apply</code> мы могли бы найти максимум в произвольном массиве, вот так:</p><code-example><script>`var arr = [];\narr.push(1);\narr.push(5);\narr.push(2);\n\n// получить максимум из элементов arr\nalert( Math.max.apply(null, arr) ); // 5`</script><code-toolbar></code-toolbar></code-example><p>В примере выше мы передали аргументы через массив – второй параметр <code>apply</code>… Но вы, наверное, заметили небольшую странность? В качестве контекста <code>this</code> был передан <code>null</code>.</p><p>Строго говоря, полным эквивалентом вызову <code>Math.max(1,2,3)</code> был бы вызов <code>Math.max.apply(Math, [1,2,3])</code>. В обоих этих вызовах контекстом будет объект <code>Math</code>.</p><p>Но в данном случае в качестве контекста можно передавать что угодно, поскольку в своей внутренней реализации метод <code>Math.max</code> не использует <code>this</code>. Действительно, зачем <code>this</code>, если нужно всего лишь выбрать максимальный из аргументов? Вот так, при помощи <code>apply</code> мы получили короткий и элегантный способ вычислить максимальное значение в массиве!</p><important-><h3>Вызов <code>call/apply</code> с <code>null</code> или <code>undefined</code></h3><p>В современном стандарте <code>call/apply</code> передают <code>this</code> «как есть». А в старом, без <code>use strict</code>, при указании первого аргумента <code>null</code> или <code>undefined</code> в <code>call/apply</code>, функция получает <code>this = window</code>, например:</p><p>Современный стандарт:</p><code-example><script>`function f() {\n  "use strict";\nMARK  alert( this ); // null\n}\n\nf.call(null);`</script><code-toolbar></code-toolbar></code-example><p>Без <code>use strict</code>:</p><code-example><script>`function f() {\n  alert( this ); // window\n}\n\nf.call(null);`</script><code-toolbar></code-toolbar></code-example></important-><h2><a name="4" href="#4">Итого про this</a></h2><p>Значение <code>this</code> устанавливается в зависимости от того, как вызвана функция:</p><ul><li><p>При вызове функции как метода:</p><code-example><script>`obj.func(...) // this = obj\nobj["func"](...)`</script></code-example></li><li><p>При обычном вызове:</p><code-example><script>`func(...) // this = window (ES3) /undefined (ES5)`</script></code-example></li><li><p>В <code>new</code>:</p><code-example><script>`new func() // this = {} (новый объект)`</script></code-example></li><li><p>Явное указание:</p><code-example><script>`func.apply(context, args) // this = context (явная передача)\nfunc.call(context, arg1, arg2, ...)`</script></code-example></li></ul><h2 id="tasks"><a href="#5" name="5">Задачи (2)</a></h2><task-content><h3><a href="#9" name="9">Перепишите суммирование аргументов</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Есть функция <code>sum</code>, которая суммирует все элементы массива:</p><code-example><script>`function sum(arr) {\n  return arr.reduce(function(a, b) {\n    return a + b;\n  });\n}\n\nalert( sum([1, 2, 3]) ); // 6 (=1+2+3)`</script><code-toolbar></code-toolbar></code-example><p>Создайте аналогичную функцию <code>sumArgs()</code>, которая будет суммировать все свои аргументы:</p><code-example><script>`function sumArgs() {\n  /* ваш код */\n}\n\nalert( sumArgs(1, 2, 3) ); // 6, аргументы переданы через запятую, без массива`</script></code-example><p>Для решения примените метод <code>reduce</code> к <code>arguments</code>, используя <code>call</code>, <code>apply</code> или одалживание метода.</p><p>P.S. Функция <code>sum</code> вам не понадобится, она приведена в качестве примера использования <code>reduce</code> для похожей задачи.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><button-answer-ext data-toggle_answer_ext="" style="">Первый вариант</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Первый вариант</h4><code-example><script>`function sumArgs() {\n  // скопируем reduce из массива\n  arguments.reduce = [].reduce;\n  return arguments.reduce(function(a, b) {\n    return a + b;\n  });\n}\n\nalert( sumArgs(4, 5, 6) ); // 15`</script><code-toolbar></code-toolbar></code-example></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Второй вариант</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Второй вариант</h4><p>Метод <code>call</code> здесь вполне подойдёт, так как требуется вызвать <code>reduce</code> в контексте <code>arguments</code> с одним аргументом.</p><code-example><script>`function sumArgs() {\n  // запустим reduce из массива напрямую\n  return [].reduce.call(arguments, function(a, b) {\n    return a + b;\n  });\n}\n\nalert( sumArgs(4, 5, 6) ); // 15`</script><code-toolbar></code-toolbar></code-example></task-answer></task-answer></task-content><task-content><h3><a href="#10" name="10">Примените функцию к аргументам</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Напишите функцию <code>applyAll(func, arg1, arg2...)</code>, которая получает функцию <code>func</code> и произвольное количество аргументов.</p><p>Она должна вызвать <code>func(arg1, arg2...)</code>, то есть передать в <code>func</code> все аргументы, начиная со второго, и возвратить результат.</p><p>Например:</p><code-example><script>`// Применить Math.max к аргументам 2, -2, 3\nalert( applyAll(Math.max, 2, -2, 3) ); // 3\n\n// Применить Math.min к аргументам 2, -2, 3\nalert( applyAll(Math.min, 2, -2, 3) ); // -2`</script></code-example><p>Область применения <code>applyAll</code>, конечно, шире, можно вызывать её и со своими функциями:</p><code-example><script>`function sum() { // суммирует аргументы: sum(1,2,3) = 6\n  return [].reduce.call(arguments, function(a, b) {\n    return a + b;\n  });\n}\n\nfunction mul() { // перемножает аргументы: mul(2,3,4) = 24\n  return [].reduce.call(arguments, function(a, b) {\n    return a * b;\n  });\n}\n\nMARKalert( applyAll(sum, 1, 2, 3) ); // -> sum(1, 2, 3) = 6\nMARKalert( applyAll(mul, 2, 3, 4) ); // -> mul(2, 3, 4) = 24`</script><code-toolbar></code-toolbar></code-example><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script src="` + window.location.toString().split('#')[0] + `sinon.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    // ...Ваш код...\n\n  <\/script>\n  <script>\n    describe("applyAll", function() {\n      it("применяет функцию ко всем аргументам, начиная со 2-го", function() {\n        var min = applyAll(Math.min, 1, 2, 3);\n        assert.equal(min, 1);\n      });\n      it("при отсутствии аргументов просто вызывает функцию", function() {\n        var spy = sinon.spy();\n        applyAll(spy);\n        assert(spy.calledOnce);\n        assert.equal(spy.firstCall.args.length, 0);\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="task_2" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="task_2">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`function sum() {\n  return [].reduce.call(arguments, function(a, b) {\n    return a + b;\n  });\n}\n\nfunction mul() {\n  return [].reduce.call(arguments, function(a, b) {\n    return a * b;\n  });\n}\n\nMARKfunction applyAll(func) {\nMARK    return func.apply(this, [].slice.call(arguments, 1));\nMARK  }\n\nalert( applyAll(sum, 1, 2, 3) ); // 6\nalert( applyAll(mul, 2, 3, 4) ); // 24\nalert( applyAll(Math.max, 2, -2, 3) ); // 3\nalert( applyAll(Math.min, 2, -2, 3) ); // -2`</script><code-toolbar></code-toolbar></code-example><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script src="` + window.location.toString().split('#')[0] + `sinon.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    function applyAll(func) {\n      return func.apply(this, [].slice.call(arguments, 1));\n    }\n\n  <\/script>\n  <script>\n    describe("applyAll", function() {\n      it("применяет функцию ко всем аргументам, начиная со 2-го", function() {\n        var min = applyAll(Math.min, 1, 2, 3);\n        assert.equal(min, 1);\n      });\n      it("при отсутствии аргументов просто вызывает функцию", function() {\n        var spy = sinon.spy();\n        applyAll(spy);\n        assert(spy.calledOnce);\n        assert.equal(spy.firstCall.args.length, 0);\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="answer_2" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="answer_2">Открыть решение с тестами в песочнице.</a></p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Статические и фабричные методы; Привязка контекста и карринг: 'bind'"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/call-apply",disqus_identifier="call-apply",disqus_title="\u042f\u0432\u043d\u043e\u0435 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435 this: \"call\", \"apply\"";</script></page-content></main>