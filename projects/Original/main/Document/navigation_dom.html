<main> <page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="99">Документ и объекты страницы</a></nav-up><h1>Навигация по DOM-элементам</h1><p>DOM позволяет делать что угодно с HTML-элементом и его содержимым, но для этого нужно сначала нужный элемент получить.</p><p>Доступ к DOM начинается с объекта <code>document</code>. Из него можно добраться до любых узлов.</p><p>Так выглядят основные ссылки, по которым можно переходить между узлами DOM:</p><figure><img src="dom-links.png" style="max-width:420px" width="100%"></figure><p>Посмотрим на них повнимательнее.</p><h2><a name="0" href="#0">Сверху documentElement и body</a></h2><p>Самые верхние элементы дерева доступны напрямую из <code>document</code>.</p><dl><dt><code>&lt;HTML&gt;</code>= <code>document.documentElement</code></dt><dd>Первая точка входа – <code>document.documentElement</code>. Это свойство ссылается на DOM-объект для тега <code>&lt;html&gt;</code>.</dd><dt><code>&lt;BODY&gt;</code>= <code>document.body</code></dt><dd>Вторая точка входа – <code>document.body</code>, который соответствует тегу <code>&lt;body&gt;</code>.</dd></dl><p>В современных браузерах (кроме IE8-) также есть <code>document.head</code> – прямая ссылка на <code>&lt;head&gt;</code></p><important-warn><h3>Есть одна тонкость: <code>document.body</code> может быть равен <code>null</code></h3><p>Нельзя получить доступ к элементу, которого еще не существует в момент выполнения скрипта.</p><p>В частности, если скрипт находится в <code>&lt;head&gt;</code>, то в нём недоступен <code>document.body</code>.</p><p>Поэтому в следующем примере первый <code>alert</code> выведет <code>null</code>:</p><code-example><script>`<!DOCTYPE HTML>\n<html>\n\n<head>\n  <script>\n    alert( "Из HEAD:&nbsp" + document.body ); // null, body ещё нет\n  <\/script>\n</head>\n\n<body>\n\n  <script>\n    alert( "Из BODY:&nbsp" + document.body ); // body есть\n  <\/script>\n\n</body>\n\n</html>`</script><code-toolbar- iframe=""><a title="показать" data-code_run=""></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example></important-warn><important-><h3>В DOM активно используется <code>null</code></h3><p>В мире DOM в качестве значения, обозначающего «нет такого элемента» или «узел не найден», используется не <code>undefined</code>, а <code>null</code>.</p></important-><h2><a name="1" href="#1">Дети: childNodes, firstChild, lastChild</a></h2><p>Здесь и далее мы будем использовать два принципиально разных термина.</p><ul><li><strong>Дочерние элементы (или дети)</strong> – элементы, которые лежат <em>непосредственно</em> внутри данного. Например, внутри <code>&lt;HTML&gt;</code> обычно лежат <code>&lt;HEAD&gt;</code> и <code>&lt;BODY&gt;</code>.</li><li><strong>Потомки</strong> – все элементы, которые лежат внутри данного, вместе с их детьми, детьми их детей и так далее. То есть, всё поддерево DOM.</li></ul><p>Псевдо-массив <code>childNodes</code> хранит все дочерние элементы, включая текстовые.</p><p>Пример ниже последовательно выведет дочерние элементы <code>document.body</code>:</p><code-example><script>`<!DOCTYPE HTML>\n<html>\n\n<body>\n  <div>Начало</div>\n\n  <ul>\n    <li>Информация</li>\n  </ul>\n\n  <div>Конец</div>\n\n  <script>\nMARK    for (var i = 0; i < document.body.childNodes.length; i++) {\nMARK      alert( document.body.childNodes[i] ); // Text, DIV, Text, UL, ..., SCRIPT\nMARK    }\n  <\/script>\n  ...\n</body>\n\n</html>`</script><code-toolbar iframe="125"><a title="показать" data-code_run="250"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>Обратим внимание на маленькую деталь. Если запустить пример выше, то последним будет выведен элемент <code>&lt;script&gt;</code>. На самом-то деле в документе есть ещё текст (обозначенный троеточием), но на момент выполнения скрипта браузер ещё до него не дошёл.</p><p>Пробельный узел будет в <em>итоговом документе</em>, но его еще нет на момент выполнения скрипта.</p><important-warn><h3>Список детей – только для чтения!</h3><p>Скажем больше – все навигационные свойства, которые перечислены в этой главе – только для чтения. Нельзя просто заменить элемент присвоением <code>childNodes[i]=...</code>.</p><p>Изменение DOM осуществляется другими методами, которые мы рассмотрим далее, все навигационные ссылки при этом обновляются автоматически.</p></important-warn><p>Свойства <code>firstChild</code> и <code>lastChild</code> обеспечивают быстрый доступ к первому и последнему элементу.</p><p>При наличии дочерних узлов всегда верно:</p><code-example><script>`elem.childNodes[0] === elem.firstChild\nelem.childNodes[elem.childNodes.length - 1] === elem.lastChild`</script></code-example><h2><a name="2" href="#2">Коллекции – не массивы</a></h2><p>DOM-коллекции, такие как <code>childNodes</code> и другие, которые мы увидим далее, не являются JavaScript-массивами.</p><p>В них нет методов массивов, таких как <code>forEach</code>, <code>map</code>, <code>push</code>, <code>pop</code> и других.</p><code-example><script>`var elems = window.parent.document.body.children[0].childNodes;\n\nelems.HIGHforEachLIGHT(function(elem) { // разве нет такого метода?!\n  /* ... */\n  console.log(elem.tagName);\n});`</script><code-toolbar></code-toolbar></code-example><p>Именно поэтому <code>childNodes</code> и называют «коллекция» или «псевдомассив».</p><p>Можно для перебора коллекции использовать обычный цикл <code>for(var i=0;i&lt;elems.length;i++) ...</code> Но что делать, если уж очень хочется воспользоваться методами массива?</p><p>Это возможно, основных варианта два:</p><ol><li><p>Применить метод массива через <code>call/apply</code>:</p><code-example><script>`var elems = document.documentElement.childNodes;\n\nMARK[].forEach.call(elems, function(elem) {\n  alert( elem.tagName || elem ); // HEAD, текст, BODY\n});`</script><code-toolbar></code-toolbar></code-example><code-example><script>`var elems = window.parent.document.body.children[0].childNodes;\n\nalert('tags:&nbsp' + [].HIGHmapLIGHT.call(elems, (elem) => { return elem.tagName }));\nalert('tags maybe:&nbsp' + elems.HIGHmapLIGHT((elem) => { return elem.tagName }));`</script><code-toolbar></code-toolbar></code-example></li><li><p>При помощи <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice">Array.prototype.slice</a> сделать из коллекции массив.</p><p>Обычно вызов <code>arr.slice(a, b)</code> делает новый массив и копирует туда элементы <code>arr</code> с индексами от <code>a</code> до <code>b-1</code> включительно. Если же вызвать его без аргументов <code>arr.slice()</code>, то он делает новый массив и копирует туда все элементы <code>arr</code>.</p><p>Это работает и для коллекции:</p><code-example><script>`var elems = document.documentElement.childNodes;\nMARKelems = Array.prototype.slice.call(elems); // теперь elems - массив\n\nelems.HIGHforEachLIGHT(function(elem) {\n  alert( elem.tagName || elem ); // HEAD, текст, BODY\n});\n\nalert('tags:&nbsp' + elems.HIGHmapLIGHT((elem) => { return elem.tagName }));`</script><code-toolbar></code-toolbar></code-example></li></ol><important-warn><h3>Нельзя перебирать коллекцию через <code>for..in</code></h3><p>Ранее мы говорили, что не рекомендуется использовать для перебора массива цикл <code>for..in</code>.</p><p><strong>Коллекции – наглядный пример, почему нельзя. Они похожи на массивы, но у них есть свои свойства и методы, которых в массивах нет.</strong></p><p>К примеру, код ниже должен перебрать все дочерние элементы <code>&lt;html&gt;</code>. Их, естественно, два: <code>&lt;head&gt;</code> и <code>&lt;body&gt;</code>. Максимум, три, если взять ещё и текст между ними.</p><p>Но в примере ниже <code>alert</code> сработает не три, а целых 8 раз!</p><code-example><script>`var elems = document.documentElement.childNodes;\n\nfor (var key in elems) {\n  alert( key ); // 0, 1, length, item, entries, forEach, keys, values\n}`</script><code-toolbar></code-toolbar></code-example><p>Цикл <code>for..in</code> выведет не только ожидаемые индексы <code>0</code>, <code>1</code>, <code>2</code>, по которым лежат узлы в коллекции, но и свойство <code>length</code> (в коллекции оно enumerable), а также функцию <code>item(n)</code> – она никогда не используется, возвращает <code>n-й</code> элемент коллекции, проще обратиться по индексу <code>[n]</code>.</p><p>В реальном коде нам нужны только элементы, мы же будем работать с ними, а служебные свойства – не нужны. Поэтому желательно использовать <code>for(var i=0;i&lt;elems.length;i++)</code>.</p></important-warn><h2><a name="3" href="#3">Соседи и родитель</a></h2><p>Доступ к элементам слева и справа данного можно получить по ссылкам <code>previousSibling</code>/ <code>nextSibling</code>.</p><p>Родитель доступен через <code>parentNode</code>. Если долго идти от одного элемента к другому, то рано или поздно дойдёшь до корня DOM, то есть до <code>document.documentElement</code>, а затем и <code>document</code>.</p><h2><a name="4" href="#4">Навигация только по элементам</a></h2><p>Навигационные ссылки, описанные выше, равно касаются всех узлов в документе. В частности, в <code>childNodes</code> сосуществуют и текстовые узлы и узлы-элементы и узлы-комментарии, если есть.</p><p>Но для большинства задач текстовые узлы нам не интересны.</p><p>Поэтому посмотрим на дополнительный набор ссылок, которые их не учитывают:</p><figure><img src="dom-links-elements.png" style="max-width:440px" width="100%"></figure><p>Эти ссылки похожи на те, что раньше, только в ряде мест стоит слово <code>Element</code>:</p><ul><li><code>children</code> – только дочерние узлы-элементы, то есть соответствующие тегам.</li><li><code>firstElementChild</code>, <code>lastElementChild</code> – соответственно, первый и последний дети-элементы.</li><li><code>previousElementSibling</code>, <code>nextElementSibling</code> – соседи-элементы.</li><li><code>parentElement</code> – родитель-элемент.</li></ul><important-><h3>Зачем <code>parentElement</code>? Неужели бывают родители не-элементы?</h3><p>Свойство <code>elem.parentNode</code> возвращает родитель элемента.</p><p>Оно всегда равно <code>parentElement</code>, кроме одного исключения:</p><code-example><script>`alert( document.documentElement.parentNode ); // document\nalert( document.documentElement.parentElement ); // null`</script><code-toolbar></code-toolbar></code-example><p>Иногда это имеет значение, если хочется перебрать всех предков и вызвать какой-то метод, а на документе его нет.</p></important-><p>Модифицируем предыдущий пример, применив <code>children</code> вместо <code>childNodes</code>.</p><p>Теперь он будет выводить не все узлы, а только узлы-элементы:</p><code-example><script>`<!DOCTYPE HTML>\n<html>\n\n<body>\n  <div>Начало</div>\n\n  <ul>\n    <li>Информация</li>\n  </ul>\n\n  <div>Конец</div>\n\n  <script>\nMARK    for (var i = 0; i < document.body.children.length; i++) {\nMARK      alert( document.body.children[i].tagName ); // DIV, UL, DIV, SCRIPT\nMARK    }\n  <\/script>\n  ...\n</body>\n\n</html>`</script><code-toolbar iframe="125"><a title="показать" data-code_run="250"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>Всегда верны равенства:</p><code-example><script>`elem.firstElementChild === elem.children[0]\nelem.lastElementChild === elem.children[elem.children.length - 1]`</script></code-example><important-warn><h3>В IE8- поддерживается только <code>children</code></h3><p>Других навигационных свойств в этих браузерах нет. Впрочем, как мы увидим далее, можно легко сделать полифилл, и они, всё же, будут.</p></important-warn><important-warn><h3>В IE8- в <code>children</code> присутствуют узлы-комментарии</h3><p>С точки зрения стандарта это ошибка, но IE8- также включает в <code>children</code> узлы, соответствующие HTML-комментариям.</p><p>Это может привести к сюрпризам при использовании свойства <code>children</code>, поэтому HTML-комментарии либо убирают либо используют фреймворк, к примеру, jQuery, который даёт свои методы перебора и отфильтрует их.</p></important-warn><h2><a name="5" href="#5">Особые ссылки для таблиц</a></h2><p>У конкретных элементов DOM могут быть свои дополнительные ссылки для большего удобства навигации.</p><p>Здесь мы рассмотрим таблицу, так как это важный частный случай и просто для примера.</p><p>В списке ниже выделены наиболее полезные:</p><dl><dt><code>TABLE</code></dt><dd><ul><li><strong><code>table.rows</code></strong> – коллекция строк <code>TR</code> таблицы.</li></ul></dd></dl><ul><li><code>table.caption/tHead/tFoot</code> – ссылки на элементы таблицы <code>CAPTION</code>, <code>THEAD</code>, <code>TFOOT</code>.</li><li><code>table.tBodies</code> – коллекция элементов таблицы <code>TBODY</code>, по спецификации их может быть несколько.</li></ul><dl><dt><code>THEAD/TFOOT/TBODY</code></dt><dd><ul><li><code>tbody.rows</code> – коллекция строк <code>TR</code> секции.</li></ul></dd><dt><code>TR</code></dt><dd><ul><li><strong><code>tr.cells</code></strong> – коллекция ячеек <code>TD/TH</code></li></ul></dd></dl><ul><li><strong><code>tr.sectionRowIndex</code></strong> – номер строки в текущей секции <code>THEAD/TBODY</code></li><li><code>tr.rowIndex</code> – номер строки в таблице</li></ul><dl><dt><code>TD/TH</code></dt><dd><ul><li><strong><code>td.cellIndex</code></strong> – номер ячейки в строке</li></ul></dd></dl><p>Пример использования:</p><code-example><script>`<table>\n  <tr>\n    <td>один</td><td>два</td>\n  </tr>\n  <tr>\n    <td>три</td><td>четыре</td>\n  </tr>\n</table>\n\n<script>\nvar table = document.body.children[0];\n\nalert( table.HIGHrows[0].cells[0]LIGHT.innerHTML ) // "один"\n<\/script>`</script><code-toolbar iframe="70"></code-toolbar></code-example><p>Спецификация: <a href="http://www.w3.org/TR/html5/tabular-data.html">HTML5: tabular data</a>.</p><p>Даже если эти свойства не нужны вам прямо сейчас, имейте их в виду на будущее, когда понадобится пройтись по таблице.</p><p>Конечно же, таблицы – не исключение.</p><p>Аналогичные полезные свойства есть у HTML-форм, они позволяют из формы получить все её элементы, а из них – в свою очередь, форму. Мы рассмотрим их позже.</p><h2><a name="6" href="#6">Интерактивное путешествие</a></h2><p>Для того, чтобы убедиться, что вы разобрались с навигацией по DOM-ссылкам – вашему вниманию предлагается интерактивное путешествие по DOM.</p><p>Ниже вы найдёте документ (в ифрейме), и кнопки для перехода по нему.</p><p>Изначальный элемент – <code>&lt;html&gt;</code>. Попробуйте по ссылкам найти «информацию». Или ещё чего-нибудь.</p><p>Вы также можете открыть документ <a href="traversing_dom.html" target="_blank">в отдельном окне</a> и походить по нему в браузерной консоли разработчика, чтобы лучше понять разницу между показанным там DOM и реальным.</p><p>Разметка:</p><code-example><script>`<!DOCTYPE HTML>\n<html>\n  <head>\n    <meta charset="utf-8">\n    <title>Документ</title>\n  </head>\n  <body>\n    <div id="header">Шапка</div>\n\n    <ul>\n      <li>\n        <span style="background-color:red">Осторожно</span>\n      </li>\n      <li class="info"><input type="text" value="Информация"></li>\n\n    </ul>\n    <div id="footer">Подвал. &copy; javascript.ru</div>\n    <!-- комментарий -->\n  </body>\n</html>`</script></code-example><p>Документ:</p><iframe src="traversing_dom.html" id="travel-dom-iframe" style="height:150px"></iframe><div id="travel-dom-control"><p>Навигация:</p><ul><li><input type="button" data-travel-dir="parentNode" value="Вверх (parentNode)"><ul><li><input type="button" data-travel-dir="previousSibling" value="previousSibling">- <b>Здесь стоите вы <code data-travel-prop="nodeText">[nodeType=ELEMENT_NODE tagName=HTML]</code></b><ul><li><input type="button" data-travel-dir="firstChild" value="firstChild">- <input type="button" data-travel-dir="lastChild" value="lastChild"></li><li><input type="button" data-travel-dir="nextSibling" value="nextSibling" disabled=""></li></ul></li></ul></li></ul><div id="travel-dom-comment">Вы стоите на элементе <code>document.documentElement</code> (тэг <code>&lt;HTML&gt;</code>)</div></div><script src="travel.js"></script><h2><a name="7" href="#7">Итого</a></h2><p>В DOM доступна навигация по соседним узлам через ссылки:</p><ul><li>По любым узлам.</li><li>Только по элементам.</li></ul><p>Также некоторые виды элементов предоставляют дополнительные ссылки для большего удобства, например у таблиц есть свойства для доступа к строкам/ячейкам.</p><h2 id="tasks"><a href="#8" name="8">Задачи (4)</a></h2><task-content><h3><a href="#17" name="17">DOM children</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Для страницы:</p><code-example><script>`<!DOCTYPE HTML>\n<html>\n\n<head>\n  <meta charset="utf-8">\n</head>\n\n<body>\n  <div>Пользователи:</div>\n  <ul>\n    <li>Маша</li>\n    <li>Вовочка</li>\n  </ul>\n\n  <!-- комментарий -->\n\n  <script>\n    // ... ваш код\n  <\/script>\n\n</body>\n\n</html>`</script></code-example><ul><li>Напишите код, который получит элемент <code>HEAD</code>.</li><li>Напишите код, который получит <code>UL</code>.</li><li>Напишите код, который получит второй <code>LI</code>. Будет ли ваш код работать в IE8-, если комментарий переместить <em>между</em> элементами <code>LI</code>?</li></ul><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="" style="">HEAD</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>HEAD</h4><p>Два способа:</p><code-example><script>`document.documentElement.children[0]\ndocument.documentElement.firstChild`</script></code-example><p>Второй способ работает, так как пробелы перед <code>&lt;head&gt;</code> игнорируются.</p><p>Также в современных браузерах доступен <code>document.head</code>.</p></task-answer><button-answer-ext data-toggle_answer_ext="" style="">UL</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>UL</h4><p>Например, так:</p><code-example><script>`document.body.children[1]`</script></code-example></task-answer><button-answer-ext data-toggle_answer_ext="" style="">LI</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>LI</h4><p>Можно так:</p><code-example><script>`document.body.children[1].children[1]; // LI`</script></code-example><p>Может возникнуть проблема с комментарием в IE8-, так как он станет одним из <code>children</code>, в результате последний код станет работать некорректно.</p><p>В последующих разделах учебника мы рассмотрим другие методы поиска по DOM, которые позволят эту проблему обойти.</p></task-answer></task-answer-ext></task-content><task-content><h3><a href="#18" name="18">Проверка существования детей</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Придумайте самый короткий код для проверки, пуст ли элемент <code>elem</code>.</p><p>«Пустой» – значит нет дочерних узлов, даже текстовых.</p><code-example><script>`if (/*...ваш код проверки elem... */) { узел elem пуст }`</script></code-example><p>Что написать в условии <code>if</code> ?</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Вначале нерабочие способы, которые могут прийти на ум:</p><code-example><script>`if (!elem) { .. }`</script></code-example><p>Это не работает, так как <code>elem</code> всегда есть, и является объектом. Так что проверка <code>if (elem)</code> всегда верна, вне зависимости от того, есть ли у <code>elem</code> потомки.</p><code-example><script>`if (!elem.childNodes) { ... }`</script></code-example><p>Тоже не работает, так как псевдо-массив <code>childNodes</code> всегда существует. Он может быть пуст или непуст, но он всегда является объектом, так что проверка <code>if (elem.childNodes)</code> всегда верна.</p><p>Несколько рабочих способов:</p><code-example><script>`if (!elem.childNodes.length) { ... }\n\nif (!elem.firstChild) { ... }\n\nif (!elem.lastChild) { ... }`</script></code-example><p>Также существует метод <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node.hasChildNodes">hasChildNodes</a>, который позволяет вызовом <code>elem.hasChildNodes()</code> определить наличие детей. Он работает так же, как проверка <code>elem.childNodes.length != 0</code>.</p></task-answer></task-content><task-content><h3><a href="#19" name="19">Вопрос по навигационным ссылкам</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Если <code>elem</code> – это произвольный узел DOM…</p><p>Верно ли, что <code>elem.lastChild.nextSibling</code> всегда <code>null</code>?</p><p>Верно ли, что <code>elem.children[0].previousSibling</code> всегда <code>null</code> ?</p><button-answer data-toggle_answer="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><ol><li><p>Да, верно, с оговоркой. Элемент <code>elem.lastChild</code> последний, у него нет правого соседа.</p><p><strong>Оговорка:</strong><code>elem.lastChild.nextSibling</code> выдаст ошибку если <code>elem</code> не имеет детей.</p></li><li><p>Нет, неверно, это может быть текстовый узел. Значением <code>elem.children[0]</code> является первый узел-элемент, перед ним может быть текст.</p><p>Аналогично предыдущему случаю, если у <code>elem</code> нет детей-элементов – будет ошибка.</p></li></ol></task-answer></task-content><task-content><h3><a href="#20" name="20">Выделите ячейки по диагонали</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Напишите код, который выделит все ячейки в таблице по диагонали.</p><p>Вам нужно будет получить из таблицы <code>table</code> все диагональные <code>td</code> и выделить их, используя код:</p><code-example><script>`// в переменной td DOM-элемент для тега <td>\ntd.style.backgroundColor = 'red';`</script></code-example><p>Должно получиться так:</p><figure- style="height:170px"><code-toolbar-><a id="row_red_task" data-code_edit="?" style="display:none"></a><a id="row_red_answer" data-code_edit="" style="display:none"></a></code-toolbar-><style>#table_row_red td{border:1px solid #000;padding:3px 5px;}#table_row_red{border-collapse:collapse;}</style><table id="table_row_red"><tbody><tr><td>1:1</td><td>2:1</td><td>3:1</td><td>4:1</td><td>5:1</td></tr><tr><td>1:2</td><td>2:2</td><td>3:2</td><td>4:2</td><td>5:2</td></tr><tr><td>1:3</td><td>2:3</td><td>3:3</td><td>4:3</td><td>5:3</td></tr><tr><td>1:4</td><td>2:4</td><td>3:4</td><td>4:4</td><td>5:4</td></tr><tr><td>1:5</td><td>2:5</td><td>3:5</td><td>4:5</td><td>5:5</td></tr></tbody></table><script>for (var table=document.getElementById('table_row_red'),i=0;i<table.rows.length;i++){table.rows[i].cells[i].style.background="red"}</script></figure-><p><a data-click="row_red_task">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Для удобства работы с таблицей используем специальные свойства <code>rows</code> и <code>cells</code>.</p><p><a data-click="row_red_answer">Открыть решение в песочнице.</a></p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Работа с DOM из консоли; Поиск: getElement* и querySelector* и не только"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><script>disqus_url="https:\/\/learn.javascript.ru\/traversing-dom",disqus_identifier="traversing-dom",disqus_title="\u041d\u0430\u0432\u0438\u0433\u0430\u0446\u0438\u044f \u043f\u043e DOM-\u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u043c";</script></page-content></main>