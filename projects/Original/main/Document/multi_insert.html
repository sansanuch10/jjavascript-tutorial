<main><script>function bench(e,t){for (var n=0,r=0;r<t;r++){e.setup&&e.setup();var a=new Date;e.work(),n += new Date-a,e.tearDown&&e.tearDown()}return n}var appendFirst=new function(){var e;this.setup=function(){for (e=document.getElementById("bench-table");e.firstChild;) e.removeChild(e.firstChild)},this.work=function(){var t=document.createElement("TBODY");t.id="removable",e.appendChild(t);for (var n=0;n<20;n++){var r=document.createElement("TR");t.appendChild(r);for (var a=0;a<20;a++){var d=document.createElement("td");d.appendChild(document.createTextNode(""+n.toString(20)+a.toString(20))),r.appendChild(d)}}}},appendLast=new function(){var e;this.setup=function(){for (e=document.getElementById("bench-table");e.firstChild;) e.removeChild(e.firstChild)},this.work=function(){var t=document.createElement("TBODY");t.id="removable";for (var n=0;n<20;n++){var r=document.createElement("TR");t.appendChild(r);for (var a=0;a<20;a++){var d=document.createElement("td");r.appendChild(d),d.appendChild(document.createTextNode(""+n.toString(20)+a.toString(20)))}} e.appendChild(t)}};</script><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="99">Документ и объекты страницы</a></nav-up><h1>Мультивставка: insertAdjacentHTML и DocumentFragment</h1><p>Обычные методы вставки работают с одним узлом. Но есть и способы вставлять множество узлов одновременно.</p><h2><a name="0" href="#0">Оптимизация вставки в документ</a></h2><p>Рассмотрим задачу: сгенерировать список <code>UL/LI</code>.</p><p>Есть две возможных последовательности:</p><ol><li><p>Сначала вставить <code>UL</code> в документ, а потом добавить к нему <code>LI</code>:</p><code-example><script>`var ul = document.createElement('ul');\ndocument.body.appendChild(ul); // сначала в документ\nfor (...) ul.appendChild(li); // потом узлы`</script></code-example></li><li><p>Полностью создать список «вне DOM», а потом – вставить в документ:</p><code-example><script>`var ul = document.createElement('ul');\nfor(...) ul.appendChild(li);   // сначала вставить узлы\ndocument.body.appendChild(ul); // затем в документ`</script></code-example></li></ol><p>Как ни странно, между этими последовательностями есть разница. В большинстве браузеров, второй вариант – быстрее.</p><p>Почему же? Иногда говорят: «потому что браузер перерисовывает каждый раз при добавлении элемента». Это не так. Дело вовсе не в перерисовке.</p><p>Браузер достаточно «умён», чтобы ничего не перерисовывать понапрасну. В большинстве случаев процессы перерисовки и сопутствующие вычисления будут отложены до окончания работы скрипта, и на тот момент уже совершенно без разницы, в какой последовательности были изменены узлы.</p><p><strong>Тем не менее, при вставке узла происходят разные внутренние события и обновления внутренних структур данных, скрытые от наших глаз.</strong></p><p>Что именно происходит – зависит от конкретной, внутренней браузерной реализации DOM, но это отнимает время. Конечно, браузеры развиваются и стараются свести лишние действия к минимуму.</p><h3><a name="8" href="#8">Бенчмарк</a></h3><p>Чтобы легко проверить текущее состояние дел – вот два бенчмарка.</p><p>Оба они создают таблицу 20x20, наполняя <code>TBODY</code> элементами <code>TR/TD</code>.</p><p>При этом первый вставляет все в документ тут же, второй – задерживает вставку <code>TBODY</code> в документ до конца процесса.</p><p>Кликните, чтобы запустить.</p><p><input type="button" onclick="alert(bench(appendFirst,50))" value="TBODY сразу в DOM" style="margin-right: 3px;"><input type="button" onclick="alert(bench(appendLast,50))" value="Отложенная вставка TBODY в DOM"></p><table id="bench-table"></table><p>Код для тестов находится в файле <a href="https://learn.javascript.ru/article/multi-insert/insert-bench.js">insert-bench.js</a>.</p><h2><a name="1" href="#1">Добавление множества узлов</a></h2><p>Продолжим работать со вставкой узлов.</p><p>Рассмотрим случай, когда в документе <em>уже есть</em> большой список <code>UL</code>. И тут понадобилось срочно добавить еще 20 элементов <code>LI</code>.</p><p>Как это сделать?</p><p>Если новые элементы пришли в виде строки, то можно попробовать добавить их так:</p><code-example><script>`ul.innerHTML += "<li>1</li><li>2</li>...";`</script></code-example><p>Но операцию <code>ul.innerHTML += "..."</code> можно по-другому переписать как <code>ul.innerHTML=ul.innerHTML+"..."</code>. Иначе говоря, она <em>не прибавляет, а заменяет</em> всё содержимое списка на дополненную строку. Это и нехорошо с точки зрения производительности, но и будут побочные эффекты. В частности, все внешние ресурсы (картинки) внутри перезаписываемого <code>innerHTML</code> будут загружены заново. Если в каких-то переменных были ссылки на элементы списка – они станут неверны, так как содержимое полностью заменяется. В общем, так лучше не делать.</p><p>А если нужно вставить в середину списка? Здесь <code>innerHTML</code> вообще не поможет.</p><p>Можно, конечно, вставить строку во временный DOM-элемент и перенести оттуда элементы, но есть и гораздо лучший вариант: метод <code>insertAdjacentHTML</code>!</p><h2><a name="2" href="#2">insertAdjacent*</a></h2><p>Метод <a href="https://developer.mozilla.org/en/DOM/element.insertAdjacentHTML">insertAdjacentHTML</a> позволяет вставлять произвольный HTML в любое место документа, в том числе <em>и между узлами</em>!</p><p>Он поддерживается всеми браузерами, кроме Firefox меньше версии 8, ну а там его можно эмулировать.</p><p>Синтаксис:</p><code-example><script>`elem.insertAdjacentHTML(where, html);`</script></code-example><dl><dt><code>html</code></dt><dd>Строка HTML, которую нужно вставить</dd></dl><p><code>where</code>: Куда по отношению к <code>elem</code> вставлять строку. Всего четыре варианта:</p><pre><code>1. `beforeBegin` -- перед `elem`.</code><code>2. `afterBegin` -- внутрь `elem`, в самое начало.</code><code>3. `beforeEnd` -- внутрь `elem`, в конец.</code><code>4. `afterEnd` -- после `elem`.</code></pre><figure><img src="insertAdjacentHTML.png" alt="" width="100%" style="max-width:447px"></figure><p>Например, вставим пропущенные элементы списка <em>перед</em><code>&lt;li&gt;5&lt;/li&gt;</code>:</p><code-example><script>`<ul>\n  <li>1</li>\n  <li>2</li>\n  <li>5</li>\n</ul>\n\n<script>\n  var ul = document.body.children[0];\n  var li5 = ul.children[2];\n\n  li5.insertAdjacentHTML("beforeBegin", "<li>3</li><li>4</li>");\n<\/script>`</script><code-toolbar iframe="125"></code-toolbar></code-example><p>Единственный недостаток этого метода – он не работает в Firefox до версии 8. Но его можно легко добавить, используя <a href="https://learn.javascript.ru/article/multi-insert/insertAdjacentFF.js">полифилл insertAdjacentHTML для Firefox</a>.</p><p>У этого метода есть «близнецы-братья», которые поддерживаются везде, кроме Firefox, но в него они добавляются тем же полифиллом:</p><ul><li><a href="http://help.dottoro.com/ljbreokf.php">elem.insertAdjacentElement(where, newElem)</a> – вставляет в произвольное место не строку HTML, а элемент <code>newElem</code>.</li><li><a href="http://help.dottoro.com/ljrsluxu.php">elem.insertAdjacentText(where, text)</a> – создаёт текстовый узел из строки <code>text</code> и вставляет его в указанное место относительно <code>elem</code>.</li></ul><p>Синтаксис этих методов, за исключением последнего параметра, полностью совпадает с <code>insertAdjacentHTML</code>. Вместе они образуют «универсальный швейцарский нож» для вставки чего угодно куда угодно.</p><h2><a name="3" href="#3">DocumentFragment</a></h2><important-warn><h3>Важно для старых браузеров</h3><p>Оптимизация, о которой здесь идёт речь, важна в первую очередь для старых браузеров, включая IE9-. В современных браузерах эффект от нее, как правило, небольшой, а иногда может быть и отрицательным.</p></important-warn><p>До этого мы говорили о вставке строки в DOM. А что делать в случае, когда надо в существующий <code>UL</code> вставить много <em>DOM-элементов</em>?</p><p>Можно вставлять их один за другим, вызовом <code>insertBefore/appendChild</code>, но при этом получится много операций с большим живым документом.</p><p><strong>Вставить пачку узлов единовременно поможет <code>DocumentFragment</code>. Это особенный <em>кросс-браузерный</em> DOM-объект, который похож на обычный DOM-узел, но им не является.</strong></p><p>Синтаксис для его создания:</p><code-example><script>`var fragment = document.createDocumentFragment();`</script></code-example><p>В него можно добавлять другие узлы.</p><code-example><script>`fragment.appendChild(node);`</script></code-example><p>Его можно клонировать:</p><code-example><script>`fragment.cloneNode(true); // клонирование с подэлементами`</script></code-example><p><strong>У <code>DocumentFragment</code> нет обычных свойств DOM-узлов, таких как <code>innerHTML</code>, <code>tagName</code> и т.п. Это не узел.</strong></p><p>Его «Фишка» заключается в том, что когда <code>DocumentFragment</code> вставляется в DOM – то он исчезает, а вместо него вставляются его дети. Это свойство является уникальной особенностью <code>DocumentFragment</code>.</p><p>Например, если добавить в него много <code>LI</code>, и потом вызвать <code>ul.appendChild(fragment)</code>, то фрагмент растворится, и в DOM вставятся именно <code>LI</code>, причём в том же порядке, в котором были во фрагменте.</p><p>Псевдокод:</p><code-example><script>`// хотим вставить в список UL много LI\n\n// делаем вспомогательный DocumentFragment\nvar fragment = document.createDocumentFragment();\n\nfor (цикл по li) {\n  fragment.appendChild(list[i]); // вставить каждый LI в DocumentFragment\n}\n\nul.appendChild(fragment); // вместо фрагмента вставятся элементы списка`</script></code-example><p>В современных браузерах эффект от такой оптимизации может быть различным, а на небольших документах иногда и отрицательным.</p><p>Понять текущее положение вещей вы можете, запустив следующий <a href="http://plnkr.co/edit/K0Kcmk2Ax3ZvVQmweal1?p=preview">небольшой бенчмарк</a>.</p><h2><a name="4" href="#4">append/prepend, before/after, replaceWith</a></h2><p>Сравнительно недавно в <a href="https://dom.spec.whatwg.org/">стандарте</a> появились методы, которые позволяют вставить что угодно и куда угодно.</p><p>Синтаксис:</p><ul><li><code>node.append(...nodes)</code> – вставляет <code>nodes</code> в конец <code>node</code>,</li><li><code>node.prepend(...nodes)</code> – вставляет <code>nodes</code> в начало <code>node</code>,</li><li><code>node.after(...nodes)</code> – вставляет <code>nodes</code> после узла <code>node</code>,</li><li><code>node.before(...nodes)</code> – вставляет <code>nodes</code> перед узлом <code>node</code>,</li><li><code>node.replaceWith(...nodes)</code> – вставляет <code>nodes</code> вместо <code>node</code>.</li></ul><p>Эти методы ничего не возвращают.</p><p>Во всех этих методах <code>nodes</code> – DOM-узлы или строки, в любом сочетании и количестве. Причём строки вставляются именно как текстовые узлы, в отличие от <code>insertAdjacentHTML</code>.</p><p>Пример (с полифиллом):</p><code-example><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <script src="https://cdn.polyfill.io/v1/polyfill.js?features=Element.prototype.append,Element.prototype.after"><\/script>\n</head>\n\n<body>\n\n  <script>\n    // добавим элемент в конец <body>\n    var p = document.createElement('p');\n    document.body.append(p);\n\n    var em = document.createElement('em');\n    em.append('Мир!');\n\n    // вставить в параграф текстовый и обычный узлы\n    p.append("Привет,&nbsp", em);\n\n    // добавить элемент после <p>\n    p.after(document.createElement('hr'))\n  <\/script>\n\n</body>\n\n</html>`</script><code-toolbar- iframe="80"><a onclick="this.parentElement.nextElementSibling.style.height='200px'" title="показать" data-code_run=""></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><h2><a name="5" href="#5">Итого</a></h2><ul><li><p>Манипуляции, меняющие структуру DOM (вставка, удаление элементов), как правило, быстрее с отдельным маленьким узлом, чем с большим DOM, который находится в документе.</p><p>Конкретная разница зависит от внутренней реализации DOM в браузере.</p></li><li><p>Семейство методов для вставки HTML/элемента/текста в произвольное место документа:</p><ul><li><code>elem.insertAdjacentHTML(where, html)</code></li><li><code>elem.insertAdjacentElement(where, node)</code></li><li><code>elem.insertAdjacentText(where, text)</code></li></ul><p>Два последних метода не поддерживаются в Firefox, на момент написания текста, но есть небольшой полифилл <a href="https://learn.javascript.ru/article/multi-insert/insertAdjacentFF.js">insertAdjacentFF.js</a>, который добавляет их. Конечно, он нужен только для Firefox.</p></li><li><p><code>DocumentFragment</code> позволяет минимизировать количество вставок в большой живой DOM. Эта оптимизация особо эффективна в старых браузерах, в новых эффект от неё меньше или наоборот отрицательный.</p><p>Элементы сначала вставляются в него, а потом – он вставляется в DOM. При вставке <code>DocumentFragment</code> «растворяется», и вместо него вставляются содержащиеся в нём узлы.</p><p><code>DocumentFragment</code>, в отличие от <code>insertAdjacent*</code>, работает с коллекцией DOM-узлов.</p></li><li><p>Современные методы, работают с любым количеством узлов и текста, желателен полифилл:</p><ul><li><code>append/prepend</code> – вставка в конец/начало.</li><li><code>before/after</code> – вставка перед/после.</li><li><code>replaceWith</code> – замена.</li></ul></li></ul><h2 id="tasks"><a href="#6" name="6">Задачи (2)</a></h2><task-content><h3><a href="#10" name="10">Вставьте элементы в конец списка</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Напишите код для вставки текста <code>html</code> в конец списка <code>ul</code> с использованием метода <code>insertAdjacentHTML</code>. Такая вставка, в отличие от присвоения <code>innerHTML+=</code>, не будет перезаписывать текущее содержимое.</p><p>Добавьте к списку ниже элементы <code>&lt;li&gt;3&lt;/li&gt;&lt;li&gt;4&lt;/li&gt;&lt;li&gt;5&lt;/li&gt;</code>:</p><code-example><script>`<ul>\n  <li>1</li>\n  <li>2</li>\n</ul>`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Решение:</p><code-example><script>`var ul = document.body.children[0];\n\nul.insertAdjacentHTML("beforeEnd", "<li>3</li><li>4</li><li>5</li>");`</script></code-example></task-answer></task-content><task-content><h3><a href="#11" name="11">Отсортировать таблицу</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Есть таблица:</p><table><tbody><tr><th>Имя</th><th>Фамилия</th><th>Отчество</th><th>Возраст</th></tr><tr><td>Вася</td><td>Петров</td><td>Александрович</td><td>10</td></tr><tr><td>Петя</td><td>Иванов</td><td>Петрович</td><td>15</td></tr><tr><td>Владимир</td><td>Ленин</td><td>Ильич</td><td>9</td></tr><tr><td>...</td><td>...</td><td>...</td><td>...</td></tr></tbody></table><p>Строк в таблице много: может быть 20, 50, 100… Есть и другие элементы в документе.</p><p>Как бы вы предложили отсортировать содержимое таблицы по полю <code>Возраст</code>? Обдумайте алгоритм, реализуйте его.</p><p>Как сделать, чтобы сортировка работала как можно быстрее? А если в таблице 10000 строк (бывает и такое)?</p><p>P.S. Может ли здесь помочь <code>DocumentFragment</code>?</p><p>P.P.S. Если предположить, что у нас заранее есть массив данных для таблицы в JavaScript – что быстрее: отсортировать эту таблицу или сгенерировать новую?</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Для сортировки нам поможет функция <code>sort</code> массива.</p><p>Общая идея лежит на поверхности: сделать массив из строк и отсортировать его. Тонкости кроются в деталях.</p><p>В ифрейме ниже загружен документ, описывающий и реализующий разные алгоритмы. Обратите внимание: разница в производительности может достигать нескольких раз!</p><figure><code-toolbar-><div></div><a title="открыть в новом окне" target="_blank" href="sort_table_bench.html"></a><a id="sort_table_bench" title="открыть в песочнице" data-code_edit=""></a></code-toolbar-><iframe style="height:800px" src="sort_table_bench.html" changeable=""></iframe></figure><p>P.S. Создавать <code>DocumentFragment</code> здесь ни к чему. Можно вытащить из документа <code>TBODY</code> и иметь дело с ним в отрыве от DOM (алгоритм 4).</p><p>P.P.S. Если нужно сделать много узлов, то обычно <code>innerHTML</code> работает быстрее, чем удаление и вставка элементов через DOM-вызовы. То есть, сгенерировать таблицу заново эффективнее.</p><p><a data-click="sort_table_bench">Открыть решение в песочнице.</a></p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Добавление и удаление узлов; Метод document.write"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/multi-insert",disqus_identifier="multi-insert",disqus_title="\u041c\u0443\u043b\u044c\u0442\u0438\u0432\u0441\u0442\u0430\u0432\u043a\u0430: insertAdjacentHTML \u0438 DocumentFragment";</script></page-content></main>