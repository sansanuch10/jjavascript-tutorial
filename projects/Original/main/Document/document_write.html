<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="99">Документ и объекты страницы</a></nav-up><h1>Метод document.write</h1><p>Метод <code>document.write</code> – один из наиболее древних методов добавления текста к документу.</p><p>У него есть существенные ограничения, поэтому он используется редко, но по своей сути он совершенно уникален и иногда, хоть и редко, может быть полезен.</p><h2><a name="0" href="#0">Как работает document.write</a></h2><p>Метод <code>document.write(str)</code> работает только пока HTML-страница находится в процессе загрузки. Он дописывает текст в текущее место HTML ещё до того, как браузер построит из него DOM.</p><p>HTML-документ ниже будет содержать <code>1 2 3</code>.</p><code-example><script>`<body>\n  1\n  <script>\n    document.write(2);\n  <\/script>\n  3\n</body>`</script><code-toolbar iframe="40"></code-toolbar></code-example><p><strong>Нет никаких ограничений на содержимое <code>document.write</code></strong>.</p><p>Строка просто пишется в HTML-документ без проверки структуры тегов, как будто она всегда там была.</p><p>Например:</p><code-example><script>`<script>\n  document.write('<style> td { color: #F40 } </style>');\n<\/script>\n<table>\n  <tr>\n    <script>\n      document.write('<td>')\n    <\/script>\n    Текст внутри TD.\n    <script>\n      document.write('</td>')\n    <\/script>\n  </tr>\n</table>`</script><code-toolbar iframe="40"></code-toolbar></code-example><p>Также существует метод <code>document.writeln(str)</code> – не менее древний, который добавляет после <code>str</code> символ перевода строки <code>"\n"</code>.</p><h2><a name="1" href="#1">Только до конца загрузки</a></h2><p>Во время загрузки браузер читает документ и тут же строит из него DOM, по мере получения информации достраивая новые и новые узлы, и тут же отображая их. Этот процесс идет непрерывным потоком. Вы наверняка видели это, когда заходили на сайты в качестве посетителя – браузер зачастую отображает неполный документ, добавляя его новыми узлами по мере их получения.</p><p><strong>Методы <code>document.write</code> и <code>document.writeln</code> пишут напрямую в текст документа, до того как браузер построит из него DOM, поэтому они могут записать в документ все, что угодно, любые стили и незакрытые теги.</strong></p><p>Браузер учтёт их при построении DOM, точно так же, как учитывает очередную порцию HTML-текста.</p><p>Технически, вызвать <code>document.write</code> можно в любое время, однако, когда HTML загрузился, и браузер полностью построил DOM, документ становится <em>«закрытым»</em>. Попытка дописать что-то в закрытый документ открывает его заново. При этом все текущее содержимое удаляется.</p><p>Текущая страница, скорее всего, уже загрузилась, поэтому если вы нажмёте на эту кнопку – её содержимое удалится:</p><input type="button" onclick="document.write(&quot;Пустая страница!&quot;);" value="Запустить document.write('Пустая страница!')"><p>Из-за этой особенности <code>document.write</code> для загруженных документов не используют.</p><important-warn><h3>XHTML и <code>document.write</code></h3><p>В некоторых современных браузерах при получении страницы с заголовком <code>Content-Type: text/xml</code> или <code>Content-Type: text/xhtml+xml</code> включается «XML-режим» чтения документа. Метод <code>document.write</code> при этом не работает.</p><p>Это лишь одна из причин, по которой XML-режим обычно не используют.</p></important-warn><h2><a name="2" href="#2">Преимущества перед innerHTML</a></h2><p>Метод <code>document.write</code> – динозавр, он существовал десятки <strike>миллионов</strike> лет назад. С тех пор, как появился и стал стандартным метод <code>innerHTML</code>, нужда в нём возникает редко, но некоторые преимущества всё же есть.</p><ul><li><p>Метод <code>document.write</code> работает быстрее, фактически это самый быстрый способ добавить на страницу текст, сгенерированный скриптом.</p><p>Это естественно, ведь он не модифицирует существующий DOM, а пишет в текст страницы до его генерации.</p></li><li><p>Метод <code>document.write</code> вставляет любой текст на страницу «как есть», в то время как <code>innerHTML</code> может вписать лишь валидный HTML (при попытке подсунуть невалидный – браузер скорректирует его).</p></li></ul><p>Эти преимущества являются скорее средством оптимизации, которое нужно использовать именно там, где подобная оптимизация нужна или уместна.</p><p>Однако, <code>document.write</code> по своей природе уникален: он добавляет текст «в текущее место документа», без всяких хитроумных DOM. Поэтому он бывает просто-напросто удобен, из-за чего его нередко используют не по назначению.</p><h2><a name="3" href="#3">Антипример: реклама</a></h2><p>Например, <code>document.write</code> используют для вставки рекламных скриптов и различных счетчиков, когда URL скрипта необходимо генерировать динамически, добавляя в него параметры из JavaScript, например:</p><code-example><script>`<script>\n  // в url указано текущее разрешение экрана посетителя\n  var url = 'http://ads.com/buyme?screen=&nbsp'_GREEN + screen.width + "x" + screen.height;\n\n  // загрузить такой скрипт прямо сейчас\n  document.write('<script src="'_GREEN + url + 'GREEN_"></scr'_GREEN + 'ipt>');\n<\/script>`</script></code-example><important-><h3>На заметку:</h3><p>Закрывающий тег <code>&lt;/script&gt;</code> в строке разделён, чтобы браузер не увидел <code>&lt;/script&gt;</code> и не посчитал его концом скрипта.</p><p>Также используют запись:</p><code-example><script>`document.write('<script src="'_GREEN + url + 'GREEN_"><\/script>_GREEN');`</script></code-example><p>Здесь <code>&lt;\/script&gt;</code> вместо <code>&lt;/script&gt;</code>: обратный слеш <code>\</code> обычно используется для вставки спецсимволов типа <code>\n</code>, а если такого спецсимвола нет, в данном случае <code>\/</code> не является спецсимволом, то будет проигнорирован. Так что получается такой альтернативный способ безопасно вставить строку <code>&lt;/script&gt;</code>.</p></important-><p>Сервер, получив запрос с такими параметрами, обрабатывает его и, учитывая переданную информацию, генерирует текст скрипта, в котором обычно есть какой-то другой <code>document.write</code>, рисующий на этом месте баннер.</p><p><strong>Проблема здесь в том, что загрузка такого скрипта блокирует отрисовку всей страницы.</strong></p><p>То есть, дело даже не в самом <code>document.write</code>, а в том, что в страницу вставляется сторонний скрипт, а браузер устроен так, что пока он его не загрузит и не выполнит – он не будет дальше строить DOM и показывать документ.</p><p>Представим на минуту, что сервер <code>ads.com</code>, с которого грузится скрипт, работает медленно или вообще завис – зависнет и наша страница.</p><p>Что делать?</p><p>В современных браузерах у скриптов есть атрибуты <code>async</code> и <code>defer</code>, которые разрешают браузеру продолжать обработку страницы, но применить их здесь нельзя, так как рекламный скрипт захочет вызвать <code>document.write</code> именно на этом месте, и браузер не должен двигаться вперёд по документу.</p><p>Альтернатива – использовать другие техники вставки рекламы и счётчиков. Примеры вы можете увидеть в коде Google Analytics, Яндекс.Метрики и других.</p><p>Если это невозможно – применяют всякие хитрые оптимизации, например заменяют метод <code>document.write</code> своей функцией, и она уже разбирается со скриптами и баннерами.</p><h2><a name="4" href="#4">Итого</a></h2><p>Метод <code>document.write</code> (или <code>writeln</code>) пишет текст прямо в HTML, как будто он там всегда был.</p><ul><li><p>Этот метод редко используется, так как работает только из скриптов, выполняемых в процессе загрузки страницы.</p><p>Запуск после загрузки приведёт к очистке документа.</p></li><li><p>Метод <code>document.write</code> очень быстр.</p><p>В отличие от установки <code>innerHTML</code> и DOM-методов, он не изменяет существующий документ, а работает на стадии текста, до того как DOM-структура сформирована.</p></li><li><p>Иногда <code>document.write</code> используют для добавления скриптов с динамическим URL.</p><p>Рекомендуется избегать этого, так как браузер остановится на месте добавления скрипта и будет ждать его загрузки. Если скрипт будет тормозить, то и страница – тоже.</p><p>Поэтому желательно подключать внешние скрипты, используя вставку скрипта через DOM или <code>async/defer</code>. Современные системы рекламы и статистики так и делают.</p></li></ul><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Мультивставка: insertAdjacentHTML и DocumentFragment; Стили, getComputedStyle"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/document-write", disqus_identifier = "document-write", disqus_title = "\u041c\u0435\u0442\u043e\u0434 document.write";</script></page-content></main>