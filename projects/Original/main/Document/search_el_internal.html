<main> <page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="99">Документ и объекты страницы</a></nav-up><h1>Внутреннее устройство поисковых методов</h1><p>Эта глава не обязательна при первом чтении учебника.</p><p>Если вы хотите действительно глубоко понимать, что происходит при поиске, то посмотрите эту главу. Если нет – её можно пропустить.</p><p>Несмотря на схожесть в синтаксисе, поисковые методы <code>get*</code> и <code>querySelector*</code> внутри устроены очень по-разному.</p><h2><a name="0" href="#0">document.getElementById(id)</a></h2><p>Браузер поддерживает у себя внутреннее соответствие <code>id -&gt; элемент</code>. Поэтому нужный элемент возвращается сразу. Это очень быстро.</p><h2><a name="1" href="#1">elem.querySelector(query), elem.querySelectorAll(query)</a></h2><p>Чтобы найти элементы, удовлетворяющие поисковому запросу, браузер не использует никаких сложных структур данных.</p><p>Он просто перебирает все подэлементы внутри элемента <code>elem</code>(или по всему документу, если вызов в контексте документа) и проверяет каждый элемент на соответствие запросу <code>query</code>.</p><p>Вызов <code>querySelector</code> прекращает перебор после первого же найденного элемента, а <code>querySelectorAll</code> собирает найденные элементы в «псевдомассив»: внутреннюю структуру данных, по сути аналогичную массиву JavaScript.</p><p>Этот перебор происходит очень быстро, так как осуществляется непосредственно движком браузера, а не JavaScript-кодом.</p><p>Оптимизации:</p><ul><li>В случае поиска по ID: <code>elem.querySelector('#id')</code>, большинство браузеров оптимизируют поиск, используя вызов <code>getElementById</code>.</li><li>Последние результаты поиска сохраняются в кеше. Но это до тех пор, пока документ как-нибудь не изменится.</li></ul><h2><a name="2" href="#2">elem.getElementsBy*(…)</a></h2><p>Результаты поиска <code>getElementsBy*</code> – живые! При изменении документа – изменяется и результат запроса.</p><p>Например, найдём все <code>div</code> при помощи <code>querySelectorAll</code> и <code>getElementsByTagName</code>, а потом изменим документ:</p><code-example><script>`<div></div>\n<script>\n  var resultGet = document.getElementsByTagName('div');\n  var resultQuery = document.querySelectorAll('div');\n\n  alert( resultQuery.length + ',&nbsp' + resultGet.length ); // 1, 1\n\n  document.body.innerHTML = ''; // удалить всё содержимое BODY\n\nMARK  alert( resultQuery.length + ',&nbsp' + resultGet.length ); // 1, 0\n<\/script>`</script><code-toolbar iframe=""></code-toolbar></code-example><p>Как видно, длина коллекции, найденной через <code>querySelectorAll</code>, осталась прежней. А длина коллекции, возвращённой <code>getElementsByTagName</code>, изменилась.</p><p>Дело в том, что результат запросов <code>getElementsBy*</code> – это не массив, а специальный объект, имеющий тип <a href="http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-536297177">NodeList</a> или <a href="http://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-75708506">HTMLCollection</a>. Он похож на массив, так как имеет нумерованные элементы и длину, но внутри это не готовая коллекция, а «живой поисковой запрос».</p><p>Собственно поиск выполняется только при обращении к элементам коллекции или к её длине.</p><h2><a name="3" href="#3">Алгоритмы getElementsBy*</a></h2><p>Поиск <code>getElementsBy*</code> наиболее сложно сделать эффективно, так как его результат – «живая» коллекция, она должна быть всегда актуальной для текущего состояния документа.</p><code-example><script>`var elems = document.getElementsByTagName('div');\nalert( elems[0] );\nMARK// изменили документ\nalert( elems[0] ); // результат может быть уже другой`</script></code-example><p>Можно искать заново при каждой попытке получить элемент из <code>elems</code>. Тогда результат будет всегда актуален, но поиск будет работать уж слишком медленно. Да и зачем? Ведь, скорее всего, документ не поменялся.</p><p><strong>Чтобы производительность <code>getElementsBy*</code> была достаточно хорошей, активно используется кеширование результатов поиска.</strong></p><p>Для этого есть два основных способа: назовём их условно «Способ Firefox» (Firefox, IE) и «Способ WebKit» (Chrome, Safari, Opera).</p><p>Для примера, рассмотрим поиск в произвольном документе, в котором есть 1000 элементов <code>div</code>.</p><p>Посмотрим, как будут работать браузеры, если нужно выполнить следующий код:</p><code-example><script>`// вместо document может быть любой элемент\nvar elems = document.getElementsByTagName('div');\nalert( elems[0] );\nalert( elems[995] );\nalert( elems[500] );\nalert( elems.length );`</script></code-example><dl><dt>Способ Firefox</dt><dd><p>Перебрать подэлементы <code>document.body</code> в порядке их появления в поддереве. Запоминать <em>все найденные элементы</em> во внутренней структуре данных, чтобы при повторном обращении обойтись без поиска.</p><p>Разбор действий браузера при выполнении кода выше:</p></dd></dl><ol><li>Браузер создаёт пустую «живую коллекцию» <code>elems</code>. Пока ничего не ищет.</li><li>Перебирает элементы, пока не найдёт первый <code>div</code>. Запоминает его и возвращает.</li><li>Перебирает элементы дальше, пока не найдёт элемент с индексом <code>995</code>. Запоминает все найденные.</li><li>Возвращает ранее запомненный элемент с индексом <code>500</code>, без дополнительного поиска!</li><li>Продолжает обход поддерева с элемента, на котором остановился ( <code>995</code>) и до конца. Запоминает найденные элементы и возвращает их количество.</li></ol><dl><dt>Способ WebKit</dt><dd><p>Перебирать подэлементы <code>document.body</code>. Запоминать только один, <em>последний найденный</em>, элемент, а также, по окончании перебора – длину коллекции.</p><p>Здесь кеширование используется меньше.</p><p>Разбор действий браузера по строкам:</p></dd></dl><ol><li>Браузер создаёт пустую «живую коллекцию» <code>elems</code>. Пока ничего не ищет.</li><li>Перебирает элементы, пока не найдёт первый <code>div</code>. Запоминает его и возвращает.</li><li>Перебирает элементы дальше, пока не найдёт элемент с индексом <code>995</code>. Запоминает его и возвращает.</li><li>Браузер запоминает только последний найденный, поэтому не помнит об элементе <code>500</code>. Нужно найти его перебором поддерева. Этот перебор можно начать либо с начала – вперед по поддереву, 500-й по счету) либо с элемента <code>995</code> – назад по поддереву, 495-й по счету. Так как назад разница в индексах меньше, то браузер выбирает второй путь и идёт от 995-го назад 495 раз. Запоминает теперь уже 500-й элемент и возвращает его.</li><li>Продолжает обход поддерева с 500-го (не 995-го!) элемента и до конца. Запоминает число найденных элементов и возвращает его.</li></ol><p>Основное различие – в том, что Firefox запоминает все найденные, а Webkit – только последний. Таким образом, «метод Firefox» требует больше памяти, но гораздо эффективнее при повторном доступе к предыдущим элементам.</p><p>А «метод Webkit» ест меньше памяти и при этом работает не хуже в самом важном и частом случае – последовательном переборе коллекции, без возврата к ранее выбранным.</p><p><strong>Запомненные элементы сбрасываются при изменениях DOM.</strong></p><p>Документ может меняться. При этом, если изменение может повлиять на результаты поиска, то запомненные элементы необходимо сбросить. Например, добавление нового узла <code>div</code> сбросит запомненные элементы коллекции <code>elem.getElementsByTagName('div')</code>.</p><p>Сбрасывание запомненных элементов при изменении документа выполняется интеллектуально.</p><ol><li><p>Во-первых, при добавлении элемента будут сброшены только те коллекции, которые могли быть затронуты обновлением. Например, если в документе есть два независимых раздела <code>&lt;section&gt;</code>, и поисковая коллекция привязана к первому из них, то при добавлении во второй – она сброшена не будет.</p><p>Если точнее – будут сброшены все коллекции, привязанные к элементам вверх по иерархии от непосредственного родителя нового <code>div</code> и выше, то есть такие, которые потенциально могли измениться. И только они.</p></li><li><p>Во-вторых, если добавлен только <code>div</code>, то не будут сброшены запомненные элементы для поиска по другим тегам, например <code>elem.getElementsByTagName('a')</code>.</p></li><li><p>…И, конечно же, не любые изменения DOM приводят к сбросу кешей, а только те, которые могут повлиять на коллекцию. Если где-то добавлен новый атрибут элементу – с кешем для <code>getElementsByTagName</code> ничего не произойдёт, так как атрибут никак не может повлиять на результат поиска по тегу.</p></li></ol><p>Прочие поисковые методы, такие как <code>getElementsByClassName</code> тоже сбрасывают кеш при изменениях интеллектуально.</p><p>Разницу в алгоритмах поиска легко «пощупать». Посмотрите сами:</p><code-example><script>`<script>\n  for (var i = 0; i < 10000; i++) document.write('<span></span>');\n\n  var elements = document.body.getElementsByTagName('span');\n  var len = elements.length;\n\n  var d = new Date;\nMARK  for (var i = 0; i < len; i++) elements[i];\n  alert( "Последовательно:&nbsp" + (new Date - d) + "мс" ); // (1)\n\n  var d = new Date;\nMARK  for (var i = 0; i < len; i += 2) elements[i], elements[len - i - 1];\n  alert( "Вразнобой:&nbsp" + (new Date - d) + "мс" ); // (2)\n<\/script>`</script><code-toolbar iframe=""></code-toolbar></code-example><p>В примере выше первый цикл проходит элементы последовательно. А второй – идет по шагам: один с начала, потом один с конца, потом ещё один с начала, ещё один – с конца, и так далее.</p><p>Количество обращений к элементам одинаково.</p><ul><li>В браузерах, которые запоминают все найденные (Firefox, IE) – скорость будет одинаковой.</li><li>В браузерах, которые запоминают только последний (Webkit) – разница будет порядка 100 и более раз, так как браузер вынужден бегать по дереву при каждом запросе заново.</li></ul><h2 id="tasks"><a href="#4" name="4">Задачи (4)</a></h2><task-content><h3><a href="#7" name="7">Длина коллекции после удаления элементов</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Вот небольшой документ:</p><code-example><script>`<ul id="menu">\n  <li>Главная страница</li>\n  <li>Форум</li>\n  <li>Магазин</li>\n</ul>`</script></code-example><ol><li>Что выведет следующий код (простой вопрос)?</li></ol><code-example><script>`var lis = document.body.getElementsByTagName('li');\n\ndocument.body.innerHTML = "";\n\nalert( lis.length );`</script></code-example><ol start="2"><li>А такой код (вопрос посложнее)?</li></ol><code-example><script>`var menu = document.getElementById('menu');\nvar lis = menu.getElementsByTagName('li');\n\ndocument.body.innerHTML = "";\n\nalert( lis.length );`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="" style="">Ответ на первый вопрос</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4 class="task__step-title">Ответ на первый вопрос</h4><p>Ответ: 0, пустая коллекция.</p><code-example><script>`<ul id="menu">\n  <li>Главная страница</li>\n  <li>Форум</li>\n  <li>Магазин</li>\n</ul>\n<script>\n  var lis = document.body.getElementsByTagName('li');\n\n  document.body.innerHTML = "";\n\n  alert( lis.length );\n<\/script>`</script><code-toolbar iframe="50"></code-toolbar></code-example><p>Это потому, что все элементы из <code>BODY</code> удаляются, а коллекция – <em>живая</em>.</p></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Ответ на второй вопрос</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4 class="task__step-title">Ответ на второй вопрос</h4><p>Ответ на второй вопрос зависит от браузера. В большинстве браузеров будет 3, коллекция не изменилась, так как она теперь привязана не к <code>BODY</code>, а к элементу, на котором идёт поиск, т.е. к <code>menu</code>.</p><p>Но элемент <code>menu</code> находится в переменной, и поэтому должен быть жив, а значит и его дети тоже. Но некоторые браузеры (IE10) используют агрессивный подход при работе с памятью и очищают все элементы, кроме тех, которые непосредственно хранятся в переменных.</p><p>Поэтому результат кода ниже в большинстве браузеров: <code>3</code>, а в IE10: <code>0</code>.</p><code-example><script>`<ul id="menu">\n  <li>Главная страница</li>\n  <li>Форум</li>\n  <li>Магазин</li>\n</ul>\n<script>\n  var menu = document.getElementById('menu');\n  var lis = menu.getElementsByTagName('li');\n\n  document.body.innerHTML = "";\n\n  alert( lis.length );\n<\/script>`</script><code-toolbar iframe="50"></code-toolbar></code-example></task-answer></task-answer-ext></task-content><task-content><h3><a href="#8" name="8">Сравнение количества элементов</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Для любого документа сделаем следующее:</p><code-example><script>`var aList1 = document.getElementsByTagName('a');\nvar aList2 = document.querySelectorAll('a');`</script></code-example><p>Что произойдёт со значениями <code>aList1.length</code>, <code>aList2.length</code>, если в документе вдруг появится ещё одна ссылка <code>&lt;a href="#"&gt;...&lt;/a&gt;</code>?</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Значение <code>aList1</code> изменится, потому что <code>getElementsByTagName</code> – <em>живая</em> коллекция. Она автоматически дополнится новым элементом <code>a</code> и ее длина увеличится на 1.</p><p>А вот <code>querySelector</code>, наоборот, возвращает статичный список узлов. Он ссылается на те же самые элементы, что бы не происходило с документом. Поэтому длина <code>aList2.length</code> останется неизменной.</p></task-answer></task-content><task-content><h3><a href="#9" name="9">Бенчмаркинг методов поиска в DOM</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 2</span><p>Какой метод поиска элементов работает быстрее: <code>getElementsByTagName(tag)</code> или <code>querySelectorAll(tag)</code>?</p><p>Допишите код, который измеряет разницу между ними.</p><code-example><script>`<style>\n  GOLD_i_GOLD { display: inline-block; }\n</style>\n\n<script>\n  for(i = 0; i < 155; i++) {\n    var n = document.createElement('i');\n    n.innerHTML = i + ',';\n    document.body.appendChild(n);\n  }\n<\/script>`</script><code-toolbar iframe="200"><a title="показать" data-code_run="0"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p><em>P.S. В задаче есть подвох, все не так просто. Если разница больше 10 раз – вы решили ее неверно. Тогда подумайте, почему такое может быть.</em></p><p><a data-click="bench_task">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Для бенчмаркинга будем использовать функцию <code>bench(f, times)</code>, которая запускает функцию <code>f</code><code>times</code> раз и возвращает разницу во времени:</p><code-example><script>`function bench(f, times) {\n  var d = new Date();\n  for (var i = 0; i < times; i++) f();\n  return new Date() - d;\n}`</script></code-example><p>Первый вариант (неверный) – замерять разницу между функциями <code>runGet/runQuery</code>, вот так:</p><code-example><script>`function runGet() {\n  var results = document.getElementsByTagName('i');\n}\n\nfunction runQuery() {\n  var results = document.querySelectorAll('i');\n}\n\nalert( bench(runGet, 10000) ); // вывести время 1000*runGet`</script></code-example><p>Он даст неверные результаты, т.к. <code>getElementsByTagName</code> является «живым поисковым запросом». Если не обратиться к его результатам, то поиска не произойдет вообще, т.е. <code>runGet</code> ничего по сути не ищет.</p><p>…А <code>querySelectorAll</code> всегда производит поиск и формирует список элементов.</p><p>Более правильный тест – это не только запустить поиск, но и получить все элементы, как это делается в реальной жизни.</p><code-example><script>`<style>\n  GOLD_i_GOLD { display: inline-block; }\n</style>\n\n<script>\n  for(i = 0; i < 155; i++) {\n    var n = document.createElement('i');\n    n.innerHTML = i + ',';\n    document.body.appendChild(n);\n  }\n  \n  function bench(f, times) {\n    var d = new Date();\n    for (var i = 0; i < times; i++) f();\n    return new Date() - d;\n  }\n\n  function runGetList() {\n    var results = document.getElementsByTagName('i');\n    var len = results.length;\n    for (var i = 0; i < len; i++) {\n      var elem = results[i];\n    }\n  }\n\n  function runQueryList() {\n    var results = document.querySelectorAll('i');\n    var len = results.length;\n    for (var i = 0; i < len; i++) {\n      var elem = results[i];\n    }\n  }\n\n  function log(msg) {\n    alert(msg);\n  }\n\n  log('getElementsByTagName:&nbsp' + bench(runGetList, 10000));\n  log('querySelectorAll:&nbsp' + bench(runQueryList, 10000));\n<\/script>`</script><code-toolbar- iframe="450"><a data-code_run="200" title="показать"></a><a id="bench" title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="bench">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#10" name="10">Получить второй LI</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Есть длинный список <code>ul</code>:</p><code-example><script>`<ul>\n  <li>...</li>\n  <li>...</li>\n  <li>...</li>\n  ...\n</ul>`</script></code-example><p>Как наиболее эффективно получить второй <code>LI</code>?</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Можно так:</p><code-example><script>`var li = ul.getElementsByTagName('li')[1];`</script></code-example><p>Или так:</p><code-example><script>`var li = ul.querySelector('li:nth-child(2)');`</script></code-example><p>Оба этих вызова будут перебирать детей <code>UL</code> и остановят перебор на найденном элементе.</p><p>А вот так – браузер найдет все элементы, а затем выберет второй. Это дольше:</p><code-example><script>`var li = ul.querySelectorAll('li')[1];`</script></code-example><p>На практике разница в производительности будет видна только для действительно больших списков, либо при частом выполнении запроса. Браузер перебирает элементы весьма шустро.</p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Поиск: getElement* и querySelector* и не только; Свойства узлов: тип, тег и содержимое"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/searching-elements-internals",disqus_identifier="searching-elements-internals",disqus_title="\u0412\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u0435\u0435 \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432\u043e \u043f\u043e\u0438\u0441\u043a\u043e\u0432\u044b\u0445 \u043c\u0435\u0442\u043e\u0434\u043e\u0432";</script></page-content></main>