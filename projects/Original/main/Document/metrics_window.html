<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="99">Документ и объекты страницы</a></nav-up><h1>Размеры и прокрутка страницы</h1><p>Как найти ширину окна браузера? Как узнать всю высоту страницы, с учётом прокрутки?Как прокрутить её из JavaScript?</p><p>С точки зрения HTML, документ – это <code>document.documentElement</code>. У этого элемента, соответствующего тегу <code>&lt;html&gt;</code>, есть все стандартные свойства и метрики и, в теории, они и должны нам помочь. Однако, на практике есть ряд нюансов, именно их мы рассмотрим в этой главе.</p><h2><a name="0" href="#0">Ширина/высота видимой части окна</a></h2><p>Свойства <code>clientWidth/Height</code> для элемента <code>document.documentElement</code> – это как раз ширина/высота видимой области окна.</p><figure><img src="document-client-width-height.png" alt="" width="100%" style="max-width:550px"></figure><p>Например, кнопка ниже выведет размер такой области для этой страницы:</p><p><button onclick="alert(document.documentElement.clientHeight)">alert(document.documentElement.clientHeight)</button></p><important-warn><h3>Не <code>window.innerWidth/Height</code></h3><p>Все браузеры, кроме IE8-, также поддерживают свойства <code>window.innerWidth/innerHeight</code>. Они хранят текущий размер <em>окна браузера</em>.</p><p>В чём отличие? Оно небольшое, но чрезвычайно важное.</p><p>Свойства <code>clientWidth/Height</code>, если есть полоса прокрутки, возвращают именно ширину/высоту внутри неё, доступную для документа, а <code>window.innerWidth/Height</code> – игнорируют её наличие.</p><p>Если справа часть страницы занимает полоса прокрутки, то эти строки выведут разное:</p><code-example><script>`alert( window.parent.innerWidth ); // вся ширина окна\nalert( window.parent\n  .document.documentElement.clientWidth ); // ширина минус прокрутка`</script><code-toolbar></code-toolbar></code-example><p>Обычно нам нужна именно <em>доступная</em> ширина окна, например, чтобы нарисовать что-либо, то есть за вычетом полосы прокрутки. Поэтому используем <code>documentElement.clientWidth</code>.</p></important-warn><h2><a name="1" href="#1">Ширина/высота страницы с учётом прокрутки</a></h2><p>Теоретически, видимая часть страницы – это <code>documentElement.clientWidth/Height</code>, а полный размер с учётом прокрутки – по аналогии, <code>documentElement.scrollWidth/scrollHeight</code>.</p><p>Это верно для обычных элементов.</p><p>А вот для страницы с этими свойствами возникает проблема, когда <em>прокрутка то есть, то нет</em>. В этом случае они работают некорректно. В браузерах Chrome/Safari и Opera при отсутствии прокрутки значение <code>documentElement.scrollHeight</code> в этом случае может быть даже меньше, чем <code>documentElement.clientHeight</code>, что, конечно же, выглядит как совершеннейшая чепуха и нонсенс.</p><p>Эта проблема возникает именно для <code>documentElement</code>, то есть для всей страницы.</p><p>Надёжно определить размер страницы с учетом прокрутки можно, взяв максимум из нескольких свойств:</p><code-example><script>`var body = window.parent.document.body;\nvar html = window.parent.document.documentElement;\n\nvar scrollHeight = Math.max(\n  body.scrollHeight, html.scrollHeight,\n  body.offsetHeight, html.offsetHeight,\n  body.clientHeight, html.clientHeight\n);\n\nalert( 'Высота с учетом прокрутки:&nbsp' + scrollHeight );`</script><code-toolbar></code-toolbar></code-example><p>Почему так? Лучше и не спрашивайте, это одно из редких мест, где просто ошибки в браузерах. Глубокой логики здесь нет.</p><h2><a name="2" href="#2">Получение текущей прокрутки</a></h2><p>У обычного элемента текущую прокрутку можно получить в <code>scrollLeft/scrollTop</code>.</p><p>Что же со страницей?</p><p>Большинство браузеров корректно обработает запрос к <code>documentElement.scrollLeft/Top</code>, однако Safari/Chrome/Opera есть ошибки (к примеру <a href="https://code.google.com/p/chromium/issues/detail?id=157855">157855</a>, <a href="https://bugs.webkit.org/show_bug.cgi?id=106133">106133</a>), из-за которых следует использовать <code>document.body</code>.</p><p>Чтобы вообще обойти проблему, можно использовать специальные свойства <code>window.pageXOffset/pageYOffset</code>:</p><code-example><script>`alert( 'Текущая прокрутка сверху:&nbsp' + window.parent.pageYOffset );\nalert( 'Текущая прокрутка слева:&nbsp' + window.parent.pageXOffset );`</script><code-toolbar></code-toolbar></code-example><p>Эти свойства:</p><ul><li>Не поддерживаются IE8-</li><li>Их можно только читать, а менять нельзя.</li></ul><p>Если IE8- не волнует, то просто используем эти свойства.</p><p>Кросс-браузерный вариант с учётом IE8 предусматривает откат на <code>documentElement</code>:</p><code-example><script>`var scrollTop = window.parent.pageYOffset || window.parent.document.documentElement.scrollTop;\n\nalert( "Текущая прокрутка:&nbsp" + scrollTop );`</script><code-toolbar></code-toolbar></code-example><h2><a name="3" href="#3">Изменение прокрутки: scrollTo, scrollBy, scrollIntoView</a></h2><important-warn><h3>Важно:</h3><p>Чтобы прокрутить страницу при помощи JavaScript, её DOM должен быть полностью загружен.</p></important-warn><p>На обычных элементах свойства <code>scrollTop/scrollLeft</code> можно изменять, и при этом элемент будет прокручиваться.</p><p>Никто не мешает точно так же поступать и со страницей. Во всех браузерах, кроме Chrome/Safari/Opera можно осуществить прокрутку установкой <code>document.documentElement.scrollTop</code>, а в указанных – использовать для этого <code>document.body.scrollTop</code>. И будет работать. Можно попробовать прокручивать и так и эдак и проверять, подействовала ли прокрутка, будет кросс-браузерно.</p><p>Но есть и другое, простое и универсальное решение – специальные методы прокрутки страницы <a href="https://developer.mozilla.org/en/Window.scrollBy">window.scrollBy(x,y)</a> и <a href="https://developer.mozilla.org/en/Window.scrollTo">window.scrollTo(pageX,pageY)</a>.</p><ul><li><p>Метод <code>scrollBy(x,y)</code> прокручивает страницу относительно текущих координат.</p><p>Например, кнопка ниже прокрутит страницу на <code>10px</code> вниз:</p><p><button onclick="window.scrollBy(0,10)">window.scrollBy(0,10)</button></p></li><li><p>Метод <code>scrollTo(pageX,pageY)</code> прокручивает страницу к указанным координатам относительно документа.</p><p>Он эквивалентен установке свойств <code>scrollLeft/scrollTop</code>.</p><p>Чтобы прокрутить в начало документа, достаточно указать координаты <code>(0,0)</code>.</p><p><button onclick="window.scrollTo(0,0)">window.scrollTo(0,0)</button></p></li></ul><h2><a name="4" href="#4">scrollIntoView</a></h2><p>Для полноты картины рассмотрим также метод <a href="https://developer.mozilla.org/en/DOM/element.scrollIntoView">elem.scrollIntoView(top)</a>.</p><p>Метод <code>elem.scrollIntoView(top)</code> вызывается на элементе и прокручивает страницу так, чтобы элемент оказался вверху, если параметр <code>top</code> равен <code>true</code>, и внизу, если <code>top</code> равен <code>false</code>. Причем, если параметр <code>top</code> не указан, то он считается равным <code>true</code>.</p><p>Кнопка ниже прокрутит страницу так, чтобы кнопка оказалась вверху:</p><p><button onclick="this.scrollIntoView()">this.scrollIntoView()</button></p><p>А следующая кнопка прокрутит страницу так, чтобы кнопка оказалась внизу:</p><p><button onclick="this.scrollIntoView(false)">this.scrollIntoView(false)</button></p><h2><a name="5" href="#5">Запрет прокрутки</a></h2><p>Иногда бывает нужно временно сделать документ «непрокручиваемым». Например, при показе большого диалогового окна над документом – чтобы посетитель мог прокручивать это окно, но не документ.</p><p><strong>Чтобы запретить прокрутку страницы, достаточно поставить <code>document.body.style.overflow = "hidden"</code>.</strong></p><p>При этом страница замрёт в текущем положении.</p><p>Попробуйте сами:</p><p><button onclick="document.body.style.overflow = 'hidden'"><code>document.body.style.overflow = 'hidden'</code></button></p><p><button onclick="document.body.style.overflow = ''"><code>document.body.style.overflow = ''</code></button></p><p>При нажатии на верхнюю кнопку страница замрёт на текущем положении прокрутки. После нажатия на нижнюю – прокрутка возобновится.</p><p>Вместо <code>document.body</code> может быть любой элемент, прокрутку которого необходимо запретить.</p><p>Недостатком этого способа является то, что сама полоса прокрутки исчезает. Если она занимала некоторую ширину, то теперь эта ширина освободится, и содержимое страницы расширится, текст «прыгнет», заняв освободившееся место.</p><p>Это может быть не очень красиво, но легко обходится, если вычислить размер прокрутки и добавить такой же по размеру <code>padding</code>.</p><h2><a name="6" href="#6">Итого</a></h2><p>Размеры:</p><ul><li><p>Для получения размеров видимой части окна: <code>document.documentElement.clientWidth/Height</code></p></li><li><p>Для получения размеров страницы с учётом прокрутки:</p><code-example><script>`var scrollHeight = Math.max(\n  document.body.scrollHeight, document.documentElement.scrollHeight,\n  document.body.offsetHeight, document.documentElement.offsetHeight,\n  document.body.clientHeight, document.documentElement.clientHeight\n);`</script></code-example></li></ul><p><strong>Прокрутка окна:</strong></p><ul><li><p>Прокрутку окна можно <em>получить</em> как <code>window.pageYOffset</code> (для горизонтальной – <code>window.pageXOffset</code>) везде, кроме IE8-.</p><p>На всякий случай – вот самый кросс-браузерный способ, учитывающий IE7- в том числе:</p><code-example><script>`var html = window.parent.document.documentElement;\nvar body = window.parent.document.body;\n\nvar scrollTop = html.scrollTop || body && body.scrollTop || 0;\nscrollTop -= html.clientTop; // в IE7- <HTML> смещён относительно (0,0)\n\nalert( "Текущая прокрутка:&nbsp" + scrollTop );`</script><code-toolbar></code-toolbar></code-example></li><li><p>Установить прокрутку можно при помощи специальных методов:</p><ul><li><code>window.scrollTo(pageX,pageY)</code> – абсолютные координаты,</li><li><code>window.scrollBy(x,y)</code> – прокрутить относительно текущего места.</li><li><code>elem.scrollIntoView(top)</code> – прокрутить, чтобы элемент <code>elem</code> стал виден.</li></ul></li></ul><h2 id="tasks"><a href="#7" name="7">Задачи (1)</a></h2><task-content><h3><a href="#10" name="10">Полифилл для pageYOffset в IE8</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 3</span><p>Обычно в IE8 не поддерживается свойство <code>pageYOffset</code>. Напишите полифилл для него.</p><p>При подключённом полифилле такой код должен работать в IE8:</p><code-example><script>`// текущая прокрутка страницы в IE8\nalert( window.pageYOffset );`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>В стандартном режиме IE8 можно получить текущую прокрутку так:</p><code-example><script>`alert( document.documentElement.scrollTop );`</script><code-toolbar></code-toolbar></code-example><p>Самым простым, но неверным было бы такое решение:</p><code-example><script>`// "полифилл"\nwindow.pageYOffset = document.documentElement.scrollTop;\n\n// использование "полифилла"\nalert( window.pageYOffset );`</script><code-toolbar></code-toolbar></code-example><p>Код выше не учитывает текущую прокрутку. Он присваивает <code>window.pageYOffset</code> текущую прокрутку, но при её изменении – не обновляет это свойство автоматически, а поэтому – бесполезен.</p><p>Более правильное решение – сделать это свойство геттером. При этом в IE8 для DOM-объектов работает <code>Object.defineProperty</code>:</p><code-example><script>`// полифилл\nObject.defineProperty(window, 'pageYOffset', {\n  get: function() {\n    return document.documentElement.scrollTop;\n  }\n});\n\n// использование полифилла\nalert( window.pageYOffset );`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Размеры и прокрутка элементов; Координаты в окне"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/metrics-window", disqus_identifier = "metrics-window", disqus_title = "\u0420\u0430\u0437\u043c\u0435\u0440\u044b \u0438 \u043f\u0440\u043e\u043a\u0440\u0443\u0442\u043a\u0430 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b";</script></page-content></main>