<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="99">Документ и объекты страницы</a></nav-up><h1>Атрибуты и DOM-свойства</h1><p>При чтении HTML браузер генерирует DOM-модель. При этом большинство стандартных HTML-атрибутов становятся свойствами соответствующих объектов.</p><p>Например, если тег выглядит как <code>&lt;body id="page"&gt;</code>, то у объекта будет свойство <code>body.id="page"</code>.</p><p>Но это преобразование – не один-в-один. Бывают ситуации, когда атрибут имеет одно значение, а свойство – другое. Бывает и так, что атрибут есть, а свойства с таким названием не создаётся.</p><p>Если коротко – HTML-атрибуты и DOM-свойства обычно, но не всегда соответствуют друг другу, нужно понимать, что такое свойство и что такое атрибут, чтобы работать с ними правильно.</p><h2><a name="0" href="#0">Свои DOM-свойства</a></h2><p>Ранее мы видели некоторые встроенные свойства DOM-узлов. Но, технически, никто нас ими не ограничивает.</p><p><strong>Узел DOM – это объект, поэтому, как и любой объект в JavaScript, он может содержать пользовательские свойства и методы.</strong></p><p>Например, создадим в <code>document.body</code> новое свойство и запишем в него объект:</p><code-example><script>`document.body.myData = {\n  name: 'Петр',\n  familyName: 'Петрович'\n};\n\nalert( document.body.myData.name ); // Петр`</script><code-toolbar></code-toolbar></code-example><p>Можно добавить и новую функцию:</p><code-example><script>`document.body.sayHi = function() {\n  alert( this.nodeName );\n}\n\ndocument.body.sayHi(); // BODY, выполнилась с правильным this`</script><code-toolbar></code-toolbar></code-example><p>Нестандартные свойства и методы видны только в JavaScript и никак не влияют на отображение соответствующего тега.</p><p>Обратим внимание, пользовательские DOM-свойства:</p><ul><li>Могут иметь любое значение.</li><li>Названия свойств <em>чувствительны</em> к регистру.</li><li>Работают за счет того, что DOM-узлы являются объектами JavaScript.</li></ul><h2><a name="1" href="#1">Атрибуты</a></h2><p>Элементам DOM, с другой стороны, соответствуют HTML-теги, у которых есть текстовые атрибуты.</p><p>Конечно, здесь речь именно об узлах-элементах, не о текстовых узлах или комментариях.</p><p>Доступ к атрибутам осуществляется при помощи стандартных методов:</p><ul><li><code>elem.hasAttribute(name)</code> – проверяет наличие атрибута</li><li><code>elem.getAttribute(name)</code> – получает значение атрибута</li><li><code>elem.setAttribute(name, value)</code> – устанавливает атрибут</li><li><code>elem.removeAttribute(name)</code> – удаляет атрибут</li></ul><p>Эти методы работают со значением, которое находится в HTML.</p><p>Также все атрибуты элемента можно получить с помощью свойства <code>elem.attributes</code>, которое содержит псевдо-массив объектов типа <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-637646024">Attr</a>.</p><p>В отличие от свойств, атрибуты:</p><ul><li>Всегда являются строками.</li><li>Их имя <em>нечувствительно</em> к регистру (ведь это HTML)</li><li>Видны в <code>innerHTML</code> (за исключением старых IE)</li></ul><p>Рассмотрим отличия между DOM-свойствами и атрибутами на примере HTML-кода:</p><code-example><script>`<body>\n  <div id="elem" about="Elephant" class="smiling"></div>\n</body>`</script></code-example><p>Пример ниже устанавливает атрибуты и демонстрирует их особенности.</p><code-example><script>`<body>\n  <div id="elem" about="Elephant"></div>\n&nbsp\n  <script>\n    alert( elem.getAttribute('About') ); // (1) 'Elephant', атрибут получен\n\n    elem.setAttribute('Test', 123); // (2) атрибут Test установлен\n    alert( document.body.innerHTML ); // (3) в HTML видны все атрибуты!\n\n    var attrs = elem.attributes; // (4) можно получить коллекцию атрибутов\n    for (var i = 0; i < attrs.length; i++) {\n      alert( attrs[i].name + " =&nbsp" + attrs[i].value );\n    }\n  <\/script>\n</body>`</script><code-toolbar iframe=""></code-toolbar></code-example><p>При запуске кода выше обратите внимание:</p><ol><li><code>getAttribute('About')</code> – первая буква имени атрибута <code>About</code> написана в верхнем регистре, а в HTML – в нижнем, но это не имеет значения, так как имена нечувствительны к регистру.</li><li>Мы можем записать в атрибут любое значение, но оно будет превращено в строку. Объекты также будут автоматически преобразованы.</li><li>После добавления атрибута его можно увидеть в <code>innerHTML</code> элемента.</li><li>Коллекция <code>attributes</code> содержит все атрибуты в виде объектов со свойствами <code>name</code> и <code>value</code>.</li></ol><h2><a name="2" href="#2">Когда полезен доступ к атрибутам?</a></h2><p>Когда браузер читает HTML и создаёт DOM-модель, то он создаёт свойства для всех <em>стандартных</em> атрибутов.</p><p>Например, свойства тега <code>'A'</code> описаны в спецификации DOM: <a href="http://www.w3.org/TR/REC-DOM-Level-1/level-one-html.html#ID-48250443">HTMLAnchorElement</a>.</p><p>Например, у него есть свойство <code>"href"</code>. Кроме того, он имеет <code>"id"</code> и другие свойства, общие для всех элементов, которые описаны в спецификации в <a href="http://www.w3.org/TR/REC-DOM-Level-1/level-one-html.html#ID-58190037">HTMLElement</a>.</p><p>Все стандартные свойства DOM синхронизируются с атрибутами, однако не всегда такая синхронизация происходит 1-в-1, поэтому иногда нам нужно значение именно из HTML, то есть атрибут.</p><p>Рассмотрим несколько примеров.</p><h3><a name="13" href="#13">Ссылка «как есть» из атрибута href</a></h3><p>Синхронизация не гарантирует одинакового значения в атрибуте и свойстве.</p><p>Для примера, посмотрим, что произойдет с атрибутом <code>"href"</code> при изменении свойства:</p><code-example><script>`<a id="a" href="#"></a>\n<script>\nMARK  a.href = '/';\n&nbsp\n  alert( 'атрибут:&nbsp' + a.getAttribute('href') ); // '/'\n  alert( 'свойство:&nbsp' + a.href );  // HIGHполный URLLIGHT\n&nbsp\n<\/script>`</script><code-toolbar iframe=""></code-toolbar></code-example><p>Это происходит потому, что атрибут может быть любым, а свойство <code>href</code>, <a href="http://www.w3.org/TR/REC-html40/struct/links.html#adef-href">в соответствии со спецификацией W3C</a>, должно быть полной ссылкой.</p><p>Стало быть, если мы хотим именно то, что в HTML, то нужно обращаться через атрибут.</p><important-><h3>Есть и другие подобные атрибуты</h3><p>Кстати, есть и другие атрибуты, которые не копируются в точности. Например, DOM-свойство <code>input.checked</code> имеет логическое значение <code>true/false</code>, а HTML-атрибут <code>checked</code> – любое строковое, важно лишь его наличие.</p><p>Работа с <code>checked</code> через атрибут и свойство:</p><code-example><script>`<input id="input" type="checkbox" checked>\n&nbsp\n<script>\nMARK  // работа с checked через атрибут\n  alert( input.getAttribute('checked') ); // пустая строка\n  input.removeAttribute('checked'); // снять галочку\n\nMARK  // работа с checked через свойство\n  alert( input.checked ); // false <-- может быть только true/false\n  input.checked = true; // поставить галочку (при этом атрибут в элементе не появится)\n<\/script>`</script><code-toolbar iframe="40"></code-toolbar></code-example></important-><h3><a name="14" href="#14">Исходное значение value</a></h3><p>Изменение некоторых свойств обновляет атрибут. Но это скорее исключение, чем правило.</p><p><strong>Чаще синхронизация – односторонняя: свойство зависит от атрибута, но не наоборот.</strong></p><p>Например, при изменении свойства <code>input.value</code> атрибут <code>input.getAttribute('value')</code> не меняется:</p><code-example><script>`<body>\n  <input id="input" type="text" value="markup">\n  <script>\nMARK    input.value = 'new'; // поменяли свойство\nMARK&nbsp\nMARK    alert( input.getAttribute('value') ); // 'markup', не изменилось!\n  <\/script>\n</body>`</script><code-toolbar iframe="40"></code-toolbar></code-example><p>То есть, изменение DOM-свойства <code>value</code> на атрибут не влияет, он остаётся таким же.</p><p>А вот изменение атрибута обновляет свойство:</p><code-example><script>`<body>\n  <input id="input" type="text" value="markup">\n  <script>\nMARK    input.setAttribute('value', 'new'); // поменяли атрибут\nMARK&nbsp\nMARK    alert( input.value ); // 'new', input.value изменилось!\n  <\/script>\n</body>`</script><code-toolbar iframe="40"></code-toolbar></code-example><p>Эту особенность можно красиво использовать.</p><p>Получается, что атрибут <code>input.getAttribute('value')</code> хранит оригинальное (исходное) значение даже после того, как пользователь заполнил поле и свойство изменилось.</p><p>Например, можно взять изначальное значение из атрибута и сравнить со свойством, чтобы узнать, изменилось ли значение. А при необходимости и перезаписать свойство атрибутом, отменив изменения.</p><h2><a name="3" href="#3">Классы в виде строки: className</a></h2><p>Атрибуту <code>"class"</code> соответствует свойство <code>className</code>.</p><p>Так как слово <code>"class"</code> является зарезервированным словом в Javascript, то при проектировании DOM решили, что соответствующее свойство будет называться <code>className</code>.</p><p>Например:</p><code-example><script>`<body class="main page">\n  <script>\n    // прочитать класс элемента\n    alert( document.body.className ); // main page\n\n    // поменять класс элемента\n    document.body.className = "class1 class2";\n  <\/script>\n</body>`</script><code-toolbar iframe=""></code-toolbar></code-example><p>Кстати, есть и другие атрибуты, которые называются иначе, чем свойство. Например, атрибуту <code>for</code> (<code>&lt;label for="..."&gt;</code>) соответствует свойство с названием <code>htmlFor</code>.</p><h2><a name="4" href="#4">Классы в виде объекта: classList</a></h2><p>Атрибут <code>class</code> – уникален. Ему соответствует аж целых два свойства!</p><p>Работать с классами как со строкой неудобно. Поэтому, кроме <code>className</code>, в современных браузерах есть свойство <code>classList</code>.</p><p><strong>Свойство <code>classList</code> – это объект для работы с классами.</strong></p><p>Оно поддерживается в IE начиная с IE10, но его можно эмулировать в IE8+, подключив мини-библиотеку <a href="https://github.com/eligrey/classList.js">classList.js</a>.</p><p>Методы <code>classList</code>:</p><ul><li><code>elem.classList.contains("class")</code> – возвращает <code>true/false</code>, в зависимости от того, есть ли у элемента класс <code>class</code>.</li><li><code>elem.classList.add/remove("class")</code> – добавляет/удаляет класс <code>class</code></li><li><code>elem.classList.toggle("class")</code> – если класса <code>class</code> нет, добавляет его, если есть – удаляет.</li></ul><p>Кроме того, можно перебрать классы через <code>for</code>, так как <code>classList</code> – это псевдо-массив.</p><p>Например:</p><code-example><script>`<body class="main page">\n  <script>\n    var classList = document.body.classList;\n\n    classList.remove('page'); // удалить класс\n    classList.add('post'); // добавить класс\n\n    for (var i = 0; i < classList.length; i++) { // перечислить классы\n      alert( classList[i] ); // main, затем post\n    }\n\n    alert( classList.contains('post') ); // проверить наличие класса\n\n    alert( document.body.className ); // main post, тоже работает\n  <\/script>\n</body>`</script><code-toolbar iframe=""></code-toolbar></code-example><h2><a name="5" href="#5">Нестандартные атрибуты</a></h2><p>У каждого элемента есть некоторый набор стандартных свойств, например для <code>&lt;a&gt;</code> это будут <code>href</code>, <code>name</code>, а для <code>&lt;img&gt;</code> это будут <code>src</code>, <code>alt</code>, и так далее.</p><p>Точный набор свойств описан в стандарте, обычно мы более-менее представляем, если пользуемся HTML, какие свойства могут быть, а какие – нет.</p><p>Для нестандартных атрибутов DOM-свойство не создаётся.</p><p>Например:</p><code-example><script>`<div id="elem" href="http://ya.ru" about="Elephant"></div>\n\n<script>\n  alert( elem.id ); // elem\nMARK  alert( elem.about ); // undefined\n<\/script>`</script><code-toolbar iframe=""></code-toolbar></code-example><p>Свойство является стандартным, только если оно описано в стандарте именно для этого элемента.</p><p>То есть, если назначить элементу <code>&lt;img&gt;</code> атрибут <code>href</code>, то свойство <code>img.href</code> от этого не появится. Как, впрочем, и если назначить ссылке <code>&lt;a&gt;</code> атрибут <code>alt</code>:</p><code-example><script>`<img id="img" href="test">\n<a id="link" alt="test"></a>\n\n<script>\n  alert( img.href ); // undefined\n  alert( link.alt ); // undefined\n<\/script>`</script><code-toolbar iframe=""></code-toolbar></code-example><p>Нестандартные атрибуты иногда используют для CSS.</p><p>В примере ниже для показа «состояния заказа» используется атрибут <code>order-state</code>:</p><code-example><script>`<style>\n  GOLD_.order_GOLD[BLUE_order-state_BLUE="new"] {\n    color: green;\n  }\n\n  GOLD_.order_GOLD[BLUE_order-state_BLUE="pending"] {\n    color: blue;\n  }\n\n  GOLD_.order_GOLD[BLUE_order-state_BLUE="canceled"] {\n    color: red;\n  }\n</style>\n&nbsp\n<div class="order" BLUE_order-state_BLUE="new">\n  Новый заказ.\n</div>\n\n<div class="order" BLUE_order-state_BLUE="pending">\n  Ожидающий заказ.\n</div>\n\n<div class="order" BLUE_order-state_BLUE="canceled">\n  Заказ отменён.\n</div>`</script><code-toolbar iframe="100"><a title="показать" data-code_run="0"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>Почему именно атрибут? Разве нельзя было сделать классы <code>.order-state-new</code>, <code>.order-state-pending</code>, <code>order-state-canceled</code>?</p><p>Конечно можно, но манипулировать атрибутом из JavaScript гораздо проще.</p><p>Например, если нужно отменить заказ, неважно в каком он состоянии сейчас – это сделает код:</p><code-example><script>`div.setAttribute('order-state', 'canceled');`</script></code-example><p>Для классов – нужно знать, какой класс у заказа сейчас. И тогда мы можем снять старый класс, и поставить новый:</p><code-example><script>`div.classList.remove('order-state-new');\ndiv.classList.add('order-state-canceled');`</script></code-example><p>…То есть, требуется больше исходной информации и надо написать больше букв. Это менее удобно.</p><p>Проще говоря, значение атрибута – произвольная строка, значение класса – это «есть» или «нет», поэтому естественно, что атрибуты «мощнее» и бывают удобнее классов как в JS так и в CSS.</p><h2><a name="6" href="#6">Свойство dataset, data-атрибуты</a></h2><p>С помощью нестандартных атрибутов можно привязать к элементу данные, которые будут доступны в JavaScript.</p><p>Как правило, это делается при помощи атрибутов с названиями, начинающимися на <code>data-</code>, например:</p><code-example><script>`<div id="elem" HIGHBLUE_data-about_BLUELIGHT="Elephant" HIGHBLUE_data-user-location_BLUELIGHT="street">\n  По улице прошёлся слон. Весьма красив и толст был он.\n</div>\n<script>\n  alert( elem.getAttribute('data-about') ); // Elephant\n  alert( elem.getAttribute('data-user-location') ); // street\n<\/script>`</script><code-toolbar iframe="40"></code-toolbar></code-example><p><a href="http://www.w3.org/TR/2010/WD-html5-20101019/elements.html#embedding-custom-non-visible-data-with-the-data-attributes">Стандарт HTML5</a> специально разрешает атрибуты <code>data-*</code> и резервирует их для пользовательских данных.</p><p>При этом во всех браузерах, кроме IE10-, к таким атрибутам можно обратиться не только как к атрибутам, но и как к свойствам, при помощи специального свойства <code>dataset</code>:</p><code-example><script>`<div id="elem" BLUE_data-_BLUEabout="Elephant" BLUE_data-user-location_BLUE="street">\n  По улице прошёлся слон. Весьма красив и толст был он.\n</div>\n<script>\nMARK  alert( elem.dataset.about ); // Elephant\nMARK  alert( elem.dataset.userLocation ); // street\n<\/script>`</script><code-toolbar iframe="40"></code-toolbar></code-example><p>Обратим внимание – название <code>data-user-location</code> трансформировалось в <code>dataset.userLocation</code>. Дефис превращается в большую букву.</p><h2><a name="7" href="#7">Полифилл для атрибута hidden</a></h2><p>Для старых браузеров современные атрибуты иногда нуждаются в полифилле. Как правило, такой полифилл включает в себя не только JavaScript, но и CSS.</p><p>Этот атрибут должен прятать элемент, действие весьма простое, для его поддержки в HTML достаточно такого CSS:</p><code-example><script>`<style>\nMARK  [BLUE_hidden_BLUE] { display: none }\n</style>\n\n<div>Текст</div>\n<div BLUE_hidden_BLUE>С атрибутом hidden</div>\n<div id="last">Со свойством hidden</div>\n\n<script>\n  last.hidden = true;\n<\/script>`</script><code-toolbar iframe="40"></code-toolbar></code-example><p>Если запустить в IE11- пример выше, то <code>&lt;div hidden&gt;</code> будет скрыт, а вот последний <code>div</code>, которому поставили свойство <code>hidden</code> в JavaScript – по-прежнему виден.</p><p>Это потому что CSS «не видит» присвоенное свойство, нужно синхронизировать его в атрибут.</p><p>Вот так – уже работает:</p><code-example><script>`<style>\nMARK  [BLUE_hidden_BLUE] { display: none }\n</style>\n\n<script>\nMARK  if (document.documentElement.hidden === undefined) {\nMARK    Object.defineProperty(Element.prototype, "hidden", {\nMARK      set: function(value) {\nMARK        this.setAttribute('hidden', value);\nMARK      },\nMARK      get: function() {\nMARK        return this.getAttribute('hidden');\nMARK      }\nMARK    });\nMARK  }\n<\/script>\n\n<div>Текст</div>\n<div BLUE_hidden_BLUE>С атрибутом hidden</div>\n<div id="last">Со свойством hidden</div>\n\n<script>\n  last.hidden = true;\n<\/script>`</script><code-toolbar iframe="40"></code-toolbar></code-example><h2><a name="8" href="#8">«Особенности» IE8</a></h2><p>Если вам нужна поддержка этих версий IE – есть пара нюансов.</p><ol><li><p>Во-первых, версии IE8- синхронизируют все свойства и атрибуты, а не только стандартные:</p><code-example><script>`document.body.setAttribute('my', 123);\n\nalert( document.body.my ); // 123 в IE8-`</script><code-toolbar></code-toolbar></code-example><p>При этом даже тип данных не меняется. Атрибут не становится строкой, как ему положено.</p></li><li><p>Ещё одна некорректность IE8-: для изменения класса нужно использовать именно свойство <code>className</code>, вызов <code>setAttribute('class', ...)</code> не сработает.</p></li></ol><p>Вывод из этого довольно прост – чтобы не иметь проблем в IE8, нужно использовать всегда только свойства, кроме тех ситуаций, когда нужны именно атрибуты. Впрочем, это в любом случае хорошая практика.</p><h2><a name="9" href="#9">Итого</a></h2><ul><li>Атрибуты – это то, что написано в HTML.</li><li>Свойство – это то, что находится внутри DOM-объекта.</li></ul><p>Таблица сравнений для атрибутов и свойств:</p><table><thead><tr><th>Свойства</th><th>Атрибуты</th></tr></thead><tbody><tr><td>Любое значение</td><td>Строка</td></tr><tr><td>Названия регистрозависимы</td><td>Не чувствительны к регистру</td></tr><tr><td>Не видны в <code>innerHTML</code></td><td>Видны в <code>innerHTML</code></td></tr></tbody></table><p>Синхронизация между атрибутами и свойствами:</p><ul><li>Стандартные свойства и атрибуты синхронизируются: установка атрибута автоматически ставит свойство DOM. Некоторые свойства синхронизируются в обе стороны.</li><li>Бывает так, что свойство не совсем соответствует атрибуту. Например, «логические» свойства вроде <code>checked</code>, <code>selected</code> всегда имеют значение <code>true/false</code>, а в атрибут можно записать произвольную строку.Выше мы видели другие примеры на эту тему, например <code>href</code>.</li></ul><p>Нестандартные атрибуты:</p><ul><li>Нестандартный атрибут (если забыть глюки старых IE) никогда не попадёт в свойство, так что для кросс-браузерного доступа к нему нужно обязательно использовать <code>getAttribute</code>.</li><li>Атрибуты, название которых начинается с <code>data-</code>, можно прочитать через <code>dataset</code>. Эта возможность не поддерживается IE10-.</li></ul><p>Для того, чтобы избежать проблем со старыми IE, а также для более короткого и понятного кода старайтесь везде использовать свойства, а атрибуты – только там, где это <em>действительно</em> нужно.</p><p>А <em>действительно</em> нужны атрибуты очень редко – лишь в следующих трёх случаях:</p><ol><li>Когда нужно кросс-браузерно получить нестандартный HTML-атрибут.</li><li>Когда нужно получить «оригинальное значение» стандартного HTML-атрибута, например, <code>&lt;input value="..."&gt;</code>.</li><li>Когда нужно получить список всех атрибутов, включая пользовательские. Для этого используется коллекция <code>attributes</code>.</li></ol><p>Если вы хотите использовать собственные атрибуты в HTML, то помните, что атрибуты с именем, начинающимся на <code>data-</code> валидны в HTML5 и современные браузеры поддерживают доступ к ним через свойство <code>dataset</code>.</p><h2 id="tasks"><a href="#10" name="10">Задачи (2)</a></h2><task-content><h3><a href="#15" name="15">Получите пользовательский атрибут</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><ol><li>Получите <code>div</code> в переменную.</li><li>Получите значение атрибута <code>"data-widget-name"</code> в переменную.</li><li>Выведите его.</li></ol><p>Документ:</p><code-example><script>`<body>\n\n  <div id="widget" BLUE_data-widget-name_BLUE="menu">Выберите жанр</div>\n\n  <script>\n    /* ... */\n  <\/script>\n</body>`</script></code-example><p><a data-click="task_1">открыть в песочнице</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`<body>\n\n  <div id="widget" BLUE_data-widget-name_BLUE="menu">Выберите жанр</div>\n\n  <script>\n    var div = document.getElementById('widget');\n\n    var widgetName = div.getAttribute('data-widget-name');\n    // или так, кроме IE10-\n    var widgetName = div.dataset.widgetName;\n\n    alert( widgetName ); // "menu"\n  <\/script>\n</body>`</script><code-toolbar- iframe="50"><a title="показать" data-code_run=""></a><a id="task_1" style="display:none" data-code_edit="?"></a><a id="answer_1" title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="answer_1">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#16" name="16">Поставьте класс ссылкам</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 3</span><p>Сделайте желтыми внешние ссылки, добавив им класс <code>external</code>.</p><p>Все ссылки без <code>href</code>, без протокола и начинающиеся с <code>http://internal.com</code> считаются внутренними.</p><code-example><script>`<style>\n  BLUE_.external_BLUE {\n    RED_background-color_RED: yellow\n  }\n</style>\n&nbsp\n<a BLUE_name_BLUE="list">список</a>\n<ul>\n  <li><a href="http://google.com">http://google.com</a></li>\n  <li><a href="/tutorial">/tutorial.html</a></li>\n  <li><a href="local/path">local/path</a></li>\n  <li><a href="ftp://ftp.com/my.zip">ftp://ftp.com/my.zip</a></li>\n  <li><a href="http://nodejs.org">http://nodejs.org</a></li>\n  <li><a href="http://internal.com/test">http://internal.com/test</a></li>\n</ul>`</script><code-toolbar iframe="250"><a title="показать" data-code_run="0"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>Результат:</p><figure-><style>.external{background-color:#ff0}</style><a- name="list">список</a-><ul id="list_links"><li><a href="http://google.com" class="external">http://google.com</a></li><li><a href="/tutorial">/tutorial.html</a></li><li><a href="local/path">local/path</a></li><li><a href="ftp://ftp.com/my.zip" class="external">ftp://ftp.com/my.zip</a></li><li><a href="http://nodejs.org" class="external">http://nodejs.org</a></li><li><a href="http://internal.com/test">http://internal.com/test</a></li></ul><script>for (var css='a[href*="://"]:not([href^="http://internal.com"])',links=document.getElementById('list_links').querySelectorAll(css),i=0;i<links.length;i++) links[i].classList.add("external")</script></figure-><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Сначала можно найти ссылки, например, при помощи <code>document.querySelectorAll('a')</code>, а затем выбрать из них нужные.</p><p>Затем определимся – что использовать для проверки адреса ссылки: свойство <code>href</code> или атрибут <code>getAttribute('href')</code>?</p><p>Различие между ними заключается в том, что свойство будет содержать полный путь ссылки, а атрибут – значение, указанное в HTML.</p><p>Если открыть страницу локально, на диске, то для <code>&lt;a href="/tutorial"&gt;</code> значения будут такими:</p><ul><li><code>a.getAttribute('href') == "/tutorial"</code>.</li><li><code>a.href == "file:///tutorial"</code> (возможно, в пути будет также буква диска).</li></ul><p>Здесь нужен именно атрибут, хотя бы потому, что в свойстве все ссылки уже с хостом и протоколом, а нам надо понять, был ли протокол в <code>href</code> или нет.</p><p>Правила определения:</p><ul><li>Ссылки без <code>href</code> и без протокола <code>://</code> являются заведомо внутренними.</li><li>Там, где протокол есть – проверяем, начинается ли адрес с <code>http://internal.com</code>.</li></ul><p>Итого, код может быть таким:</p><code-example><script>`var links = document.querySelectorAll('a');\n\nfor (var i = 0; i < links.length; i++) {\n\n  var a = links[i];\n\n  var href = a.getAttribute('href');\n\n  if (!href) continue; // нет атрибута\n\n  if (href.indexOf('://'_GREEN) == -RED_1_RED) BLUE_continue_BLUE; // без протокола\n\n  if (href.indexOf('http://internal.com'_GREEN) === RED_0_RED) BLUE_continue_BLUE; // внутренняя\n\n  a.classList.add('external');\n}`</script></code-example><p>…Но, как это часто бывает, знание CSS может упростить задачу. Удобнее и эффективнее здесь – указать проверки для <code>href</code> прямо в CSS-селекторе:</p><code-example><script>`<style>\n  BLUE_.external_BLUE {\n    RED_background-color_RED: yellow\n  }\n</style>\n&nbsp\n<a BLUE_name_BLUE="list">список</a>\n<ul>\n  <li><a href="http://google.com">http://google.com</a></li>\n  <li><a href="/tutorial">/tutorial.html</a></li>\n  <li><a href="local/path">local/path</a></li>\n  <li><a href="ftp://ftp.com/my.zip">ftp://ftp.com/my.zip</a></li>\n  <li><a href="http://nodejs.org">http://nodejs.org</a></li>\n  <li><a href="http://internal.com/test">http://internal.com/test</a></li>\n</ul>\n\n<script>\n// ищем все ссылки, у которых в href есть протокол,\n// но адрес начинается не с http://internal.com\nvar css = 'a[href*="://"]:not([href^="http://internal.com"])';\nvar links = document.querySelectorAll(css);\n\nfor (var i = 0; i < links.length; i++) {\n  links[i].classList.add('external');\n}\n<\/script>`</script><code-toolbar iframe="450"><a title="показать" data-code_run="0"></a><a id="answer_2" title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p><a data-click="answer_2">Открыть решение в песочнице.</a></p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Современный DOM: полифиллы; Методы contains и compareDocumentPosition"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/attributes-and-custom-properties",disqus_identifier="attributes-and-custom-properties",disqus_title="\u0410\u0442\u0440\u0438\u0431\u0443\u0442\u044b \u0438 DOM-\u0441\u0432\u043e\u0439\u0441\u0442\u0432\u0430";</script></page-content></main>