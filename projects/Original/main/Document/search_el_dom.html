<main> <page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="99">Документ и объекты страницы</a></nav-up><h1>Поиск: getElement* и querySelector* и не только</h1><p>Прямая навигация от родителя к потомку удобна, если элементы рядом. А если нет?</p><p>Как достать произвольный элемент откуда-то из глубины документа?</p><p>Для этого в DOM есть дополнительные методы поиска.</p><h2><a name="0" href="#0">document.getElementById или просто id</a></h2><p>Если элементу назначен специальный атрибут <code>id</code>, то можно получить его прямо по переменной с именем из значения <code>id</code>.</p><p>Например:</p><code-example><script>`<content- id="HIGHcontent-holderLIGHT">\n  <div id="HIGHcontentLIGHT">Элемент</div>\n</content->\n\n<script>\nMARK  alert( content.tagName ); // DOM-элемент\nMARK  alert( window['content-holder'].tagName ); // в имени дефис, поэтому через [...]\n<\/script>`</script><code-toolbar iframe="40"></code-toolbar></code-example><p>Это поведение соответствует <a href="http://www.whatwg.org/specs/web-apps/current-work/#dom-window-nameditem">стандарту</a>. Оно существует, в первую очередь, для совместимости, как осколок далёкого прошлого и не очень приветствуется, поскольку использует глобальные переменные. Браузер пытается помочь нам, смешивая пространства имён JS и DOM, но при этом возможны конфликты.</p><p><strong>Более правильной и общепринятой практикой является доступ к элементу вызовом <code>document.getElementById("идентификатор")</code>.</strong></p><p>Например:</p><code-example><script>`<div id="content">Выделим этот элемент</div>\n\n<script>\nMARK  var elem = document.getElementById('content');\nMARK&nbsp\nMARK  elem.style.background = 'red';\nMARK&nbsp\nMARK  setTimeout(() => {\nMARK    alert( elem == content ); // true\nMARK&nbsp\nMARK    content.style.background = ""; // один и тот же элемент\nMARK  }, 100); \n<\/script>`</script><code-toolbar iframe="40"></code-toolbar></code-example><important-><h3>Должен остаться только один</h3><p>По стандарту значение <code>id</code> должно быть уникально, то есть в документе может быть только один элемент с данным <code>id</code>. И именно он будет возвращён.</p><p>Если в документе есть несколько элементов с уникальным <code>id</code>, то поведение неопределено. То есть, нет гарантии, что браузер вернёт именно первый или последний – вернёт случайным образом.</p><p>Поэтому стараются следовать правилу уникальности <code>id</code>.</p></important-><p>Далее в примерах я часто буду использовать прямое обращение через переменную, чтобы было меньше букв и проще было понять происходящее. Но предпочтительным методом является <code>document.getElementById</code>.</p><h2><a name="1" href="#1">getElementsByTagName</a></h2><p>Метод <code>elem.getElementsByTagName(tag)</code> ищет все элементы с заданным тегом <code>tag</code> внутри элемента <code>elem</code> и возвращает их в виде списка.</p><p>Регистр тега не имеет значения.</p><p>Например:</p><code-example><script>`// получить все div-элементы\nvar elements = document.getElementsByTagName('div');`</script></code-example><p><strong>Обратим внимание: в отличие от <code>getElementById</code>, который существует только в контексте <code>document</code>, метод <code>getElementsByTagName</code> может искать внутри любого элемента.</strong></p><p>Например, найдём все элементы <code>input</code> внутри таблицы:</p><code-example><script>`<table id="age-table">\n  <tr>\n    <td>Ваш возраст:</td>\n\n    <td>\n      <label>\n        <input type="radio" name="age" value="young" checked> младше 18\n      </label>\n      <label>\n        <input type="radio" name="age" value="mature"> от 18 до 50\n      </label>\n      <label>\n        <input type="radio" name="age" value="senior"> старше 60\n      </label>\n    </td>\n  </tr>\n\n</table>\n\n<script>\nMARK  var tableElem = document.getElementById('age-table');\nMARK  var elements = tableElem.getElementsByTagName('input');\n\n  for (var i = 0; i < elements.length; i++) {\n    var input = elements[i];\n    alert( input.value + ':&nbsp' + input.checked );\n  }\n<\/script>`</script><code-toolbar- iframe="60"><a title="показать" data-code_run="200"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><p><strong>Можно получить всех потомков, передав звездочку <code>'*'</code> вместо тега:</strong></p><code-example><script>`// получить все элементы документа\ndocument.getElementsByTagName('*');\n\n// получить всех потомков элемента elem:\nelem.getElementsByTagName('*');`</script></code-example><important-warn><h3>Не забываем про букву <code>"s"</code>!</h3><p>Одна из самых частых ошибок начинающих (впрочем, иногда и не только) – это забыть букву <code>"s"</code>, то есть пробовать вызывать метод <code>getElementByTagName</code> вместо <code>getElement<b>s</b>ByTagName</code>.</p><p>Буква <code>"s"</code> не нужна там, где элемент только один, то есть в <code>getElementById</code>, в остальных методах она обязательна.</p></important-warn><important-warn><h3>Возвращается коллекция, а не элемент</h3><p>Другая частая ошибка – это код вида:</p><code-example><script>`// не работает\ndocument.getElementsByTagName('input').value = 5;`</script></code-example><p>То есть, вместо элемента присваивают значение коллекции. Работать такое не будет.</p><p>Коллекцию нужно или перебрать в цикле или получить элемент по номеру и уже ему присваивать <code>value</code>, например так:</p><code-example><script>`// работает\ndocument.getElementsByTagName('input')[0].value = 5;`</script></code-example></important-warn><h2><a name="2" href="#2">document.getElementsByName</a></h2><p>Вызов <code>document.getElementsByName(name)</code> позволяет получить все элементы с данным атрибутом <code>name</code>.</p><p>Например, все элементы с именем <code>age</code>:</p><code-example><script>`var elems = document.getElementsByName('age');`</script></code-example><p>До появления стандарта HTML5 этот метод возвращал только те элементы, в которых предусмотрена поддержка атрибута <code>name</code>, в частности: <code>iframe</code>, <code>a</code>, <code>input</code> и другими. В современных браузерах (IE10+) тег не имеет значения.</p><p>Используется этот метод весьма редко.</p><h2><a name="3" href="#3">getElementsByClassName</a></h2><p>Вызов <code>elem.getElementsByClassName(className)</code> возвращает коллекцию элементов с классом <code>className</code>. Находит элемент и в том случае, если у него несколько классов, а искомый – один из них.</p><p>Поддерживается всеми современными браузерами, кроме IE8-.</p><p>Например:</p><code-example><script>`<div class="article">Статья</div>\n<div class="long article">Длинная статья</div>\n\n<script>\n  var articles = document.getElementsByClassName('article');\n  alert( articles.length ); // 2, найдёт оба элемента\n<\/script>`</script><code-toolbar iframe="60"></code-toolbar></code-example><p>Как и <code>getElementsByTagName</code>, этот метод может быть вызван и в контексте DOM-элемента, и в контексте документа.</p><h2><a name="4" href="#4">querySelectorAll</a></h2><p>Вызов <code>elem.querySelectorAll(css)</code> возвращает все элементы внутри <code>elem</code>, удовлетворяющие CSS-селектору <code>css</code>.</p><p>Это один из самых часто используемых и полезных методов при работе с DOM.</p><p>Он есть во всех современных браузерах, включая IE8+ (в режиме соответствия стандарту).</p><p>Следующий запрос получает все элементы <code>LI</code>, которые являются последними потомками в <code>UL</code>:</p><code-example><script>`<ul>\n  <li>Этот</li>\n  <li>тест</li>\n</ul>\n<ul>\n  <li>полностью</li>\n  <li>пройден</li>\n</ul>\n<script>\nMARK  var elements = document.querySelectorAll('ul > li:last-child');\n\n  for (var i = 0; i < elements.length; i++) {\n    alert( elements[i].innerHTML ); // "тест", "пройден"\n  }\n<\/script>`</script><code-toolbar iframe="125"></code-toolbar></code-example><important-><h3>Псевдо-класс тоже работает</h3><p>Псевдо-классы в CSS-селекторе, в частности <code>:hover</code> и <code>:active</code>, также поддерживаются. Например, <code>document.querySelectorAll(':hover')</code> вернёт список, в порядке вложенности, из текущих элементов под курсором мыши.</p></important-><h2><a name="5" href="#5">querySelector</a></h2><p>Вызов <code>elem.querySelector(css)</code> возвращает не все, а только первый элемент, соответствующий CSS-селектору <code>css</code>.</p><p>Иначе говоря, результат – такой же, как и при <code>elem.querySelectorAll(css)[0]</code>, но в последнем вызове сначала ищутся все элементы, а потом берётся первый, а в <code>elem.querySelector(css)</code> ищется только первый, то есть он эффективнее.</p><p>Этот метод часто используется, когда мы заведомо знаем, что подходящий элемент только один, и хотим получить в переменную сразу его.</p><h2><a name="6" href="#6">matches</a></h2><p>Предыдущие методы искали по DOM.</p><p>Метод <a href="http://dom.spec.whatwg.org/#dom-element-matches">elem.matches(css)</a> ничего не ищет, а проверяет, удовлетворяет ли <code>elem</code> селектору <code>css</code>. Он возвращает <code>true</code> либо <code>false</code>.</p><p>Не поддерживается в IE8-.</p><p>Этот метод бывает полезным, когда мы перебираем элементы (в массиве или по обычным навигационным ссылкам) и пытаемся отфильтровать те из них, которые нам интересны.</p><p>Ранее в спецификации он назывался <code>matchesSelector</code>, и большинство браузеров поддерживают его под этим старым именем, либо с префиксами <code>ms/moz/webkit</code>.</p><p>Например:</p><code-example><script>`<a href="http://example.com/file.zip">...</a>\n<a href="http://ya.ru">...</a>\n\n<script>\n  var elems = document.body.children;\n\n  for (var i = 0; i < elems.length; i++) {\n    if (elems[i].HIGHmatchesLIGHT(GOLD_'a[href$="zip"]'_GOLD)) {\n      alert( "Ссылка на архив:&nbsp" + elems[i].href );\n    }\n  }\n<\/script>`</script><code-toolbar iframe="100"><a data-code_run="100" title="показать"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><h2><a name="7" href="#7">closest</a></h2><p>Метод <code>elem.closest(css)</code> ищет ближайший элемент выше по иерархии DOM, подходящий под CSS-селектор <code>css</code>. Сам элемент тоже включается в поиск.</p><p>Иначе говоря, метод <code>closest</code> бежит от текущего элемента вверх по цепочке родителей и проверяет, подходит ли элемент под указанный CSS-селектор. Если подходит – останавливается и возвращает его.</p><p>Он самый новый из методов, рассмотренных в этой главе, поэтому старые браузеры его слабо поддерживают. Это, конечно, легко поправимо, как мы увидим позже в главе <a href="/dom-polyfill">Современный DOM: полифиллы</a>.</p><p>Пример использования (браузер должен поддерживать <code>closest</code>):</p><code-example><script>`<ul>\n  <li class="chapter">Глава I\n    <ul>\n      <li class="subchapter">Глава <span class="num">1.1</span></li>\n      <li class="subchapter">Глава <span class="num">1.2</span></li>\n    </ul>\n  </li>\n</ul>\n\n<script>\n  var numberSpan = document.querySelector('.num');\n  alert(numberSpan.innerHTML);\n  // ближайший элемент сверху подходящий под селектор li\n  alert(numberSpan.closest('li').innerHTML) // subchapter\n\n  // ближайший элемент сверху подходящий под селектор .chapter\n  alert(numberSpan.closest('.chapter').tagName) // LI\n\n  // ближайший элемент сверху, подходящий под селектор span\n  // это сам numberSpan, так как поиск включает в себя сам элемент\n  alert(numberSpan.closest('span') === numberSpan) // true\n<\/script>`</script><code-toolbar iframe="95"></code-toolbar></code-example><h2><a name="8" href="#8">XPath в современных браузерах</a></h2><p>Для полноты картины рассмотрим ещё один способ поиска, который обычно используется в XML. Это <a href="http://www.w3.org/TR/xpath/">язык запросов XPath</a>.</p><p>Он очень мощный, во многом мощнее CSS, но сложнее. Например, запрос для поиска элементов <code>H2</code>, содержащих текст <code>"XPath"</code>, будет выглядеть так: <code>//h2[contains(., "XPath")]</code>.</p><p>Все современные браузеры, кроме IE, поддерживают XPath с синтаксисом, близким к <a href="https://developer.mozilla.org/en/XPath">описанному в MDN</a>.</p><p>Найдем заголовки с текстом <code>XPath</code> в текущем документе:</p><code-example><script>`var result = document.evaluate("//h2[contains(., 'XPath')]", document.documentElement, null,\n  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);\n\nfor (var i = 0; i < result.snapshotLength; i++) {\n  alert( result.snapshotItem(i).outerHTML );\n}`</script><code-toolbar></code-toolbar></code-example><p>IE тоже поддерживает XPath, но эта поддержка не соответствует стандарту и работает только для XML-документов, например, полученных с помощью <code>XMLHTTPRequest</code> (AJAX). Для обычных же HTML-документов XPath в IE не поддерживается.</p><p>Так как XPath сложнее и длиннее CSS, то используют его очень редко.</p><h2><a name="9" href="#9">Итого</a></h2><p>Есть 6 основных методов поиска элементов DOM:</p><table><thead><tr><td>Метод</td><td>Ищет по...</td><td>Ищет внутри элемента?</td><td>Поддержка</td></tr></thead><tbody><tr><td><code>getElementById</code></td><td><code>id</code></td><td>-</td><td>везде</td></tr><tr><td><code>getElementsByName</code></td><td><code>name</code></td><td>-</td><td>везде</td></tr><tr><td><code>getElementsByTagName</code></td><td>тег или <code>'*'</code></td><td>✔</td><td>везде</td></tr><tr><td><code>getElementsByClassName</code></td><td>классу</td><td>✔</td><td>кроме IE8-</td></tr><tr><td><code>querySelector</code></td><td>CSS-селектор</td><td>✔</td><td>везде</td></tr><tr><td><code>querySelectorAll</code></td><td>CSS-селектор</td><td>✔</td><td>везде</td></tr></tbody></table><p>Практика показывает, что в 95% ситуаций достаточно <code>querySelector/querySelectorAll</code>. Хотя более специализированные методы <code>getElement*</code> работают чуть быстрее, но разница в миллисекунду-другую редко играет роль.</p><p>Кроме того:</p><ul><li>Есть метод <code>elem.matches(css)</code>, который проверяет, удовлетворяет ли элемент CSS-селектору. Он поддерживается большинством браузеров в префиксной форме ( <code>ms</code>, <code>moz</code>, <code>webkit</code>).</li><li>Метод <code>elem.closest(css)</code> ищет ближайший элемент выше по иерархии DOM, подходящий под CSS-селектор css. Сам элемент тоже включается в поиск.</li><li>Язык запросов XPath поддерживается большинством браузеров, кроме IE, даже 9-й версии, но <code>querySelector</code> удобнее. Поэтому XPath используется редко.</li></ul><h2 id="tasks"><a href="#10" name="10">Задачи (2)</a></h2><task-content><h3><a href="#13" name="13">Поиск элементов</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>Ниже находится документ с таблицей и формой.</p><figure- style="padding: 5px;font-size: 14px;"><code-toolbar-><div></div><a id="get_new_window" title="открыть в новом окне" data-new_window=""></a><div></div></code-toolbar-><form name="search"><label>Поиск по сайту: <input type="text" name="search"></label><input type="submit" value="Искать!"></form><hr><form name="search-person">Поиск по посетителям: <table id="age-table"><tbody><tr><td>Возраст:</td><td id="age-list"><label><input type="radio" name="age" value="young">до 18</label><label><input type="radio" name="age" value="mature">18-50</label><label><input type="radio" name="age" value="senior">более 50</label></td></tr><tr><td>Дополнительно:</td><td><input type="text" name="info[0]"><input type="text" name="info[1]"><input type="text" name="info[2]"></td></tr></tbody></table><input type="submit" value="Искать!"></form></figure-><p>Найдите (получите в переменную) в нём:</p><ol><li>Все элементы <code>label</code> внутри таблицы. Должно быть 3 элемента.</li><li>Первую ячейку таблицы (со словом <code>"Возраст"</code>).</li><li>Вторую форму в документе.</li><li>Форму с именем <code>search</code>, без использования её позиции в документе.</li><li>Элемент <code>input</code> в форме с именем <code>search</code>. Если их несколько, то нужен первый.</li><li>Элемент с именем <code>info[0]</code>, без точного знания его позиции в документе.</li><li>Элемент с именем <code>info[0]</code>, внутри формы с именем <code>search-person</code>.</li></ol><p>Используйте для этого консоль браузера, <a data-click="get_new_window">открыв документ</a> в отдельном окне.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Есть много вариантов решения, вот некоторые из них:</p><code-example><script>`// 1\ndocument.getElementById('age-table').getElementsByTagName('label');\n\n// 2\ndocument.getElementById('age-table').getElementsByTagName('td')[0];\n// в современных браузерах можно одним запросом:\nvar result = document.querySelector('#age-table td');\n\n// 3\ndocument.getElementsByTagName('form')[1];\n\n// 4\ndocument.querySelector('form[name="search"]');\n\n// 5\ndocument.querySelector('form[name="search"] input')\n\n// 6\ndocument.getElementsByName("info[0]")[0];\n\n// 7\ndocument.querySelector('form[name="search-person"] [name="info[0]"]');`</script></code-example></task-answer></task-content><task-content><h3><a href="#14" name="14">Дерево</a><task-open hover-style="" data-show_task="" title="Закрыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Есть дерево из тегов <code>&lt;ul&gt;/&lt;li&gt;</code>.</p><iframe- src="tree.html" changeable=""><script> function on(){window.showAlert=function(){var lis=tree.getElementsByTagName('li');for (i=0;i<lis.length;i++){/* получить название из текстового узла */ var title=lis[i].firstChild.data;title=title.trim();/* убрать лишние пробелы с концов */ var childCount=lis[i].getElementsByTagName('li').length;/* получить количество детей */ alert(title+': '+childCount);}} let b=document.createElement('button');b.innerHTML='показать';b.onclick=function(){showAlert();};tree.appendChild(b);}</script><code-toolbar-><a title="показать" onclick="showAlert()"></a><a id="tree_new_window" title="открыть в новом окне" data-new_window=""></a><a data-code_edit="" id="tree_answer" style="display: none;"></a><a data-code_edit="?" id="tree_task" title="открыть в песочнице"></a></code-toolbar-></iframe-><p>Напишите код, который для каждого элемента <code>&lt;li&gt;</code> выведет:</p><ol><li>Текст непосредственно в нём (без подразделов).</li><li>Количество вложенных в него элементов <code>&lt;li&gt;</code> – всех, с учётом вложенных.</li></ol><p><a data-click="tree_new_window">Демо в новом окне</a></p><p><a data-click="tree_task">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Сделаем цикл по узлам <code>&lt;li&gt;</code>:</p><code-example><script>`var lis = document.getElementsByTagName('li');\n\nfor (i = 0; i < lis.length; i++) {\n  ...\n}`</script></code-example><p>В цикле для каждого <code>lis[i]</code> можно получить текст, используя свойство <code>firstChild</code>. Ведь первым в <code>&lt;li&gt;</code> является как раз текстовый узел, содержащий текст названия.</p><p>Также можно получить количество потомков, используя <code>lis[i].getElementsByTagName('li')</code>.</p><p>Напишите код с этой подсказкой.</p><p>Если уж не выйдет – тогда откройте решение.</p><p><a data-click="tree_answer">Открыть решение в песочнице.</a></p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Навигация по DOM-элементам; Внутреннее устройство поисковых методов"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/searching-elements-dom",disqus_identifier="searching-elements-dom",disqus_title="\u041f\u043e\u0438\u0441\u043a: getElement* \u0438 querySelector* \u0438 \u043d\u0435 \u0442\u043e\u043b\u044c\u043a\u043e";</script></page-content></main>