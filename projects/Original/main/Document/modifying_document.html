<main> <page-content><iframe src="clock.html" class="clock" style="position: fixed"></iframe><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="99">Документ и объекты страницы</a></nav-up><h1>Добавление и удаление узлов</h1><p>Изменение DOM – ключ к созданию «живых» страниц.</p><p>В этой главе мы рассмотрим, как создавать новые элементы «на лету» и заполнять их данными.</p><h2><a name="0" href="#0">Пример: показ сообщения</a></h2><p>В качестве примера рассмотрим добавление сообщения на страницу, чтобы оно было оформленно красивее чем обычный <code>alert</code>.</p><p>HTML-код для сообщения:</p><code-example><script>`<style>\nGOLD_.alert_GOLD {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background: #dff0d8;\n}\n</style>\n\nMARK<div class="alert">\nMARK  <strong>Ура!</strong> Вы прочитали это важное сообщение.\nMARK</div>`</script><code-toolbar iframe="80"></code-toolbar></code-example><h2><a name="1" href="#1">Создание элемента</a></h2><p>Для создания элементов используются следующие методы:</p><dl><dt><code>document.createElement(tag)</code></dt><dd><p>Создает новый элемент с указанным тегом:</p><code-example><script>`var div = document.createElement('div');`</script></code-example></dd></dl><p><code>document.createTextNode(text)</code></p><p>Создает новый *текстовый* узел с данным текстом:</p><code-example><script>`var textElem = document.createTextNode('Тут был я');`</script></code-example><h3><a name="9" href="#9">Создание сообщения</a></h3><p>В нашем случае мы хотим сделать DOM-элемент <code>div</code>, дать ему классы и заполнить текстом:</p><code-example><script>`var div = document.createElement('div');\ndiv.className = "alert alert-success";\ndiv.innerHTML = "<strong>Ура!</strong> Вы прочитали это важное сообщение.";`</script></code-example><p>После этого кода у нас есть готовый DOM-элемент. Пока что он присвоен в переменную <code>div</code>, но не виден, так как никак не связан со страницей.</p><h2><a name="2" href="#2">Добавление элемента: appendChild, insertBefore</a></h2><p>Чтобы DOM-узел был показан на странице, его необходимо вставить в <code>document</code>.</p><p>Для этого первым делом нужно решить, куда мы будем его вставлять. Предположим, что мы решили, что вставлять будем в некий элемент <code>parentElem</code>, например <code>var parentElem=document.body</code>.</p><p>Для вставки внутрь <code>parentElem</code> есть следующие методы:</p><p><code>parentElem.appendChild(elem)</code></p><p>Добавляет <code>elem</code> в конец дочерних элементов <code>parentElem</code>.</p><p>Следующий пример добавляет новый элемент в конец <code>&lt;ol&gt;</code>:</p><code-example><script>`<ol id="list">\n  <li>0</li>\n  <li>1</li>\n  <li>2</li>\n</ol>\n\n<script>\n  var newLi = document.createElement('li');\n  newLi.innerHTML = 'Привет, мир!';\n\n  list.appendChild(newLi);\n<\/script>`</script><code-toolbar iframe="110"></code-toolbar></code-example><p><code>parentElem.insertBefore(elem, nextSibling)</code></p><p>Вставляет <code>elem</code> в коллекцию детей <code>parentElem</code>, перед элементом <code>nextSibling</code>.</p><p>Следующий код вставляет новый элемент перед вторым <code>&lt;li&gt;</code>:</p><code-example><script>`<ol id="list">\n  <li>0</li>\n  <li>1</li>\n  <li>2</li>\n</ol>\n<script>\n  var newLi = document.createElement('li');\n  newLi.innerHTML = 'Привет, мир!';\n\nMARK  list.insertBefore(newLi, list.children[1]);\n<\/script>`</script><code-toolbar iframe="110"></code-toolbar></code-example><p>Для вставки элемента в начало достаточно указать, что вставлять будем перед первым потомком:</p><code-example><script>`list.insertBefore(newLi, list.firstChild);`</script></code-example><p>У читателя, который посмотрит на этот код внимательно, наверняка возникнет вопрос: «А что, если <code>list</code> вообще пустой, в этом случае ведь <code>list.firstChild=null</code>, произойдёт ли вставка?»</p><p>Ответ – да, произойдёт.</p><p><strong>Дело в том, что если вторым аргументом указать <code>null</code>, то <code>insertBefore</code> сработает как <code>appendChild</code>:</strong></p><code-example><script>`parentElem.insertBefore(elem, null);\n// то же, что и:\nparentElem.appendChild(elem)`</script></code-example><p>Так что <code>insertBefore</code> универсален.</p><important-><h3>На заметку:</h3><p>Все методы вставки возвращают вставленный узел.</p><p>Например, <code>parentElem.appendChild(elem)</code> возвращает <code>elem</code>.</p></important-><h3><a name="11" href="#11">Пример использования</a></h3><p>Добавим сообщение в конец <code>&lt;body&gt;</code>:</p><code-example><script>`<style>\nGOLD_.alert_GOLD {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background: #dff0d8;\n}\n</style>\n\n<body>\n  <h3>Моя страница</h3>\n</body>\n\n<script>\n  var div = document.createElement('div');\n  div.className = "alert alert-success";\n  div.innerHTML = "<strong>Ура!</strong> Вы прочитали это важное сообщение.";\n\nMARK  document.body.appendChild(div);\n<\/script>`</script><code-toolbar iframe="130"><a title="показать" data-code_run="0"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>…А теперь – в начало <code>&lt;body&gt;</code>:</p><code-example><script>`<style>\nGOLD_.alert_GOLD {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background: #dff0d8;\n}\n</style>\n\n<body>\n  <h3>Моя страница</h3>\n</body>\n\n<script>\n  var div = document.createElement('div');\n  div.className = "alert alert-success";\n  div.innerHTML = "<strong>Ура!</strong> Вы прочитали это важное сообщение.";\n\nMARK  document.body.insertBefore(div, document.body.firstChild);\n<\/script>`</script><code-toolbar iframe="120"><a title="показать" data-code_run="0"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><h2><a name="3" href="#3">Клонирование узлов: cloneNode</a></h2><p>А как бы вставить второе похожее сообщение?</p><p>Конечно, можно сделать функцию для генерации сообщений и поместить туда этот код, но в ряде случаев гораздо эффективнее – <em>клонировать</em> существующий <code>div</code>, а потом изменить текст внутри. В частности, если элемент большой, то клонировать его будет гораздо быстрее, чем пересоздавать.</p><p>Вызов <code>elem.cloneNode(true)</code> создаст «глубокую» копию элемента – вместе с атрибутами, включая подэлементы. Если же вызвать с аргументом <code>false</code>, то копия будет сделана без дочерних элементов. Это нужно гораздо реже.</p><p>Пример со вставкой копии сообщения:</p><code-example><script>`<body>\n  <style>\n  GOLD_.alert_GOLD {\n    padding: 15px;\n    border: 1px solid #d6e9c6;\n    border-radius: 4px;\n    color: #3c763d;\n    background: #dff0d8;\n  }\n  </style>\n\n  <h3>Моя страница</h3>\n\n  <script>\n    var div = document.createElement('div');\n    div.className = "alert alert-success";\n    div.innerHTML = "<strong>Ура!</strong> Вы прочитали это важное сообщение.";\n\n    document.body.insertBefore(div, document.body.firstChild);\n\nMARK    // создать копию узла\nMARK    var div2 = div.cloneNode(true);\nMARK    // копию можно подправить\nMARK    div2.querySelector('strong').innerHTML = 'Супер!';\nMARK    // вставим её после текущего сообщения\nMARK    div.parentNode.insertBefore(div2, div.nextSibling);\n  <\/script>\n</body>`</script><code-toolbar- iframe="170"><a title="показать" data-code_run="0"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><p>Обратите внимание на последнюю строку, которая вставляет <code>div2</code> после <code>div</code>:</p><code-example><script>`div.parentNode.insertBefore(div2, div.nextSibling);`</script></code-example><ol><li>Для вставки нам нужен будущий родитель. Мы, возможно, не знаем, где точно находится <code>div</code> (или не хотим зависеть от того, где он), но если нужно вставить рядом с <code>div</code>, то родителем определённо будет <code>div.parentNode</code>.</li><li>Мы хотели бы вставить <em>после</em><code>div</code>, но метода <code>insertAfter</code> нет, есть только <code>insertBefore</code>, поэтому вставляем <em>перед</em> его правым соседом <code>div.nextSibling</code>.</li></ol><h2><a name="4" href="#4">Удаление узлов: removeChild</a></h2><p>Для удаления узла есть два метода:</p><dl><dt><code>parentElem.removeChild(elem)</code></dt><dd>Удаляет <code>elem</code> из списка детей <code>parentElem</code>.</dd><dt><code>parentElem.replaceChild(newElem, elem)</code></dt><dd>Среди детей <code>parentElem</code> удаляет <code>elem</code> и вставляет на его место <code>newElem</code>.</dd></dl><p>Оба этих метода возвращают удаленный узел, то есть <code>elem</code>. Если нужно, его можно вставить в другое место DOM тут же или в будущем.</p><important-><h3>На заметку:</h3><p>Если вы хотите <em>переместить</em> элемент на новое место – не нужно его удалять со старого.</p><p><strong>Все методы вставки автоматически удаляют вставляемый элемент со старого места.</strong></p><p>Конечно же, это очень удобно.</p><p>Например, поменяем элементы местами:</p><code-example><script>`<div>Первый</div>\n<div>Второй</div>\n<script>\n  var first = document.body.children[0];\n  var last = document.body.children[1];\n\n  // нет необходимости в предварительном removeChild(last)\n  document.body.insertBefore(last, first); // поменять местами\n<\/script>`</script><code-toolbar iframe="80"></code-toolbar></code-example></important-><important-><h3>Метод <code>remove</code></h3><p>В современном стандарте есть также метод <a href="https://dom.spec.whatwg.org/#dom-childnode-remove">elem.remove()</a>, который удаляет элемент напрямую, не требуя ссылки на родителя. Это зачастую удобнее, чем <code>removeChild</code>.</p><p>Он поддерживается во всех современных браузерах, кроме IE11-. Впрочем, легко подключить или даже сделать полифилл.</p></important-><h3><a name="14" href="#14">Удаление сообщения</a></h3><p>Сделаем так, что через секунду сообщение пропадёт:</p><code-example><script>`<body>\n  <style>\n  GOLD_.alert_GOLD {\n    padding: 15px;\n    border: 1px solid #d6e9c6;\n    border-radius: 4px;\n    color: #3c763d;\n    background: #dff0d8;\n  }\n  </style>\n\n  <h3>Сообщение пропадёт через секунду</h3>\n\n  <script>\n    var div = document.createElement('div');\n    div.className = "alert alert-success";\n    div.innerHTML = "<strong>Ура!</strong> Вы прочитали это важное сообщение.";\n\n    document.body.appendChild(div);\n\nMARK    setTimeout(function() {\nMARK    div.parentNode.removeChild(div);\nMARK  }, 1000);\n  <\/script>\n</body>`</script><code-toolbar- iframe="125"><a title="показать" data-code_run="320"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><h2><a name="5" href="#5">Текстовые узлы для вставки текста</a></h2><p>При работе с сообщением мы использовали только узлы-элементы и <code>innerHTML</code>.</p><p>Но и текстовые узлы тоже имеют интересную область применения!</p><p>Если текст для сообщения нужно показать именно как текст, а не как HTML, то можно обернуть его в текстовый узел.</p><p>Например:</p><code-example><script>`<style>\nGOLD_.alert_GOLD {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background: #dff0d8;\n}\n</style>\n\n<script>\n  var div = document.createElement('div');\n  div.className = "alert alert-success";\n  document.body.appendChild(div);\n\nMARK  var text = prompt("Введите текст для сообщения", "Жили были <a> и <b>!");\nMARK&nbsp\nMARK  // вставится именно как текст, без HTML-обработки\nMARK  div.appendChild(document.createTextNode(text));\n<\/script>`</script><code-toolbar iframe="70"></code-toolbar></code-example><p>В современных браузерах (кроме IE8-) в качестве альтернативы можно использовать присвоение <code>textContent</code>.</p><h2><a name="6" href="#6">Итого</a></h2><p>Методы для создания узлов:</p><ul><li><code>document.createElement(tag)</code> – создает элемент</li><li><code>document.createTextNode(value)</code> – создает текстовый узел</li><li><code>elem.cloneNode(deep)</code> – клонирует элемент, если <code>deep == true</code>, то со всеми потомками, если <code>false</code> – без потомков.</li></ul><p>Вставка и удаление узлов:</p><ul><li><code>parent.appendChild(elem)</code></li><li><code>parent.insertBefore(elem, nextSibling)</code></li><li><code>parent.removeChild(elem)</code></li><li><code>parent.replaceChild(newElem, elem)</code></li></ul><p>Все эти методы возвращают <code>elem</code>.</p><p>Методы для изменения DOM также описаны в спецификации <a href="http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html">DOM Level 1</a>.</p><h2 id="tasks"><a href="#7" name="7">Задачи (10)</a></h2><task-content><h3><a href="#15" name="15">createTextNode vs innerHTML</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Есть <em>пустой</em> узел DOM <code>elem</code>.</p><p><strong>Одинаковый ли результат дадут эти скрипты?</strong></p><p>Первый:</p><code-example><script>`elem.appendChild(document.createTextNode(text));`</script></code-example><p>Второй:</p><code-example><script>`elem.innerHTML = text;`</script></code-example><p>Если нет – дайте пример значения <code>text</code>, для которого результат разный.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Результат выполнения может быть разный: <code>innerHTML</code> вставит именно HTML, а <code>createTextNode</code> интерпретирует теги как текст.</p><p>Запустите следующие примеры, чтобы увидеть разницу:</p><ul><li><p><code>createTextNode</code> создает текст <code>„&lt;b&gt;текст&lt;/b&gt;“</code>:</p><code-example><script>`<div id="elem"></div>\n<script>\n  var text = '<b>текст</b>';\n\n  elem.appendChild(document.createTextNode(text));\n<\/script>`</script><code-toolbar iframe="50"></code-toolbar></code-example></li><li><p><code>innerHTML</code> присваивает HTML <code>&lt;b&gt;текст&lt;/b&gt;</code>:</p><code-example><script>`<div id="elem"></div>\n<script>\n  var text = '<b>текст</b>';\n\n  elem.innerHTML = text;\n<\/script>`</script><code-toolbar iframe="50"></code-toolbar></code-example></li></ul></task-answer></task-content><task-content><h3><a href="#16" name="16">Удаление элементов</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Напишите полифилл для метода <code>remove</code> для старых браузеров.</p><p>Вызов <code>elem.remove()</code>:</p><ul><li>Если у <code>elem</code> нет родителя – ничего не делает.</li><li>Если есть – удаляет элемент из родителя.</li></ul><code-example><script>`<div>Это</div>\n<div>Все</div>\n<div>Элементы DOM</div>\n\n<script>\n  /* ваш код полифилла */\n\n  var elem = document.body.children[0];\n\nMARK  elem.remove(); // <-- вызов должен удалить элемент\n<\/script>`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Родителя <code>parentNode</code> можно получить из <code>elem</code>.</p><p>Вот так выглядит решение:</p><code-example><script>`<div>Это</div>\n<div>Все</div>\n<div>Элементы DOM</div>\n\n<script>\n  if (!Element.prototype.remove) {\n    Element.prototype.remove = function remove() {\n      if (this.parentNode) {\n        this.parentNode.removeChild(this);\n      }\n    };\n  }\n\n  var elem = document.body.children[0];\n\n  elem.remove();\n<\/script>`</script><code-toolbar iframe="60"></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#17" name="17">insertAfter</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Напишите функцию <code>insertAfter(elem, refElem)</code>, которая добавит <code>elem</code> после узла <code>refElem</code>.</p><code-example><script>`<div>Это</div>\n<div>Элементы</div>\n\n<script>\n  var elem = document.createElement('div');\n  elem.innerHTML = '<b>Новый элемент</b>';\n\n  function insertAfter(elem, refElem) { /* ваш код */ }\n\n  var body = document.body;\n\n  // вставить elem после первого элемента\n  insertAfter(elem, body.firstChild); // <--- должно работать\n\n  // вставить elem за последним элементом\n  insertAfter(elem, body.lastChild); // <--- должно работать\n<\/script>`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Для того, чтобы добавить элемент <em>после</em><code>refElem</code>, мы можем, используя <code>insertBefore</code>, вставить его <em>перед</em><code>refElem.nextSibling</code>.</p><p>Но что если <code>nextSibling</code> нет? Это означает, что <code>refElem</code> является последним потомком своего родителя и можем использовать <code>appendChild</code>.</p><p>Код:</p><code-example><script>`function insertAfter(elem, refElem) {\n  var parent = refElem.parentNode;\n  var next = refElem.nextSibling;\n  if (next) {\n    return parent.insertBefore(elem, next);\n  } else {\n    return parent.appendChild(elem);\n  }\n}`</script></code-example><p>Но код может быть гораздо короче, если вспомнить, что <code>insertBefore</code> со вторым аргументом null работает как <code>appendChild</code>:</p><code-example><script>`function insertAfter(elem, refElem) {\n  return refElem.parentNode.insertBefore(elem, refElem.nextSibling);\n}`</script></code-example><p>Если нет <code>nextSibling</code>, то второй аргумент <code>insertBefore</code> становится <code>null</code> и тогда <code>insertBefore(elem, null)</code> осуществит вставку в конец, как и требуется.</p><p>В решении нет проверки на существование <code>refElem.parentNode</code>, поскольку вставка после элемента без родителя – уже ошибка, пусть она возникнет в функции, это нормально.</p></task-answer></task-content><task-content><h3><a href="#18" name="18">removeChildren</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Напишите функцию <code>removeChildren</code>, которая удаляет всех потомков элемента.</p><code-example><script>`<table id="table">\n  <tr>\n    <td>Это</td>\n    <td>Все</td>\n    <td>Элементы DOM</td>\n  </tr>\n</table>\n\n<ol id="ol">\n  <li>Вася</li>\n  <li>Петя</li>\n  <li>Маша</li>\n  <li>Даша</li>\n</ol>\n\n<script>\n  function removeChildren(elem) { /* ваш код */ }\n\n  removeChildren(table); // очищает таблицу\n  removeChildren(ol); // очищает список\n<\/script>`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="" style="">Неправильное решение</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4 class="task__step-title">Неправильное решение</h4><p>Для начала рассмотрим забавный пример того, как делать <em>не надо</em>:</p><code-example><script>`function removeChildren(elem) {\n  for (var k = 0; k < elem.childNodes.length; k++) {\n    elem.removeChild(elem.childNodes[k]);\n  }\n}`</script></code-example><p>Если вы попробуете это на практике, то увидите, что это не сработает.</p><p>Не сработает потому, что коллекция <code>childNodes</code> всегда начинается с индекса 0 и автоматически обновляется, когда первый потомок удален(т.е. тот, что был вторым, станет первым). А переменная <code>k</code> в цикле всё время увеличивается, поэтому такой цикл пропустит половину узлов.</p></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Решение через DOM</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4 class="task__step-title">Решение через DOM</h4><p>Правильное решение:</p><code-example><script>`function removeChildren(elem) {\n  while (elem.lastChild) {\n    elem.removeChild(elem.lastChild);\n  }\n}`</script></code-example></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Альтернатива через innerHTML</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4 class="task__step-title">Альтернатива через innerHTML</h4><p>Можно и просто обнулить содержимое через <code>innerHTML</code>:</p><code-example><script>`function removeChildren(elem) {\n  elem.innerHTML = '';\n}`</script></code-example><p>Это не будет работать в IE8- для таблиц, так как на большинстве табличных элементов (кроме ячеек <code>TH/TD</code>) в старых IE запрещено менять <code>innerHTML</code>.</p><p>Впрочем, можно завернуть <code>innerHTML</code> в <code>try/catch</code>:</p><code-example><script>`function removeChildren(elem) {\n  try {\n    elem.innerHTML = '';\n  } catch (e) {\n    while (elem.firstChild) {\n      elem.removeChild(elem.firstChild);\n    }\n  }\n}`</script></code-example></task-answer></task-answer-ext></task-content><task-content><h3><a href="#19" name="19">Почему остаётся "ааа" ?</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 1</span><p>Запустите этот пример. Почему вызов <code>removeChild</code> не удалил текст <code>"aaa"</code>?</p><code-example><script>`<table>\n  aaa\n  <tr>\n    <td>Test</td>\n  </tr>\n</table>\n\n<script>\n  var table = document.body.children[0];\n\n  alert( table ); // таблица, пока всё правильно\n\n  document.body.removeChild(table);\n  // почему в документе остался текст?\n<\/script>`</script><code-toolbar iframe="50"></code-toolbar></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>HTML в задаче некорректен. В этом всё дело. И вопрос легко решится, если открыть отладчик.</p><p>В нём видно, что браузер поместил текст <code>aaa</code><em>перед</em> таблицей. Поэтому он и остался в документе.</p><p>Вообще, в стандарте HTML5 описано, как браузеру обрабатывать некорректный HTML, так что такое действие браузера является правильным.</p></task-answer></task-content><task-content><h3><a href="#20" name="20">Создать список</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>Напишите интерфейс для создания списка.</p><p>Для каждого пункта:</p><ol><li>Запрашивайте содержимое пункта у пользователя с помощью <code>prompt</code>.</li><li>Создавайте пункт и добавляйте его к <code>UL</code>.</li><li>Процесс прерывается, когда пользователь нажимает ESC или вводит пустую строку.</li></ol><p><strong>Все элементы должны создаваться динамически.</strong></p><p>Если посетитель вводит теги – пусть в списке они показываются как обычный текст.</p><p><a data-click="list">Демо в новом окне</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Делаем цикл, пока посетитель что-то вводит – добавляет <code>&lt;li&gt;</code>.</p><p>Содержимое в <code>&lt;li&gt;</code> присваиваем через <code>document.createTextNode</code>, чтобы правильно работали &lt;, &gt; и т.д.</p><code-example><script>`<h1>Создание списка</h1>\n\n<script>\n  var ul = document.createElement('ul');\n  document.body.appendChild(ul);\n\n  while (true) {\n    var data = prompt("Введите текст для пункта списка", "");\n\n    if (!data) {\n      break;\n    }\n\n    var li = document.createElement('li');\n    li.appendChild(document.createTextNode(data));\n    ul.appendChild(li);\n  }\n<\/script>`</script><code-toolbar- iframe="100"><a title="показать" data-code_run=""></a><a id="list" title="открыть в новом окне" data-new_window="code"></a><a id="list_answer" title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="list_answer">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#21" name="21">Создайте дерево из объекта</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Напишите функцию, которая создаёт вложенный список <code>UL/LI</code> (дерево) из объекта.</p><p>Например:</p><code-example><script>`var data = {\n  "Рыбы": {\n    "Форель": {},\n    "Щука": {}\n  },\n\n  "Деревья": {\n    "Хвойные": {\n      "Лиственница": {},\n      "Ель": {}\n    },\n    "Цветковые": {\n      "Берёза": {},\n      "Тополь": {}\n    }\n  }\n};`</script></code-example><p>Синтаксис:</p><code-example><script>`var container = document.getElementById('container');\nMARKcreateTree(container, data); // создаёт`</script></code-example><p>Результат (дерево):</p><figure- style="height:250px"><div id="container"><ul><li>Рыбы <ul><li>Форель</li><li>Щука</li></ul></li><li>Деревья <ul><li>Хвойные <ul><li>Лиственница</li><li>Ель</li></ul></li><li>Цветковые <ul><li>Берёза</li><li>Тополь</li></ul></li></ul></li></ul></div></figure-><p>Выберите один из двух способов решения этой задачи:</p><ol><li>Создать строку, а затем присвоить через <code>container.innerHTML</code>.</li><li>Создавать узлы через методы DOM.</li></ol><p>Если получится – сделайте оба.</p><p>P.S. Желательно, чтобы в дереве не было лишних элементов, в частности – пустых <code>&lt;ul&gt;&lt;/ul&gt;</code> на нижнем уровне.</p><p><a data-code_edit="tree_task.html">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><h4>Решения через рекурсию. <p></p></h4><button-answer-ext data-toggle_answer_ext="" style="">Через innerHTML</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`<div id="container"></div>\n<script>\n  var data = {\n    "Рыбы": {\n      "Форель": {},\n      "Щука": {}\n    },\n\n    "Деревья": {\n      "Хвойные": {\n        "Лиственница": {},\n        "Ель": {}\n      },\n      "Цветковые": {\n        "Берёза": {},\n        "Тополь": {}\n      }\n    }\n  };\n\n  function createTree(container, obj) {\n    container.innerHTML = createTreeText(obj);\n  }\n\n  function createTreeText(obj) { // отдельная рекурсивная функция\n    var li = '';\n    for (var key in obj) {\n      li += "<li>" + key + createTreeText(obj[key]) + '</li>';\n    }\n    if (li) {\n      var ul = "<ul>" + li + '</ul>';\n    }\n    return ul || '';\n  }\n\n  var container = document.getElementById('container');\n  createTree(container, data);\n<\/script>`</script><code-toolbar- iframe="550"><a title="показать" data-code_run="0"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Через DOM</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`<div id="container"></div>\n\n<script>\n  var data = {\n    "Рыбы": {\n      "Форель": {},\n      "Щука": {}\n    },\n\n    "Деревья": {\n      "Хвойные": {\n        "Лиственница": {},\n        "Ель": {}\n      },\n      "Цветковые": {\n        "Берёза": {},\n        "Тополь": {}\n      }\n    }\n  };\n\n  function createTree(container, obj) {\n    container.appendChild(createTreeDom(obj));\n  }\n\n  function createTreeDom(obj) {\n    // если нет детей, то рекурсивный вызов ничего не возвращает\n    // так что вложенный UL не будет создан\n    if (isObjectEmpty(obj)) return;\n\n    var ul = document.createElement('ul');\n\n    for (var key in obj) {\n      var li = document.createElement('li');\n      li.innerHTML = key;\n\n      var childrenUl = createTreeDom(obj[key]);\n      if (childrenUl) li.appendChild(childrenUl);\n\n      ul.appendChild(li);\n    }\n    return ul;\n  }\n\n  function isObjectEmpty(obj) {\n    for (var key in obj) {\n      return false;\n    }\n    return true;\n  }\n\n  var container = document.getElementById('container');\n  createTree(container, data);\n<\/script>`</script><code-toolbar- iframe="650"><a title="показать" data-code_run="0"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example></task-answer></task-answer-ext></task-content><task-content><h3><a href="#22" name="22">Дерево</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Есть дерево, организованное в виде вложенных списков <code>&lt;ul&gt;/&lt;li&gt;</code>.</p><p>Напишите код, который добавит каждому элементу списка <code>&lt;li&gt;</code> количество вложенных в него элементов. Узлы нижнего уровня, без детей – пропускайте.</p><p>Результат:</p><iframe- src="tree.html" changeable=""><code-toolbar-><a data-code_edit="" id="answer_8" style="display:none"></a><a data-new_window="" id="new_8" title="открыть в новом окне"></a><a data-code_edit="?" id="task_8" title="открыть в песочнице"></a></code-toolbar-><script> function on(){var lis=tree.getElementsByTagName('li');for (i=0;i<lis.length;i++){var childCount=lis[i].getElementsByTagName('li').length;/* получить количество детей */ if (!childCount) continue;lis[i].firstChild.data += ' ['+childCount+']';/* добавить кол-во детей к текстовому узлу */}}</script></iframe-><p><a data-click="task_8">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="" style="">Подсказки</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4 class="task__step-title">Подсказки</h4><ol><li>Получить количество вложенных узлов можно через <code>elem.getElementsByTagName('*').length</code>.</li><li>Текст в начале <code>&lt;li&gt;</code> доступен как <code>li.firstChild</code>, его содержимое – <code>li.firstChild.data</code>.</li></ol></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Решение</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Решение</h4><p><a data-click="answer_8">Открыть решение в песочнице.</a></p></task-answer></task-answer-ext></task-content><task-content><h3><a href="#23" name="23">Создать календарь в виде таблицы</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>Напишите функцию, которая умеет генерировать календарь для заданной пары (месяц, год).</p><p>Календарь должен быть таблицей, где каждый день – это <code>TD</code>. У таблицы должен быть заголовок с названиями дней недели, каждый день – <code>TH</code>.</p><p>Синтаксис: <code>createCalendar(id, year, month)</code>.</p><p>Такой вызов должен генерировать текст для календаря месяца <code>month</code> в году <code>year</code>, а затем помещать его внутрь элемента с указанным <code>id</code>.</p><p>Например: <code>createCalendar("cal", 2012, 9)</code> сгенерирует в <code>&lt;div id=„cal“&gt;&lt;/div&gt;</code> следующий календарь:</p><figure- style="height:180px"><code-toolbar-><a onclick="calendar.innerHTML='';setTimeout(()=>{createCalendar('calendar', 2012, 9)},100)" data-code_edit="?" id="task_9" style="display:none"></a><a onclick="calendar.innerHTML='';setTimeout(()=>{createCalendar('calendar', 2012, 9)},100)" data-code_edit="" id="answer_9" title="открыть в песочнице"></a></code-toolbar-><style> table{border-collapse:collapse}td,th{border:1px solid #000;padding:3px;text-align:center}th{font-weight:700;background-color:#e6e6e6}</style><div id="calendar"><table><tbody><tr><th>пн</th><th>вт</th><th>ср</th><th>чт</th><th>пт</th><th>сб</th><th>вс</th></tr><tr><td></td><td></td><td></td><td></td><td></td><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr><tr><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td></tr><tr><td>17</td><td>18</td><td>19</td><td>20</td><td>21</td><td>22</td><td>23</td></tr><tr><td>24</td><td>25</td><td>26</td><td>27</td><td>28</td><td>29</td><td>30</td></tr><tr></tr></tbody></table></div><script>function createCalendar(id,year,month){var elem=document.getElementById(id);var mon=month-1;/* месяцы в JS идут от 0 до 11,а не от 1 до 12 */ var d=new Date(year,mon);var table='<table><tr><th>пн</th><th>вт</th><th>ср</th><th>чт</th><th>пт</th><th>сб</th><th>вс</th></tr><tr>';for (var i=0;i<getDay(d);i++){/* заполнить первый ряд от понедельника и до дня,с которого начинается месяц * * * | 1 2 3 4 */ table += '<td></td>';}while (d.getMonth() == mon){/* ячейки календаря с датами */ table += '<td>'+d.getDate()+'</td>';if (getDay(d) % 7 == 6){/* вс,последний день-перевод строки */ table += '</tr><tr>';}d.setDate(d.getDate()+1);}if (getDay(d) != 0){/* добить таблицу пустыми ячейками,если нужно */ for (var i=getDay(d);i<7;i++){table += '<td></td>';}} table += '</tr></table>';/* закрыть таблицу */ elem.innerHTML=table;/* только одно присваивание innerHTML */}function getDay(date){/* получить номер дня недели,от 0(пн) до 6(вс) */ var day=date.getDay();if (day == 0) day=7;return day-1;}createCalendar("calendar",2012,9)</script></figure-><p>P.S. Достаточно сгенерировать календарь, кликабельным его делать не нужно.</p><p><a data-click="task_9">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Для решения задачи сгенерируем таблицу в виде строки: <code>"&lt;table&gt;...&lt;/table&gt;"</code>, а затем присвоим в <code>innerHTML</code>.</p><p>Алгоритм:</p><ol><li>Создать объект даты <code>d=new Date(year, month-1)</code>. Это первый день месяца <code>month</code> (с учетом того, что месяцы в JS начинаются от 0, а не от 1).</li><li>Ячейки первого ряда пустые от начала и до дня недели <code>d.getDay()</code>, с которого начинается месяц. Создадим их.</li><li>Увеличиваем день в <code>d</code> на единицу: <code>d.setDate(d.getDate()+1)</code>, и добавляем в календарь очередную ячейку, пока не достигли следующего месяца. При этом последний день недели означает вставку перевода строки <code>«&lt;/tr&gt;&lt;tr&gt;»</code>.</li><li>При необходимости, если календарь окончился не на воскресенье – добавить пустые <code>TD</code> в таблицу, чтобы было все ровно.</li></ol><p><a data-click="answer_9">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#24" name="24">Часики с использованием "setInterval"</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>Создайте цветные часики как в примере ниже:</p><figure><code-toolbar-><a id="clock_task" style="display:none" title="показать" data-code_edit="task"></a><a id="clock_answer" style="display:none" title="открыть в песочнице" data-code_edit=""></a></code-toolbar-><iframe src="clock.html" class="clock"></iframe></figure><p><a data-click="clock_task">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Для начала, придумаем подходящую HTML/CSS-структуру.</p><p>Здесь каждый компонент времени удобно поместить в соответствующий <code>SPAN</code>:</p><code-example><script>`<div id="clock">\n  <span class="hour">hh</span>:<span class="min">mm</span>:<span class="sec">ss</span>\n</div>`</script></code-example><p>Каждый <code>SPAN</code> раскрашивается при помощи CSS.</p><p>Жизнь часам будет обеспечивать функция <code>update</code>, вызываемая каждую секунду:</p><code-example><script>`function update() {\n  var clock = document.getElementById('clock');\n\nMARK  var date = new Date(); // (*)\n\n  var hours = date.getHours();\n  if (hours < 10) hours = '0' + hours;\n  clock.children[0].innerHTML = hours;\n\n  var minutes = date.getMinutes();\n  if (minutes < 10) minutes = '0' + minutes;\n  clock.children[1].innerHTML = minutes;\n\n  var seconds = date.getSeconds();\n  if (seconds < 10) seconds = '0' + seconds;\n  clock.children[2].innerHTML = seconds;\n}`</script></code-example><p>В строке <code>(*)</code> каждый раз мы получаем текущую дату. Мы должны это сделать, несмотря на то, что, казалось бы, могли бы просто увеличивать счетчик каждую секунду.</p><p>На самом деле мы не можем опираться на счетчик для вычисления даты, т.к. <code>setInterval</code> не гарантирует точную задержку. Если в другом участке кода будет вызван <code>alert</code>, то часы остановятся, как и любые счетчики.</p><p>Для запуска часов:</p><code-example><script>`setInterval(update, 1000);\nupdate();`</script></code-example><p>Обратите внимание, что вызов <code>update</code> не только запланирован, но и тут же производится в строке <code>(*)</code>. Иначе посетителю пришлось бы ждать до первого выполнения <code>setInterval</code>, то есть целую секунду.</p><p><a data-click="clock_answer">Открыть решение в песочнице.</a></p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Методы contains и compareDocumentPosition; Мультивставка: insertAdjacentHTML и DocumentFragment"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/modifying-document",disqus_identifier="modifying-document",disqus_title="\u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0438 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u0435 \u0443\u0437\u043b\u043e\u0432";</script></page-content></main>