<main> <page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="99">Документ и объекты страницы</a></nav-up><h1>Размеры и прокрутка элементов</h1><p>Для того, чтобы показывать элементы на произвольных местах страницы, необходимо во-первых, знать CSS-позиционирование, а во-вторых – уметь работать с «геометрией элементов» из JavaScript.</p><p>В этой главе мы поговорим о размерах элементов DOM, способах их вычисления и <em>метриках</em> – различных свойствах, которые содержат эту информацию.</p><h2><a name="0" href="#0">Образец документа</a></h2><p>Мы будем использовать для примера вот такой элемент, у которого есть рамка (border), поля (padding), и прокрутка:</p><code-example><script>`<div id="example">\n  ...Текст...\n</div>\n<style>\n  GOLD_#example_GOLD {\n    width: 300px;\n\n    height: 200px;\n\n    border: 25px solid #E8C48F; /* рамка 25px */\n\n    padding: 20px;              /* поля 20px */\n\n    overflow: auto;             /* прокрутка */\n  }\n</style>`</script></code-example><p>У него нет отступов <code>margin</code>, в этой главе они не важны, так как метрики касаются именно размеров самого элемента, отступы в них не учитываются.</p><p>Результат выглядит так:</p><figure><img src="metric-css.png" alt="" width="100%" style="max-width:566px"></figure><p>Вы можете открыть <a href="http://plnkr.co/edit/iQIbur6EeZDAe015k65z?p=preview">этот документ в песочнице</a>.</p><important-><h3>Внимание, полоса прокрутки!</h3><p>В иллюстрации выше намеренно продемонстрирован самый сложный и полный случай, когда у элемента есть ещё и полоса прокрутки.</p><p>В этом случае полоса прокрутки «отодвигает» содержимое вместе с <code>padding</code> влево, отбирая у него место.</p><p>Именно поэтому ширина содержимого обозначена как <code>content width</code> и равна <code>284px</code>, а не <code>300px</code>, как в CSS.</p><p>Точное значение получено в предположении, что ширина полосы прокрутки равна <code>16px</code>, то есть после её вычитания на содержимое остаётся <code>300-16=284px</code>. Конечно, она сильно зависит от браузера, устройства, ОС.</p><p>Мы должны в точности понимать, что происходит с размерами элемента при наличии полосы прокрутки, поэтому на картинке выше это отражено.</p></important-><important-><h3> Поля <code>padding</code> могут быть заполнены текстом </h3><p>На рисунке выше поля <code>padding</code> изображены пустыми, но текст там вполне может быть, к примеру, при наличии вертикальной прокрутки.</p></important-><h2><a name="1" href="#1">Метрики</a></h2><p>У элементов существует ряд свойств, содержащих их внешние и внутренние размеры. Мы будем называть их «метриками».</p><p>Метрики, в отличие от свойств CSS, содержат числа, всегда в пикселях и без единиц измерения на конце.</p><p>Вот общая картина:</p><figure><img src="metric-all.png" alt="" width="100%" style="max-width:670px"></figure><p>На картинке все они с трудом помещаются, но, как мы увидим далее, их значения просты и понятны.</p><p>Будем исследовать их снаружи элемента и вовнутрь.</p><h2><a name="2" href="#2">offsetParent, offsetLeft/Top</a></h2><p>Ситуации, когда эти свойства нужны, можно перечислить по пальцам. Они возникают действительно редко. Как правило, эти свойства используют, потому что не знают средств правильной работы с координатами, о которых мы поговорим позже.</p><p>Несмотря на то, что эти свойства нужны реже всего, они – самые «внешние», поэтому начнём с них.</p><p><strong> В <code>offsetParent</code> находится ссылка на родительский элемент в смысле отображения на странице. </strong></p><p>Уточним, что имеется в виду.</p><p>Когда браузер рисует страницу, то он высчитывает дерево расположения элементов, иначе говоря «дерево геометрии» или «дерево рендеринга», которое содержит всю информацию о размерах.</p><p>При этом одни элементы естественным образом рисуются внутри других. Но, к примеру, если у элемента стоит <code>position:absolute</code>, то его расположение вычисляется уже не относительно непосредственного родителя <code>parentNode</code>, а относительно ближайшего <a href="http://www.w3.org/TR/CSS21/visuren.html#position-props">позиционированного элемента</a> (т.е. свойство <code>position</code> которого не равно <code>static</code>), или <code>BODY</code>, если такой отсутствует.</p><p>Получается, что элемент имеет в дополнение к обычному родителю в DOM – ещё одного «родителя по позиционированию», то есть относительно которого он рисуется. Этот элемент и будет в свойстве <code>offsetParent</code>.</p><p><strong> Свойства <code>offsetLeft/Top</code> задают смещение относительно <code>offsetParent</code>. </strong></p><p>В примере ниже внутренний <code>&lt;div&gt;</code> имеет DOM-родителя <code>&lt;form&gt;</code>, но <code>offsetParent</code> у него <code>&lt;main&gt;</code>, и сдвиги относительно его верхнего-левого угла будут в <code>offsetLeft/Top</code>:</p><code-example><script>`<main style="position: relative">\n  <form>\n    <div id="example" style="position: absolute; left: 180px; top: 180px">...</div>\n  </form>\n</main>`</script></code-example><figure><img src="metric-offset-parent.png" alt="" width="100%" style="max-width:641px"></figure><h2><a name="3" href="#3">offsetWidth/Height</a></h2><p>Теперь переходим к самому элементу.</p><p>Эти два свойства – самые простые. Они содержат «внешнюю» ширину/высоту элемента, то есть его полный размер, включая рамки <code>border</code>.</p><figure><img src="metric-offset-width-height.png" alt="" width="100%" style="max-width:507px"></figure><p>Для нашего элемента:</p><ul><li><code>offsetWidth=390</code> – внешняя ширина блока, её можно получить сложением CSS-ширины ( <code>300px</code>, но её часть на рисунке выше отнимает прокрутка, поэтому <code>284+16</code>), полей( <code>2*20px</code>) и рамок ( <code>2*25px</code>). </li><li><code>offsetHeight=290</code> – внешняя высота блока. </li></ul><important-><h3>Метрики для невидимых элементов равны нулю.</h3><p>Координаты и размеры в JavaScript устанавливаются только для <em>видимых</em> элементов.</p><p>Для элементов с <code>display:none</code> или находящихся вне документа дерево рендеринга не строится. Для них метрики равны нулю. Кстати, и <code>offsetParent</code> для таких элементов тоже <code>null</code>.</p><p><strong>Это дает нам замечательный способ для проверки, виден ли элемент</strong>:</p><code-example><script>`function isHidden(elem) {\n  return !elem.offsetWidth && !elem.offsetHeight;\n}`</script></code-example><ul><li> Работает, даже если родителю элемента установлено свойство <code>display:none</code>. </li><li> Работает для всех элементов, кроме <code>TR</code>, с которым возникают некоторые проблемы в разных браузерах. Обычно, проверяются не <code>TR</code>, поэтому всё ок. </li><li> Считает элемент видимым, даже если позиционирован за пределами экрана или имеет свойство <code>visibility:hidden</code>. </li><li> «Схлопнутый» элемент, например пустой <code>div</code> без высоты и ширины, будет считаться невидимым. </li></ul></important-><h2><a name="4" href="#4">clientTop/Left</a></h2><p>Далее внутри элемента у нас рамки <code>border</code>.</p><p>Для них есть свойства-метрики <code>clientTop</code> и <code>clientLeft</code>.</p><p>В нашем примере:</p><ul><li><code>clientLeft=25</code> – ширина левой рамки </li><li><code>clientTop=25</code> – ширина верхней рамки </li></ul><figure><img src="metric-client-left-top.png" alt="" width="100%" style="max-width:352px"></figure><p>…Но на самом деле они – вовсе не рамки, а отступ внутренней части элемента от внешней.</p><p>В чём же разница?</p><p>Она возникает тогда, когда документ располагается <em>справа налево</em> (операционная система на арабском языке или иврите). Полоса прокрутки в этом случае находится слева, и тогда свойство <code>clientLeft</code> включает в себя еще и ширину полосы прокрутки.</p><p>Получится так:</p><figure><img src="metric-client-left-top-rtl.png" alt="" width="100%" style="max-width:358px"></figure><h2><a name="5" href="#5">clientWidth/Height</a></h2><p>Эти свойства – размер элемента внутри рамок <code>border</code>.</p><p>Они включают в себя ширину содержимого <code>width</code> вместе с полями <code>padding</code>, но без прокрутки.</p><figure><img src="metric-client-width-height.png" alt="" width="100%" style="max-width:500px"></figure><p>На рисунке выше посмотрим вначале на <code>clientHeight</code>, её посчитать проще всего. Прокрутки нет, так что это в точности то, что внутри рамок: CSS-высота <code>200px</code> плюс верхнее и нижнее поля <code>padding</code> (по <code>20px</code>), итого <code>240px</code>.</p><p>На рисунке нижний <code>padding</code> заполнен текстом, но это неважно: по правилам он всегда входит в <code>clientHeight</code>.</p><p>Теперь <code>clientWidth</code> – ширина содержимого здесь не равна CSS-ширине, её часть «съедает» полоса прокрутки.Поэтому в <code>clientWidth</code> входит не CSS-ширина, а реальная ширина содержимого <code>284px</code> плюс левое и правое поля <code>padding</code> (по <code>20px</code>), итого <code>324px</code>.</p><p><strong> Если <code>padding</code> нет, то <code>clientWidth/Height</code> в точности равны размеру области содержимого, внутри рамок и полосы прокрутки. </strong></p><figure><img src="metric-client-width-nopadding.png" alt="" width="100%" style="max-width:408px"></figure><p>Поэтому в тех случаях, когда мы точно знаем, что <code>padding</code> нет, их используют для определения внутренних размеров элемента.</p><h2><a name="6" href="#6">scrollWidth/Height</a></h2><p>Эти свойства – аналоги <code>clientWidth/clientHeight</code>, но с учетом прокрутки.</p><p>Свойства <code>clientWidth/clientHeight</code> относятся только к видимой области элемента, а <code>scrollWidth/scrollHeight</code> добавляют к ней прокрученную (которую не видно) по горизонтали/вертикали.</p><figure><img src="metric-scroll-width-height.png" alt="" width="100%" style="max-width:462px"></figure><p>На рисунке выше:</p><ul><li><code>scrollHeight=723</code> – полная внутренняя высота, включая прокрученную область. </li><li><code>scrollWidth=324</code> – полная внутренняя ширина, в данном случае прокрутки нет, поэтому она равна <code>clientWidth</code>. </li></ul><p>Эти свойства можно использовать, чтобы «распахнуть» элемент на всю ширину/высоту, таким кодом:</p><code-example><script>`element.style.height = element.scrollHeight + 'px';`</script></code-example><p>Нажмите на кнопку, чтобы распахнуть элемент:</p><div id="scrollOpen" style="width: 300px; height: 200px; padding: 0px; overflow: auto; border: 1px solid black;"> текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст </div><p><button style="padding:0" onclick="var t = document.getElementById('scrollOpen'); if(!t.open){t.open = true; t.style.height = t.scrollHeight + 'px';} else {delete t.open; t.style.height = '200px'}">element.style.height=element.scrollHeight+„px“</button></p><h2><a name="7" href="#7">scrollLeft/scrollTop</a></h2><p>Свойства <code>scrollLeft/scrollTop</code> – ширина/высота невидимой, прокрученной в данный момент, части элемента слева и сверху.</p><p>Следующая иллюстрация показывает значения <code>scrollHeight</code> и <code>scrollTop</code> для блока с вертикальной прокруткой.</p><figure><img src="metric-scroll-top.png" alt="" width="100%" style="max-width:488px"></figure><important-><h3><code>scrollLeft/scrollTop</code> можно изменять </h3><p>В отличие от большинства свойств, которые доступны только для чтения, значения <code>scrollLeft/scrollTop</code> можно изменить, и браузер выполнит прокрутку элемента.</p><p>При клике на следующий элемент будет выполняться код <code>elem.scrollTop += 10</code>. Поэтому он будет прокручиваться на <code>10px</code> вниз:</p><div onclick="this.scrollTop+=10" style="cursor:pointer;border:1px solid black;width:100px;height:80px;overflow:auto;padding:5px"> Кликни <br>Меня <br>1 <br>2 <br>3 <br>4 <br>5 <br>6 <br>7 <br>8 <br>9 </div></important-><h2><a name="8" href="#8">Не стоит брать width/height из CSS</a></h2><p>Мы рассмотрели метрики – свойства, которые есть у DOM-элементов. Их обычно используют для получения их различных высот, ширин и прочих расстояний.</p><p>Теперь несколько слов о том, как <em>не</em> надо делать.</p><p>Как мы знаем, CSS-высоту и ширину можно установить с помощью <code>elem.style</code> и извлечь, используя <code>getComputedStyle</code>, которые в подробностях обсуждаются в главе <a href="/styles-and-classes">Стили, getComputedStyle</a>.</p><p>Получение ширины элемента может быть таким:</p><code-example><script>`var elem = document.body;\n\nalert( getComputedStyle(elem).width ); // вывести CSS-ширину для elem`</script><code-toolbar></code-toolbar></code-example><p>Не лучше ли получать ширину так, вместо метрик? Вовсе нет!</p><ol><li><p>Во-первых, CSS-свойства <code>width/height</code> зависят от другого свойства – <code>box-sizing</code>, которое определяет, что такое, собственно, эти ширина и высота. Получается, что изменение <code>box-sizing</code>, к примеру, для более удобной вёрстки, сломает такой JavaScript.</p></li><li><p>Во-вторых, в CSS свойства <code>width/height</code> могут быть равны <code>auto</code>, например, для инлайн-элемента:</p><code-example><script>`<span id="elem">Привет!</span>\n\n<script>\nMARK  alert( getComputedStyle(elem).width ); // auto\n<\/script>`</script><code-toolbar iframe="40"></code-toolbar></code-example><p>Конечно, с точки зрения CSS размер <code>auto</code> – совершенно нормально, но нам-то в JavaScript нужен конкретный размер в пикселях, который мы могли бы использовать для вычислений. Получается, что в данном случае ширина <code>width</code> из CSS вообще бесполезна.</p></li></ol><p>Есть и ещё одна причина.</p><p>Полоса прокрутки – причина многих проблем и недопониманий. Как говорится, «дьявол кроется в деталях». Недопустимо, чтобы наш код работал на элементах без прокрутки и начинал «глючить» с ней.</p><p>Как мы говорили ранее, при наличии вертикальной полосы прокрутки, в зависимости от браузера, устройства и операционной системы, она может сдвинуть содержимое.</p><p>Получается, что реальная ширина содержимого меньше CSS-ширины. И это учитывают свойства <code>clientWidth/clientHeight</code>.</p><p>…Но при этом некоторые браузеры также учитывают это в результате <code>getComputedStyle(elem).width</code>, то есть возвращают реальную внутреннюю ширину, а некоторые – именно CSS-свойство. Эти кросс-браузерные отличия – ещё один повод не использовать такой подход, а использовать свойства-метрики.</p><p>Если ваш браузер показывает полосу прокрутки (например, под Windows почти все браузеры так делают), то вы можете протестировать это сами, нажав на кнопку в ифрейме ниже.</p><figure-><code-toolbar-><div></div><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-><div id="elem" style="overflow-y:scroll;width:300px;height:200px;border:1px solid #000"> текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст </div>У элемента стоит <code>style="width:300px"</code><br><button onclick="alert(getComputedStyle(elem).width)">alert( getComputedStyle(elem).width )</button>&nbsp; <button onclick="alert(elem.style.width)">elem.style.width</button></figure-><p>У элемента с текстом в стилях указано <code>width:300px</code>.</p><p>На момент написания этой главы при тестировании в Chrome под Windows <code>alert</code> выводил <code>283px</code>, а в Firefox – <code>300px</code>. При этом оба браузера показывали прокрутку. Это из-за того, что Firefox возвращал именно CSS-ширину, а Chrome – реальную ширину, за вычетом прокрутки.</p><p>Описанные разночтения касаются только чтения свойства <code>getComputedStyle(...).width</code> из JavaScript, визуальное отображение корректно в обоих случаях.</p><h2><a name="9" href="#9">Итого</a></h2><p>У элементов есть следующие метрики:</p><ul><li><code>offsetParent</code> – «родитель по дереву рендеринга» – ближайшая ячейка таблицы, body для статического позиционирования или ближайший позиционированный элемент для других типов позиционирования. </li><li><code>offsetLeft/offsetTop</code> – позиция в пикселях левого верхнего угла блока, относительно его <code>offsetParent</code>. </li><li><code>offsetWidth/offsetHeight</code> – «внешняя» ширина/высота блока, включая рамки. </li><li><code>clientLeft/clientTop</code> – отступ области содержимого от левого-верхнего угла элемента. Если операционная система располагает вертикальную прокрутку справа, то равны ширинам левой/верхней рамки, если же слева (ОС на иврите, арабском), то <code>clientLeft</code> включает в себя прокрутку. </li><li><code>clientWidth/clientHeight</code> – ширина/высота содержимого вместе с полями <code>padding</code>, но без полосы прокрутки. </li><li><code>scrollWidth/scrollHeight</code> – ширина/высота содержимого, включая прокручиваемую область. Включает в себя <code>padding</code> и не включает полосы прокрутки. </li><li><code>scrollLeft/scrollTop</code> – ширина/высота прокрученной части документа, считается от верхнего левого угла. </li></ul><p>Все свойства, доступны только для чтения, кроме <code>scrollLeft/scrollTop</code>. Изменение этих свойств заставляет браузер прокручивать элемент.</p><p>В этой главе мы считали, что страница находится в режиме соответствия стандартам. В режиме совместимости – некоторые старые браузеры требуют <code>document.body</code> вместо <code>documentElement</code>, в остальном всё так же. Конечно, по возможности, стоит использовать только режим соответствия стандарту.</p><h2 id="tasks"><a href="#10" name="10">Задачи (6)</a></h2><task-content><h3><a href="#16" name="16">Найти размер прокрутки снизу</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Свойство <code>elem.scrollTop</code> содержит размер прокрученной области при отсчете сверху. А как подсчитать размер прокрутки снизу?</p><p>Напишите соответствующее выражение для произвольного элемента <code>elem</code>.</p><p>Проверьте: если прокрутки нет вообще или элемент полностью прокручен – оно должно давать ноль.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Решение: <code>elem.scrollHeight-elem.scrollTop-elem.clientHeight</code>.</p></task-answer></task-content><task-content><h3><a href="#17" name="17">Узнать ширину полосы прокрутки</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 3</span><p>Напишите код, который возвращает ширину стандартной полосы прокрутки. Именно самой полосы, где ползунок. Обычно она равна <code>16px</code>, в редких и мобильных браузерах может колебаться от <code>14px</code> до <code>18px</code>, а кое-где даже равна <code>0px</code>.</p><p>P.S. Ваш код должен работать на любом HTML-документе, независимо от его содержимого.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Создадим элемент с прокруткой, но без <code>border</code> и <code>padding</code>. Тогда разница между его полной шириной <code>offsetWidth</code> и внутренней <code>clientWidth</code> будет равна как раз прокрутке:</p><code-example><script>`// создадим элемент с прокруткой\nvar div = document.createElement('div');\n\ndiv.style.overflowY = 'scroll';\ndiv.style.width = '50px';\ndiv.style.height = '50px';\n\n// при display:none размеры нельзя узнать\n// нужно, чтобы элемент был видим,\n// &nbspvisibility:hidden - можно, т.к. сохраняет геометрию\ndiv.style.visibility = 'hidden';\n\ndocument.body.appendChild(div);\nvar scrollWidth = div.offsetWidth - div.clientWidth;\ndocument.body.removeChild(div);\n\nalert( scrollWidth );`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#18" name="18">Подменить div на другой с таким же размером</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 3</span><p>Посмотрим следующий случай из жизни. Был текст, который, в частности, содержал <code>div</code> с зелеными границами:</p><code-example><script>`<style>\n  GOLD_#moving-div_GOLD {\n    border: 5px groove green;\n    padding: 5px;\n    margin: 10px;\n    background-color: yellow;\n  }\n</style>\n\nBefore Before Before\n\n<div id="moving-div">\nText Text Text<br>\nText Text Text<br>\n</div>\n\nAfter After After`</script><code-toolbar iframe="131"></code-toolbar></code-example><p>Программист Валера из вашей команды написал код, который позиционирует его абсолютно и смещает в правый верхний угол. Вот этот код:</p><code-example><script>`var div = document.getElementById('moving-div');\ndiv.style.position = 'absolute';\ndiv.style.right = div.style.top = 0;`</script></code-example><p>Побочным результатом явилось смещение текста, который раньше шел после <code>DIV</code>. Теперь он поднялся вверх:</p><figure- style="min-height:90px"> Before Before Before <moving-div toggle-style="position:relative" style="position: absolute; top: 0px; right: 0px;" title="toggle"> Text Text Text <br>Text Text Text <br></moving-div>After After After <script>var div=document.querySelector("moving-div");div.style.position="absolute",div.style.right=div.style.top=0</script></figure-><p><strong> Допишите код Валеры, сделав так, чтобы текст оставался на своем месте после того, как <code>DIV</code> будет смещен. </strong></p><p>Сделайте это путем создания вспомогательного <code>DIV</code> с теми же <code>width</code>, <code>height</code>, <code>border</code>, <code>margin</code>, <code>padding</code>, что и у желтого <code>DIV</code>.</p><p>Используйте только JavaScript, без CSS.</p><p>Должно быть так (новому блоку задан фоновый цвет для демонстрации):</p><figure- style="min-height:90px"><code-toolbar-><div></div><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-><style> moving-div,moving-div_1{display:block;border:5px groove green;background-color:#ff0;padding:5px;margin:10px;cursor:pointer;} </style> Before Before Before <div style="height: 64px; margin: 10px; background-color: rgb(192, 192, 192);"></div><moving-div_1 style="position: absolute; top: 0px; right: 0px;" onclick="if(this.previousElementSibling.tagName==='DIV'){this.previousElementSibling.remove()}else{eval(this.nextElementSibling.innerHTML)}" title="toggle"> Text Text Text <br>Text Text Text <br></moving-div_1>After After After <script>+ function(){var div=document.querySelector("moving-div_1");if (div.previousElementSibling.tagName==='DIV') return;var placeHolder=document.createElement("div");placeHolder.style.height=div.offsetHeight+"px";var computedStyle=div.currentStyle||getComputedStyle(div,null);placeHolder.style.margin=computedStyle.margin;placeHolder.style.backgroundColor="#C0C0C0";div.parentElement.insertBefore(placeHolder,div);div.style.position="absolute";div.style.right=div.style.top=0;}()</script></figure-><p><a data-click="task_3">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Нам нужно создать <code>div</code> с такими же размерами и вставить его на место «переезжающего».</p><p>Один из вариантов – это просто клонировать элемент.</p><p>Если делать это при помощи <code>div.cloneNode(true)</code>, то склонируется все содержимое, которого может быть много. Обычно нам это не нужно, поэтому можно использовать <code>div.cloneNode(false)</code> для клонирования элемента со стилями, и потом поправить его <code>width/height</code>.</p><p>Можно и просто создать новый <code>div</code> и поставить ему нужные размеры.</p><p><strong> Всё, кроме <code>margin</code>, можно получить из свойств DOM-элемента, а <code>margin</code> – только через <code>getComputedStyle</code>. </strong></p><p>Причём <code>margin</code> мы обязаны поставить, так как иначе наш элемент при вставке будет вести себя иначе, чем исходный.</p><p>Код:</p><code-example><script>`<style>\n  GOLD_#moving-div_GOLD {\n    border: 5px groove green;\n    padding: 5px;\n    margin: 10px;\n    background-color: yellow;\n  }\n</style>\n\nBefore Before Before\n\n<div id="moving-div">\n  Text Text Text\n  <br> Text Text Text\n  <br>\n</div>\n\nAfter After After\n\n<script>\n  var div = document.getElementById("moving-div");\n\n  var placeHolder = document.createElement('div');\nMARK  placeHolder.style.height = div.offsetHeight + 'px';\n\n  // IE || другой браузер\n  var computedStyle = div.currentStyle || getComputedStyle(div, null);\n\nMARK  placeHolder.style.marginTop = computedStyle.marginTop; // full prop name\nMARK  placeHolder.style.marginBottom = computedStyle.marginBottom;\n\n  // highlight it for demo purposes\n  placeHolder.style.backgroundColor = '#C0C0C0';\n\n  document.body.insertBefore(placeHolder, div);\n\n  div.style.position = 'absolute';\n  div.style.right = div.style.top = 0;\n<\/script>`</script><code-toolbar iframe="550"><a title="показать" data-code_run="80"></a><a id="task_3" style="display:none" data-code_edit="?"></a><a id="answer_3" title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>В строке <code>(1)</code> использование полного название свойства <code>"marginTop"</code> гарантирует, что полученное значение будет корректным.</p><p><a data-click="answer_3">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#19" name="19">Поместите мяч в центр поля</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Поместите мяч в центр поля.</p><p>Исходный документ выглядит так:</p><figure><code-toolbar-><a target="_blank" title="открыть в песочнице" data-code_edit=""></a></code-toolbar-><iframe style="height:180px" src="js_move_ball.html"></iframe></figure><p><strong>Используйте JavaScript, чтобы поместить мяч в центр:</strong></p><figure><code-toolbar-><div></div><a title="открыть в новом окне" data-new_window=""></a><a target="_blank" title="открыть в песочнице" data-code_edit=""></a></code-toolbar-><iframe id="ball" style="height:180px" src="js_move_ball.html"></iframe></figure><script>+ function(){frameAddScript('ball',on);function on(){var field=document.querySelector("field-");var ball=field.children[0];ball.style.left=Math.round(field.clientWidth/2-getComputedStyle(ball).width.split('px')[0]/2)+"px";ball.style.top=Math.round(field.clientHeight/2-getComputedStyle(ball).height.split('px')[0]/2)+"px";}}();</script><ul><li>Менять CSS нельзя, мяч должен переносить в центр ваш скрипт, через установку нужных стилей элемента.</li><li> JavaScript-код должен работать при разных размерах мяча ( <code>10</code>, <code>20</code>, <code>30</code> пикселей) без изменений. </li><li> JavaScript-код должен работать при различных размерах и местоположениях поля на странице без изменений. Также он не должен зависеть от ширины рамки поля <code>border</code>. </li></ul><p>P.S. Да, центрирование можно сделать при помощи чистого CSS, но задача именно на JavaScript. Далее будут другие темы и более сложные ситуации, когда JavaScript будет уже точно необходим, это – своего рода «разминка».</p><p><a data-click="task_4">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>При абсолютном позиционировании мяча внутри поля его координаты <code>left/top</code> отсчитываются от <strong>внутреннего</strong> угла поля, например верхнего-левого:</p><figure><img src="field.png" alt="" width="100%" style="max-width:222px"></figure><p>Метрики для внутренней зоны поля – это <code>clientWidth/Height</code>.</p><p>Центр – это <code>(clientWidth/2, clientHeight/2)</code>.</p><p>Но если мы установим мячу такие значения <code>ball.style.left/top</code>, то в центре будет не сам мяч, а его левый верхний угол:</p><code-example><script>`var ball = document.getElementById('ball');\nvar field = document.getElementById('field');\n\nball.style.left = Math.round(+HIGHgetComputedStyle(field)LIGHT.width.split('px')[0] / 2) + 'px';\nball.style.top = Math.round(+HIGHgetComputedStyle(field)LIGHT.height.split('px')[0] / 2) + 'px';`</script></code-example><figure><code-toolbar-><div></div><a target="_blank" title="открыть в песочнице" data-code_edit=""></a></code-toolbar-><iframe id="ball_1" style="height:180px" src="js_move_ball.html"></iframe><script>+ function(){frameAddScript('ball_1',on);function on(){var field=document.querySelector("field-");var ball=field.children[0];ball.style.left=Math.round(+getComputedStyle(field).width.split('px')[0]/2)+'px';ball.style.top=Math.round(+getComputedStyle(field).height.split('px')[0]/2)+'px';}}();</script></figure><p><strong>Внимание, подводный камень!</strong></p><strong>Код выше стабильно работать не будет, если не установить и ширину и высоту для <code>FIELD-</code>, а также <code>clientWidth</code> не везде работает во вложенных елементах.</strong><p>Для того, чтобы центр мяча находился в центре поля, нам нужно сместить мяч на половину его ширины влево и на половину его высоты вверх.</p><code-example><script>`<style>\n GOLD_#field_GOLD {\n    width: 200px;\n    border: 10px groove black;\n    background: #00FF00;\n    position: relative;\n  }\n\n GOLD_ #ball_GOLD {\n    position: absolute;\n  }\n</style>\n\n<div id="field">\n  <img id="ball" width="40" height="40" src="` + host + `ball.svg"> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n</div>\n\n<script>\n  var ball = document.getElementById('ball');\n  var field = document.getElementById('field');\n\n  // ball.offsetWidth=0 before image loaded!\n  // to fix: set width\n  ball.style.left = Math.round(field.clientWidth / 2 - ball.offsetWidth / 2) + 'px';\n  ball.style.top = Math.round(field.clientHeight / 2 - ball.offsetHeight / 2) + 'px';\n<\/script>`</script><code-toolbar iframe="470"><a title="показать" data-code_run="0"></a><a id="task_4" data-code_edit="?" style="display:none"></a><a id="answer_4" title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p><a data-click="answer_4">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#20" name="20">Расширить элемент</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>В <code>&lt;body&gt;</code> есть элемент <code>&lt;div&gt;</code> с заданной шириной <code>width</code>.</p><p>Задача – написать код, который «распахнет» <code>&lt;div&gt;</code> по ширине на всю страницу.</p><p>Исходный документ ( <code>&lt;div&gt;</code> содержит текст и прокрутку):</p><figure- toggle-style="" title="toggle"><code-toolbar-><div></div><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-><style> div_1{width:200px;height:150px;background-color:red;padding:20px;overflow:auto;border:1px solid black;} </style><div_1 toggle-style="width:auto"> текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст </div_1><script> var elem=document.getElementById("elem");// ... ваш код</script></figure-><p>P.S. Пользоваться следует исключительно средствами JS, CSS в этой задаче менять нельзя. Также ваш код должен быть универсален и не ломаться, если цифры в CSS станут другими.</p><p>P.P.S. При расширении элемент <code>&lt;div&gt;</code> не должен вылезти за границу <code>&lt;body&gt;</code>.</p><p><a data-click="task_5">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext id="50"><button-answer-ext href="#50" data-toggle_answer_ext="" style="">Решение через width: auto</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4 class="task__step-title">Решение через width: auto</h4><p>Вначале рассмотрим решение через «умную» установку CSS-свойства.</p><p>Они могут быть разными. Самое простое выглядит так:</p><code-example><script>`elem.style.width = 'auto';`</script></code-example><p>Такой способ работает, так как <code>&lt;div&gt;</code> по умолчанию распахивается на всю ширину.</p><p>Конечно, такое решение не будет работать для элементов, которые сами по себе не растягиваются, например в случае со <code>&lt;span&gt;</code> или при наличии <code>position: absolute</code>.</p><p>Обратим внимание, такой вариант был бы неверен:</p><code-example><script>`elem.style.width = '100%';`</script></code-example><p>По умолчанию в CSS ширина <code>width</code> – это то, что <em> внутри <code>padding</code></em>, а проценты отсчитываются от ширины родителя. То есть, ставя ширину в <code>100%</code>, мы говорим: «внутренняя область должна занимать <code>100%</code> ширины родителя». А в элементе есть ещё <code>padding</code>, которые в итоге вылезут наружу.</p><p>Можно бы поменять блочную модель, указав <code>box-sizing</code> через свойство <code>elem.style.boxSizing</code>, но такое изменение потенциально может затронуть много других свойств, поэтому нежелательно.</p></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Точное вычисление</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4 class="task__step-title">Точное вычисление</h4><p>Альтернатива – вычислить ширину родителя через <code>clientWidth</code>.</p><p>Доступную внутреннюю ширину родителя можно получить, вычитая из <code>clientWidth</code> размеры <code>paddingLeft/paddingRight</code>, и затем присвоить её элементу:</p><code-example><script>`<style>\n  GOLD_#elem_GOLD {\n    width: 200px;\n    height: 150px;\n    background: red;\n    padding: 20px;\n    overflow: auto;\n    /* position: absolute */\n  }\n\n  GOLD_body_GOLD {\n    border: 1px solid black;\n  }\n</style>\n\n<div id="elem">\n  текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст\n  текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст\n  текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст\n  текст текст\n</div>\n\n<script>\n  var elem = document.getElementById("elem");\n\n  // неверно!\n  //elem.style.width = '100%';\n\n  // верно (так как обычный div по умолчанию растягивается во всю ширину)\n  //elem.style.width = 'auto';\n\n  // верно (решение с JS)\n  var bodyWidth = document.body.clientWidth;\n\n  var style = getComputedStyle(elem);\n\n  var bodyInnerWidth = bodyWidth - parseInt(style.paddingLeft) - parseInt(style.paddingRight);\n\n  elem.style.width = bodyInnerWidth + 'px';\n<\/script>`</script><code-toolbar iframe="600"><a title="показать" data-code_run="0"></a><a id="task_5" data-code_edit="?" style="display:none"></a><a id="answer_5" title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>Такое решение будет работать всегда, вне зависимости от типа элемента. Конечно, при изменении размеров окна браузера ширина не адаптируется к новому размеру автоматически, как с <code>width:auto</code>. Это недостаток. Его, конечно, тоже можно обойти при помощи событий (изучим далее), но как общий рецепт – если CSS может решить задачу – лучше использовать CSS.</p><p><a data-click="answer_5">Открыть решение в песочнице.</a></p></task-answer></task-answer-ext></task-content><task-content><h3><a href="#21" name="21">В чём отличие "width" и "clientWidth" ?</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>В чём отличия между <code>getComputedStyle(elem).width</code> и <code>elem.clientWidth</code>?</p><p>Укажите хотя бы три отличия, лучше – больше.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Отличия:</p><ol><li><p><code>getComputedStyle</code> не работает в IE8-.</p></li><li><p><code>clientWidth</code> возвращает число, а <code>getComputedStyle(...).width</code> – строку, на конце <code>px</code>.</p></li><li><p><code>getComputedStyle</code> не всегда даст ширину, он может вернуть, к примеру, <code>"auto"</code> для инлайнового элемента.</p></li><li><p><code>clientWidth</code> соответствует внутренней видимой области элемента, *включая <code>padding</code>, а CSS-ширина <code>width</code> при стандартном значении <code>box-sizing</code> соответствует зоне <em> внутри <code>padding</code></em>.</p></li><li><p>Если есть полоса прокрутки, то некоторые браузеры включают её ширину в <code>width</code>, а некоторые – нет.</p><p>Свойство <code>clientWidth</code>, с другой стороны, полностью кросс-браузерно. Оно всегда обозначает размер <em>за вычетом прокрутки</em>, т.е. реально доступный для содержимого.</p></li></ol></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Стили, getComputedStyle; Размеры и прокрутка страницы"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/metrics",disqus_identifier="metrics",disqus_title="\u0420\u0430\u0437\u043c\u0435\u0440\u044b \u0438 \u043f\u0440\u043e\u043a\u0440\u0443\u0442\u043a\u0430 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432";</script></page-content></main>