<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="98">Документ, события, интерфейсы</a><arrow-next></arrow-next><a data-load_page="99">Документ и объекты страницы</a></nav-up><h1>Методы contains и compareDocumentPosition</h1><p>Если есть два элемента, то иногда бывает нужно понять, лежит ли один из них выше другого, то есть является ли его предком.</p><p>Обычные поисковые методы здесь не дают ответа, но есть два специальных. Они используются редко, но когда подобная задача встаёт, то знание метода может сэкономить много строк кода.</p><h2><a name="0" href="#0">Метод contains для проверки на вложенность</a></h2><p>Синтаксис:</p><code-example><script>`var result = parent.contains(child);`</script></code-example><p>Возвращает <code>true</code>, если <code>parent</code> содержит <code>child</code> или <code>parent == child</code>.</p><h2><a name="1" href="#1">Метод compareDocumentPosition для порядка узлов</a></h2><p>Бывает, что у нас есть два элемента, к примеру, <code>&lt;li&gt;</code> в списке, и нужно понять, какой из них выше другого.</p><p>Метод <code>compareDocumentPosition</code> – более мощный, чем <code>contains</code>, он предоставляет одновременно информацию и о содержании и об относительном порядке элементов.</p><p>Синтаксис:</p><code-example><script>`var result = nodeA.compareDocumentPosition(nodeB);`</script></code-example><p>Возвращаемое значение – битовая маска (см. <a data-load_page="17">Побитовые операторы</a>), биты в которой означают следующее:</p><table><thead><tr><th>Биты</th><th>Число</th><th>Значение</th></tr></thead><tbody><tr><td>000000</td><td>0</td><td><code>nodeA</code> и <code>nodeB</code> -- один и тот же узел</td></tr><tr><td>000001</td><td>1</td><td>Узлы в разных документах (или один из них не в документе)</td></tr><tr><td>000010</td><td>2</td><td><code>nodeB</code> предшествует <code>nodeA</code> (в порядке обхода документа)</td></tr><tr><td>000100</td><td>4</td><td><code>nodeA</code> предшествует <code>nodeB</code></td></tr><tr><td>001000</td><td>8</td><td><code>nodeB</code> содержит <code>nodeA</code></td></tr><tr><td>010000</td><td>16</td><td><code>nodeA</code> содержит <code>nodeB</code></td></tr><tr><td>100000</td><td>32</td><td>Зарезервировано для браузера</td></tr></tbody></table><p>Понятие «предшествует» – означает не только «предыдущий сосед при общем родителе», но и имеет более общий смысл:  "раньше встречается в порядке <a href="http://algolist.manual.ru/ds/walk.php">прямого обхода</a> дерева документа.</p><p>Могут быть и сочетания битов. Примеры реальных значений:</p><code-example><script>`<p>...</p>\n<ul>\n  <li>1.1</li>\n</ul>\n&nbsp\n<script>\n  var p = document.body.children[0];\n  var ul = document.body.children[1];\n  var li = ul.children[0];\n\n  // 1. <ul> находится после <p>\n  alert( ul.compareDocumentPosition(p) ); // 2 = 10\n\n  // 2. <p>находится до <ul>\n  alert( p.compareDocumentPosition(ul) ); // 4 = 100\n\n  // 3. <ul> родитель <li>\n  alert( ul.compareDocumentPosition(li) ); // 20 = 10100\n\n  // 4. <ul> потомок &lt;tbody>\n  alert( ul.compareDocumentPosition(document.body) ); // 10 = 1010\n<\/script>`</script><code-toolbar iframe="85"></code-toolbar></code-example><p>Более подробно:</p><ol><li>Узлы не вложены один в другой, поэтому стоит только бит «предшествования», отсюда <code>10</code>.</li><li>То же самое, но обратный порядок узлов, поэтому <code>100</code>.</li><li>Здесь стоят сразу два бита: <code>10100</code> означает, что <code>ul</code> одновременно содержит <code>li</code> и является его предшественником, то есть при прямом обходе дерева документа сначала встречается <code>ul</code>, а потом <code>li</code>.</li><li>Аналогично предыдущему, <code>1010</code> означает, что <code>document.body</code> содержит <code>ul</code> и предшествует ему.</li></ol><important-><h3>Перевод в двоичную систему</h3><p>Самый простой способ самостоятельно посмотреть, как число выглядит в 2-ной системе – вызвать для него <code>toString(2)</code>, например:</p><code-example><script>`var x = 20;\nalert( x.toString(2) ); // "10100"`</script><code-toolbar></code-toolbar></code-example><p>Или так:</p><code-example><script>`alert( 20..toString(2) );`</script><code-toolbar></code-toolbar></code-example><p>Здесь после <code>20</code> две точки, так как если одна, то JS подумает, что после неё десятичная часть – будет ошибка.</p></important-><p>Проверить конкретное условие, например, "<code>nodeA</code> содержит <code>nodeB</code>", можно при помощи битовых операций, в данном случае: <code>nodeA.compareDocumentPosition(nodeB) &amp; 16</code>, например:</p><code-example><script>`<ul>\n  <li>1</li>\n</ul>\n\n<script>\n  var body = document.body;\n  var li = document.body.children[0].children[0];\n\nMARK  if (body.compareDocumentPosition(li) & 16) {\nMARK    alert( body + ' содержит&nbsp' + li );\nMARK  }\n<\/script>`</script><code-toolbar iframe="50"></code-toolbar></code-example><p>Более подробно о битовых масках:  <a data-load_page="17">Побитовые операторы</a>.</p><h2><a name="2" href="#2">Поддержка в IE8-</a></h2><p>В IE8- поддерживаются свои, нестандартные, метод и свойство:</p><dl><dt><a href="http://msdn.microsoft.com/en-us/library/ms536377.aspx">nodeA.contains(nodeB)</a></dt><dd>Результат: <code>true</code>, если <code>nodeA</code> содержит <code>nodeB</code>, а также в том случае, если <code>nodeA == nodeB</code>.</dd><dt><a href="http://msdn.microsoft.com/en-us/library/ms534635.aspx">node.sourceIndex</a></dt><dd>Номер элемента <code>node</code> в порядке прямого обхода дерева. Только для узлов-элементов.</dd></dl><p>На их основе можно написать полифилл для <code>compareDocumentPosition</code>:</p><code-example><script>`// код с http://compatibility.shwups-cms.ch/en/polyfills/?&id=82\n(function() {\n  var el = document.documentElement;\n  if (!el.compareDocumentPosition && el.sourceIndex !== undefined) {\n\n    Element.prototype.compareDocumentPosition = function(other) {\n      return (BLUE_this_BLUE != other && this.contains(other) && 16) +\n        (BLUE_this_BLUE != other && other.contains(this) && 8) +\n        (this.sourceIndex >= 0 && other.sourceIndex >= 0 ?\n          (this.sourceIndex < other.sourceIndex && 4) +\n          (this.sourceIndex > other.sourceIndex && 2) : 1\n        ) + 0;\n    }\n  }\n}());`</script></code-example><p>С этим полифиллом метод доступен для элементов во всех браузерах.</p><h2><a name="3" href="#3">Итого</a></h2><ul><li>Для проверки, является ли один узел предком другого, достаточно метода <code>nodeA.contains(nodeB)</code>.</li><li>Для расширенной проверки на предшествование есть метод <code>compareDocumentPosition</code>.</li><li>Для IE8 нужен полифилл для <code>compareDocumentPosition</code>.</li></ul><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Атрибуты и DOM-свойства; Добавление и удаление узлов"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/compare-document-position", disqus_identifier = "compare-document-position", disqus_title = "\u041c\u0435\u0442\u043e\u0434\u044b contains \u0438 compareDocumentPosition";</script></page-content></main>