<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="234">О всякой всячине</a></nav-up><h1>Применяем ООП: Drag'n'Drop++</h1><p>Эта статья представляет собой продолжение главы <a data-load_page="133">Мышь: Drag'n'Drop более глубоко</a>.Она посвящена более гибкой и расширяемой реализации переноса.</p><p>Рекомендуется прочитать указанную главу перед тем, как двигаться дальше.</p><p>В сложных приложениях Drag’n’Drop обладает рядом особенностей:</p><ol><li><p>Перетаскиваются <em>элементы</em> из <em>зоны переноса <code>dragZone</code></em> в <em>зону-цель <code>dropTarget</code></em>. При этом сама зона не переносится.</p><p>Например – два списка, нужен перенос элемента из одного в другой. В этом случае один список является зоной переноса, второй – зоной-целью.</p><p>Возможно, что перенос осуществляется внутри одного и того же списка. При этом  <code>dragZone == dropTarget</code>.</p></li><li><p>На странице может быть несколько разных зон переноса и зон-целей.</p></li><li><p>Обработка завершения переноса может быть асинхронной, с уведомлением сервера.</p></li><li><p>Должно быть легко добавить новый тип зоны переноса или зоны-цели, а также расширить поведение существующей.</p></li><li><p>Фреймворк для переноса должен быть расширяемым с учётом сложных сценариев.</p></li></ol><p>Всё это вполне реализуемо. Но для этого фреймворк, описанный в статье <a data-load_page="133">Мышь: Drag'n'Drop более глубоко</a>, нужно отрефакторить, и разделить на сущности.</p><h2><a name="0" href="#0">Основные сущности</a></h2><p>Всего будет 4 сущности:</p><dl><dt><code>DragZone</code></dt><dd>Зона переноса. С нее начинается перенос. Она принимает нажатие мыши и генерирует аватар нужного типа.</dd><dt><code>DragAvatar</code></dt><dd>Переносимый объект. Предоставляет доступ к информации о том, что переносится. Умеет двигать себя по экрану. В зависимости от вида переноса, может что-то делать с собой в конце, например, самоуничтожаться.</dd><dt><code>DropTarget</code></dt><dd>Зона-цель, на которую можно положить. В процессе переноса аватара над ней умеет рисовать на себе предполагаемое «место приземления». Обрабатывает окончание переноса.</dd><dt><code>dragManager</code></dt><dd>Единый объект, который стоит над всеми ними, ставит обработчики <code>mousedown/mousemove/mouseup</code> и управляет процессом. В терминах ООП, это не класс, а <a href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%BE%D1%87%D0%BA%D0%B0_%28%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%29">объект-синглтон</a>, поэтому он с маленькой буквы.</dd></dl><p>На макете страницы ниже возможен перенос студентов из левого списка – вправо, в одну из команд или в «корзину»:</p><figure><img src="dragzonetarget.png" alt="" width="100%" style="max-width:523px"></figure><p>Здесь левый список является зоной переноса <code>ListDragZone</code>, а правые списки – это несколько зон-целей <code>ListDropTarget</code>. Кроме того, корзина также является зоной-целью отдельного типа <code>RemoveDropTarget</code>.</p><h2><a name="1" href="#1">Пример</a></h2><p>В этой статье мы реализуем пример, когда узлы дерева можно переносить внутри него. То есть, дерево, которое является одновременно <code>TreeDragZone</code> и <code>TreeDropTarget</code>.</p><p>Структура дерева будет состоять из вложенных списков с заголовком в <code>SPAN</code>:</p><code-example><script>`<ul>\n  <li><span>Заголовок 1</span>\n    <ul>\n      <li><span>Заголовок 1.1</span></li>\n      <li><span>Заголовок 1.2</span></li>\n      ...\n    </ul>\n  </li>\n  ...\n</ul>`</script></code-example><p>При переносе:</p><ul><li>Для аватара нужно клонировать заголовок узла, на котором было нажатие.</li><li>Узлы, на которые можно положить, при переносе подсвечиваются красным.</li><li>Нельзя перенести узел сам в себя или в своего потомка.</li><li>Дерево само поддерживает сортировку по алфавиту среди узлов.</li><li>Обязательна расширяемость кода, поддержка большого количества узлов и т.п.</li></ul><code-result class="code-result"><iframe style="height:430px" src="drag_tree.html"></iframe></code-result><h2><a name="2" href="#2">dragManager</a></h2><p>Обязанность <code>dragManager</code> – обработка событий мыши и координация всех остальных сущностей в процессе переноса.</p><p><strong>Готовьтесь, дальше будет много кода с комментариями.</strong></p><p>Следующий код должен быть очевиден по смыслу, если вы читали <a data-load_page="133">предыдущую статью</a>. Объект взят оттуда, и из него изъята лишняя функциональность, которая перенесена в другие сущности.</p><p>Если вызываемые в нём методы <code>onDrag*</code> непонятны – смотрите далее, в описание остальных объектов.</p><code-example><script>`var dragManager = new function() {\n\n  var dragZone, avatar, dropTarget;\n  var downX, downY;\n\n  var self = this;\n\n  function onMouseDown(e) {\n\n    if (e.which != 1) { // не левой кнопкой\n      return false;\n    }\n\n    dragZone = findDragZone(e);\n\n    if (!dragZone) {\n      return;\n    }\n\n    // запомним, что элемент нажат на текущих координатах pageX/pageY\n    downX = e.pageX;\n    downY = e.pageY;\n\n    return false;\n  }\n\n  function onMouseMove(e) {\n    if (!dragZone) return; // элемент не зажат\n\n    if (!avatar) { // элемент нажат, но пока не начали его двигать\n      if (Math.abs(e.pageX - downX) < 3 && Math.abs(e.pageY - downY) < 3) {\n        return;\n      }\n      // попробовать захватить элемент\n      avatar = dragZone.onDragStart(downX, downY, e);\n\n      if (!avatar) { // не получилось, значит перенос продолжать нельзя\n        cleanUp(); // очистить приватные переменные, связанные с переносом\n        return;\n      }\n    }\n\n    // отобразить перенос объекта, перевычислить текущий элемент под курсором\n    avatar.onDragMove(e);\n\n    // найти новый dropTarget под курсором: newDropTarget\n    // текущий dropTarget остался от прошлого mousemove\n    // *оба значения: и newDropTarget и dropTarget могут быть null\n    var newDropTarget = findDropTarget(e);\n\n    if (newDropTarget != dropTarget) {\n      // уведомить старую и новую зоны-цели о том, что с них ушли/на них зашли\n      dropTarget && dropTarget.onDragLeave(newDropTarget, avatar, e);\n      newDropTarget && newDropTarget.onDragEnter(dropTarget, avatar, e);\n    }\n\n    dropTarget = newDropTarget;\n\n    dropTarget && dropTarget.onDragMove(avatar, e);\n\n    return false;\n  }\n\n  function onMouseUp(e) {\n\n    if (e.which != 1) { // не левой кнопкой\n      return false;\n    }\n\n    if (avatar) { // если уже начали передвигать\n\n      if (dropTarget) {\n        // завершить перенос и избавиться от аватара, если это нужно\n        // эта функция обязана вызвать avatar.onDragEnd/onDragCancel\n        dropTarget.onDragEnd(avatar, e);\n      } else {\n        avatar.onDragCancel();\n      }\n\n    }\n\n    cleanUp();\n  }\n\n  function cleanUp() {\n    // очистить все промежуточные объекты\n    dragZone = avatar = dropTarget = null;\n  }\n\n  function findDragZone(event) {\n    var elem = event.target;\n    while (elem != document && !elem.dragZone) {\n      elem = elem.parentNode;\n    }\n    return elem.dragZone;\n  }\n\n  function findDropTarget(event) {\n    // получить элемент под аватаром\n    var elem = avatar.getTargetElem();\n\n    while (elem != document && !elem.dropTarget) {\n      elem = elem.parentNode;\n    }\n\n    if (!elem.dropTarget) {\n      return null;\n    }\n\n    return elem.dropTarget;\n  }\n\n  document.ondragstart = function() {\n    return false;\n  }\n\n  document.onmousemove = onMouseMove;\n  document.onmouseup = onMouseUp;\n  document.onmousedown = onMouseDown;\n};`</script></code-example><h2><a name="3" href="#3">DragZone</a></h2><p>Основная задача <code>DragZone</code> – создать аватар и инициализировать его. В зависимости от места, где произошел клик, аватар получит соответствующий подэлемент зоны.</p><p>Метод для создания аватара <code>_makeAvatar</code> вынесен отдельно, чтобы его легко можно было переопределить и подставить собственный тип аватара.</p><code-example><script>`/**\nCOMMENT * Зона, из которой можно переносить объекты\nCOMMENT * Умеет обрабатывать начало переноса на себе и создавать "аватар"\nCOMMENT * @param elem DOM-элемент, к которому привязана зона\n */\nfunction DragZone(elem) {\n  elem.dragZone = this;\n  this._elem = elem;\n}\n\n/**\nCOMMENT * Создать аватар, соответствующий зоне.\nCOMMENT * У разных зон могут быть разные типы аватаров\n */\nDragZone.prototype._makeAvatar = function() {\n  /* override */\n};\n\n/**\nCOMMENT * Обработать начало переноса.\nCOMMENT *\nCOMMENT * Получает координаты изначального нажатия мышки, событие.\nCOMMENT *\nCOMMENT * @param downX Координата изначального нажатия по X\nCOMMENT * @param downY Координата изначального нажатия по Y\nCOMMENT * @param event текущее событие мыши\nCOMMENT *\nCOMMENT * @return аватар или false, если захватить с данной точки ничего нельзя\n */\nDragZone.prototype.onDragStart = function(downX, downY, event) {\n\n  var avatar = this._makeAvatar();\n\n  if (!avatar.initFromEvent(downX, downY, event)) {\n    return false;\n  }\n\n  return avatar;\n};`</script></code-example><h3><a name="9" href="#9">TreeDragZone</a></h3><p>Объект зоны переноса для дерева, по существу, не вносит ничего нового, по сравнению с <code>DragZone</code>.</p><p>Он только переопределяет <code>_makeAvatar</code> для создания <code>TreeDragAvatar</code>.</p><code-example><script>`function TreeDragZone(elem) {\n  DragZone.apply(this, arguments);\n}\n\nextend(TreeDragZone, DragZone);\n\nTreeDragZone.prototype._makeAvatar = function() {\n  return new TreeDragAvatar(this, this._elem);\n};`</script></code-example><h2><a name="4" href="#4">DragAvatar</a></h2><p>Аватар создается только зоной переноса при начале Drag’n’Drop. Он содержит всю необходимую информацию об объекте, который переносится.</p><p>В дальнейшем вся работа происходит <em>только с аватаром</em>, сама зона напрямую не вызывается.</p><p>У аватара есть три основных свойства:</p><dl><dt><code>_dragZone</code></dt><dd><p>Зона переноса, которая его создала.</p></dd><dt><code>_dragZoneElem</code></dt><dd><p>Элемент, соответствующий аватару в зоне переноса. По умолчанию – DOM-элемент всей зоны. Это подходит в тех случаях, когда зона перетаскивается только целиком.При инициализации аватара значение этого свойства может быть уточнено, например изменено на подэлемент списка, который перетаскивается.</p></dd><dt><code>_elem</code></dt><dd><p>Основной элемент аватара, который будет двигаться по экрану. По умолчанию  равен <code>_dragZoneElem</code>, т.е мы переносим сам элемент.</p><p>При инициализации мы можем также склонировать <code>_dragZoneElem</code>, или создать своё красивое представление переносимого элемента и поместить его в <code>_elem</code>.</p></dd></dl><code-example><script>`/**\nCOMMENT * "Аватар" - элемент, который перетаскивается.\nCOMMENT *\nCOMMENT * В простейшем случае аватаром является сам переносимый элемент\nCOMMENT * Также аватар может быть клонированным элементом\nCOMMENT * Также аватар может быть иконкой и вообще чем угодно.\n */\nfunction DragAvatar(dragZone, dragElem) {\n  /** "родительская" зона переноса */\n  this._dragZone = dragZone;\n\n  /**\nCOMMENT   * подэлемент родительской зоны, к которому относится аватар\nCOMMENT   * по умолчанию - элемент, соответствующий всей зоне\nCOMMENT   * может быть уточнен в initFromEvent\n   */\n  this._dragZoneElem = dragElem;\n\n  /**\nCOMMENT   * Сам элемент аватара, который будет носиться по экрану.\nCOMMENT   * Инициализуется в initFromEvent\n   */\n  this._elem = dragElem;\n}\n\n/**\nCOMMENT * Инициализировать this._elem и позиционировать его\nCOMMENT * При необходимости уточнить this._dragZoneElem\nCOMMENT * @param downX Координата X нажатия мыши\nCOMMENT * @param downY Координата Y нажатия мыши\nCOMMENT * @param event Текущее событие мыши\n */\nDragAvatar.prototype.initFromEvent = function(downX, downY, event) {\n  /* override */\n};\n\n/**\nCOMMENT * Возвращает информацию о переносимом элементе для DropTarget\nCOMMENT * @param event\n */\nDragAvatar.prototype.getDragInfo = function(event) {\n  // тут может быть еще какая-то информация, необходимая для обработки конца или процесса переноса\n  return {\n    elem: this._elem,\n    dragZoneElem: this._dragZoneElem,\n    dragZone: this._dragZone\n  };\n};\n\n/**\nCOMMENT * Возвращает текущий самый глубокий DOM-элемент под this._elem\nCOMMENT * Приватное свойство _currentTargetElem обновляется при каждом передвижении\n */\nDragAvatar.prototype.getTargetElem = function() {\n  return this._currentTargetElem;\n};\n\n/**\nCOMMENT * При каждом движении мыши перемещает this._elem\nCOMMENT * и записывает текущий элемент под this._elem в _currentTargetElem\nCOMMENT * @param event\n */\nDragAvatar.prototype.onDragMove = function(event) {\n  this._elem.style.left = event.pageX - this._shiftX + 'px';\n  this._elem.style.top = event.pageY - this._shiftY + 'px';\n\n  this._currentTargetElem = getElementUnderClientXY(this._elem, event.clientX, event.clientY);\n};\n\n/**\nCOMMENT * Действия с аватаром, когда перенос не удался\nCOMMENT * Например, можно вернуть элемент обратно или уничтожить\n */\nDragAvatar.prototype.onDragCancel = function() {\n  /* override */\n};\n\n/**\nCOMMENT * Действия с аватаром после успешного переноса\n */\nDragAvatar.prototype.onDragEnd = function() {\n  /* override */\n};`</script></code-example><h3><a name="10" href="#10">TreeDragAvatar</a></h3><p>Основные изменения – в методе <code>initFromEvent</code>, который создает аватар из узла, на котором был клик.</p><p>Обратите внимание, возможно что клик был не на заголовке <code>SPAN</code>, а просто где-то на дереве. В этом случае <code>initFromEvent</code> возвращает <code>false</code> и перенос не начинается.</p><code-example><script>`function TreeDragAvatar(dragZone, dragElem) {\n  DragAvatar.apply(this, arguments);\n}\n\nextend(TreeDragAvatar, DragAvatar);\n\nTreeDragAvatar.prototype.initFromEvent = function(downX, downY, event) {\n  if (event.target.tagName != 'SPAN') return false;\n\n  this._dragZoneElem = event.target;\n  var elem = this._elem = this._dragZoneElem.cloneNode(true);\n  elem.className = 'avatar';\n\n  // создать вспомогательные свойства shiftX/shiftY\n  var coords = getCoords(this._dragZoneElem);\n  this._shiftX = downX - coords.left;\n  this._shiftY = downY - coords.top;\n\n  // инициировать начало переноса\n  document.body.appendChild(elem);\n  elem.style.zIndex = 9999;\n  elem.style.position = 'absolute';\n\n  return true;\n};\n\n/**\nCOMMENT * Вспомогательный метод\n */\nTreeDragAvatar.prototype._destroy = function() {\n  this._elem.parentNode.removeChild(this._elem);\n};\n\n/**\nCOMMENT * При любом исходе переноса элемент-клон больше не нужен\n */\nTreeDragAvatar.prototype.onDragCancel = function() {\n  this._destroy();\n};\n\nTreeDragAvatar.prototype.onDragEnd = function() {\n  this._destroy();\n};`</script></code-example><h2><a name="5" href="#5">DropTarget</a></h2><p>Именно на <code>DropTarget</code> ложится работа по отображению предполагаемой «точки приземления» аватара, а также, по завершению переноса, обработка результата.</p><p>Как правило, <code>DropTarget</code> принимает переносимый узел в себя, а вот как конкретно организован процесс вставки – нужно описать в классе-наследнике. Разные типы зон делают разное при вставке: <code>TreeDropTarget</code> вставляет элемент в качестве потомка, а <code>RemoveDropTarget</code> – удаляет.</p><code-example><script>`/**\nCOMMENT * Зона, в которую объекты можно класть\nCOMMENT * Занимается индикацией передвижения по себе, добавлением в себя\n */\nfunction DropTarget(elem) {\n  elem.dropTarget = this;\n  this._elem = elem;\n\n  /**\nCOMMENT   * Подэлемент, над которым в настоящий момент находится аватар\n   */\n  this._targetElem = null;\n}\n\n/**\nCOMMENT * Возвращает DOM-подэлемент, над которым сейчас пролетает аватар\nCOMMENT *\nCOMMENT * @return DOM-элемент, на который можно положить или undefined\n */\nDropTarget.prototype._getTargetElem = function(avatar, event) {\n  return this._elem;\n};\n\n/**\nCOMMENT * Спрятать индикацию переноса\nCOMMENT * Вызывается, когда аватар уходит с текущего this._targetElem\n */\nDropTarget.prototype._hideHoverIndication = function(avatar) {\n  /* override */\n};\n\n/**\nCOMMENT * Показать индикацию переноса\nCOMMENT * Вызывается, когда аватар пришел на новый this._targetElem\n */\nDropTarget.prototype._showHoverIndication = function(avatar) {\n  /* override */\n};\n\n/**\nCOMMENT * Метод вызывается при каждом движении аватара\n */\nDropTarget.prototype.onDragMove = function(avatar, event) {\n\n  var newTargetElem = this._getTargetElem(avatar, event);\n\n  if (this._targetElem != newTargetElem) {\n\n    this._hideHoverIndication(avatar);\n    this._targetElem = newTargetElem;\n    this._showHoverIndication(avatar);\n  }\n};\n\n/**\nCOMMENT * Завершение переноса.\nCOMMENT * Алгоритм обработки (переопределить функцию и написать в потомке):\nCOMMENT * 1. Получить данные переноса из avatar.getDragInfo()\nCOMMENT * 2. Определить, возможен ли перенос на _targetElem (если он есть)\nCOMMENT * 3. Вызвать avatar.onDragEnd() или avatar.onDragCancel()\nCOMMENT *  Если нужно подтвердить перенос запросом на сервер, то avatar.onDragEnd(),\nCOMMENT *  а затем асинхронно, если сервер вернул ошибку, avatar.onDragCancel()\nCOMMENT *  При этом аватар должен уметь "откатываться" после onDragEnd.\nCOMMENT *\nCOMMENT * При любом завершении этого метода нужно (делается ниже):\nCOMMENT *  снять текущую индикацию переноса\nCOMMENT *  обнулить this._targetElem\n */\nDropTarget.prototype.onDragEnd = function(avatar, event) {\n  this._hideHoverIndication(avatar);\n  this._targetElem = null;\n};\n\n/**\nCOMMENT * Вход аватара в DropTarget\n */\nDropTarget.prototype.onDragEnter = function(fromDropTarget, avatar, event) {};\n\n/**\nCOMMENT * Выход аватара из DropTarget\n */\nDropTarget.prototype.onDragLeave = function(toDropTarget, avatar, event) {\n  this._hideHoverIndication();\n  this._targetElem = null;\n};`</script></code-example><p>Как видно, из кода выше, по умолчанию <code>DropTarget</code> занимается только отслеживанием и индикацией «точки приземления». По умолчанию, единственной возможной «точкой приземления» является сам элемент зоны. В более сложных ситуациях это может быть подэлемент.</p><p>Для применения в реальности необходимо как минимум переопределить обработку результата переноса в <code>onDragEnd</code>.</p><h3><a name="11" href="#11">TreeDropTarget</a></h3><p><code>TreeDropTarget</code> содержит код, специфичный для дерева:</p><ul><li>Индикацию переноса над элементом: методы <code>_showHoverIndication</code> и <code>_hideHoverIndication</code>.</li><li>Получение текущей точки приземления <code>_targetElem</code> в методе <code>_getTargetElem</code>. Ей может быть только заголовок узла дерева, причем дополнительно проверяется, что это не потомок переносимого узла.</li><li>Обработка успешного переноса в <code>onDragEnd</code>, вставка исходного узла <code>avatar.dragZoneElem</code> в узел, соответствующий <code>_targetElem</code>.</li></ul><code-example><script>`function TreeDropTarget(elem) {\n  TreeDropTarget.parent.constructor.apply(this, arguments);\n}\n\nextend(TreeDropTarget, DropTarget);\n\nTreeDropTarget.prototype._showHoverIndication = function() {\n  this._targetElem && this._targetElem.classList.add('hover');\n};\n\nTreeDropTarget.prototype._hideHoverIndication = function() {\n  this._targetElem && this._targetElem.classList.remove('hover');\n};\n\nTreeDropTarget.prototype._getTargetElem = function(avatar, event) {\n  var target = avatar.getTargetElem();\n  if (target.tagName != 'SPAN') {\n    return;\n  }\n\n  // проверить, может быть перенос узла внутрь самого себя или в себя?\n  var elemToMove = avatar.getDragInfo(event).dragZoneElem.parentNode;\n\n  var elem = target;\n  while (elem) {\n    if (elem == elemToMove) return; // попытка перенести родителя в потомка\n    elem = elem.parentNode;\n  }\n\n  return target;\n};\n\nTreeDropTarget.prototype.onDragEnd = function(avatar, event) {\n\n  if (!this._targetElem) {\n    // перенос закончился вне подходящей точки приземления\n    avatar.onDragCancel();\n    return;\n  }\n\n  this._hideHoverIndication();\n\n  // получить информацию об объекте переноса\n  var avatarInfo = avatar.getDragInfo(event);\n\n  avatar.onDragEnd(); // аватар больше не нужен, перенос успешен\n\n  // вставить элемент в детей в отсортированном порядке\n  var elemToMove = avatarInfo.dragZoneElem.parentNode; // <LI>\n  var title = avatarInfo.dragZoneElem.innerHTML; // переносимый заголовок\n\n  // получить контейнер для узлов дерева, соответствующий точке преземления\n  var ul = this._targetElem.parentNode.getElementsByTagName('UL')[0];\n  if (!ul) { // нет детей, создадим контейнер\n    ul = document.createElement('UL');\n    this._targetElem.parentNode.appendChild(ul);\n  }\n\n  // вставить новый узел в нужное место среди потомков, в алфавитном порядке\n  var li = null;\n  for (var i = 0; i < ul.children.length; i++) {\n    li = ul.children[i];\n    var childTitle = li.children[0].innerHTML;\n    if (childTitle > title) {\n      break;\n    }\n    li = null;\n  }\n\n  ul.insertBefore(elemToMove, li);\n\n  this._targetElem = null;\n};`</script></code-example><h2><a name="6" href="#6">Итого</a></h2><p>Реализация Drag’n’Drop оказалась отличным способом применить ООП в JavaScript.</p><p>Исходный код примера целиком находится <a href="http://plnkr.co/edit/GZMmUwVeTJ35MS6yQMal?p=preview">в песочнице</a>.</p><ul><li><p>Синглтон <code>dragManager</code> и классы <code>Drag*</code> задают общий фреймворк. От них наследуются конкретные объекты. Для создания новых зон достаточно унаследовать стандартные классы и переопределить их.</p></li><li><p>Мини-фреймворк для Drag’n’Drop, который здесь представлен, является переписанным и обновленным вариантом реальной библиотеки, на основе которой было создано много успешных скриптов переноса.</p><p>В зависимости от ваших потребностей, вы можете расширить его, добавить перенос нескольких объектов одновременно, поддержку событий и другие возможности.</p></li><li><p>На сегодняшний день в каждом серьезном фреймворке есть библиотека для Drag’n’Drop. Она работает похожим образом, но сделать универсальный перенос – штука непростая. Зачастую он перегружен лишним функционалом, либо наоборот – недостаточно расширяем в нужных местах.Понимание, как это все может быть устроено, на примере этой статьи, может помочь в адаптации существующего кода под ваши потребности.</p></li></ul><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Выделение: Range, TextRange и Selection; Куки, document.cookie"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/drag-and-drop-plus", disqus_identifier = "drag-and-drop-plus", disqus_title = "\u041f\u0440\u0438\u043c\u0435\u043d\u044f\u0435\u043c \u041e\u041e\u041f: Drag'n'Drop++";</script></page-content></main>