<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="234">О всякой всячине</a></nav-up><h1>Позднее связывание "bindLate"</h1><p>Обычный метод <code>bind</code> называется «ранним связыванием», поскольку фиксирует привязку сразу же.</p><p>Как только значения привязаны – они уже не могут быть изменены. В том числе, если метод объекта, который привязали, кто-то переопределит – «привязанная» функция этого не заметит.</p><p>Позднее связывание – более гибкое, оно позволяет переопределить привязанный метод когда угодно.</p><h2><a name="0" href="#0">Раннее связывание</a></h2><p>Например, попытаемся переопределить метод при раннем связывании:</p><code-example><script>`function bind(func, context) {\n  return function() {\n    return func.apply(context, arguments);\n  };\n}\n\nvar user = {\n  sayHi: function() { alert('Привет!'); }\n}\n\n// привязали метод к объекту\nMARKvar userSayHi = bind(user.sayHi, user);\n\n// понадобилось переопределить метод\nuser.sayHi = function() { alert('Новый метод!'); }\n\n// будет вызван старый метод, а хотелось бы - новый!\nuserSayHi(); // HIGHвыведет "Привет!"LIGHT`</script><code-toolbar></code-toolbar></code-example><p>…Привязка всё ещё работает со старым методом, несмотря на то что он был переопределён.</p><h2><a name="1" href="#1">Позднее связывание</a></h2><p>При позднем связывании <code>bind</code> вызовет не ту функцию, которая была в <code>sayHi</code> на момент привязки, а ту, которая есть на момент вызова.**</p><p>Встроенного метода для этого нет, поэтому нужно реализовать.</p><p>Синтаксис будет таков:</p><code-example><script>`var func = bindLate(obj, "method");`</script></code-example><dl><dt><code>obj</code></dt><dd>Объект</dd><dt><code>method</code></dt><dd>Название метода (строка)</dd></dl><p>Код:</p><code-example><script>`function bindLate(context, funcName) {\n  return function() {\n    return context[funcName].apply(context, arguments);\n  };\n}`</script></code-example><p>Этот вызов похож на обычный <code>bind</code>, один из вариантов которого как раз и выглядит как <code>bind(obj, "method")</code>, но работает по-другому.</p><p><strong>Поиск метода в объекте: <code>context[funcName]</code>, осуществляется при вызове, самой обёрткой</strong>.</p><p><strong>Поэтому, если метод переопределили – будет использован всегда последний вариант.</strong></p><p>В частности, пример, рассмотренный выше, станет работать правильно:</p><code-example><script>`function bindLate(context, funcName) {\n  return function() {\n    return context[funcName].apply(context, arguments);\n  };\n}\n\nvar user = {\n  sayHi: function() { alert('Привет!'); }\n}\n\nMARKvar userSayHi = bindLate(user, 'sayHi');\n\nuser.sayHi = function() { alert('Здравствуйте!'); }\n\nuserSayHi(); // HIGHЗдравствуйте!LIGHT`</script><code-toolbar></code-toolbar></code-example><h2><a name="2" href="#2">Привязка метода, которого нет</a></h2><p>Позднее связывание позволяет привязать к объекту даже метод, которого ещё нет!</p><p>Конечно, предполагается, что к моменту вызова он уже будет определён ;).</p><p>Например:</p><code-example><script>`function bindLate(context, funcName) {\n  return function() {\n    return context[funcName].apply(context, arguments);\n  };\n}\n\nMARK// метода нет\nvar user = {  };\n\nMARK// ..а привязка возможна!\nMARKvar userSayHi = bindLate(user, 'sayHi');\n\n// по ходу выполнения добавили метод..\nuser.sayHi = function() { alert('Привет!'); }\n\nuserSayHi(); // Метод работает: HIGHПривет!LIGHT`</script><code-toolbar></code-toolbar></code-example><p>В некотором смысле, позднее связывание всегда лучше, чем раннее. Оно удобнее и надежнее, так как всегда вызывает нужный метод, который в объекте сейчас.</p><p>Но оно влечет и небольшие накладные расходы – поиск метода при каждом вызове.</p><h2><a name="3" href="#3">Итого</a></h2><p><em>Позднее связывание</em> ищет функцию в объекте в момент вызова.</p><p>Оно используется для привязки в тех случаях, когда метод <em>может быть переопределён</em> после привязки или <em>на момент привязки не существует</em>.</p><p>Обёртка для позднего связывания (без карринга):</p><code-example><script>`function bindLate(context, funcName) {\n  return function() {\n    return context[funcName].apply(context, arguments);\n  };\n}`</script></code-example><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Асинхронное выполнение: setImmediate; Sublime Text: шпаргалка"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/bind-late", disqus_identifier = "bind-late", disqus_title = "\u041f\u043e\u0437\u0434\u043d\u0435\u0435 \u0441\u0432\u044f\u0437\u044b\u0432\u0430\u043d\u0438\u0435 \"bindLate\"";</script></page-content></main>