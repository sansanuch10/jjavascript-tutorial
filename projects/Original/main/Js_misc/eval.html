<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="63">Некоторые другие возможности</a></nav-up><h1>Запуск кода из строки: eval</h1><p>Функция <code>eval(code)</code> позволяет выполнить код, переданный ей в виде строки.</p><p>Этот код будет выполнен в <em>текущей области видимости</em>.</p><h2><a name="0" href="#0">Использование eval</a></h2><p>В простейшем случае <code>eval</code> всего лишь выполняет код, например:</p><code-example><script>`var a = 1;\n\n(function() {\n\n  var a = 2;\n\nMARK  eval(' alert(a) '); // 2\n\n})()`</script><code-toolbar></code-toolbar></code-example><p>Но он может не только выполнить код, но и вернуть результат.</p><p><strong>Вызов <code>eval</code> возвращает последнее вычисленное выражение, например</strong>:</p><code-example><script>`alert( eval('1+1') ); // 2`</script><code-toolbar></code-toolbar></code-example><p><strong>При вызове <code>eval</code> имеет полный доступ к локальным переменным.</strong></p><p>Это означает, что текущие переменные могут быть изменены или дополнены:</p><code-example><script>`var x = 5;\neval("alert( x ); x = 10"); // 5, доступ к старому значению\nalert( x ); // 10, значение изменено внутри eval`</script><code-toolbar></code-toolbar></code-example><important-><h3>В строгом режиме <code>eval</code> имеет свою область видимости </h3><p>В строгом режиме функционал <code>eval</code> чуть-чуть меняется.</p><p>При <code>use strict</code> код внутри <code>eval</code> по-прежнему сможет читать и менять внешние переменные, однако переменные и функции, объявленные внутри <code>eval</code>, не попадут наружу.</p><code-example><script>`"use strict";\n\nMARKeval("var a = 5; function f() {&nbsp}");\nalert( a ); // ошибка, переменная не определена\n// функция f тоже не видна снаружи`</script><code-toolbar></code-toolbar></code-example><p>Иными словами, в новом стандарте <code>eval</code> имеет свою область видимости, а к внешним переменным обращается через замыкание, аналогично тому, как работают обычные функции.</p></important-><h2><a name="1" href="#1">Неграмотное использование eval</a></h2><p>Начнём с того, что <code>eval</code> применяется очень редко. Действительно редко. Есть даже такое выражение «eval is evil» (eval – зло).</p><p>Причина проста: когда-то JavaScript был гораздо более слабым языком, чем сейчас, и некоторые вещи без <code>eval</code> было сделать невозможно. Но те времена давно прошли. И теперь найти тот случай, когда действительно надо выполнить код из строки – это надо постараться.</p><p>Но если вы действительно знаете, что это именно тот случай и вам необходим <code>eval</code> – есть ряд вещей, которые нужно иметь в виду.</p><p>Доступ к локальным переменным – худшее, что можно сделать при <code>eval</code>.</p><p>Дело в том, что локальные переменные могут быть легко переименованы:</p><code-example><script>`function sayHi() {\n  var phrase = "Привет";\n  eval(str);\n}`</script></code-example><p>Переменная <code>phrase</code> может быть переименована в <code>hello</code>, и если строка <code>str</code> обращается к ней – будет ошибка.</p><p>Современные средства сжатия JavaScript переименовывают локальные переменные автоматически. Это считается безопасным, так как локальная переменная видна лишь внутри функции и если в ней везде поменять <code>phrase</code> на <code>p</code>, то никто этого не заметит.</p><p>До сжатия:</p><code-example><script>`function sayHi() {\n  var phrase = "Привет";\n  alert( phrase );\n}`</script></code-example><p>После сжатия:</p><code-example><script>`function sayHi() {\n  var a = "Привет";\n  alert( a );\n}`</script></code-example><p>На самом деле всё ещё проще – в данном случае утилита сжатия автоматически уберёт переменную <code>a</code> и код станет таким:</p><code-example><script>`function sayHi() {\n  alert( "Привет" );\n}`</script></code-example><p>Итак, если где-то в функции есть <code>eval</code>, то его взаимодействие с локальными переменными будет нарушено с непредсказуемыми побочными эффектами.</p><p>Некоторые инструменты сжатия предупреждают, когда видят <code>eval</code> или стараются вообще не сжимать такой код вместе с его внешними функциями, но всё это борьба с последствиями кривого кода.</p><p>Как правило, <code>eval</code> не нужен, именно поэтому говорят: «eval is evil».</p><h2><a name="2" href="#2">Запуск скрипта в глобальной области</a></h2><p>Ок, взаимодействовать с локальными переменными нельзя.</p><p>Но, допустим, мы загрузили с сервера или вручную сгенерировали скрипт, который нужно выполнить. Желательно в глобальной области, вне любых функций, чтобы он уж точно к локальным переменным отношения не имел.</p><p>Здесь <code>eval</code> может пригодиться. Есть два трюка для выполнения кода в глобальной области:</p><ol><li><p>Везде, кроме IE8-, достаточно вызвать <code>eval</code> не напрямую, а через <code>window.eval</code>.</p><p>Вот так:</p><code-example><script>`var a = 1;\n\n(function() {\n\n  var a = 2;\nMARK  window.eval(' alert(a) '); // 1, выполнено глобально везде, кроме IE8-\n})();`</script><code-toolbar></code-toolbar></code-example></li><li><p>В IE8- можно применить нестандартную фунцию <a href="http://msdn.microsoft.com/en-us/library/ie/ms536420%28v=vs.85%29.aspx">execScript</a>. Она, как и <code>eval</code>, выполняет код, но всегда в глобальной области видимости и не возвращает значение.</p></li></ol><p>Оба способа можно объединить в единой функции <code>globalEval(code)</code>, выполняющей код без доступа к локальным переменным:</p><code-example><script>`MARKfunction globalEval(code) { // объединим два способа в одну функцию\nMARK  window.execScript ? execScript(code) : window.eval(code);\nMARK}\n\nvar a = 1;\n\n(function() {\n\n  var a = 2;\n\n  globalEval(' alert(a) '); // 1, во всех браузерах\n\n})();`</script><code-toolbar></code-toolbar></code-example><h2><a name="3" href="#3">Внешние данные через new Function</a></h2><p>Итак, у нас есть код, который всё же нужно выполнить динамически, через <code>eval</code>, но не просто скрипт – а ему нужно передать какие-то значения.</p><p>Как мы говорили ранее, считать их из локальных переменных нельзя: это подвержено ошибкам при переименовании переменных и сразу ломается при сжатии JavaScript. Да и вообще, неочевидно и криво.</p><p><strong>К счастью, существует отличная альтернатива <code>eval</code>, которая позволяет корректно взаимодействовать с внешним кодом: <code>new Function</code>.</strong></p><p>Вызов <code>new Function('a,b', '..тело..')</code> создает функцию с указанными аргументами <code>a,b</code> и телом. Как мы помним, доступа к текущему замыканию у такой функции не будет, но можно передать параметры и получить результат.</p><p>Например:</p><code-example><script>`var a = 2,\n  b = 3;\n\nMARK// вместо обращения к a,b через eval\nMARK// будем принимать их как аргументы динамически созданной функции\nMARKvar mul = new Function('a, b', ' return a * b;');\n\nalert( mul(a, b) ); // 6`</script><code-toolbar></code-toolbar></code-example><h2><a name="4" href="#4">JSON и eval</a></h2><p>В браузерах IE7- не было методов <code>JSON.stringify</code> и <code>JSON.parse</code>, поэтому работа с JSON происходила через <code>eval</code>.</p><p>Этот способ работы с JSON давно устарел, но его можно встретить кое-где в старом коде, так что для примера рассмотрим его.</p><p>Вызов <code>eval(code)</code> выполняет код и, если это выражение, то возвращает его значение, поэтому можно в качестве кода передать JSON.</p><p>Например:</p><code-example><script>`var str = \`{\n    "name": "Вася",\n    "age": 25\n}\`;\n\nMARKvar user = eval('(&nbsp' + str + ' )');\n\nalert( user.name ); // Вася`</script><code-toolbar></code-toolbar></code-example><p>Зачем здесь нужны скобки <code>eval( '(' + str + ')' )</code>, почему не просто <code>eval(str)</code>?</p><p>…Всё дело в том, что в JavaScript с фигурной скобки <code>{</code> начинаются не только объекты, а в том числе и «блоки кода». Что имеется в виду в данном случае – интерпретатор определяет по контексту. Если в основном потоке кода – то блок, если в контексте выражения, то объект.</p><p>Поэтому если передать в <code>eval</code> объект напрямую, то интерпретатор подумает, что это на самом деле блок кода, а там внутри какие-то двоеточия…</p><p>Вот, для примера, <code>eval</code> без скобок, он выдаст ошибку:</p><code-example><script>`var user = eval('{  "name": "Вася",  "age": 25  }');`</script><code-toolbar></code-toolbar></code-example><p>А если <code>eval</code> получает выражение в скобках <code>( ... )</code>, то интерпретатор точно знает, что это не блок кода, а объект:</p><code-example><script>`var user = eval('( {  "name": "Вася",  "age": 25  } )');\nalert( user.age ); // 25`</script><code-toolbar></code-toolbar></code-example><important-warn><h3>Осторожно, злой JSON!</h3><p>Если мы получаем JSON из недоверенного источника, например с чужого сервера, то разбор через <code>eval</code> может быть опасен.</p><p>Например, чужой сервер может быть взломан (за свой-то код мы отвечаем, а за чужой – нет), и вместо JSON вставлен злонамеренный JavaScript-код.</p><p><strong>Поэтому рекомендуется, всё же, использовать <code>JSON.parse</code>.</strong></p><p>При разборе через <code>JSON.parse</code> некорректный JSON просто приведёт к ошибке, а вот при разборе через <code>eval</code> этот код реально выполнится, он может вывести что-то на странице, перенаправить посетителя куда-то и т.п.</p></important-warn><h2><a name="5" href="#5">Итого</a></h2><ul><li>Функция <code>eval(str)</code> выполняет код и возвращает последнее вычисленное выражение. В современном JavaScript она используется редко.</li><li>Вызов <code>eval</code> может читать и менять локальные переменные. Это – зло, которого нужно избегать.</li><li>Для выполнения скрипта в глобальной области используются трюк с <code>window.eval/execScript</code>. При этом локальные переменные не будут затронуты, так что такое выполнение безопасно и иногда, в редких архитектурах, может быть полезным.</li><li>Если выполняемый код всё же должен взаимодействовать с локальными переменными – используйте <code>new Function</code>. Создавайте функцию из строки и передавайте переменные ей, это надёжно и безопасно.</li></ul><p>Ещё примеры использования <code>eval</code> вы найдёте далее, в главе <a data-load_page="65">Формат JSON, метод toJSON</a>.</p><h2 id="tasks"><a href="#6" name="6">Задачи (1)</a></h2><task-content><h3><a href="#10" name="10">Eval-калькулятор</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>Напишите интерфейс, который принимает математическое выражение (<code>prompt</code>) и возвращает его результат.</p><p>Проверять выражение на корректность не требуется.</p><p><a data-click="run_1">Запустить демо</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Вычислить любое выражение нам поможет <code>eval</code>:</p><code-example><script>`var expr = prompt("Введите выражение?", '2*3+2');\n\nalert( eval(expr) );`</script><code-toolbar-><a id="run_1" title="показать" data-code_run=""></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar-></code-example><p>При этом посетитель потенциально может делать все, что угодно.</p><p>Чтобы ограничить выражения только математикой, вводимую строку нужно проверять при помощи <a data-load_page="219">регулярных выражений</a> на наличие любых символов, кроме букв, пробелов и знаков пунктуации.</p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="setTimeout и setInterval; Перехват ошибок, 'try..catch'"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/eval",disqus_identifier="eval",disqus_title="\u0417\u0430\u043f\u0443\u0441\u043a \u043a\u043e\u0434\u0430 \u0438\u0437 \u0441\u0442\u0440\u043e\u043a\u0438: eval";</script></page-content></main>