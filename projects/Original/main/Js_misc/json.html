<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="63">Некоторые другие возможности</a></nav-up><h1>Формат JSON, метод toJSON</h1><p>В этой главе мы рассмотрим работу с форматом <a href="http://ru.wikipedia.org/wiki/JSON">JSON</a>, который используется для представления объектов в виде строки.</p><p>Это один из наиболее удобных форматов данных при взаимодействии с JavaScript. Если нужно с сервера взять объект с данными и передать его клиенту, то в качестве промежуточного формата – для передачи по сети, почти всегда используют именно его.</p><p>В современных браузерах есть замечательные методы, знание тонкостей которых делает операции с JSON простыми и комфортными.</p><h2><a name="0" href="#0">Формат JSON</a></h2><p>Данные в формате JSON (<a href="http://tools.ietf.org/html/rfc4627">RFC 4627</a>) представляют собой:</p><ul><li>JavaScript-объекты <code>{ ... }</code> или</li><li>Массивы <code>[ ... ]</code> или</li><li>Значения одного из типов:<ul><li>строки в двойных кавычках,</li><li>число,</li><li>логическое значение <code>true</code>/<code>false</code>,</li><li><code>null</code>.</li></ul></li></ul><p>Почти все языки программирования имеют библиотеки для преобразования объектов в формат JSON.</p><p>Основные методы для работы с JSON в JavaScript – это:</p><ul><li><code>JSON.parse</code> – читает объекты из строки в формате JSON.</li><li><code>JSON.stringify</code> – превращает объекты в строку в формате JSON, используется, когда нужно из JavaScript передать данные по сети.</li></ul><h2><a name="1" href="#1">Метод JSON.parse</a></h2><p>Вызов <code>JSON.parse(str)</code> превратит строку с данными в формате JSON в JavaScript-объект/массив/значение.</p><p>Например:</p><code-example><script>`var numbers = "[0, 1, 2, 3]";\n\nnumbers = JSON.parse(numbers);\n\nalert( numbers[1] ); // 1`</script><code-toolbar></code-toolbar></code-example><p>Или так:</p><code-example><script>`var user = \'{ "name": "Вася", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }\';\n\nuser = JSON.parse(user);\n\nalert( user.friends[1] ); // 1`</script><code-toolbar></code-toolbar></code-example><p>Данные могут быть сколь угодно сложными, объекты и массивы могут включать в себя другие объекты и массивы. Главное, чтобы они соответствовали формату.</p><important-warn><h3>JSON-объекты ≠ JavaScript-объекты</h3><p>Объекты в формате JSON похожи на обычные JavaScript-объекты, но отличаются от них более строгими требованиями к строкам – они должны быть именно в двойных кавычках.</p><p>В частности, первые два свойства объекта ниже – некорректны:</p><code-example><script>`{\n  HIGHnameLIGHT: "Вася",       // ошибка: ключ name без кавычек!\n  "surname": HIGH\'Петров\'LIGHT, // ошибка: одинарные кавычки у значения \'Петров\'!\n  "age": 35,           // .. а тут всё в порядке.\n  "isAdmin": false    // и тут тоже всё ок\n}`</script></code-example><p>Кроме того, в формате JSON не поддерживаются комментарии. Он предназначен только для передачи данных.</p><p>Есть нестандартное расширение формата JSON, которое называется <a href="http://json5.org/">JSON5</a> и как раз разрешает ключи без кавычек, комментарии и т.п, как в обычном JavaScript. На данном этапе это отдельная библиотека.</p></important-warn><h2><a name="2" href="#2">Умный разбор: JSON.parse(str, reviver)</a></h2><p>Метод <code>JSON.parse</code> поддерживает и более сложные алгоритмы разбора.</p><p>Например, мы получили с сервера объект с данными события <code>event</code>.</p><p>Он выглядит так:</p><code-example><script>`// title: название события, date: дата события\nvar str = \'{"title":"Конференция","date":"2014-11-30T12:00:00.000Z"}\';`</script></code-example><p>…И теперь нужно <em>восстановить</em> его, то есть превратить в JavaScript-объект.</p><p>Попробуем вызвать для этого <code>JSON.parse</code>:</p><code-example><script>`var str = \'{"title":"Конференция","date":"2014-11-30T12:00:00.000Z"}\';\n\nvar event = JSON.parse(str);\nnMARKalert( event.date.getDate() ); // ошибка!`</script><code-toolbar></code-toolbar></code-example><p>…Увы, ошибка!</p><p>Дело в том, что значением <code>event.date</code> является строка, а отнюдь не объект <code>Date</code>. Откуда методу <code>JSON.parse</code> знать, что нужно превратить строку именно в дату?</p><p><strong>Для интеллектуального восстановления из строки у <code>JSON.parse(str, reviver)</code> есть второй параметр <code>reviver</code>, который является функцией <code>function(key, value)</code>.</strong></p><p>Если она указана, то в процессе чтения объекта из строки <code>JSON.parse</code> передаёт ей по очереди все создаваемые пары ключ-значение и может возвратить либо преобразованное значение, либо <code>undefined</code>, если его нужно пропустить.</p><p>В данном случае мы можем создать правило, что ключ <code>date</code> всегда означает дату:</p><code-example><script>`// дата в строке - в формате UTC\nvar str = \'{"title":"Конференция","date":"2014-11-30T12:00:00.000Z"}\';\n\nMARKvar event = JSON.parse(str, function(key, value) {\nMARK  if (key == \'date\') return new Date(value);\nMARK  return value;\nMARK});\n\nalert( event.date.getDate() ); // теперь сработает!`</script><code-toolbar></code-toolbar></code-example><p>Кстати, эта возможность работает и для вложенных объектов тоже:</p><code-example><script>`var schedule = \`{\nSTRING  "events": [\nSTRING    GREEN_{"title":"Конференция",GREEN_"GREEN_date":"2014-11-30T12:00:00.000Z"}_GREEN,\nSTRING    GREEN_{"title":"День рождения",GREEN_"GREEN_date":"2015-04-18T12:00:00.000Z"}_GREEN\nSTRING  GREEN_]_GREEN\nGREEN_}\`_GREEN;\n\nschedule = JSON.parse(schedule, function(key, value) {\n  if (key == \'date\') return new Date(value);\n  return value;\n});\n\nMARKalert( schedule.events[1].date.getDate() ); // сработает!`</script><code-toolbar></code-toolbar></code-example><h2><a name="3" href="#3">Сериализация, метод JSON.stringify</a></h2><p>Метод <code>JSON.stringify(value, replacer, space)</code> преобразует («сериализует») значение в JSON-строку.</p><p>Пример использования:</p><code-example><script>`var event = {\n  title: "Конференция",\n  date: "сегодня"\n};\n\nvar str = JSON.stringify(event);\nalert( str ); // {"title":"Конференция","date":"сегодня"}\n\n// Обратное преобразование.\nevent = JSON.parse(str);`</script><code-toolbar></code-toolbar></code-example><p><strong>При сериализации объекта вызывается его метод <code>toJSON</code>.</strong></p><p>Если такого метода нет – перечисляются его свойства, кроме функций.</p><p>Посмотрим это в примере посложнее:</p><code-example><script>`var room = {\n  number: 23,\  occupy: function() {\n    alert( this.number );\n  }\n};\n\nvar event = {\n  title: "Конференция",\n  date: new Date(Date.UTC(2014, 0, 1)),\n  room: room\n};\n\nalert( JSON.stringify(event) );\n/*\n  {\nCOMMENT    "title":"Конференция",\nCOMMENT    "date":"2014-01-01T00:00:00.000Z",  // (1)\nCOMMENT    "room": {"number":23}               // (2)\n  }\n*/`</script><code-toolbar></code-toolbar></code-example><p>Обратим внимание на два момента:</p><ol><li><p>Дата превратилась в строку. Это не случайно: у всех дат есть встроенный метод <code>toJSON</code>. Его результат в данном случае – строка в таймзоне UTC.</p></li><li><p>У объекта <code>room</code> нет метода <code>toJSON</code>. Поэтому он сериализуется перечислением свойств.</p><p>Мы, конечно, могли бы добавить такой метод, тогда в итог попал бы его результат:</p><code-example><script>`var room = {\n  number: 23,\nMARK  toJSON: function() {\nMARK return this.number;\nMARK }\n};\n\nalert( JSON.stringify(room) ); // 23`</script><code-toolbar></code-toolbar></code-example></li></ol><h3><a name="8" href="#8">Исключение свойств</a></h3><p>Попытаемся преобразовать в JSON объект, содержащий ссылку на DOM.</p><p>Например:</p><code-example><script>`var user = {\n  name: "Вася",\n  age: 25,\n  window: window\n};\n\nMARKalert( JSON.stringify(user) ); // ошибка!\nMARK// TypeError: Converting circular structure to JSON (текст из Chrome)`</script><code-toolbar></code-toolbar></code-example><p>Произошла ошибка! В чём же дело? Неужели некоторые объекты запрещены? Как видно из текста ошибки – дело совсем в другом. Глобальный объект <code>window</code> – сложная структура с кучей встроенных свойств и круговыми ссылками, поэтому его преобразовать невозможно. Да и нужно ли?</p><p><strong>Во втором параметре <code>JSON.stringify(value, replacer)</code> можно указать массив свойств, которые подлежат сериализации.</strong></p><p>Например:</p><code-example><script>`var user = {\n  name: "Вася",\n  age: 25,\n  window: window\n};\n\nMARKalert( JSON.stringify(user, ["name", "age"]) );\nMARK// {"name":"Вася","age":25}`</script><code-toolbar></code-toolbar></code-example><p>Для более сложных ситуаций вторым параметром можно передать функцию <code>function(key, value)</code>, которая возвращает сериализованное <code>value</code> либо <code>undefined</code>, если его не нужно включать в результат:</p><code-example><script>`var user = {\n  name: "Вася",\n  age: 25,\n  window: window\n};\n\nMARKvar str = JSON.stringify(user, function(key, value) {\nMARK  if (key == \'window\') return undefined;\nMARK  return value;\nMARK});\n\nalert( str ); // {"name":"Вася","age":25}`</script><code-toolbar></code-toolbar></code-example><p>В примере выше функция пропустит свойство с названием <code>window</code>. Для остальных она просто возвращает значение, передавая его стандартному алгоритму. А могла бы и как-то обработать.</p><important-><h3>Функция <code>replacer</code> работает рекурсивно</h3><p>То есть, если объект содержит вложенные объекты, массивы и т.п., то все они пройдут через <code>replacer</code>.</p></important-><h3><a name="10" href="#10">Красивое форматирование</a></h3><p>В методе <code>JSON.stringify(value, replacer, space)</code> есть ещё третий параметр <code>space</code>.</p><p>Если он является числом – то уровни вложенности в JSON оформляются указанным количеством пробелов, если строкой – вставляется эта строка.</p><p>Например:</p><code-example><script>`var user = {\n  name: "Вася",\n  age: 25,\n  roles: {\n    isAdmin: false,\n    isEditor: true\n  }\n};\n\nMARKvar str = JSON.stringify(user, "", 4);\n\nalert( str );\n/* Результат -- красиво сериализованный объект:\n{\nCOMMENT    "name": "Вася",\nCOMMENT    "age": 25,\nCOMMENT    "roles": {\nCOMMENT        "isAdmin": false,\nCOMMENT        "isEditor": true\n    }\n}\n*/`</script><code-toolbar></code-toolbar></code-example><h2><a name="4" href="#4">Итого</a></h2><ul><li>JSON – формат для представления объектов (и не только) в виде строки.</li><li>Методы <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">JSON.parse</a> и <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">JSON.stringify</a> позволяют интеллектуально преобразовать объект в строку и обратно.</li></ul><h2 id="tasks"><a href="#5" name="5">Задачи (2)</a></h2><task-content><h3><a href="#11" name="11">Превратите объект в JSON</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 3</span><p>Превратите объект <code>leader</code> из примера ниже в JSON:</p><code-example><script>`var leader = {\n  name: "Василий Иванович",\n  age: 35
};`</script></code-example><p>После этого прочитайте получившуюся строку обратно в объект.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`var leader = {\n  name: "Василий Иванович",\n  age: 35\n};\n\nvar leaderStr = JSON.stringify(leader);\nleader = JSON.parse(leaderStr);`</script></code-example></task-answer></task-content><task-content><h3><a href="#12" name="12">Превратите объекты со ссылками в JSON</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 3</span><p>Превратите объект <code>team</code> из примера ниже в JSON:</p><code-example><script>`var leader = {\n  name: "Василий Иванович"\n};\n\nvar soldier = {\n  name: "Петька"\n};\n\n// эти объекты ссылаются друг на друга!\nleader.soldier = soldier;\nsoldier.leader = leader;\n\nvar team = [leader, soldier];`</script></code-example><ol><li>Может ли это сделать прямой вызов <code>JSON.stringify(team)</code>? Если нет, то почему?</li><li>Какой подход вы бы предложили для чтения и восстановления таких объектов?</li></ol><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="">Ответ на первый вопрос</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Ответ на первый вопрос</h4><p>Обычный вызов <code>JSON.stringify(team)</code> выдаст ошибку, так как объекты <code>leader</code> и <code>soldier</code> внутри структуры ссылаются друг на друга.</p><p>Формат JSON не предусматривает средств для хранения ссылок.</p></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Варианты решения</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Варианты решения</h4><p>Чтобы превращать такие структуры в JSON, обычно используются два подхода:</p><ol><li><p>Добавить в <code>team</code> свой код <code>toJSON</code>:</p><code-example><script>`team.toJSON = function() {\n  /* свой код, который может создавать копию объекта без круговых ссылок и передавать управление JSON.stringify */\n}`</script></code-example><p>При этом, конечно, понадобится и своя функция чтения из JSON, которая будет восстанавливать объект, а затем дополнять его круговыми ссылками.</p></li><li><p>Можно учесть возможную проблему в самой структуре, используя вместо ссылок <code>id</code>. Как правило, это несложно, ведь на сервере у данных тоже есть идентификаторы.</p><p>Изменённая структура может выглядеть так:</p><code-example><script>`var leader = {\n  id: 12,\n  name: "Василий Иванович"\n};\n\nvar soldier = {\n  id: 51,\n  name: "Петька"\n};\n\nMARK// поменяли прямую ссылку на ID\nMARKleader.soldierId = 51;\nMARKsoldier.leaderId = 12;\n\nvar team = {\n  12: leader,\n  51: soldier\n};`</script></code-example><p>…Но действительно ли это решение будет оптимальным? Использовать структуру стало сложнее, и вряд ли это изменение стоит делать лишь из-за JSON. Вот если есть другие преимущества, тогда можно подумать.</p></li></ol><p>Универсальный вариант подхода, описанного выше – это использование особой реализации JSON, которая не входит в стандарт и поддерживает расширенный формат для поддержки ссылок.</p><p>Она, к примеру, есть во фреймворке Dojo.</p><p>При вызове <code>dojox.json.ref.toJson(team)</code> будет создано следующее строковое представление:</p><code-example><script>`[{"name":"Василий Иванович","soldier":{"name":"Петька","leader":{"$ref":"#0"}}},{"$ref":"#0.soldier"}]\n&nbsp`</script></code-example><p>Метод разбора такой строки – также свой: <code>dojox.json.ref.fromJson</code>.</p></task-answer></task-answer-ext></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Типы данных: [[Class]], instanceof и утки; setTimeout и setInterval"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/json",disqus_identifier="json",disqus_title="\u0424\u043e\u0440\u043c\u0430\u0442 JSON, \u043c\u0435\u0442\u043e\u0434 toJSON";</script></page-content></main>