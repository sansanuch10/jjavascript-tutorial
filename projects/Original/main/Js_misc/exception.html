<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="63">Некоторые другие возможности</a></nav-up><h1>Перехват ошибок, "try..catch"</h1><p>Как бы мы хорошо ни программировали, в коде бывают ошибки. Или, как их иначе называют, «исключительные ситуации» (исключения).</p><p>Обычно скрипт при ошибке, как говорят, «падает», с выводом ошибки в консоль.</p><p>Но бывают случаи, когда нам хотелось бы как-то контролировать ситуацию, чтобы скрипт не просто «упал», а сделал что-то разумное.</p><p>Для этого в JavaScript есть замечательная конструкция <code>try..catch</code>.</p><h2><a name="0" href="#0">Конструкция try…catch</a></h2><p>Конструкция <code>try..catch</code> состоит из двух основных блоков: <code>try</code>, и затем <code>catch</code>:</p><code-example><script>`try {\n\n  // код ...\n\n} catch (err) {\n\n  // обработка ошибки\n\n}`</script></code-example><p>Работает она так:</p><ol><li><p>Выполняется код внутри блока <code>try</code>.</p></li><li><p>Если в нём ошибок нет, то блок <code>catch(err)</code> игнорируется, то есть выполнение доходит до конца <code>try</code> и потом прыгает через <code>catch</code>.</p></li><li><p>Если в нём возникнет ошибка, то выполнение <code>try</code> на ней прерывается, и управление прыгает в начало блока <code>catch(err)</code>.</p><p>При этом переменная <code>err</code> (можно выбрать и другое название) будет содержать объект ошибки с подробной информацией о произошедшем.</p></li></ol><p><strong>Таким образом, при ошибке в <code>try</code> скрипт не «падает», и мы получаем возможность обработать ошибку внутри <code>catch</code>.</strong></p><p>Посмотрим это на примерах.</p><ul><li><p>Пример без ошибок: при запуске сработают <code>alert</code><code>(1)</code> и <code>(2)</code>:</p><code-example><script>`try {\n\n  alert('Начало блока try');  // HIGH(1) <--LIGHT\n\n  // .. код без ошибок\n\n  alert('Конец блока try');   // HIGH(2) <--LIGHT\n\n} catch(e) {\n\n  alert('Блок catch не получит управление, так как нет ошибок'); // (3)\n\n}\n\nalert("Потом код продолжит выполнение...");`</script><code-toolbar></code-toolbar></code-example></li><li><p>Пример с ошибкой: при запуске сработают <code>(1)</code> и <code>(3)</code>:</p><code-example><script>`try {\n\n  alert('Начало блока try');  // HIGH(1) <--LIGHT\n\n  lalala; // ошибка, переменная не определена!\n\n  alert('Конец блока try');  // (2)\n\n} catch(e) {\n\n  alert('Ошибка&nbsp' + e.name + ":&nbsp" + e.message + "\\n" + e.stack); // (3) <--\n\n}\n\nalert("Потом код продолжит выполнение...");`</script><code-toolbar></code-toolbar></code-example></li></ul><important-warn><h3><code>try..catch</code> подразумевает, что код синтаксически верен</h3><p>Если грубо нарушена структура кода, например не закрыта фигурная скобка или где-то стоит лишняя запятая, то никакой <code>try..catch</code> здесь не поможет. Такие ошибки называются <em>синтаксическими</em>, интерпретатор не может понять такой код.</p><p>Здесь же мы рассматриваем ошибки <em>семантические</em>, то есть происходящие в корректном коде, в процессе выполнения.</p></important-warn><important-warn><h3><code>try..catch</code> работает только в синхронном коде</h3><p>Ошибку, которая произойдёт в коде, запланированном «на будущее», например в <code>setTimeout</code>, <code>try..catch</code> не поймает:</p><code-example><script>`try {\n  setTimeout(function() {\n    throw new Error(); // вылетит в консоль\n  }, 1000);\n} catch (e) {\n  alert( "не сработает" );\n}`</script><code-toolbar></code-toolbar></code-example><p>На момент запуска функции, назначенной через <code>setTimeout</code>, этот код уже завершится, интерпретатор выйдет из блока <code>try..catch</code>.</p><p>Чтобы поймать ошибку внутри функции из <code>setTimeout</code>, и <code>try..catch</code> должен быть в той же функции.</p></important-warn><h2><a name="1" href="#1">Объект ошибки</a></h2><p>В примере выше мы видим объект ошибки. У него есть три основных свойства:</p><dl><dt><code>name</code></dt><dd>Тип ошибки. Например, при обращении к несуществующей переменной: <code>"ReferenceError"</code>.</dd><dt><code>message</code></dt><dd>Текстовое сообщение о деталях ошибки.</dd><dt><code>stack</code></dt><dd>Везде, кроме IE8-, есть также свойство <code>stack</code>, которое содержит строку с информацией о последовательности вызовов, которая привела к ошибке.</dd></dl><p>В зависимости от браузера у него могут быть и дополнительные свойства, см. <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error">Error в MDN</a> и <a href="http://msdn.microsoft.com/en-us/library/dww52sbt%28v=vs.85%29.aspx">Error в MSDN</a>.</p><h2><a name="2" href="#2">Пример использования</a></h2><p>В JavaScript есть встроенный метод <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">JSON.parse(str)</a>, который используется для чтения JavaScript-объектов (и не только) из строки.</p><p>Обычно он используется для того, чтобы обрабатывать данные, полученные по сети, с сервера или из другого источника.</p><p>Мы получаем их и вызываем метод <code>JSON.parse</code>, вот так:</p><code-example><script>`var data = '{"name":"Вася", "age": 30}'; // строка с данными, полученная с сервера\n\nvar user = JSON.parse(data); // преобразовали строку в объект\n\n// теперь user -- это JS-объект с данными из строки\nalert( user.name ); // Вася\nalert( user.age ); // 30`</script><code-toolbar></code-toolbar></code-example><p>Более детально формат JSON разобран в главе <a data-load_page="65">Формат JSON, метод toJSON</a>.</p><p><strong>В случае, если данные некорректны, <code>JSON.parse</code> генерирует ошибку, то есть скрипт «упадёт».</strong></p><p>Устроит ли нас такое поведение? Конечно нет!</p><p>Получается, что если вдруг что-то не так с данными, то посетитель никогда (если, конечно, не откроет консоль) об этом не узнает.</p><p>А люди очень-очень не любят, когда что-то «просто падает», без всякого объявления об ошибке.</p><p><strong>Бывают ситуации, когда без <code>try..catch</code> не обойтись, это – одна из таких.</strong></p><p>Используем <code>try..catch</code>, чтобы обработать некорректный ответ:</p><code-example><script>`var data = "Has Error"; // в данных ошибка\n\ntry {\n\n  var user = JSON.parse(data); // <-- ошибка при выполнении\n  alert( user.name ); // не сработает\n\n} catch (e) {\n  // ...выполнится catch\n  alert( "Извините, в данных ошибка, мы попробуем получить их ещё раз" );\n  alert( e.name );\n  alert( e.message );\n}`</script><code-toolbar></code-toolbar></code-example><p>Здесь в <code>alert</code> только выводится сообщение, но область применения гораздо шире: можно повторять запрос, можно предлагать посетителю использовать альтернативный способ, можно отсылать информацию об ошибке на сервер… Свобода действий.</p><h2><a name="3" href="#3">Генерация своих ошибок</a></h2><p>Представим на минуту, что данные являются корректным JSON… Но в этом объекте нет нужного свойства <code>name</code>:</p><code-example><script>`var data = '{ "age": 30 }'; // данные неполны\n\ntry {\n\n  var user = JSON.parse(data); // <-- выполнится без ошибок\nMARK  alert( user.name ); // undefined\n\n} catch (e) {\n  // не выполнится\n  alert( "Извините, в данных ошибка" );\n}`</script><code-toolbar></code-toolbar></code-example><p>Вызов <code>JSON.parse</code> выполнится без ошибок, но ошибка в данных есть. И, так как свойство <code>name</code> обязательно должно быть, то для нас это такие же некорректные данные, как и <code>"Has Error"</code>.</p><p>Для того, чтобы унифицировать и объединить обработку ошибок парсинга и ошибок в структуре, мы воспользуемся оператором <code>throw</code>.</p><h3><a name="13" href="#13">Оператор throw</a></h3><p>Оператор <code>throw</code> генерирует ошибку.</p><p>Синтаксис: <code>throw &lt;объект ошибки&gt;</code>.</p><p>Технически в качестве объекта ошибки можно передать что угодно, это может быть даже не объект, а число или строка, но всё же лучше, чтобы это был объект, желательно – совместимый со стандартным, то есть чтобы у него были как минимум свойства <code>name</code> и <code>message</code>.</p><p><strong>В качестве конструктора ошибок можно использовать встроенный конструктор: <code>new Error(message)</code> или любой другой.</strong></p><p>В JavaScript встроен ряд конструкторов для стандартных ошибок: <code>SyntaxError</code>, <code>ReferenceError</code>, <code>RangeError</code> и некоторые другие. Можно использовать и их, но только чтобы не было путаницы.</p><p>В данном случае мы используем конструктор <code>new SyntaxError(message)</code>. Он создаёт ошибку того же типа, что и <code>JSON.parse</code>.</p><code-example><script>`var data = '{ "age": 30 }'; // данные неполны\n\ntry {\n\n  var user = JSON.parse(data); // <-- выполнится без ошибок\n\nMARK  if (!user.name) {\nMARK    throw new SyntaxError("Данные некорректны");\nMARK  }\n\n  alert( user.name );\n\n} catch (e) {\n  alert( "Извините, в данных ошибка" );\n}`</script><code-toolbar></code-toolbar></code-example><p>Получилось, что блок <code>catch</code> – единое место для обработки ошибок во всех случаях: когда ошибка выявляется при <code>JSON.parse</code> или позже.</p><h2><a name="4" href="#4">Проброс исключения</a></h2><p>В коде выше мы предусмотрели обработку ошибок, которые возникают при некорректных данных. Но может ли быть так, что возникнет какая-то другая ошибка?</p><p>Конечно, может! Код – это вообще мешок с ошибками, бывает даже так, что библиотеку выкладывают в открытый доступ, она там 10 лет лежит, её смотрят миллионы людей и на 11-й год находятся опаснейшие ошибки. Такова жизнь, таковы люди.</p><p>Блок <code>catch</code> в нашем примере предназначен для обработки ошибок, возникающих при некорректных данных. Если же в него попала какая-то другая ошибка, то вывод сообщения о «некорректных данных» будет дезинформацией посетителя.</p><p><strong>Ошибку, о которой <code>catch</code> не знает, он не должен обрабатывать.</strong></p><p>Такая техника называется <em>«проброс исключения»</em>: в <code>catch(e)</code> мы анализируем объект ошибки, и если он нам не подходит, то делаем <code>throw e</code>.</p><p>При этом ошибка «выпадает» из <code>try..catch</code> наружу. Далее она может быть поймана либо внешним блоком <code>try..catch</code> (если есть), либо «повалит» скрипт.</p><p>В примере ниже <code>catch</code> обрабатывает только ошибки <code>SyntaxError</code>, а остальные – выбрасывает дальше:</p><code-example><script>`var data = '{ "name": "Вася", "age": 30 }'; // данные корректны\n\ntry {\n\n  var user = JSON.parse(data);\n\n  if (!user.name) {\n    throw new SyntaxError("Ошибка в данных");\n  }\n\nMARK  blabla(); // произошла непредусмотренная ошибка\n\n  alert( user.name );\n\n} catch (e) {\n\nMARK  if (e.name == "SyntaxError") {\nMARK    alert( "Извините, в данных ошибка" );\nMARK  } else {\nMARK    throw e;\nMARK  }\n\n}`</script><code-toolbar></code-toolbar></code-example><p>Заметим, что ошибка, которая возникла внутри блока <code>catch</code>, «выпадает» наружу, как если бы была в обычном коде.</p><p>В следующем примере такие ошибки обрабатываются ещё одним, «более внешним» <code>try..catch</code>:</p><code-example><script>`function readData() {\n  var data = '{ "name": "Вася", "age": 30 }';\n\n  try {\n    // ...\nMARK    blabla(); // ошибка!\n  } catch (e) {\n    // ...\nMARK    if (e.name != 'SyntaxError') {\nMARK      throw e; // пробрасываем\nMARK    }\n  }\n}\n\ntry {\n  readData();\n} catch (e) {\nMARK  alert( "Поймал во внешнем catch:&nbsp" + e ); // ловим\n}`</script><code-toolbar></code-toolbar></code-example><p>В примере выше <code>try..catch</code> внутри <code>readData</code> умеет обрабатывать только <code>SyntaxError</code>, а внешний – все ошибки.</p><p>Без внешнего проброшенная ошибка «вывалилась» бы в консоль с остановкой скрипта.</p><h2><a name="5" href="#5">Оборачивание исключений</a></h2><p>И, для полноты картины – последняя, самая продвинутая техника по работе с ошибками. Она, впрочем, является стандартной практикой во многих объектно-ориентированных языках.</p><p>Цель функции <code>readData</code> в примере выше – прочитать данные. При чтении могут возникать разные ошибки, не только <code>SyntaxError</code>, но и, возможно, к примеру <code>URIError</code> (неправильное применение функций работы с URI) да и другие.</p><p>Код, который вызвал <code>readData</code>, хотел бы иметь либо результат, либо информацию об ошибке.</p><p>При этом очень важным является вопрос: обязан ли этот внешний код знать о всевозможных типах ошибок, которые могут возникать при чтении данных, и уметь перехватывать их?</p><p>Обычно внешний код хотел бы работать «на уровень выше», и получать либо результат, либо «ошибку чтения данных», при этом какая именно ошибка произошла – ему неважно. Ну, или, если будет важно, то хотелось бы иметь возможность это узнать, но обычно не требуется.</p><p>Это важнейший общий подход к проектированию – каждый участок функционала должен получать информацию на том уровне, который ему необходим.</p><p>Мы его видим везде в грамотно построенном коде, но не всегда отдаём себе в этом отчёт.</p><p>В данном случае, если при чтении данных происходит ошибка, то мы будем генерировать её в виде объекта <code>ReadError</code>, с соответствующим сообщением. А «исходную» ошибку на всякий случай тоже сохраним, присвоим в свойство <code>cause</code> (англ. – причина).</p><p>Выглядит это так:</p><code-example><script>`function ReadError(message, cause) {\n  this.message = message;\n  this.cause = cause;\n  this.name = 'ReadError';\n  this.stack = cause.stack;\n}\n\nfunction readData() {\n  var data = '{ bad data }';\n\n  try {\n    // ...\n    JSON.parse(data);\n    // ...\n  } catch (e) {\n    // ...\n    if (e.name == 'URIError') {\n      throw new ReadError("Ошибка в URI", e);\n    } else if (e.name == 'SyntaxError') {\nMARK      throw new ReadError("Синтаксическая ошибка в данных", e);\n    } else {\n      throw e; // пробрасываем\n    }\n  }\n}\n\ntry {\n  readData();\n} catch (e) {\n  if (e.name == 'ReadError') {\n    alert( e.message );\n    alert( e.cause ); // оригинальная ошибка-причина\n  } else {\n    throw e;\n  }\n}`</script><code-toolbar></code-toolbar></code-example><p>Этот подход называют «оборачиванием» исключения, поскольку мы берём ошибки «более низкого уровня» и «заворачиваем» их в <code>ReadError</code>, которая соответствует текущей задаче.</p><h2><a name="6" href="#6">Секция finally</a></h2><p>Конструкция <code>try..catch</code> может содержать ещё один блок: <code>finally</code>.</p><p>Выглядит этот расширенный синтаксис так:</p><code-example><script>`HIGHtry LIGHT{\n   .. пробуем выполнить код ..\n}HIGH catch LIGHT(e) {\n   .. перехватываем исключение ..\n}HIGH finally LIGHT{\n   .. выполняем всегда ..\n}`</script></code-example><p>Секция <code>finally</code> не обязательна, но если она есть, то она выполняется всегда:</p><ul><li>после блока <code>try</code>, если ошибок не было,</li><li>после <code>catch</code>, если они были.</li></ul><p>Попробуйте запустить такой код?</p><code-example><script>`try {\n  alert( 'try' );\n  if (confirm('Сгенерировать ошибку?')) BAD_CODE();\n} catch (e) {\n  alert( 'catch' );\n} finally {\n  alert( 'finally' );\n}`</script><code-toolbar></code-toolbar></code-example><p>У него два варианта работы:</p><ol><li>Если вы ответите на вопрос «сгенерировать ошибку?» утвердительно, то <code>try -&gt; catch -&gt; finally</code>.</li><li>Если ответите отрицательно, то <code>try -&gt; finally</code>.</li></ol><p><strong>Секцию <code>finally</code> используют, чтобы завершить начатые операции при любом варианте развития событий.</strong></p><p>Например, мы хотим подсчитать время на выполнение функции <code>sum(n)</code>, которая должна возвратить сумму чисел от <code>1</code> до <code>n</code> и работает рекурсивно:</p><code-example><script>`function sum(n) {\n  return n ? (n + sum(n - 1)) : 0;\n}\n\nvar n = +prompt('Введите n?', 100);\n\nvar start = new Date();\n\ntry {\n  var result = sum(n);\n} catch (e) {\n  result = 0;\nMARK} finally {\nMARK  var diff = new Date() - start;\nMARK}\n\nalert( result ? result : 'была ошибка' );\nalert( "Выполнение заняло&nbsp" + diff );`</script><code-toolbar></code-toolbar></code-example><p>Здесь секция <code>finally</code> гарантирует, что время будет подсчитано в любых ситуациях: при ошибке в <code>sum</code> или без неё.</p><p>Вы можете проверить это, запустив код с указанием <code>n=100</code> – будет без ошибки, <code>finally</code> выполнится после <code>try</code>, а затем с <code>n=100000</code> – будет ошибка из-за слишком глубокой рекурсии, управление прыгнет в <code>finally</code> после <code>catch</code>.</p><important-><h3><code>finally</code> и <code>return</code></h3><p>Блок <code>finally</code> срабатывает при <em>любом</em> выходе из <code>try..catch</code>, в том числе и <code>return</code>.</p><p>В примере ниже из <code>try</code> происходит <code>return</code>, но <code>finally</code> получает управление до того, как контроль возвращается во внешний код.</p><code-example><script>`function func() {\n\n  try {\n    // сразу вернуть значение\n    return 1;\n\n  } catch (e) {\n    /* ... */\n  } finally {\nMARK    alert( 'finally' );\n  }\n}\n\nalert( func() ); // сначала finally, потом 1`</script><code-toolbar></code-toolbar></code-example><p>Если внутри <code>try</code> были начаты какие-то процессы, которые нужно завершить по окончании работы, то в <code>finally</code> это обязательно будет сделано.</p><p>Кстати, для таких случаев иногда используют <code>try..finally</code> вообще без <code>catch</code>:</p><code-example><script>`function func() {\n  try {\n    return 1;\n  } finally {\n    alert( 'Вызов завершён' );\n  }\n}\n\nalert( func() ); // сначала finally, потом 1`</script><code-toolbar></code-toolbar></code-example><p>В примере выше <code>try..finally</code> вообще не обрабатывает ошибки. Задача в другом: выполнить код при любом выходе из <code>try</code> – с ошибкой ли, без ошибок или через <code>return</code>.</p></important-><h2><a name="7" href="#7">Последняя надежда: window.onerror</a></h2><p>Допустим, ошибка произошла вне блока <code>try..catch</code> или выпала из <code>try..catch</code> наружу, во внешний код. Скрипт упал.</p><p>Можно ли как-то узнать о том, что произошло? Да, конечно.</p><p>В браузере существует специальное свойство <code>window.onerror</code>, если в него записать функцию, то она выполнится и получит в аргументах сообщение ошибки, текущий URL и номер строки, откуда «выпала» ошибка.</p><p>Необходимо лишь позаботиться, чтобы функция была назначена заранее.</p><p>Например:</p><code-example><script>`<script>\nMARK  window.onerror = function(message, url, lineNumber) {\nMARK    alert("Поймана ошибка, выпавшая в глобальную область!\\n" +\nMARK      "Сообщение:&nbsp" + message + "\\n(&nbsp" + url + ":&nbsp" + lineNumber + " )");\nMARK  };\n\n  function readData() {\n    error(); // ой, что-то не так\n  }\n\n  readData();\n<\/script>`</script><code-toolbar></code-toolbar></code-example><p>Как правило, роль <code>window.onerror</code> заключается в том, чтобы не оживить скрипт – скорее всего, это уже невозможно, а в том, чтобы отослать сообщение об ошибке на сервер, где разработчики о ней узнают.</p><p>Существуют даже специальные веб-сервисы, которые предоставляют скрипты для отлова и аналитики таких ошибок, например: <a href="https://errorception.com/">https://errorception.com/</a> или <a href="http://www.muscula.com/">http://www.muscula.com/</a>.</p><h2><a name="8" href="#8">Итого</a></h2><p>Обработка ошибок – большая и важная тема.</p><p>В JavaScript для этого предусмотрены:</p><ul><li><p>Конструкция <code>try..catch..finally</code> – она позволяет обработать произвольные ошибки в блоке кода.</p><p>Это удобно в тех случаях, когда проще сделать действие и потом разбираться с результатом, чем долго и нудно проверять, не упадёт ли чего.</p><p>Кроме того, иногда проверить просто невозможно, например <code>JSON.parse(str)</code> не позволяет «проверить» формат строки перед разбором. В этом случае блок <code>try..catch</code> необходим.</p><p>Полный вид конструкции:</p><code-example><script>`HIGHtryLIGHT {\n   .. пробуем выполнить код ..\n} HIGHcatchLIGHT(e) {\n   .. перехватываем исключение ..\n} HIGHfinallyLIGHT {\n   .. выполняем всегда ..\n}`</script></code-example><p>Возможны также варианты <code>try..catch</code> или <code>try..finally</code>.</p></li><li><p>Оператор <code>throw err</code> генерирует свою ошибку, в качестве <code>err</code> рекомендуется использовать объекты, совместимые с встроенным типом <a href="http://javascript.ru/Error">Error</a>, содержащие свойства <code>message</code> и <code>name</code>.</p></li></ul><p>Кроме того, мы рассмотрели некоторые важные приёмы:</p><ul><li><p>Проброс исключения – <code>catch(err)</code> должен обрабатывать только те ошибки, которые мы рассчитываем в нём увидеть, остальные – пробрасывать дальше через <code>throw err</code>.</p><p>Определить, нужная ли это ошибка, можно, например, по свойству <code>name</code>.</p></li><li><p>Оборачивание исключений – функция, в процессе работы которой возможны различные виды ошибок, может «обернуть их» в одну общую ошибку, специфичную для её задачи, и уже её пробросить дальше. Чтобы при необходимости можно было подробно определить, что произошло, исходную ошибку обычно присваивают в свойство этой, общей. Обычно это нужно для логирования.</p></li><li><p>В <code>window.onerror</code> можно присвоить функцию, которая выполнится при любой «выпавшей» из скрипта ошибке. Как правило, это используют в информационных целях, например отправляют информацию об ошибке на специальный сервис.</p></li></ul><h2 id="tasks"><a href="#9" name="9">Задачи (2)</a></h2><task-content><h3><a href="#15" name="15">Finally или просто код?</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Сравните два фрагмента кода.</p><ol><li><p>Первый использует <code>finally</code> для выполнения кода по выходу из <code>try..catch</code>:</p><code-example><script>`try {\  начать работу\n  работать\n} catch (e) {\n  обработать ошибку\n} finally {\nMARK  финализация: завершить работу\n}`</script></code-example></li><li><p>Второй фрагмент просто ставит очистку ресурсов за <code>try..catch</code>:</p><code-example><script>`try {\n  начать работу\n} catch (e) {\n  обработать ошибку\n}\n\nMARKфинализация: завершить работу`</script></code-example></li></ol><p>Нужно, чтобы код финализации всегда выполнялся при выходе из блока <code>try..catch</code> и, таким образом, заканчивал начатую работу. Имеет ли здесь <code>finally</code> какое-то преимущество или оба фрагмента работают одинаково?</p><p>Если имеет, то дайте пример когда код с <code>finally</code> работает верно, а без – неверно.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Разница в поведении станет очевидной, если рассмотреть код внутри функции.</p><p>Поведение будет различным, если управление каким-то образом выпрыгнет из <code>try..catch</code>.</p><p>Например, <code>finally</code> сработает после <code>return</code>, но до передачи управления внешнему коду:</p><code-example><script>`function f() {\n  try {\n    ...\nMARK    return result;\n  } catch (e) {\n    ...\n  } finally {\n    очистить ресурсы\n  }\n}`</script></code-example><p>Или же управление может выпрыгнуть из-за <code>throw</code>:</p><code-example><script>`function f() {\n  try {\n    ...\n\n  } catch (e) {\n    ...\n    if(не умею обрабатывать эту ошибку) {\nMARK      throw e;\n    }\n\n  } finally {\n    очистить ресурсы\n  }\n}`</script></code-example><p>В этих случаях именно <code>finally</code> гарантирует выполнение кода до окончания работы <code>f</code>, просто код не будет вызван.</p></task-answer></task-content><task-content><h3><a href="#16" name="16">Eval-калькулятор с ошибками</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Напишите интерфейс, который принимает математическое выражение (в <code>prompt</code>) и результат его вычисления через <code>eval</code>.</p><p><strong>При ошибке нужно выводить сообщение и просить переввести выражение</strong>.</p><p>Ошибкой считается не только некорректное выражение, такое как <code>2+</code>, но и выражение, возвращающее <code>NaN</code>, например <code>0/0</code>.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Вычислить любое выражение нам поможет <code>eval</code>:</p><code-example><script>`alert( eval("2+2") ); // 4`</script><code-toolbar></code-toolbar></code-example><p>Считываем выражение в цикле <code>while(true)</code>. Если при вычислении возникает ошибка – ловим её в <code>try..catch</code>.</p><p>Ошибкой считается, в том числе, получение <code>NaN</code> из <code>eval</code>, хотя при этом исключение не возникает. Можно бросить своё исключение в этом случае.</p><p>Код решения:</p><code-example><script>`var expr, res;\n\nwhile (true) {\n  expr = prompt("Введите выражение?", '2-');\n  if (expr == null) break;\n\n  try {\n    res = eval(expr);\n    if (isNaN(res)) {\n      throw new Error("Результат неопределён");\n    }\n\n    break;\n  } catch (e) {\n    alert( "Ошибка:&nbsp" + e.message + ", повторите ввод" );\n  }\n}\n\nalert( res );`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Запуск кода из строки: eval; ООП в функциональном стиле"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/exception",disqus_identifier="exception",disqus_title="\u041f\u0435\u0440\u0435\u0445\u0432\u0430\u0442 \u043e\u0448\u0438\u0431\u043e\u043a, \"try..catch\"";</script></page-content></main>