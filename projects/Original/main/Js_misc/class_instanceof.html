<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="63">Некоторые другие возможности</a></nav-up><h1>Типы данных: [[Class]], instanceof и утки</h1><p>Время от времени бывает удобно создавать так называемые «полиморфные» функции, то есть такие, которые по-разному обрабатывают аргументы, в зависимости от их типа. Например, функция вывода может по-разному форматировать числа и даты.</p><p>Для реализации такой возможности нужен способ определить тип переменной.</p><h2><a name="0" href="#0">Оператор typeof</a></h2><p>Мы уже знакомы с простейшим способом – оператором <a data-load_page="14">typeof</a>.</p><p>Оператор <code>typeof</code> надежно работает с примитивными типами, кроме <code>null</code>, а также с функциями. Он возвращает для них тип в виде строки:</p><code-example><script>`alert( typeof 1 );         // 'number'\nalert( typeof true );      // 'boolean'\nalert( typeof \"Текст\" );   // 'string'\nalert( typeof undefined ); // 'undefined'\nalert( typeof null );      // 'object' (ошибка в языке)\nalert( typeof alert );     // 'function'`</script><code-toolbar></code-toolbar></code-example><p>…Но все объекты, включая массивы и даты для <code>typeof</code> – на одно лицо, они имеют один тип <code>'object'</code>:</p><code-example><script>`alert( typeof {} ); // 'object'\nalert( typeof [] ); // 'object'\nalert( typeof new Date ); // 'object'`</script><code-toolbar></code-toolbar></code-example><p>Поэтому различить их при помощи <code>typeof</code> нельзя, и в этом его основной недостаток.</p><h2><a name="1" href="#1">Секретное свойство [[Class]]</a></h2><p>Для встроенных объектов есть одна «секретная» возможность узнать их тип, которая связана с методом <code>toString</code>.</p><p>Во всех встроенных объектах есть специальное свойство <code>[[Class]]</code>, в котором хранится информация о его типе или конструкторе.</p><p>Оно взято в квадратные скобки, так как это свойство – внутреннее. Явно получить его нельзя, но можно прочитать его «в обход», воспользовавшись методом <code>toString</code> стандартного объекта <code>Object</code>.</p><p>Его внутренняя реализация выводит <code>[[Class]]</code> в небольшом обрамлении, как <code>"[object значение]"</code>.</p><p>Например:</p><code-example><script>`var toString = {}.toString;\n\nvar arr = [1, 2];\nalert( toString.call(arr) ); // [object Array]\n\nvar date = new Date;\nalert( toString.call(date) ); // [object Date]\n\nvar user = { name: "Вася" };\nalert( toString.call(user) ); // [object Object]`</script><code-toolbar></code-toolbar></code-example><p>В первой строке мы взяли метод <code>toString</code>, принадлежащий именно стандартному объекту <code>{}</code>. Нам пришлось это сделать, так как у <code>Date</code> и <code>Array</code> – свои собственные методы <code>toString</code>, которые работают иначе.</p><p>Затем мы вызываем этот <code>toString</code> в контексте нужного объекта <code>obj</code>, и он возвращает его внутреннее, невидимое другими способами, свойство <code>[[Class]]</code>.</p><p><strong>Для получения <code>[[Class]]</code> нужна именно внутренняя реализация <code>toString</code> стандартного объекта <code>Object</code>, другая не подойдёт.</strong></p><p>К счастью, методы в JavaScript – это всего лишь функции-свойства объекта, которые можно скопировать в переменную и применить на другом объекте через <code>call/apply</code>. Что мы и делаем для <code>{}.toString</code>.</p><p>Метод также можно использовать с примитивами:</p><code-example><script>`alert( {}.toString.call(123) ); // [object Number]\nalert( {}.toString.call("строка") ); // [object String]`</script><code-toolbar></code-toolbar></code-example><important-warn><h3>Вызов <code>{}.toString</code> в консоли может выдать ошибку</h3><p>При тестировании кода в консоли вы можете обнаружить, что если ввести в командную строку <code>{}.toString.call(...)</code> – будет ошибка. С другой стороны, вызов <code>alert( {}.toString... )</code> – работает.</p><p>Эта ошибка возникает потому, что фигурные скобки <code>{ }</code> в основном потоке кода интерпретируются как блок. Интерпретатор читает <code>{}.toString.call(...)</code> так:</p><code-example><script>`{ } // пустой блок кода\n.toString.call(...) // а что это за точка в начале? не понимаю, ошибка!`</script></code-example><p>Фигурные скобки считаются объектом, только если они находятся в контексте выражения. В частности, оборачивание в скобки <code>( {}.toString... )</code> тоже сработает нормально.</p></important-warn><p>Для большего удобства можно сделать функцию <code>getClass</code>, которая будет возвращать только сам <code>[[Class]]</code>:</p><code-example><script>`function getClass(obj) {\n  return {}.toString.call(obj).slice(8, -1);\n}\n\nalert( getClass(new Date) ); // Date\nalert( getClass([1, 2, 3]) ); // Array`</script><code-toolbar></code-toolbar></code-example><p>Заметим, что свойство <code>[[Class]]</code> есть и доступно для чтения указанным способом – у всех <em>встроенных</em> объектов. Но его нет у объектов, которые создают <em>наши функции</em>. Точнее, оно есть, но равно всегда <code>"Object"</code>.</p><p>Например:</p><code-example><script>`function User() {}\n\nvar user = new User();\n\nalert( {}.toString.call(user) ); // [object Object], не [object User]`</script><code-toolbar></code-toolbar></code-example><p>Поэтому узнать тип таким образом можно только для встроенных объектов.</p><h2><a name="2" href="#2">Метод Array.isArray()</a></h2><p>Для проверки типа на массив есть специальный метод: <code>Array.isArray(arr)</code>. Он возвращает <code>true</code> только если <code>arr</code> – массив:</p><code-example><script>`alert( Array.isArray([1,2,3]) ); // true\nalert( Array.isArray("not array")); // false`</script><code-toolbar></code-toolbar></code-example><p>Но этот метод – единственный в своём роде.</p><p>Других аналогичных, типа <code>Object.isObject</code>, <code>Date.isDate</code> – нет.</p><h2><a name="3" href="#3">Оператор instanceof</a></h2><p>Оператор <code>instanceof</code> позволяет проверить, создан ли объект данной функцией, причём работает для любых функций – как встроенных, так и наших.</p><code-example><script>`function User() {}\n\nvar user = new User();\n\nalert( user instanceof User ); // true`</script><code-toolbar></code-toolbar></code-example><p>Таким образом, <code>instanceof</code>, в отличие от <code>[[Class]]</code> и <code>typeof</code> может помочь выяснить тип для новых объектов, созданных нашими конструкторами.</p><p>Заметим, что оператор <code>instanceof</code> – сложнее, чем кажется. Он учитывает наследование, которое мы пока не проходили, но скоро изучим и затем вернёмся к <code>instanceof</code> в главе <a data-load_page="80">Проверка класса: "instanceof"</a>.</p><h2><a name="4" href="#4">Утиная типизация</a></h2><p>Альтернативный подход к типу – «утиная типизация», которая основана на одной известной пословице: <em>«If it looks like a duck, swims like a duck and quacks like a duck, then it probably is a duck (who cares what it really is)»</em>.</p><p>В переводе: <em>«Если это выглядит как утка, плавает как утка и крякает как утка, то, вероятно, это утка (какая разница, что это на самом деле)»</em>.</p><p>Смысл утиной типизации – в проверке необходимых методов и свойств.</p><p>Например, мы можем проверить, что объект – массив, не вызывая <code>Array.isArray</code>, а просто уточнив наличие важного для нас метода, например <code>splice</code>:</p><code-example><script>`var something = [1, 2, 3];\n\nif (something.splice) {\n  alert( 'Это утка! То есть, массив!' );\n}`</script><code-toolbar></code-toolbar></code-example><p>Обратите внимание – в <code>if</code> мы не вызываем метод <code>something.splice()</code>, а пробуем получить само свойство <code>something.splice</code>. Для массивов оно всегда есть и является функцией, т.е. даст в логическом контексте <code>true</code>.</p><p>Проверить на дату можно, определив наличие метода <code>getTime</code>:</p><code-example><script>`var x = new Date();\n\nif (x.getTime) {\n  alert( 'Дата!' );\n  alert( x.getTime() ); // работаем с датой\n}`</script><code-toolbar></code-toolbar></code-example><p>С виду такая проверка хрупка, ее можно «сломать», передав похожий объект с тем же методом.</p><p>Но как раз в этом и есть смысл утиной типизации: если объект похож на дату, у него есть методы даты, то будем работать с ним как с датой (какая разница, что это на самом деле).</p><p>То есть мы намеренно позволяем передать в код нечто менее конкретное, чем определённый тип, чтобы сделать его более универсальным.</p><important-><h3>Проверка интерфейса</h3><p>Если говорить словами «классического программирования», то «duck typing» – это проверка реализации объектом требуемого интерфейса. Если реализует – ок, используем его. Если нет – значит это что-то другое.</p></important-><h2><a name="5" href="#5">Пример полиморфной функции</a></h2><p>Пример полиморфной функции – <code>sayHi(who)</code>, которая будет говорить «Привет» своему аргументу, причём если передан массив – то «Привет» каждому:</p><code-example><script>`function sayHi(who) {\n\n  if (Array.isArray(who)) {\n    who.forEach(sayHi);\n  } else {\n    alert( \'Привет,&nbsp\' + who );\n  }\n}\n\n// Вызов с примитивным аргументом\nsayHi("Вася"); // Привет, Вася\n\n// Вызов с массивом\nsayHi(["Саша", "Петя"]); // Привет, Саша... Петя\n\n// Вызов с вложенными массивами - тоже работает!\nsayHi(["Саша", "Петя", ["Маша", "Юля"]]); // Привет Саша..Петя..Маша..Юля`</script><code-toolbar></code-toolbar></code-example><p>Проверку на массив в этом примере можно заменить на «утиную» – нам ведь нужен только метод <code>forEach</code>:</p><code-example><script>`function sayHi(who) {\n\n  if (who.forEach) {  // если есть forEach\n    who.forEach(sayHi); // предполагаем, что он ведёт себя \"как надо\"\n  } else {\n    alert( 'Привет,&nbsp' + who );\n  }\n}`</script><code-toolbar></code-toolbar></code-example><h2><a name="6" href="#6">Итого</a></h2><p>Для написания полиморфных (это удобно!) функций нам нужна проверка типов.</p><ul><li><p>Для примитивов с ней отлично справляется оператор <code>typeof</code>.</p><p>У него две особенности:</p><ul><li>Он считает <code>null</code> объектом, это внутренняя ошибка в языке.</li><li>Для функций он возвращает <code>function</code>, по стандарту функция не считается базовым типом, но на практике это удобно и полезно.</li></ul></li><li><p>Для встроенных объектов мы можем получить тип из скрытого свойства <code>[[Class]]</code>, при помощи вызова <code>{}.toString.call(obj).slice(8, -1)</code>. Для конструкторов, которые объявлены нами, <code>[[Class]]</code> всегда равно <code>"Object"</code>.</p></li><li><p>Оператор <code>obj instanceof Func</code> проверяет, создан ли объект <code>obj</code> функцией <code>Func</code>, работает для любых конструкторов. Более подробно мы разберём его в главе <a data-load_page="80">Проверка класса: "instanceof"</a>.</p></li><li><p>И, наконец, зачастую достаточно проверить не сам тип, а просто наличие нужных свойств или методов. Это называется «утиная типизация».</p></li></ul><h2 id="tasks"><a href="#7" name="7">Задачи</a></h2><task-content><h3><a href="#11" name="11">Полиморфная функция formatDate</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Напишите функцию <code>formatDate(date)</code>, которая возвращает дату в формате <code>dd.mm.yy</code>.</p><p>Ее первый аргумент должен содержать дату в одном из видов:</p><ol><li>Как объект <code>Date</code>.</li><li>Как строку, например <code>yyyy-mm-dd</code> или другую в стандартном формате даты.</li><li>Как число <em>секунд</em> с <code>01.01.1970</code>.</li><li>Как массив <code>[гггг, мм, дд]</code>, месяц начинается с нуля</li></ol><p>Для этого вам понадобится определить тип данных аргумента и, при необходимости, преобразовать входные данные в нужный формат.</p><p>Пример работы:</p><code-example><script>`function formatDate(date) { /* ваш код */ }\n\nalert( formatDate('2011-10-02') ); // 02.10.11\nalert( formatDate(1234567890) ); // 14.02.09\nalert( formatDate([2014, 0, 1]) ); // 01.01.14\nalert( formatDate(new Date(2014, 0, 1)) ); // 01.01.14`</script></code-example><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    // ...Ваш код...\n\n  <\/script>\n  <script>\n    describe("formatDate", function() {\n      it("читает дату вида гггг-мм-дд из строки", function() {\n        assert.equal(formatDate('2011-10-02'), "02.10.11");\n      });\n      it("читает дату из числа 1234567890 (секунды)", function() {\n        assert.equal(formatDate(1234567890), "14.02.09");\n      });\n      it("читает дату из массива вида [гггг, м, д]", function() {\n        assert.equal(formatDate([2014, 0, 1]), "01.01.14");\n      });\n      it("читает дату из объекта Date", function() {\n        assert.equal(formatDate(new Date(2014, 0, 1)), "01.01.14");\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="task_1" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="task_1">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Для определения примитивного типа строка/число подойдет оператор <a href="/types-intro#type-typeof">typeof</a>.</p><p>Примеры его работы:</p><code-example><script>`alert( typeof 123 ); // "number"\nalert( typeof "строка" ); // "string"\nalert( typeof new Date() ); // "object"\nalert( typeof [] ); // "object"`</script><code-toolbar></code-toolbar></code-example><p>Оператор <code>typeof</code> не умеет различать разные типы объектов, они для него все на одно лицо: <code>"object"</code>. Поэтому он не сможет отличить <code>Date</code> от <code>Array</code>.</p><p>Для отличия <code>Array</code> используем вызов <code>Array.isArray</code>. Если он неверен, значит у нас дата.</p><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    function formatDate(date) {\n      if (typeof date == 'number') {\n        // перевести секунды в миллисекунды и преобразовать к Date\n        date = new Date(date * 1000);\n      } else if (typeof date == 'string') {\n        // строка в стандартном формате автоматически будет разобрана в дату\n        date = new Date(date); \n      } else if (Array.isArray(date)) { \n        date = new Date(date[0], date[1], date[2]);\n      }\n      // преобразования для поддержки полиморфизма завершены, \n      // теперь мы работаем с датой (форматируем её)    \n      return date.toLocaleString("ru", {day: '2-digit', month: '2-digit', year: '2-digit'});    \n      /*\n      // можно и вручную, если лень добавлять в старый IE поддержку локализации\n      var day = date.getDate();\n      if (day < 10) day = '0' + day;    \n      var month = date.getMonth() + 1;\n      if (month < 10) month = '0' + month;    \n      // взять 2 последние цифры года\n      var year = date.getFullYear() % 100;\n      if (year < 10) year = '0' + year;    \n      var formattedDate = day + '.' + month + '.' + year;      \n      return formattedDate;\n      */\n    }\n\n  <\/script>\n  <script>\n    describe("formatDate", function() {\n      it("читает дату вида гггг-мм-дд из строки", function() {\n        assert.equal(formatDate('2011-10-02'), "02.10.11");\n      });\n      it("читает дату из числа 1234567890 (секунды)", function() {\n        assert.equal(formatDate(1234567890), "14.02.09");\n      });\n      it("читает дату из массива вида [гггг, м, д]", function() {\n        assert.equal(formatDate([2014, 0, 1]), "01.01.14");\n      });\n      it("читает дату из объекта Date", function() {\n        assert.equal(formatDate(new Date(2014, 0, 1)), "01.01.14");\n      });\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="answer_1" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="answer_1">Открыть решение с тестами в песочнице.</a></p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Некоторые другие возможности; Формат JSON, метод toJSON"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/class-instanceof",disqus_identifier="class-instanceof",disqus_title="\u0422\u0438\u043f\u044b \u0434\u0430\u043d\u043d\u044b\u0445: [[Class]], instanceof \u0438 \u0443\u0442\u043a\u0438";</script></page-content></main>