<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="180">Оптимизация</a></nav-up><h1>Очистка памяти при removeChild/innerHTML</h1><p>Управление памятью в случае с DOM работает по сути так же, как и с обычными JavaScript-объектами. Пока объект достижим – он остаётся в памяти.</p><p>Но есть и особенности, поскольку DOM весь переплетён ссылками.</p><h2><a name="0" href="#0">Пример</a></h2><p>Для примера рассмотрим следующий HTML:</p><code-example><script>`<html>\n\n<body>\n  <div>\n    <ul>\n      <li>Список</li>\n    </ul>\n    Сосед\n  </div>\n</body>\n\n</html>`</script></code-example><p>Его DOM (показаны только основные ссылки):</p><figure><img src="html.png" alt="" width="100%" style="max-width:313px"></figure><h2><a name="1" href="#1">Удаление removeChild</a></h2><p>Операция <code>removeChild</code> разрывает все связи между удаляемым узлом и его родителем.</p><p>Поэтому, если удалить <code>DIV</code> из <code>BODY</code>, то всё поддерево под <code>DIV</code> станет недостижимым и будет удалено.</p><p>А что происходит, если на какой-то элемент внутри удаляемого поддерева есть ссылка?</p><p>Например, <code>UL</code> сохранён в переменную <code>list</code>:</p><code-example><script>`var list = document.getElementsByTagName('UL')[0];\ndocument.body.removeChild(document.body.children[0]);`</script></code-example><p>В этом случае, так как из этого <code>UL</code> можно по ссылкам добраться до любого другого места DOM, то получается, что все объекты по-прежнему достижимы и должны остаться в памяти:</p><figure><img src="html-list.png" alt="" width="100%" style="max-width:367px"></figure><p>То есть, DOM-объекты при использовании <code>removeChild</code> работают по той же логике, что и обычные объекты.</p><h2><a name="2" href="#2">Удаление через innerHTML</a></h2><p>А вот удаление через очистку <code>elem.innerHTML="..."</code> браузеры интерпретируют по-разному.</p><p>По идее, при присвоении <code>elem.innerHTML=html</code> из DOM должны удаляться предыдущие узлы и добавляться новые,  из указанного <code>html</code>. Но стандарт ничего не говорит о том, что делать с узлами после удаления. И тут разные браузеры имеют разное мнение.</p><p>Посмотрим, что произойдёт с DOM-структурой при очистке <code>BODY</code>, если на какой-либо элемент есть ссылка.</p><code-example><script>`var list = document.getElementsByTagName('UL')[0];\ndocument.body.innerHTML = "";`</script></code-example><p>Обращаю внимание – связь разрывается только между <code>DIV</code> и <code>BODY</code>, т.е. на верхнем уровне, а <code>list</code> – это произвольный элемент.</p><p>Чтобы увидеть, что останется в памяти, а что нет – запустим код:</p><code-example><script>`<div>\n  <ul>\n    <li>Список</li>\n  </ul>\n  Сосед\n</div>\n\n<script>\n  var list = document.getElementsByTagName('ul')[0];\n  document.body.innerHTML = ''; // удалили DIV\n\n  alert( list.parentNode ); // цела ли ссылка UL -> DIV ?\n  alert( list.nextSibling ); // живы ли соседи UL ?\n  alert( list.children.length ); // живы ли потомки UL ?\n<\/script>`</script><code-toolbar><a title="показать" data-code_run="0"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>Как ни странно, браузеры ведут себя по-разному:</p><table><thead><tr><th></th><th><code>parentNode</code></th><th><code>nextSibling</code></th><th><code>children.length</code></th></tr></thead><tbody><tr><td>Chrome/Safari/Opera</td><td><code>null</code></td><td><code>null</code></td><td><code>1</code></td></tr><tr><td>Firefox</td><td>узел DOM</td><td>узел DOM</td><td><code>1</code></td></tr><tr><td>IE 11-</td><td><code>null</code></td><td><code>null</code></td><td><code>0</code></td></tr></tbody></table><p>Иными словами, браузеры ведут себя с различной степенью агрессивности по отношению к элементам.</p><dl><dt>Firefox</dt><dd>Главный пацифист. Оставляет всё, на что есть ссылки, т.е. элемент, его родителя, соседей и детей, в точности как при <code>removeChild</code>.</dd><dt>Chrome/Safari/Opera</dt><dd>Считают, что раз мы задали ссылку на <code>UL</code>, то нам нужно только это поддерево, а остальные узлы (соседей, родителей) можно удалить.</dd><dt>Internet Explorer</dt><dd>Как ни странно, самый агрессивный. Удаляет вообще всё, кроме узла, на который есть ссылка. Это поведение одинаково для всех версий IE.</dd></dl><p>На иллюстрации ниже показано, какую часть DOM оставит каждый из браузеров:<img src="/article/memory-removechild-innerhtml/html-innerhtml.png" alt="" width="415" height="325"></p><h2><a name="3" href="#3">Итого</a></h2><p>Если на какой-то DOM-узел есть ссылка, то:</p><ul><li><p>При использовании <code>removeChild</code> на родителе (или на этом узле, не важно) все узлы, достижимые из данного, остаются в памяти.</p><p>То есть, фактически, в памяти может остаться большая часть дерева DOM. Это даёт наибольшую свободу в коде, но может привести к большим «утечкам памяти» из-за сохранения данных, которые реально не нужны.</p></li><li><p>При удалении через <code>innerHTML</code> браузеры ведут себя с различной степенью агрессивности. Кросс-браузерно гарантировано одно: сам узел, на который есть ссылка, останется в памяти.</p><p>Поэтому обращаться к соседям и детям узла, предок которого удалён через присвоение <code>innerHTML</code>, нельзя.</p></li></ul><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Утечки памяти при использовании jQuery; GCC: продвинутые оптимизации"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/memory-removechild-innerhtml", disqus_identifier = "memory-removechild-innerhtml", disqus_title = "\u041e\u0447\u0438\u0441\u0442\u043a\u0430 \u043f\u0430\u043c\u044f\u0442\u0438 \u043f\u0440\u0438 removeChild\/innerHTML";</script></page-content></main>