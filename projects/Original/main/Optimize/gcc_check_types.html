<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="180">Оптимизация</a></nav-up><h1>GCC: статическая проверка типов</h1><p>Google Closure Compiler, как и любой кошерный компилятор, старается проверить правильность кода и предупредить о возможных ошибках.</p><p>Первым делом он, разумеется, проверяет структуру кода и сразу же выдает такие ошибки как пропущенная скобка или лишняя запятая.</p><p>Но, кроме этого, он умеет проверять типы переменных, используя как свои собственные знания о встроенных javascript-функциях и преобразованиях типов,так и информацию о типах из JSDoc, указываемую javascript-разработчиком.</p><p>Это обеспечивает то, чем так гордятся компилируемые языки – статическую проверку типов, что позволяет избежать лишних ошибок во время выполнения.</p><p>Для вывода предупреждений при проверки типов используется флаг <code>--jscomp_warning checkTypes</code>.</p><h2><a name="0" href="#0">Задание типа при помощи аннотации</a></h2><p>Самый очевидный способ задать тип – это использовать аннотацию. Полный список аннотаций вы найдете в <a href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler">документации</a>.</p><p>В следующем примере параметр <code>id</code> функции <code>f1</code> присваивается переменной <code>boolVar</code> другого типа:</p><code-example><script>`/** @param {number} id */\nfunction f(id) {\n  /** @type {boolean} */\n  var boolVar;\n\n  boolVar = id; // (!)\n}`</script></code-example><p>Компиляция с флагом <code>--jscomp_warning checkTypes</code> выдаст предупреждение:</p><code-example><script>`f.js:6: WARNING - assignment\nfound   : number\nrequired: boolean\n        boolVar = id; // (!)\n        ^`</script></code-example><p>Действительно: произошло присвоение значения типа <code>number</code> переменной типа <code>boolean</code>.</p><p>Типы отслеживаются по цепочке вызовов.</p><p>Еще пример, на этот раз вызов функции с некорректным параметром:</p><code-example><script>`/** @param {number} id */\nfunction f1(id) {\n  f2(id); // (!)\n}\n\n/** @param {string} id */\nfunction f2(id) {}`</script></code-example><p>Такой вызов приведёт к предупреждению со стороны минификатора:</p><code-example><script>`f2.js:3: WARNING - actual parameter 1 of f2 does not match formal parameter\nfound   : number\nrequired: string\n  f2(id); // (!)\n     ^`</script></code-example><p>Действительно, вызов функции <code>f2</code> произошел с числовым типом вместо строки.</p><p><strong>Отслеживание приведений и типов идёт при помощи графа взаимодействий и выведению (infer) типов, который строит GCC по коду.</strong></p><h2><a name="1" href="#1">Знания о преобразовании типов</a></h2><p>Google Closure Compiler знает, как операторы javascript преобразуют типы. Такой код уже не выдаст ошибку:</p><code-example><script>`/** @param {number} id */\nfunction f1(id) {\n  /** @type {boolean} */\n  var boolVar;\n\n  boolVar = !!id\n}`</script></code-example><p>Действительно – переменная преобразована к типу boolean двойным оператором НЕ.А код <code>boolVar = „test-“+id</code> выдаст ошибку, т.к. конкатенация со строкой дает тип <code>string</code>.</p><h2><a name="2" href="#2">Знание о типах встроенных функций, объектные типы</a></h2><p>Google Closure Compiler содержит описания большинства встроенных объектов и функций javascript вместе с типами параметров и результатов.</p><p>Например, объектный тип <code>Node</code> соответствует узлу DOM.</p><p>Пример некорректного кода:</p><code-example><script>`/** @param {Node} node */\nfunction removeNode(node) {\n  node.parentNode.removeChild(node)\n}\ndocument.onclick = function() {\n  removeNode("123")\n}`</script></code-example><p>Выдаст предупреждение</p><code-example><script>`f3.js:7: WARNING - actual parameter 1 of removeNode does not match formal parameter\nfound   : string\nrequired: (Node|null)\n  removeNode("123")\n             ^`</script></code-example><p>Обратите внимание – в этом примере компилятор выдает <code>required: Node|null</code>. Это потому, что указание объектного типа (не элементарного) подразумевает, что в функцию может быть передан <code>null</code>.</p><p>В следующем примере тип указан жестко, без возможности обнуления:</p><code-example><script>`MARK/** @param {!Node} node */\nfunction removeNode(node) {\n  node.parentNode.removeChild(node)\n}`</script></code-example><p>Восклицательный знак означает, что параметр обязатален.</p><p>Найти описания встроенных типов и объектов javascript вы можете в файле экстернов: <code>externs.zip</code> находится в корне архива <code>compiler.jar</code>.</p><h2><a name="3" href="#3">Интеграция с проверками типов из Google Closure Library</a></h2><p>В Google Closure Library есть функции проверки типов: <code>goog.isArray</code>, <code>goog.isDef</code>, <code>goog.isNumber</code> и т.п.</p><p>Google Closure Compiler знает о них и понимает, что внутри следующего <code>if</code> переменная может быть только функцией:</p><code-example><script>`var goog = {\n  isFunction: function(f) {\n    return typeof f == 'function'\n  }\n}\n\nif (goog.isFunction(func)) {\n  func.apply(1, 2)\n}`</script></code-example><p>Сжатие с проверкой выдаст предупреждение:</p><code-example><script>`f.js:6: WARNING - actual parameter 2 of Function.apply does not match formal parameter\nfound   : number\nrequired: (Object|null|undefined)\n  func.apply(1, 2)\n                ^      ^`</script></code-example><p>То есть, компилятор увидел, что код, использующий <code>func</code> находится в <code>if (goog.isFunction(func))</code> и сделал соответствующий вывод, что в этой ветке <code>func</code> является функцией, а значит вызов <code>func.apply(1,2)</code> ошибочен (второй аргумент не может быть числом).</p><p>Дело тут именно в интеграции с Google Closure Library. Если поменять <code>goog</code> на <code>g</code> – предупреждения не будет.</p><h2><a name="4" href="#4">Резюме</a></h2><p>Из нескольких примеров, которые мы рассмотрели, должна быть понятна общая логика проверки типов.</p><p>Соответствующие различным типам и ограничениям на типы аннотации вы можете найти в <a href="http://code.google.com/intl/ru/closure/compiler/docs/js-for-compiler.html">Документации Google</a>. В частности, возможно указание нескольких возможных типов, типа <code>undefined</code> и т.п.</p><p>Также можно указывать количество и тип параметров функции, ключевого слова <code>this</code>, объявлять классы, приватные методы и интерфейсы.</p><p>Проверка типов javascript, предоставляемая Google Closure Compiler – пожалуй, самая продвинутая из существующих на сегодняшний день.</p><p>С ней аннотации, документирующие типы и параметры, становятся не просто украшением, а реальным средством проверки, уменьшающим количество ошибок на production.</p><p>Очень подробно проверка типов описана в книге <a href="http://www.ozon.ru/context/detail/id/6089988/">Closure: The Definitive Guide</a>, автора Michael Bolin.</p><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="GCC: продвинутые оптимизации; GCC: интеграция с Google Closure Library"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/gcc-check-types", disqus_identifier = "gcc-check-types", disqus_title = "GCC: \u0441\u0442\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0430\u044f \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0442\u0438\u043f\u043e\u0432";</script></page-content></main>