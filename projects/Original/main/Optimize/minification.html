<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="180">Оптимизация</a></nav-up><h1>Как работают сжиматели JavaScript</h1><p>Перед выкладыванием JavaScript на «боевую» машину – пропускаем его через минификатор (также говорят «сжиматель»), который удаляет пробелы и по-всякому оптимизирует код, уменьшая его размер.</p><p>В этой статье мы посмотрим, как работают современные минификаторы, за счёт чего они укорачивают код и какие с ними возможны проблемы.</p><h2><a name="0" href="#0">Современные сжиматели</a></h2><p>Рассматриваемые в этой статье алгоритмы и подходы относятся к минификаторам последнего поколения.</p><p>Вот их список:</p><ul><li><a href="https://developers.google.com/closure/compiler/">Google Closure Compiler</a></li><li><a href="https://github.com/mishoo/UglifyJS">UglifyJS</a></li><li><a href="http://ajaxmin.codeplex.com/">Microsoft AJAX Minifier</a></li></ul><p>Самые широко используемые – первые два, поэтому будем рассматривать в первую очередь их.</p><p>Наша цель – понять, как они работают, и что интересного с их помощью можно сотворить.</p><h2><a name="1" href="#1">С чего начать?</a></h2><p>Для GCC:</p><ol><li>Убедиться, что стоит <a href="http://java.oracle.com">Java</a></li><li>Скачать и распаковать <a href="http://closure-compiler.googlecode.com/files/compiler-latest.zip">http://closure-compiler.googlecode.com/files/compiler-latest.zip</a>, нам нужен файл <code>compiler.jar</code>.</li><li>Сжать файл <code>my.js</code>: <code>java -jar compiler.jar --charset UTF-8 --js my.js --js_output_file my.min.js</code></li></ol><p>Обратите внимание на флаг <code>--charset</code> для GCC. Без него русские буквы будут закодированы во что-то типа <code>\u1234</code>.</p><p>Google Closure Compiler также содержит <a href="http://closure-compiler.appspot.com/home">песочницу</a> для тестирования сжатия и <a href="https://developers.google.com/closure/compiler/docs/gettingstarted_api?hl=ru">веб-сервис</a>, на который код можно отправлять для сжатия. Но скачать файл обычно гораздо проще, поэтому его редко где используют.</p><p>Для UglifyJS:</p><ol><li>Убедиться, что стоит <a href="http://nodejs.org">Node.js</a></li><li>Поставить <code>npm install -g uglify-js</code>.</li><li>Сжать файл <code>my.js</code>: <code>uglifyjs my.js -o my.min.js</code></li></ol><h2><a name="2" href="#2">Что делает минификатор?</a></h2><p>Все современные минификаторы работают следующим образом:</p><ol><li><p>Разбирают JavaScript-код в синтаксическое дерево.</p><p>Также поступает любой интерпретатор JavaScript перед тем, как его выполнять. Но затем, вместо исполнения кода…</p></li><li><p>Бегают по этому дереву, анализируют и оптимизируют его.</p></li><li><p>Записывают из синтаксического дерева получившийся код.</p></li></ol><h2><a name="3" href="#3">Как выглядит дерево?</a></h2><p>Посмотреть синтаксическое дерево можно, запустив компилятор со специальным флагом.</p><p>Для GCC есть даже способ вывести его:</p><ol><li><p>Сначала сгенерируем дерево в формате <a href="http://en.wikipedia.org/wiki/DOT_language">DOT</a>:</p><code-example><script>`java -jar compiler.jar --js my.js --use_only_custom_externs --print_tree >my.dot`</script></code-example><p>Здесь флаг <code>--print_tree</code> выводит дерево, а <code>--use_only_custom_externs</code> убирает лишнюю служебную информацию.</p></li><li><p>Файл в этом формате используется в различных программах для графопостроения.</p><p>Чтобы превратить его в обычную картинку, подойдёт утилита <code>dot</code> из пакета <a href="http://www.graphviz.org/">Graphviz</a>:</p><code-example><script>`// конвертировать в формат png\ndot -Tpng my.dot -o my.png\n\n// конвертировать в формат svg\ndot -Tsvg my.dot -o my.svg`</script></code-example></li></ol><p>Пример кода <code>my.js</code>:</p><code-example><script>`function User(name) {\n\n  this.sayHi = function() {\n    alert( name );\n  };\n\n}`</script></code-example><p>Результат, получившееся из <code>my.js</code> дерево:</p><figure><img src="my.png" alt="" width="100%" style="max-width:568px"></figure><p>В узлах-эллипсах на иллюстрации выше стоит тип, например <code>FUNCTION</code> (функция) или <code>NAME</code> (имя переменной). Комментарии к ним на русском языке добавлены мной вручную.</p><p>Кроме него к каждому узлу привязаны конкретные данные. Сжиматель умеет ходить по этому дереву и менять его, как пожелает.</p><important-><h3>Комментарии JSDoc</h3><p>Обычно когда код превращается в дерево – из него естественным образом исчезают комментарии и пробелы. Они не имеют значения при выполнении, поэтому игнорируются.</p><p>Но Google Closure Compiler добавляет в дерево информацию из <em>комментариев JSDoc</em>, т.е. комментариев вида <code>/** ... */</code>, например:</p><code-example><script>`/**\nMARKCOMMENT * Номер минимальной поддерживаемой версии IE\nMARKCOMMENT * @const\nMARKCOMMENT * @type {number}\nMARKCOMMENT */\nvar minIEVersion = 8;`</script></code-example><p>Такие комментарии не создают новых узлов дерева, а добавляются в качестве информации к существующем. В данном случае – к переменной <code>minIEVersion</code>.</p><p>В них может содержаться информация о типе переменной (<code>number</code>) и другая, которая поможет сжимателю лучше оптимизировать код (<code>const</code> – константа).</p><h2><a name="4" href="#4">Оптимизации</a></h2><p>Сжиматель бегает по дереву, ищет «паттерны» – известные ему структуры, которые он знает, как оптимизировать, и обновляет дерево.</p><p>В разных минификаторах реализован разный набор оптимизаций, сами оптимизации применяются в разном порядке, поэтому результаты работы могут отличаться. В примерах ниже даётся результат работы GCC.</p><dl><dt>Объединение и сжатие констант</dt><dd><p>До оптимизации:</p><code-example><script>`function test(a, b) {\n  run(a, GREEN_'GREEN_my' + 'string', 600 * 600 * 5, 1 && 0, b && 0)\n}`</script></code-example><p>После:</p><code-example><script>`function test(a,b){run(a,GREEN_"GREEN_mystring"_GREEN,18E5,0,b&&0)};`</script></code-example></dd></dl><ul><li><code>'my' + 'string'</code> → <code>"mystring"</code>.</li><li><code>600 * 600 * 5</code> → <code>18E5</code> (научная форма числа, для краткости).</li><li><code>1 &amp;&amp; 0</code> → <code>0</code>.</li><li><code>b &amp;&amp; 0</code> → без изменений, т.к. результат зависит от <code>b</code>.</li></ul><dl><dt>Укорачивание локальных переменных</dt><dd><p>До оптимизации:</p><code-example><script>`function sayHi(HIGHname_LIGHT, HIGHmessageLIGHT) {\n  alert(name + " сказал:&nbsp" + message);\n}`</script></code-example><p>После оптимизации:</p><code-example><script>`function sayHi(a,b){alert(a+GREEN_" GREEN_сказал:&nbsp"+b)};`</script></code-example></dd></dl><ul><li>Локальная переменная заведомо доступна только внутри функции, поэтому обычно её переименование безопасно (необычные случаи рассмотрим далее).</li><li>Также переименовываются локальные функции.</li><li>Вложенные функции обрабатываются корректно.</li></ul><dl><dt>Объединение и удаление локальных переменных</dt><dd><p>До оптимизации:</p><code-example><script>`function test(nodeId) {\n  var elem = document.getElementsById(nodeId);\n  var parent = elem.parentNode;\n  alert( parent );\n}`</script></code-example><p>После оптимизации GCC:</p><code-example><script>`function test(a){a=document.getElementsById(a).parentNode;alert(a)};`</script></code-example></dd></dl><ul><li>Локальные переменные были переименованы.</li><li>Лишние переменные убраны. Для этого сжиматель создаёт вспомогательную внутреннюю структуру данных, в которой хранятся сведения о «пути использования» каждой переменной. Если одна переменная заканчивает свой путь и начинает другая, то вполне можно дать им одно имя.</li><li>Кроме того, операции <code>elem = getElementsById</code> и <code>elem.parentNode</code> объединены, но это уже другая оптимизация.</li></ul><dl><dt>Уничтожение недостижимого кода, разворачивание <code>if</code>-веток</dt><dd><p>До оптимизации:</p><code-example><script>`function test(node) {\n  var parent = node.parentNode;\n\n  if (0) {\n    alert( "Привет с параллельной планеты" );\n  } else {\n    alert( "Останется только один" );\n  }\n\n  return;\n\n  alert( 1 );\n}`</script></code-example><p>После оптимизации:</p><code-example><script>`function test(){alert("Останется только один")}`</script></code-example></dd></dl><ul><li><p>Если переменная присваивается, но не используется, она может быть удалена. В примере выше эта оптимизация была применена к переменной <code>parent</code>, а затем и к параметру <code>node</code>.</p></li><li><p>Заведомо ложная ветка <code>if(0) { .. }</code> убрана, заведомо истинная – оставлена.</p><p>То же самое будет с условиями в других конструкциях, например <code>a = true ? c : d</code> превратится в <code>a = c</code>.</p></li><li><p>Код после <code>return</code> удалён как недостижимый.</p></li></ul><dl><dt>Переписывание синтаксических конструкций</dt><dd><p>До оптимизации:</p><code-example><script>`var i = 0;\nwhile (i++ < 10) {\n  alert( i );\n}\n\nif (i) {\n  alert( i );\n}\n\nif (i == '1') {\n  alert( 1 );\n} else if (i == '2') {\n  alert( 2 );\n} else {\n  alert( i );\n}`</script></code-example><p>После оптимизации:</p><code-example><script>`for(var i=0;10>i++;)alert(i);i&&alert(i);"1"==i?alert(1):"2"==i?alert(2):alert(i);`</script></code-example></dd></dl><ul><li>Конструкция <code>while</code> переписана в <code>for</code>.</li><li>Конструкция <code>if (i) ...</code> переписана в <code>i&amp;&amp;...</code>.</li><li>Конструкция <code>if (cond) ... else ...</code> была переписана в <code>cond ? ... : ...</code>.</li></ul><dl><dt>Инлайнинг функций</dt><dd><p><em>Инлайнинг функции</em> – приём оптимизации, при котором функция заменяется на своё тело.</p><p>До оптимизации:</p><code-example><script>`function sayHi(message) {\n\n  var elem = createMessage('div', message);\n  showElement(elem);\n\n  function createMessage(tagName, message) {\n    var el = document.createElement(tagName);\n    el.innerHTML = message;\n    return el;\n  }\n\n  function showElement(elem) {\n    document.body.appendChild(elem);\n  }\n}`</script></code-example><p>После оптимизации (переводы строк также будут убраны):</p><code-example><script>`function sayHi(b) {\n  var a = document.createElement("div");\n  a.innerHTML = b;\n  document.body.appendChild(a)\n};`</script></code-example></dd></dl><ul><li>Вызовы функций <code>createMessage</code> и <code>showElement</code> заменены на тело функций. В данном случае это возможно, так как функции используются всего по разу.</li><li>Эта оптимизация применяется не всегда. Если бы каждая функция использовалась много раз, то с точки зрения размера выгоднее оставить их «как есть».</li></ul><dl><dt>Инлайнинг переменных</dt><dd><p>Переменные заменяются на значение, если оно заведомо известно.</p><p>До оптимизации:</p><code-example><script>`(function() {\n  var isVisible = true;\n  var hi = "Привет вам из JavaScript";\n\n  window.sayHi = function() {\n    if (isVisible) {\n      alert( hi );\n      alert( hi );\n      alert( hi );\n      alert( hi );\n      alert( hi );\n      alert( hi );\n      alert( hi );\n      alert( hi );\n      alert( hi );\n      alert( hi );\n      alert( hi );\n      alert( hi );\n    }\n  }\n\n})();`</script></code-example><p>После оптимизации:</p><code-example><script>`(function() {\n    window.sayHi = function() {\n      alert( "Привет вам из JavaScript" );\n      alert( "Привет вам из JavaScript" );\n      alert( "Привет вам из JavaScript" );\n      alert( "Привет вам из JavaScript" );\n      alert( "Привет вам из JavaScript" );\n      alert( "Привет вам из JavaScript" );\n      alert( "Привет вам из JavaScript" );\n      alert( "Привет вам из JavaScript" );\n      alert( "Привет вам из JavaScript" );\n      alert( "Привет вам из JavaScript" );\n      alert( "Привет вам из JavaScript" );\n      alert( "Привет вам из JavaScript" );\n    };\n  }\n})();`</script></code-example><ul><li><p>Переменная <code>isVisible</code> заменена на <code>true</code>, после чего <code>if</code> стало возможным убрать.</p></li><li><p>Переменная <code>hi</code> заменена на строку.</p><p>Казалось бы – зачем менять <code>hi</code> на строку? Ведь код стал ощутимо длиннее!</p><p>…Но всё дело в том, что минификатор знает, что дальше код будет сжиматься при помощи gzip. Во всяком случае, все правильно настроенные сервера так делают.</p></li></ul></dd></dl><p><a href="http://www.gzip.org/algorithm.txt">Алгоритм работы gzip</a> заключается в том, что он ищет повторы в данных и выносит их в специальный «словарь», заменяя на более короткий идентификатор. Архив как раз и состоит из словаря и данных, в которых дубликаты заменены на идентификаторы.</p><p>Если вынести строку обратно в переменную, то получится как раз частный случай такого сжатия – взяли <code>"Привет вам из JavaScript"</code> и заменили на идентификатор <code>hi</code>. Но gzip справляется с этим лучше, поэтому эффективнее будет оставить именно строку. Gzip сам найдёт дубликаты и сожмёт их.</p><p>Плюс такого подхода станет очевиден, если сжать gzip оба кода – до и после минификации. Минифицированный gzip-сжатый код в итоге даст меньший размер.</p><dl><dt>Разные мелкие оптимизации</dt><dd>Кроме основных оптимизаций, описанных выше, есть ещё много мелких:</dd></dl><ul><li>Убираются лишние кавычки у ключей</li></ul><code-example><script>`{"prop" : "val" }   =>  {prop:"val"}`</script></code-example><ul><li>Упрощаются простые вызовы <code>Array/Object</code></li></ul><code-example><script>`a = new Array()   =>  a = []\no = new Object()  => o = {}`</script></code-example><code>Эта оптимизация предполагает, что `Array` и `Object` не переопределены программистом. Для включения её в UglifyJS нужен флаг `--unsafe`.</code><ul><li>…И еще некоторые другие мелкие изменения кода…</li></ul><h2><a name="5" href="#5">Подводные камни</a></h2><p>Описанные оптимизации, в целом, безопасны, но есть ряд подводных камней.</p><h3-><a name="8" href="#8">Конструкция with</a></h3-><p>Рассмотрим код:</p><code-example><script>`function changePosition(style) {\n  var position, test;\n\nMARK  with (style) {\nMARK    position = 'absolute';\nMARK  }\n}`</script></code-example><p>Куда будет присвоено значение <code>position = 'absolute'</code>?</p><p>Это неизвестно до момента выполнения: если свойство <code>position</code> есть в <code>style</code> – то туда, а если нет – то в локальную переменную.</p><p>Можно ли в такой ситуации заменить локальную переменную на более короткую? Очевидно, нет:</p><code-example><script>`function changePosition(style) {\n  var a, b;\n\nMARK  with (style) {          // а что, если в style нет такого свойства?\nMARK    position = 'absolute';// куда будет осуществлена запись? в window.position?\nMARK  }\n}`</script></code-example><p>Такая же опасность для сжатия кроется в использованном <code>eval</code>. Ведь <code>eval</code> может обращаться к локальным переменным:</p><code-example><script>`function f(code) {\n  var myVar;\n\n  eval(code); // а что, если будет присвоение eval("myVar = ...") ?\n\n  alert(myVar);`</script></code-example><p>Получается, что при наличии <code>eval</code> мы не имеем права переименовывать локальные переменные. Причём (!), если функция является вложенной, то и во внешних функциях тоже.</p><p>А ведь сжатие переменных – очень важная оптимизация. Как правило, она уменьшает размер сильнее всего.</p><p>Что делать? Разные минификаторы поступают по-разному.</p><ul><li>UglifyJS – не будет переименовывать переменные. Так что наличие <code>with/eval</code> сильно повлияет на степень сжатие кода.</li><li>GCC – всё равно сожмёт локальные переменные. Это, конечно же, может привести к ошибкам, причём в сжатом коде, отлаживать который не очень-то удобно. Поэтому он выдаст предупреждение о наличии опасной конструкции.</li></ul><p>Ни тот ни другой вариант нас, по большому счёту, не устраивают.</p><p><strong>Для того, чтобы код сжимался хорошо и работал правильно, не используем <code>with</code> и <code>eval</code>.</strong></p><p>Либо, если уж очень надо использовать – делаем это с оглядкой на поведение минификатора, чтобы не было проблем.</p><h3-><a name="9" href="#9">Условная компиляция IE10-</a></h3-><p>В IE10- поддерживалось <a href="http://msdn.microsoft.com/en-us/library/121hztk3.aspx">условное выполнение JavaScript</a>.</p><p>Синтаксис: <code>/*@cc_on код */</code>.</p><p>Такой код выполнится в IE10-, например:</p><code-example><script>`var isIE /*@cc_on =true@*/ ;\n\nalert( isIE ); // true в IE10-`</script><code-toolbar></code-toolbar></code-example><p>Можно хитро сделать, чтобы комментарий остался, например так:</p><code-example><script>`var isIE = new Function('', '/*@cc_on return true@*/')();\n\nalert( isIE ); // true в IE.`</script><code-toolbar></code-toolbar></code-example><p>…Однако, с учётом того, что в современных IE11+ эта компиляция не работает в любом случае, лучше избавиться от неё вообще.</p><p>В следующих главах мы посмотрим, какие продвинутые возможности есть в минификаторах, как сделать сжатие более эффективным.</p></important-><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Введение; Улучшаем сжатие кода"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/minification", disqus_identifier = "minification", disqus_title = "\u041a\u0430\u043a \u0440\u0430\u0431\u043e\u0442\u0430\u044e\u0442 \u0441\u0436\u0438\u043c\u0430\u0442\u0435\u043b\u0438 JavaScript;"</script></page-content></main>