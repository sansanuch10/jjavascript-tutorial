<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="152">Веб-компоненты: взгляд в будущее</a></nav-up><h1>Стили и селекторы</h1><p>Стилизация Shadow DOM покрывается более общей спецификацией <a href="http://drafts.csswg.org/css-scoping/">«CSS Scoping»</a>.</p><p>По умолчанию стили внутри Shadow DOM относятся только к его содержимому.</p><p>Например:</p><code-example><script>`<p>Жили мы тихо-мирно, и тут...</p>\n\n<p id="elem">Доброе утро, страна!</p>\n&nbsp\n<template id="tmpl">\nMARK  <style>\nMARK    p {\nMARK      color: red;\nMARK    }\nMARK  </style>\n  <h3><content></content></h3>\n  <p>Привет из подполья!</p>\n</template>\n&nbsp\n<script>\n  var root = elem.createShadowRoot();\n  root.appendChild(tmpl.content.cloneNode(true));\n<\/script>`</script><code-toolbar iframe="140"><a title="показать" data-code_run="180"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>При запуске окрашенным в красный цвет окажется только <code>&lt;p&gt;</code> внутри Shadow DOM. Обратим внимание, окрасился именно тот элемент, который находится непосредственно в Shadow DOM. А элементы, которые отображены в Shadow DOM при помощи <code>&lt;content&gt;</code>, этот стиль не получили – у них есть свои, заданные на внешней странице.</p><h2><a hover-inner="Раздел устарел, нужно менять!" name="0" href="#0">Внешний стиль для Shadow DOM</a></h2><p>Граница между Shadow DOM и основным DOM, хоть и существует, но при помощи специальных селекторов её можно переходить.</p><p>Если нужно с основной страницы стилизовать или выбрать элементы внутри Shadow DOM, то можно использовать селекторы:</p><ul><li><p><strong><code>::shadow</code> – выбирает корень Shadow DOM.</strong></p><p>Выбранный элемент сам по себе не создаёт CSS box, но служит отправной точкой для дальнейшей выборки уже внутри дерева Shadow DOM.</p><p>Например, <code>#elem::shadow &gt; div</code> найдёт внутри Shadow DOM <code>#elem</code> элементы <code>div</code> первого уровня.</p></li><li><p><strong><code>&gt;&gt;&gt;</code> – особого вида CSS-селектор для всех элементов Shadow DOM, который полностью игнорирует границы между DOM’ами, включая вложенные подэлементы, у которых тоже может быть свой Shadow DOM.</strong></p><p>Например, <code>#elem &gt;&gt;&gt; span</code> найдёт все <code>span</code> внутри Shadow DOM <code>#elem</code>, но кроме того, если в <code>#elem</code> есть подэлементы, у которых свой Shadow DOM, то оно продолжит поиск в них.</p><p>Вот пример, когда внутри одного Shadow DOM есть <code>&lt;input type="date"&gt;</code>, у которого тоже есть Shadow DOM:</p><code-example title="стили не работают,::shadow устарело"><script>`<style>\n  GOLD_#elem::shadow span_GOLD {\n /* для span только внутри Shadow DOM #elem */\n\n &nbsp  border: 1px dashed blue;\n  }\n\n  GOLD_#elem >>> *_GOLD {\n /* для всех элементов внутри Shadow DOM #elem и далее внутри input[type=date] */\n\n &nbsp  color: red;\n  }\n</style>\n&nbsp\n<p id="elem"></p>\n&nbsp\n<script>\n  var root = elem.createShadowRoot();\n  root.innerHTML = "<span>Текущее время:</span><input type='date'>";\n<\/script>`</script><code-toolbar iframe="60"><a title="показать" data-code_run="300"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example></li><li><p>Кроме того, на Shadow DOM действует обычное CSS-наследование, если свойство поддерживает его по умолчанию.</p><p>В этом примере CSS-стили для <code>body</code> наследуются на внутренние элементы, включая Shadow DOM:</p><code-example><script>`<style>\n  GOLD_body_GOLD {\n &nbsp  margin: 10px;\n &nbsp  color: red;\n  &nbsp font-style: italic;\n  }\n</style>\n<p id="elem"></p>\n<script>\n  elem.createShadowRoot().innerHTML = "<span>Привет, мир!</span>";\n<\/script>`</script><code-toolbar iframe="60"><a title="показать" data-code_run="145"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>Внутренний элемент станет красным курсивом.</p></li></ul><important-warn><h3>Нельзя получить содержимое встроенных элементов</h3><p>Описанные CSS-селекторы можно использовать не только в CSS, но и в <code>querySelector</code>.</p><p>Исключением являются встроенные элементы типа <code>&lt;input type="date"&gt;</code>, для которых CSS-селекторы работают, но получить их содержимое нельзя.</p><p>Например:</p><code-example><script>`<p id="elem"></p>\n\n<script>\n  var root = elem.createShadowRoot();\n  root.innerHTML = "<span>Текущее время:</span><input type='date'>";\n\n  // выберет только span из #elem\n  // вообще-то, должен выбрать span и из вложенных Shadow DOM,\n  // но для встроенных элементов - не умеет\n  alert( document.querySelectorAll('#elem::shadow span').length ); // 1\n<\/script>`</script><code-toolbar iframe="60"><a title="показать" data-code_run="150"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example></important-warn><h2><a name="1" href="#1">Стиль в зависимости от хозяина</a></h2><p>Следующие селекторы позволяют изнутри Shadow DOM выбрать внешний элемент («элемент-хозяин»):</p><ul><li><p><code>:host</code> выбирает элемент-хозяин, в котором, живёт Shadow DOM.</p><p>Хозяин :host выбирается именно в контексте Shadow DOM.</p><p>То есть, это доступ не к внешнему элементу, а, скорее, к корню текущего Shadow DOM.</p><p>После <code>:host</code> мы можем указать селекторы и стили, которые нужно применить, если хозяин удовлетворяет тому или иному условию, например:</p><code-example><script>`<style>\n  GOLD_:host > p_GOLD {\n &nbsp  color: green;\n  }\n</style>`</script></code-example><p>Этот селектор сработает для <code>&lt;p&gt;</code> первого уровня внутри Shadow DOM.</p></li><li><p><code>:host(селектор хозяина)</code> выбирает элемент-хозяин, если он подходит под селектор.</p><p>Этот селектор используется для темизации хозяина «изнутри», в зависимости от его классов и атрибутов. Он отлично добавляет просто <code>:host</code>, например:</p><code-example><script>`GOLD_:host p_GOLD {\n  color: green;\n}\n\nGOLD_:host(.important) p_GOLD {\n  color: red;\n}`</script></code-example><p>Здесь параграфы будут иметь <code>color:green</code>, но если у хозяина класс <code>.important</code>, то <code>color:red</code>.</p></li><li><p><code>:host-context(селектор хозяина)</code> выбирает элемент-хозяин, если какой-либо из его родителей удовлетворяет селектору, например:</p><code-example><script>`GOLD_:host-context(h1) p_GOLD {\n  /* селектор сработает для p, если хозяин находится внутри h1 */\n}`</script></code-example><p>Это используется для расширенной темизации, теперь уже не только в зависимости от его атрибутов, но и от того, внутри каких элементов он находится.</p></li></ul><p>Пример использования селектора <code>:host()</code> для разной расцветки Shadow DOM-сообщения, в зависимости от того, в каком оно <code>&lt;p&gt;</code>:</p><code-example><script>`MARK<p class="message info">Доброе утро, страна!</p>\n\nMARK<p class="message warning">Внимание-внимание! Говорит информбюро!</p>\n&nbsp\n<template id="tmpl">\n  <style>\n  GOLD_.content_GOLD {\n    BLUE_min-height_BLUE: 20px;\n    padding: 19px;\n    margin: 20px 0;\n    background: #f5f5f5;\n    border: 1px solid #e3e3e3;\n    border-radius: 4px;\n    box-shadow: inset 0 1px 1px rgba(0, 0, 0, .05);\n  }\n\n  GOLD_:host(.info) .content_GOLD {\nMARK    color: green;\nMARK  }\n\n  GOLD_:host(.warning) .content_GOLD {\nMARK    color: red;\nMARK  }\n\n  </style>\n  <div class="content"><content></content></div>\n</template>\n&nbsp\n<script>\n  var elems = document.querySelectorAll('p.message');\n\n  elems[0].createShadowRoot().appendChild( tmpl.content.cloneNode(true) );\n  elems[1].createShadowRoot().appendChild( tmpl.content.cloneNode(true) );\n<\/script>`</script><code-toolbar iframe="180"><a title="показать" data-code_run="250"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><h2><a name="2" href="#2">Стиль для content</a></h2><p>Тег <code>&lt;content&gt;</code> не меняет DOM, а указывает, что где показывать. Поэтому если элемент изначально находится в элементе-хозяине – внешний документ сохраняет к нему доступ.</p><p>К нему будут применены стили и сработают селекторы, всё как обычно.</p><p>Например, здесь применится стиль для <code>&lt;span&gt;</code>:</p><code-example><script>`<style>\n  GOLD_span_GOLD HIGH{ BLUE_text-decoration_BLUE: underline; }LIGHT\n</style>\n\n<p id="elem"><span>Доброе утро, страна!</span></p>\n\n<template id="tmpl">\n  <h3><content></content></h3>\n  <p>Привет из подполья!</p>\n</template>\n\n<script>\n  elem.createShadowRoot().appendChild( tmpl.content.cloneNode(true) );\n<\/script>`</script><code-toolbar iframe="100"><a title="показать" data-code_run="150"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>В примере выше заголовок «Доброе утро, страна!», который пришёл как <code>&lt;span&gt;</code> из внешнего документа, будет подчёркнут,</p><p>Итак, стили основного DOM-дерева применяются, всё в порядке.</p><p>Но что, если Shadow DOM тоже «имеет виды» на <code>&lt;content&gt;</code> и хочет стилизовать вставленное? Это тоже возможно.</p><p><strong>Для обращения к «содержимому» <code>&lt;content&gt;</code> из стилей внутри Shadow DOM используется псевдоэлемент <code>::content</code>.</strong></p><p>Например, изнутри Shadow DOM селектор <code>content[select="h1"]::content span</code> найдёт элемент <code>&lt;content select="h1"&gt;</code> и <em>в его содержимом</em> отыщет <code>&lt;span&gt;</code>.</p><p>В примере ниже селектор <code>::content span</code> стилизует все <code>&lt;span&gt;</code> внутри всех <code>&lt;content&gt;</code>:</p><code-example><script>`<style>\n  GOLD_span_GOLD HIGH{ BLUE_text-decoration_BLUE: underline; }LIGHT\n</style>\n&nbsp\n<p id="elem"><span>Доброе утро, страна!</span></p>\n&nbsp\n<template id="tmpl">\n  <style>\n    GOLD_::content span_GOLD { color: green; }\n  </style>\n  <h3><content></content></h3>\n  <span>Привет из подполья!</span>\n</template>\n&nbsp\n<script>\n  elem.createShadowRoot().appendChild( tmpl.content.cloneNode(true) );\n<\/script>`</script><code-toolbar iframe="100"><a title="показать" data-code_run="200"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>Текст внутри <code>&lt;h3&gt;</code> – зелёный и подчёркнутый одновременно, но стилизуется именно тот <code>&lt;span&gt;</code>, который показан в <code>&lt;content&gt;</code>, а тот, который просто в Shadow DOM – нет.</p><p>Приоритет селекторов рассчитывается по <a href="http://www.w3.org/TR/css3-selectors/#specificity">обычным правилам специфичности</a>, если же приоритеты стилей на странице и в Shadow DOM равны, то, как описано в секции <a href="http://dev.w3.org/csswg/css-scoping/#cascading">Cascading</a>, побеждает страница, а для <code>!important</code>-стиля побеждает Shadow DOM.</p><h2><a name="3" href="#3">Итого</a></h2><p>По умолчанию стили и селекторы из DOM-дерева действуют только на те элементы, в которых сами находятся.</p><p>Границу можно преодолевать, причём проще, естественно, от родителя к Shadow DOM, чем наоборот:</p><ul><li>Снаружи можно выбирать и стилизовать элементы внутри Shadow DOM – при помощи селекторов <code>::shadow</code> и <code>&gt;&gt;&gt;</code>.</li><li>Изнутри Shadow DOM можно стилизовать не только то, что изначально в Shadow DOM, но и узлы, показываемые в <code>&lt;content&gt;</code>.</li><li>Также можно ставить стиль в зависимость от хозяина при помощи селекторов <code>::host</code>, <code>::host-context</code>, но выбирать и стилизовать произвольные теги внутри хозяина нельзя.</li></ul><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Шаблоны &amp;lttemplate>; Импорты"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/css-scoping",disqus_identifier="css-scoping",disqus_title="\u0421\u0442\u0438\u043b\u0438 \u0438 \u0441\u0435\u043b\u0435\u043a\u0442\u043e\u0440\u044b";</script></page-content></main>