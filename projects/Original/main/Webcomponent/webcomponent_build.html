<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="152">Веб-компоненты: взгляд в будущее</a></nav-up><h1>Веб-компонент в сборе</h1><p>В этой главе мы посмотрим на итоговый пример веб-компонента, включающий в себя описанные ранее технологии: Custom Elements, Shadow DOM, CSS Scoping и, конечно же, Imports.</p><h2><a name="0" href="#0">Компонент ui-message</a></h2><p>Компонент <code>ui-message</code> будет описан в отдельном файле <code>ui-message.html</code>.</p><p>Его использование будет выглядеть следующим образом:</p><code-example><script>`<link rel="import" id="link" href="ui-message.html">\n\n<style>\n  GOLD_ui-message_GOLD {\n    width: 80%;\n    margin: auto;\n  }\n</style>\n\nMARK<RED_ui-message_RED class="info">Доброе утро, страна!</RED_ui-message_RED>\n\nMARK<RED_ui-message_RED class="warning">Внимание-внимание! Говорит информбюро!</RED_ui-message_RED>`</script></code-example><p>Этот код ничем не отличается от использования обычного элемента, поэтому перейдём дальше, к содержимому <code>ui-message.html</code></p><h2><a name="1" href="#1">Шаблон для ui-message</a></h2><p>Файл <code>ui-message.html</code> можно начать с шаблона:</p><code-example><script>`<template id="tmpl">\n  <style>\n    GOLD_.content_GOLD {\n      BLUE_min-height_BLUE: 20px;\n      padding: 19px;\n      margin: 0 0 20px 0;\n      background: #f5f5f5;\n      border: 1px solid #e3e3e3;\n      border-radius: 4px;\n      box-shadow: inset 0 1px 1px rgba(0, 0, 0, .05);\n    }\n\n    GOLD_:host_GOLD {\n      display: block;\n    }\n\n    GOLD_:host(.info) .content_GOLD {\n      color: green;\n    }\n\n    GOLD_:host(.warning) .content_GOLD {\n      color: red;\n    }\n  </style>\n  <div class="content">\n    <content></content>\n  </div>\n</template>`</script></code-example><p>Этот шаблон рисует <code>&lt;div class="content"&gt;</code> и заполняет его содержимым элемента-хозяина.</p><p>Важные детали:</p><ul><li><p>Самое важное правило здесь <code>:host { display:block }</code>.</p><p>Оно обязательно! . Это правило задаёт, что корень DOM-дерева будет иметь <code>display:block</code>. По умолчанию <code>:host</code> не создаёт CSS-блок, а это значит, что ни ширину ни отступы указать не получится.</p></li><li><p>Последующие правила <code>:host(.info) .content</code> и <code>:host(.warning) .content</code> стилизуют содержимое в зависимости от того, какой на хозяине класс.</p></li></ul><h2><a name="2" href="#2">Скрипт для ui-message</a></h2><p>В файле <code>ui-message.html</code> мы создадим новый элемент <code>&lt;ui-message&gt;</code>:</p><code-example><script>`// (1) получить шаблон\nvar localDocument = document.currentScript.ownerDocument;\nvar tmpl = localDocument.getElementById('tmpl');\n\n// (2) создать элемент\nvar MessageProto = Object.create(HTMLElement.prototype);\n\nMessageProto.createdCallback = function() {\n  var root = this.createShadowRoot();\n  root.appendChild(tmpl.content.cloneNode(true));\n};\n\n// (3) зарегистрировать в DOM\ndocument.registerElement('ui-message', {\n  prototype: MessageProto\n});`</script></code-example><p>Все компоненты этого кода мы подробно разбирали ранее:</p><ol><li>Получаем шаблон из текущего документа, то есть из самого импорта.</li><li>Описываем элемент. Он довольно прост – при создании записывает в свой <code>Shadow DOM</code> шаблон. При этом содержимое исходного элемента будет показано в <code>&lt;content&gt;</code>, но делать правила на сам <code>content</code> бессмысленно – они не сработают. Нужно либо перейти внутрь <code>&lt;content&gt;</code> при помощи <code>::content</code>-селектора, либо указать для внешнего элемента <code>.content</code>, что в данном случае и сделано.</li><li>С момента регистрации все уже существующие элементы <code>&lt;ui-message&gt;</code> будут превращены в описанные здесь. И будущие, конечно, тоже.</li></ol><p>Компонент в действии:</p><code-tabs data-code_switch=""><tools-><button-0 class="current">index.html</button-0><button-1>ui-message.html</button-1></tools-><code-example style="display: block;"><script>`<!DOCTYPE HTML>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="import" id="link" href="ui-message.html">\n  <style>\n    GOLD_ui-message_GOLD {\n      width: 80%;\n      margin: auto;\n    }\n  </style>\n</head>\n\n<body>\n\n  <RED_ui-message_RED class="info">Доброе утро, страна!</RED_ui-message_RED>\n\n  <RED_ui-message_RED class="warning">Внимание-внимание! Говорит информбюро!</RED_ui-message_RED>\n\n</body>\n\n</html>`</script><code-toolbar iframe="190"><a title="показать" data-code_run="210"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><code-example><script>`<!DOCTYPE HTML>\n<html>\n\n<body>\n\n  <template id="tmpl">\n    <style>\n      GOLD_body_GOLD { margin:20px }\n\n      GOLD_.content_GOLD {\n        BLUE_min-height_BLUE: 20px;\n        padding: 19px;\n        margin: 0 0 20px 0;\n        background: #f5f5f5;\n        border: 1px solid #e3e3e3;\n        border-radius: 4px;\n        box-shadow: inset 0 1px 1px rgba(0, 0, 0, .05);\n      }\n\n      GOLD_:host_GOLD {\n        display: block;\n      }\n\n      GOLD_:host(.info) .content_GOLD {\n        color: green;\n      }\n\n      GOLD_:host(.warning) .content_GOLD {\n        color: red;\n      }\n    </style>\n    <div class="content">\n      <content></content>\n    </div>\n  </template>\n\n  <script>\n    !function() {\n      var localDocument = document.currentScript.ownerDocument;\n      var tmpl = localDocument.getElementById('tmpl');\n\n      var MessageProto = Object.create(HTMLElement.prototype);\n\n      MessageProto.createdCallback = function() {\n        var root = this.createShadowRoot();\n        root.appendChild(tmpl.content.cloneNode(true));\n      };\n\n      document.registerElement('ui-message', {\n        prototype: MessageProto\n      });\n    }();\n  <\/script>\n\n</body>\n\n</html>`</script></code-example></code-tabs><h2><a name="3" href="#3">Компонент ui-slider с jQuery</a></h2><p>Компонент может использовать и внешние библиотеки.</p><p>Для примера создадим слайдер с использованием библиотеки <a href="http://jqueryui.com">jQuery UI</a>.</p><p>Компонент <code>ui-slider</code> будет показывать слайдер с минимальным и максимальным значением из атрибутов <code>min/max</code> и генерировать событие <code>slide</code> при его перемещении.</p><p>Использование:</p><code-example><script>`<link rel="import" id="link" href="ui-slider.html">\n\n<ui-slider min="0" max="1000" id="elem"></ui-slider>\n\n<script>\n  elem.addEventListener("slide", function(e) {\n    value.innerHTML = e.detail.value;\n  });\n<\/script>\n\n<div id="value">0</div>`</script></code-example><h2><a name="4" href="#4">Файл компонента ui-slider</a></h2><p>Файл <code>ui-slider.html</code>, задающий компонент, мы разберём по частям.</p><h3><a name="7" href="#7">Заголовок</a></h3><p>В начале подключим jQuery и jQuery UI.</p><p>Мы импортируем в слайдер <code>jquery.html</code>, который содержит теги <code>&lt;script&gt;</code> вместо того, чтобы явным образом прописывать загрузку скриптов:</p><code-example><script>`<head>\n  <link rel="import" href="jquery.html">\n</head>`</script></code-example><p>Это сделано для того, чтобы другие компоненты, которым тоже могут понадобится эти библиотеки, также могли импортировать <code>jquery.html</code>. При повторном импорте ничего не произойдёт, скрипты не будут подгружены и исполнены два раза.</p><p>То есть, это средство оптимизации.</p><p>Содержимое <code>jquery.html</code>:</p><code-example><script>`<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"><\/script>\n<script src="https://code.jquery.com/ui/1.11.4/jquery-ui.js"><\/script>`</script></code-example><h3><a name="8" href="#8">Шаблон</a></h3><p>Шаблон будет помещён в Shadow DOM. В нём должны быть стили и элементы, необходимые слайдеру.</p><p>Конкретно для слайдера из разметки достаточно одного элемента <code>&lt;div id="slider"&gt;&lt;/div&gt;</code>, который затем будет обработан jQuery UI.</p><p>Кроме того, в шаблоне должны быть стили:</p><code-example><script>`<template id="tmpl">\n  <style>\n    BLUE_@import_BLUE BROWN_url(https://code.jquery.com/ui/1.11.4/themes/ui-lightness/jquery-ui.css)_BROWN;\n    GOLD_:host_GOLD {\n      display: block;\n    }\n  </style>\n  <div id="slider"></div>\n</template>`</script></code-example><h3><a name="9" href="#9">Скрипт</a></h3><p>Скрипт для нового элемента похож на тот, что делали раньше, но теперь он использует jQuery UI для создания слайдера внутри своего Shadow DOM.</p><p>Для его понимания желательно знать jQuery, хотя в коде ниже я намеренно свёл использование этой библиотеки к минимуму.</p><code-example><script>`var localDocument = document.currentScript.ownerDocument;\nvar tmpl = localDocument.getElementById('tmpl');\n\nvar SliderProto = Object.create(HTMLElement.prototype);\n\nSliderProto.createdCallback = function() {\n  // (1) инициализировать Shadow DOM, получить из него #slider\n  var root = this.createShadowRoot();\n  root.appendChild(tmpl.content.cloneNode(true));\n\n  this.$slider = $(root.getElementById('slider'));\n\n  var self = this;\n\n  // (2) инициализировать слайдер, пробросить параметры\n  this.$slider.slider({\n    min: this.getAttribute('min') || 0,\n    max: this.getAttribute('max') || 100,\n    value: this.getAttribute('value') || 0,\n    slide: function() {\n      // (3) пробросить событие\n      var event = new CustomEvent("slide", {\n        detail: {\n          value: self.$slider.slider("option", "value")\n        },\n        bubbles: true\n      });\n      self.dispatchEvent(event);\n    }\n  });\n};\n\ndocument.registerElement('ui-slider', {\n  prototype: SliderProto\n});`</script></code-example><p>Функция <code>createdCallback</code> по шагам:</p><ol><li>Создаём Shadow DOM, элемент <code>#slider</code> получаем из него, он не в основном документе.</li><li>Используя jQuery UI, слайдер создаётся вызовом <a href="http://jqueryui.com/slider/">jQuery UI методом slider</a>, который имеет вид <code>$elem.slider({...параметры...});</code>. Параметры получаем из атрибутов <code>&lt;ui-slider&gt;</code> (он же <code>this</code>) и отдаём библиотеке. Она делает всю работу.</li><li>Параметр <code>slide</code> задаёт функцию-коллбэк, которая вызывается при передвижении слайдера и будет генерировать DOM-событие на элементе, на которое можно будет поставить обработчик при помощи <code>addEventListener</code>. В его деталях мы указываем новое значение слайдера.</li></ol><p>Полный код с примером:</p><code-tabs data-code_switch=""><tools-><button-0 class="current">index.html</button-0><button-1>jquery.html</button-1><button-2>ui-slider.html</button-2></tools-><code-example style="display: block;"><script>`<!DOCTYPE HTML>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="import" id="link" href="ui-slider.html">\n  <style>\n    GOLD_ui-slider_GOLD {\n      width: 300px;\n      margin: 10px;\n    }\n  </style>\n</head>\n\n<body>\n\n  <RED_ui-slider_RED min="0" max="1000" id="elem"></RED_ui-slider_RED>\n\n  <script>\n    elem.addEventListener("slide", function(e) {\n      value.innerHTML = e.detail.value; // = this.value\n    });\n  <\/script>\n\n  <div id="value">0</div>\n\n</body>\n\n</html>`</script><code-toolbar iframe="100"><a title="показать" data-code_run="210"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><code-example><script>`<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"><\/script>\n<script src="https://code.jquery.com/ui/1.11.4/jquery-ui.js"><\/script>`</script></code-example><code-example><script>`<!DOCTYPE HTML>\n<html>\n\n<head>\n  <link rel="import" href="jquery.html">\n</head>\n\n<body>\n\n  <template id="tmpl">\n    <style>\n      BLUE_@_BLUEimport BROWN_url(https://code.jquery.com/ui/1.11.4/themes/ui-lightness/jquery-ui.css)_BROWN;\n      GOLD_:host_GOLD {\n        display: block;\n      }\n    </style>\n    <div id="slider"></div>\n  </template>\n\n  <script>\n    !function() {\n      var localDocument = document.currentScript.ownerDocument;\n      var tmpl = localDocument.getElementById('tmpl');\n\n      var SliderProto = Object.create(HTMLElement.prototype);\n\n      SliderProto.createdCallback = function() {\n        var root = this.createShadowRoot();\n        root.appendChild(tmpl.content.cloneNode(true));\n\n        this.$slider = $(root.getElementById('slider'));\n\n        var self = this;\n\n        this.$slider.slider({\n          min: +this.getAttribute('min') || 0,\n          max: +this.getAttribute('max') || 100,\n          value: this.getAttribute('value') || 0,\n          slide: function() {\n            var event = new CustomEvent("slide", {\n              detail: {\n                value: self.$slider.slider("option", "value")\n              },\n              bubbles: true\n            });\n            self.dispatchEvent(event);\n          }\n        });\n      };\n\n\n      document.registerElement('ui-slider', {\n        prototype: SliderProto\n      });\n    }();\n  <\/script>\n\n</body>\n\n</html>`</script></code-example></code-tabs><p>Его можно далее улучшать, например добавить геттер и сеттер для значения <code>value</code>:</p><code-example><script>`Object.defineProperty(SliderProto, 'value', {\n  get: function() {\n    return this.$slider.slider("option", "value");\n  },\n  set: function(value) {\n    this.$slider.slider('option', 'value', value);\n  }\n});`</script></code-example><p>Если добавить этот код, то к значению <code>&lt;ui-slider&gt;</code> можно будет обращаться как <code>elem.value</code>, аналогично всяким встроенным <code>&lt;input&gt;</code>.</p><h2><a name="5" href="#5">Проблема с jQuery</a></h2><p>Попробуйте пример выше. Он не совсем работает. Слайдер прокручивается первый раз, но второй раз он как-то странно «прыгает».</p><p>Чтобы понять, почему это происходит, я заглянул в исходники jQuery UI и, после отладки происходящего, натолкнулся на проблемный код.</p><p>Он был в методе <a href="http://api.jquery.com/offset/">offset</a>, который предназначен для того, чтобы определять координаты элемента. Этот метод не срабатывал, поскольку в нём есть проверка, которая выглядит примерно так:</p><code-example><script>`var box = {\n  top: 0,\n  left: 0\n};\n...\n// Make sure it's not a disconnected DOM node\nif(!jQuery.contains(elem.ownerDocument, elem)) {\n  return box;\n}`</script></code-example><p>То есть, jQuery проверяет, находится ли элемент <code>elem</code> внутри своего документа <code>elem.ownerDocument</code>. Если нет – то считается, что элемент вне DOM, и его размеры равны нулю.</p><p>Если копнуть чуть глубже, то <code>jQuery.contains</code> в современных браузерах сводится к обычному вызову <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/contains">contains</a>.</p><p>Парадокс с Shadow DOM заключается в том, что вызов <code>elem.ownerDocument.contains(elem)</code> вернёт <code>false</code>!</p><p>Получилось, что элемент не в документе и одновременно он имеет размеры. Такого разработчики jQuery не предусмотрели.</p><p>Можно, конечно, побежать исправлять jQuery, но давайте подумаем, может быть так оно и должно быть?</p><p>С точки зрения здравого смысла, Shadow DOM является частью текущего документа. Это соответствует и духу <a href="http://w3c.github.io/webcomponents/spec/shadow/">текущей спецификации</a>, где shadow tree рассматривается в контексте document tree.</p><p>Поэтому на самом деле <code>document.contains(elem)</code> следовало бы возвращать <code>true</code>.</p><p>Почему же <code>false</code>? Причина проста – описанный в <a href="http://www.w3.org/TR/dom/#dom-node-contains">другом стандарте</a> механизм работы <code>contains</code> по сути состоит в проходе вверх от <code>elem</code> по цепочке <code>parentNode</code>, пока либо встретим искомый элемент, тогда ответ <code>true</code>, а иначе <code>false</code>. В случае с Shadow DOM этот путь закончится на корне Shadow DOM-дерева, оно ведь не является потомком хозяина.</p><p><strong>Метод <code>contains</code> описан стандартом без учёта Shadow DOM, поэтому возвратил неверный результат <code>false</code>.</strong></p><p>Это один из тех небольших, но важных нюансов, которые показывают, что стандарты всё ещё в разработке.</p><h2><a name="6" href="#6">Итого</a></h2><ul><li>С использованием современных технологий можно делать компоненты. Но это, всё же, дело будущего. Все стандарты находятся в процессе доработки, готовятся новые.</li><li>Можно использовать произвольную библиотеку, такую как jQuery, и работать с Shadow DOM с её использованием. Но возможны проблемки. Выше была продемонстрирована одна из них, могут быть и другие.</li></ul><p>Пока веб-компоненты ещё не являются законченными стандартами, можно попробовать <a href="http://www.polymer-project.org">Polymer</a> – это самый известный из полифиллов на тему веб-компонент.</p><p>Он старается их эмулировать по возможности кросс-браузерно, но пока что это довольно-таки сложно, в частности, необходима дополнительная разметка.</p><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Импорты; AJAX и COMET"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/webcomponent-build",disqus_identifier="webcomponent-build",disqus_title="\u0412\u0435\u0431-\u043a\u043e\u043c\u043f\u043e\u043d\u0435\u043d\u0442 \u0432 \u0441\u0431\u043e\u0440\u0435";</script></page-content> </main>