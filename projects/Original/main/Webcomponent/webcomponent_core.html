<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="152">Веб-компоненты: взгляд в будущее</a></nav-up><h1>Пользовательские элементы: Custom Elements</h1><p>Платформа «веб-компоненты» включает в себя несколько стандартов <a href="http://www.w3.org/standards/techs/components#w3c_all">Web Components</a>, которые находятся в разработке.</p><p>Начнём мы со стандарта <a href="http://www.w3.org/TR/custom-elements/">Custom Elements</a>, который позволяет создавать свои типы элементов.</p><h2><a name="0" href="#0">Зачем Custom Elements?</a></h2><p>Критично настроенный читатель скажет: «Зачем ещё стандарт для своих типов элементов? Я могу создать любой элемент и прямо сейчас! В любом из современных браузеров можно писать любой HTML, используя свои теги: <code>&lt;mytag&gt;</code>. Или создавать элементы из JavaScript при помощи <code>document.createElement('mytag')</code>.»</p><p>Однако, по умолчанию элемент с нестандартным названием (например <code>&lt;mytag&gt;</code>) воспринимается браузером, как нечто неопределённо-непонятное. Ему соответствует класс <a href="http://www.w3.org/TR/html5/dom.html#htmlunknownelement">HTMLUnknownElement</a>, и у него нет каких-либо особых методов.</p><p><strong>Стандарт Custom Elements позволяет описывать для новых элементов свои свойства, методы, объявлять свой DOM, подобие конструктора и многое другое.</strong></p><p>Давайте посмотрим это на примерах.</p><important-warn><h3>Для примеров рекомендуется Chrome</h3><p>Так как спецификация не окончательна, то для запуска примеров рекомендуется использовать Google Chrome, лучше – последнюю сборку <a href="https://www.google.ru/chrome/browser/canary.html">Chrome Canary</a>, в которой, как правило, отражены последние изменения.</p></important-warn><h2><a name="1" href="#1">Новый элемент</a></h2><p>Для описания нового элемента используется вызов <code>document.registerElement(имя, { prototype: прототип })</code>.</p><p>Здесь:</p><ul><li><code>имя</code> – имя нового тега, например <code>"mega-select"</code>. Оно обязано содержать дефис <code>"-"</code>. Спецификация требует дефис, чтобы избежать в будущем конфликтов со стандартными элементами HTML. Нельзя создать элемент <code>timer</code> или <code>myTimer</code> – будет ошибка.</li><li><code>прототип</code> – объект-прототип для нового элемента, он должен наследовать от <code>HTMLElement</code>, чтобы у элемента были стандартные свойства и методы.</li></ul><p>Вот, к примеру, новый элемент <code>&lt;my-timer&gt;</code>:</p><code-example><script>`<script>\nMARK  // прототип с методами для нового элемента\n  var MyTimerProto = Object.create(HTMLElement.prototype);\n  MyTimerProto.tick = function() { // HIGHсвой метод tickLIGHT\n    this.innerHTML++;\n  };\n\nMARK  // регистрируем новый элемент в браузере\n  document.registerElement("my-timer", {\n    prototype: MyTimerProto\n  });\n<\/script>\n\nMARK<!-- теперь используем новый элемент -->\n<RED_my-timer_RED id="timer">0</RED_my-timer_RED>\n\n<script>\nMARK  // вызовем метод tick() на элементе\n  setInterval(function() {\n    timer.tick();\n  }, 1000);\n<\/script>`</script><code-toolbar iframe="40"><a title="показать" data-code_run="340"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>Использовать новый элемент в HTML можно и до его объявления через <code>registerElement</code>.</p><p>Для этого в браузере предусмотрен специальный режим «обновления» существующих элементов.</p><p>Если браузер видит элемент с неизвестным именем, в котором есть дефис <code>-</code> (такие элементы называются «unresolved»), то:</p><ul><li>Он ставит такому элементу специальный CSS-псевдокласс <code>:unresolved</code>, для того, чтобы через CSS можно было показать, что он ещё «не подгрузился».</li><li>При вызове <code>registerElement</code> такие элементы автоматически обновятся до нужного класса.</li></ul><p>В примере ниже регистрация элемента происходит через 2 секунды после его появления в разметке:</p><code-example><script>`<style>\nMARK  /* стиль для :unresolved элемента (до регистрации) */\n  GOLD_hello-world:unresolved_GOLD {\n    color: white;\n  }\n\n  GOLD_hello-world_GOLD {\n    transition: color 3s;\n  }\n<\/style>\n&nbsp\n<RED_hello-world_RED id="hello">Hello, world!</RED_hello-world_RED>\n&nbsp\n<script>\nMARK  // регистрация произойдёт через 2 сек\n  setTimeout(function() {\n    document.registerElement("hello-world", {\n      prototype: {\n        __proto__: HTMLElement.prototype,\n        sayHi: function() { alert('Привет!'); }\n      }\n    });\n\nMARK    // у нового типа элементов есть метод sayHi\n    hello.sayHi();\n  }, 2000);\n<\/script>`</script><code-toolbar iframe="40"><a title="показать" data-code_run="350"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>Можно создавать такие элементы и в JavaScript – обычным вызовом <code>createElement</code>:</p><code-example><script>`var timer = document.createElement('my-timer');`</script></code-example><h2><a name="2" href="#2">Расширение встроенных элементов</a></h2><p>Выше мы видели пример создания элемента на основе базового <code>HTMLElement</code>. Но можно расширить и другие, более конкретные HTML-элементы.</p><p>Для расширения встроенных элементов у <code>registerElement</code> предусмотрен параметр <code>extends</code>, в котором можно задать, какой тег мы расширяем.</p><p>Например, кнопку:</p><code-example><script>`<script>\n  var MyTimerProto = Object.create(HIGHHTMLButtonElement.prototypeLIGHT);\n  MyTimerProto.tick = function() {\n    this.innerHTML++;\n  };\n\n  document.registerElement("my-timer", {\n    prototype: MyTimerProto,\nMARK    extends: 'button'\n  });\n<\/script>\n\n<button HIGHis="my-timer"LIGHT id="timer">0</button>\n\n<script>\n  setInterval(function() {\n    timer.tick();\n  }, 1000);\n\n  timer.onclick = function() {\n    alert("Текущее значение: " + this.innerHTML);\n  };\n<\/script>`</script><code-toolbar iframe="40"><a title="показать" data-code_run="360"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>Важные детали:</p><dl><dt>Прототип теперь наследует не от <code>HTMLElement</code>, а от <code>HTMLButtonElement</code></dt><dd>Чтобы расширить элемент, нужно унаследовать прототип от его класса.</dd><dt>В HTML указывается при помощи атрибута <code>is="..."</code></dt><dd>Это принципиальное отличие разметки от обычного объявления без <code>extends</code>. Теперь <code>&lt;my-timer&gt;</code> работать не будет, нужно использовать исходный тег и <code>is</code>.</dd><dt>Работают методы, стили и события кнопки.</dt><dd>При клике на кнопку её не отличишь от встроенной. И всё же, это новый элемент, со своими методами, в данном случае <code>tick</code>.</dd></dl><p>При создании нового элемента в JS, если используется <code>extends</code>, необходимо указать и исходный тег в том числе:</p><code-example><script>`var timer = document.createElement("button", "my-timer");`</script></code-example><h2><a name="3" href="#3">Жизненный цикл</a></h2><p>В прототипе своего элемента мы можем задать специальные методы, которые будут вызываться при создании, добавлении и удалении элемента из DOM:</p><table><tbody><tr><td><code>createdCallback</code></td><td>Элемент создан</td></tr><tr><td><code>attachedCallback</code></td><td>Элемент добавлен в документ</td></tr><tr><td><code>detachedCallback</code></td><td>Элемент удалён из документа</td></tr><tr><td><code>attributeChangedCallback(name, prevValue, newValue)</code></td><td>Атрибут добавлен, изменён или удалён</td></tr></tbody></table><p>Как вы, наверняка, заметили, <code>createdCallback</code> является подобием конструктора. Он вызывается только при создании элемента, поэтому всю дополнительную инициализацию имеет смысл описывать в нём.</p><p>Давайте используем <code>createdCallback</code>, чтобы инициализировать таймер, а <code>attachedCallback</code> – чтобы автоматически запускать таймер при вставке в документ:</p><code-example><script>`<script>\n  var MyTimerProto = Object.create(HTMLElement.prototype);\n\n  MyTimerProto.tick = function() {\n    this.timer++;\n    this.innerHTML = this.timer;\n  };\n\nMARK  MyTimerProto.createdCallback = function() {\nMARK    this.timer = 0;\nMARK  };\n\nMARK  MyTimerProto.attachedCallback = function() {\nMARK    setInterval(this.tick.bind(this), 1000);\nMARK  };\n\n  document.registerElement("my-timer", {\n    prototype: MyTimerProto\n  });\n<\/script>\n\n<RED_my-timer_RED id="timer">0</RED_my-timer_RED>`</script><code-toolbar iframe="40"><a title="показать" data-code_run="340"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><h2><a name="4" href="#4">Итого</a></h2><p>Мы рассмотрели, как создавать свои DOM-элементы при помощи стандарта <a href="http://www.w3.org/TR/custom-elements/">Custom Elements</a>.</p><p>Далее мы перейдём к изучению дополнительных возможностей по работе с DOM.</p><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="С высоты орбитального полёта; Shadow DOM"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/webcomponent-core",disqus_identifier="webcomponent-core",disqus_title="\u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b: Custom Elements";</script></page-content></main>