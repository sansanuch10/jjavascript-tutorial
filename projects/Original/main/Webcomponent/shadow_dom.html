<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="152">Веб-компоненты: взгляд в будущее</a></nav-up><h1>Shadow DOM</h1><p>Спецификация <a href="http://w3c.github.io/webcomponents/spec/shadow/">Shadow DOM</a> является отдельным стандартом. Частично он уже используется для обычных DOM-элементов, но также применяется для создания веб-компонентов.</p><p><em>Shadow DOM</em> – это внутренний DOM элемента, который существует отдельно от внешнего документа. В нём могут быть свои ID, свои стили и так далее. Причём снаружи его, без применения специальных техник, не видно, поэтому не возникает конфликтов.</p><h2><a name="0" href="#0">Внутри браузера</a></h2><p>Концепция Shadow DOM начала применяться довольно давно внутри самих браузеров. Когда браузер показывает сложные элементы управления, наподобие слайдера <code>&lt;input type="range"&gt;</code> или календаря <code>&lt;input type="date"&gt;</code> – внутри себя он конструирует их из самых обычных стилизованных <code>&lt;div&gt;</code>, <code>&lt;span&gt;</code> и так далее.</p><p>С первого взгляда они незаметны, но если в настройках Chrome Development Tools выбрать показ Shadow DOM, то их можно легко увидеть.</p><p>Например, вот такое содержимое будет у <code>&lt;input type="date"&gt;</code>: <img src="/article/shadow-dom/shadow-dom-chrome.png" alt="" style="width:100%; max-width:565"></p><p>То, что находится под <code>#shadow-root</code> – это и есть Shadow DOM.</p><p><strong>Получить элементы из Shadow DOM можно только при помощи специальных JavaScript-вызовов или селекторов. Это не обычные дети, а намного более мощное средство отделения содержимого.</strong></p><p>В Shadow DOM выше можно увидеть полезный атрибут <code>pseudo</code>. Он нестандартный, существует по историческим причинам. С его помощью можно стилизовать подэлементы через CSS, например, сделаем поле редактирования даты красным:</p><code-example><script>`<style>\nGOLD_input::-webkit-datetime-edit_GOLD {\n  background: red;\n}\n</style>\n\n<input type="date">`</script><code-toolbar iframe="40"><a title="показать" data-code_run="100"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>Ещё раз заметим, что <code>pseudo</code> – нестандартный атрибут. Если говорить хронологически, то сначала браузеры начали экспериментировать внутри себя с инкапсуляцией внутренних DOM-структур, а уже потом, через некоторое время, появился стандарт Shadow DOM, который позволяет делать то же самое разработчикам.</p><p>Далее мы рассмотрим работу с Shadow DOM из JavaScript, по стандарту <a href="http://w3c.github.io/webcomponents/spec/shadow/">Shadow DOM</a>.</p><h2><a name="1" href="#1">Создание Shadow DOM</a></h2><p>Shadow DOM можно создать внутри любого элемента вызовом <code>elem.createShadowRoot()</code>.</p><p>Например:</p><code-example><script>`<p id="elem">Доброе утро, страна!</p>\n\n<script>\n  var root = elem.createShadowRoot();\n  root.innerHTML = "<p>Привет из подполья!</p>";\n<\/script>`</script><code-toolbar iframe="55"><a title="показать" data-code_run="70"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>Если вы запустите этот пример, то увидите, что изначальное содержимое элемента куда-то исчезло и показывается только «Привет из подполья!». Это потому, что у элемента есть Shadow DOM.</p><p><strong>С момента создания Shadow DOM обычное содержимое (дети) элемента не отображается, а показывается только Shadow DOM.</strong></p><p>Внутрь этого Shadow DOM, при желании, можно поместить обычное содержимое. Для этого нужно указать, куда. В Shadow DOM это делается через «точку вставки» (insertion point). Она объявляется при помощи тега <code>&lt;content&gt;</code>, например:</p><code-example><script>`<p id="elem">Доброе утро, страна!</p>\n\n<script>\n  var root = elem.createShadowRoot();\n  root.innerHTML = "<h3>HIGH<content></content>LIGHT</h3><p>Привет из подполья!</p>";\n<\/script>`</script><code-toolbar iframe="100"><a title="показать" data-code_run="0"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>Теперь вы увидите две строчки: «Доброе утро, страна!» в заголовке, а затем «Привет из подполья».</p><p>Shadow DOM примера выше в инструментах разработки:</p><figure><img src="shadow-content.png" alt="" width="100%" style="max-width:280px"></figure><p>Важные детали:</p><ul><li>Тег <code>&lt;content&gt;</code> влияет только на отображение, он не перемещает узлы физически. Как видно из картинки выше, текстовый узел «Доброе утро, страна!» остался внутри <code>p#elem</code>. Его можно даже получить при помощи <code>elem.firstElementChild</code>.</li><li>Внутри <code>&lt;content&gt;</code> показывается не элемент целиком <code>&lt;p id="elem"&gt;</code>, а его содержимое, то есть в данном случае текст «Доброе утро, страна!».</li></ul><p><strong>В <code>&lt;content&gt;</code> атрибутом <code>select</code> можно указать конкретный селектор содержимого, которое нужно переносить. Например, <code>&lt;content select="h3"&gt;&lt;/content&gt;</code> перенесёт только заголовки.</strong></p><p>Внутри Shadow DOM можно использовать <code>&lt;content&gt;</code> много раз с разными значениями <code>select</code>, указывая таким образом, где конкретно какие части исходного содержимого разместить. Но при этом дублирование узлов невозможно. Если узел показан в одном <code>&lt;content&gt;</code>, то в следующем он будет пропущен.</p><p>Например, если сначала идёт <code>&lt;content select="h3.title"&gt;</code>, а затем <code>&lt;content select="h3"&gt;</code>, то в первом <code>&lt;content&gt;</code> будут показаны заголовки <code>&lt;h3&gt;</code> с классом <code>title</code>, а во втором – все остальные, кроме уже показанных.</p><p>В примере выше тег <code>&lt;content&gt;&lt;/content&gt;</code> внутри пуст. Если в нём указать содержимое, то оно будет показано только в том случае, если узлов для вставки нет. Например потому что ни один узел не подпал под указанный <code>select</code>, или все они уже отображены другими, более ранними <code>&lt;content&gt;</code>.</p><p>Например:</p><code-example><script>`<RED_section_RED id="elem">\n  <h1>Новости</h1>\n  <article>Жили-были <i>старик со старухой</i>, но недавно...</article>\n</RED_section_RED>\n\n<script>\n  var root = elem.createShadowRoot();\n\n  root.innerHTML = "<content select='h1'></content> \\n   <content select='.author'>Без автора.</content> \\n   <content></content>";\n\n<\/script>\n\n<button onclick="alert(root.innerHTML)">root.innerHTML</button>`</script><code-toolbar iframe="140"><a title="показать" data-code_run="100"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><p>При запуске мы увидим, что:</p><ul><li>Первый <code>&lt;content select='h1'&gt;</code> выведет заголовок.</li><li>Второй <code>&lt;content select=".author"&gt;</code> вывел бы автора, но так как такого элемента нет – выводится содержимое самого <code>&lt;content select=".author"&gt;</code>, то есть «Без автора».</li><li>Третий <code>&lt;content&gt;</code> выведет остальное содержимое исходного элемента – уже без заголовка <code>&lt;h1&gt;</code>, он выведен ранее!</li></ul><p>Ещё раз обратим внимание, что <code>&lt;content&gt;</code> физически не перемещает узлы по DOM. Он только показывает, где их отображать, а также, как мы увидим далее, влияет на применение стилей.</p><h2><a name="2" href="#2">Корень shadowRoot</a></h2><p>После создания корень внутреннего DOM-дерева доступен как <code>elem.shadowRoot</code>.</p><p>Он представляет собой специальный объект, поддерживающий основные методы CSS-запросов и подробно описанный в стандарте как <a href="http://w3c.github.io/webcomponents/spec/shadow/#shadowroot-object">ShadowRoot</a>.</p><p>Если нужно работать с содержимым в Shadow DOM, то нужно перейти к нему через <code>elem.shadowRoot</code>. Можно и создать новое Shadow DOM-дерево из JavaScript, например:</p><code-example><script>`<p id="elem">Доброе утро, страна!</p>\n&nbsp\n<script>\nMARK  // создать новое дерево Shadow DOM для elem\n  var root = elem.createShadowRoot();\n\n  root.innerHTML = "<h3><content></content></h3><p>Привет из подполья!</p><hr>";\n<\/script>\n&nbsp\n<script>\nMARK  // прочитать данные из Shadow DOM для elem\n  var root = elem.shadowRoot;\n  // Привет из подполья!\n  document.write("<p>p:" + root.querySelector('p').innerHTML);\n  // пусто, так как физически узлы - вне content\n  document.write("<p>content:" + root.querySelector('content').innerHTML);\n<\/script>`</script><code-toolbar iframe="200"><a title="показать" data-code_run="0"></a><a title="открыть в песочнице" data-code_edit=""></a></code-toolbar></code-example><important-warn><h3>Внутрь встроенных элементов так «залезть» нельзя</h3><p>На момент написания статьи <code>shadowRoot</code> можно получить только для Shadow DOM, созданного описанным выше способом, но не встроенного, как в элементах типа <code>&lt;input type="date"&gt;</code>.</p></important-warn><h2><a name="3" href="#3">Итого</a></h2><p>Shadow DOM – это средство для создания отдельного DOM-дерева внутри элемента, которое не видно снаружи без применения специальных методов.</p><ul><li>Ряд браузерных элементов со сложной структурой уже имеют Shadow DOM.</li><li>Можно создать Shadow DOM внутри любого элемента вызовом <code>elem.createShadowRoot()</code>. В дальнейшем его корень будет доступен как <code>elem.shadowRoot</code>. У встроенных элементов он недоступен.</li><li>Как только у элемента появляется Shadow DOM, его изначальное содержимое скрывается. Теперь показывается только Shadow DOM, который может указать, какое содержимое хозяина куда вставлять, при помощи элемента <code>&lt;content&gt;</code>. Можно указать селектор <code>&lt;content select="селектор"&gt;</code> и размещать разное содержимое в разных местах Shadow DOM.</li><li>Элемент <code>&lt;content&gt;</code> перемещает содержимое исходного элемента в Shadow DOM только визуально, в структуре DOM оно остаётся на тех же местах.</li></ul><p>Подробнее спецификация описана по адресу <a href="http://w3c.github.io/webcomponents/spec/shadow/">http://w3c.github.io/webcomponents/spec/shadow/</a>.</p><p>Далее мы рассмотрим работу с шаблонами, которые также являются частью платформы Web Components и не заменяют существующие шаблонные системы, но дополняют их важными встроенными в браузер возможностями.</p><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Пользовательские элементы: Custom Elements; Шаблоны &amp;lttemplate>"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/shadow-dom",disqus_identifier="shadow-dom",disqus_title="Shadow DOM";</script></page-content></main>