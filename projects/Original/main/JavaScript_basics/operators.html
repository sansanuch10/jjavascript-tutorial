<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="7">Основы JavaScript</a></nav-up><h1>Основные операторы</h1><p>Для работы с переменными, со значениями, JavaScript поддерживает все стандартные операторы, большинство которых есть и в других языках программирования.</p><p>Несколько операторов мы знаем со школы – это обычные сложение <code>+</code>, умножение <code>*</code>, вычитание и так далее.</p><p>В этой главе мы сконцентрируемся на операторах, которые в курсе математики не проходят, и на их особенностях в JavaScript.</p><h2><a name="a" href="#a">Термины: «унарный», «бинарный», «операнд»</a></h2><p>У операторов есть своя терминология, которая используется во всех языках программирования.</p><p>Прежде, чем мы двинемся дальше – несколько терминов, чтобы понимать, о чём речь.</p><ul><li>  <p><em>Операнд</em> – то, к чему применяется оператор. Например:  <code>5 * 2</code> – оператор умножения с левым и правым операндами. Другое название: «аргумент оператора».</p></li><li>  <p><em>Унарным</em> называется оператор, который применяется к одному выражению. Например, оператор унарный  минус  <code>"-"</code> меняет знак числа на противоположный:</p>  <code-example>  <script>`var x = 1;\n\nMARKx = -x;\nalert( x ); // -1, применили унарный минус`</script>  <code-toolbar></code-toolbar>  </code-example></li><li>  <p><em>Бинарным</em> называется оператор, который применяется к двум операндам. Тот же минус существует и в  бинарной форме:</p>  <code-example>  <script>`var x = 1, y = 3;\nalert( y - x ); // 2, бинарный минус`</script>  <code-toolbar></code-toolbar>  </code-example></li></ul><h2><a name="b" href="#b">Сложение строк, бинарный +</a></h2><p>Обычно при помощи плюса <code>'+'</code> складывают числа.</p><p>Но если бинарный оператор <code>'+'</code> применить к строкам, то он их объединяет в одну:</p><code-example><script>`var a = "моя" + "строка";\nalert( a ); // моястрока`</script><code-toolbar></code-toolbar></code-example><p>Иначе говорят, что «плюс производит конкатенацию (сложение) строк».</p><p><strong>Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке!</strong></p><p>Причем не важно, справа или слева находится операнд-строка, в любом случае нестроковый аргумент будет преобразован. Например:</p><code-example><script>`alert( '1' + 2 ); // "12"\nalert( 2 + '1' ); // "21"`</script><code-toolbar></code-toolbar></code-example><p><strong>Это приведение к строке – особенность исключительно бинарного оператора  <code>"+"</code>.</strong></p><p>Остальные арифметические операторы работают только с числами и всегда приводят аргументы к числу.</p><p>Например:</p><code-example><script>`alert( 2 - '1' ); // 1\nalert( 6 / '2' ); // 3`</script><code-toolbar></code-toolbar></code-example><h2><a name="c" href="#c">Преобразование к числу, унарный плюс +</a></h2><p>Унарный, то есть применённый к одному значению, плюс ничего не делает с числами:</p><code-example><script>`alert( +1 ); // 1\nalert( +(1 - 2) ); // -1`</script><code-toolbar></code-toolbar></code-example><p>Как видно, плюс ничего не изменил в выражениях. Результат – такой же, как и без него.</p><p>Тем не менее, он широко применяется, так как его «побочный эффект» – преобразование значения в число.</p><p>Например, когда мы получаем значения из HTML-полей или от пользователя, то они обычно в форме строк.</p><p>А что, если их нужно, к примеру, сложить? Бинарный плюс сложит их как строки:</p><code-example><script>`var apples = "2";\nvar oranges = "3";\n\nalert( apples + oranges ); // "23", так как бинарный плюс складывает строки`</script><code-toolbar></code-toolbar></code-example><p>Поэтому используем унарный плюс, чтобы преобразовать к числу:</p><code-example><script>`var apples = "2";\nvar oranges = "3";\n\nalert( +apples + +oranges ); // 5, число, оба операнда предварительно преобразованы в числа`</script><code-toolbar></code-toolbar></code-example><p>С точки зрения математики такое изобилие плюсов может показаться странным. С точки зрения программирования – никаких разночтений: сначала выполнятся унарные плюсы, приведут строки к числам, а затем – бинарный <code>'+'</code> их сложит.</p><p>Почему унарные плюсы выполнились до бинарного сложения? Как мы сейчас увидим, дело в их приоритете.</p><h2><a name="d" href="#d">Приоритет</a></h2><p>В том случае, если в выражении есть несколько операторов – порядок их выполнения определяется <em>приоритетом</em>.</p><p>Из школы мы знаем, что умножение в выражении <code>2 * 2 + 1</code> выполнится раньше сложения, т.к. его <em>приоритет</em> выше, а скобки явно задают порядок выполнения. Но в JavaScript – гораздо больше операторов, поэтому существует целая <a href="https://developer.mozilla.org/en/JavaScript/Reference/operators/operator_precedence">таблица приоритетов</a>.</p><p>Она содержит как уже пройденные операторы, так и те, которые мы еще не проходили. В ней каждому оператору задан числовой приоритет. Тот, у кого число больше – выполнится раньше. Если приоритет одинаковый, то порядок выполнения – слева направо.</p><p>Отрывок из таблицы:</p><table><thead><tr><th>Приоритет</th><th>Название</th><th>Обозначение</th></tr></thead><tbody><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>15</td><td>унарный плюс</td><td><code>+</code></td></tr><tr><td>15</td><td>унарный минус</td><td><code>-</code></td></tr><tr><td>14</td><td>умножение</td><td><code>*</code></td></tr><tr><td>14</td><td>деление</td><td><code>/</code></td></tr><tr><td>13</td><td>сложение</td><td><code>+</code></td></tr><tr><td>13</td><td>вычитание</td><td><code>-</code></td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>3</td><td>присваивание</td><td><code>=</code></td></tr><tr><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>Так как «унарный плюс» имеет приоритет <code>15</code>, выше, чем <code>13</code> у обычного «сложения», то в выражении <code>+apples + +oranges</code> сначала сработали плюсы у <code>apples</code> и <code>oranges</code>, а затем уже обычное сложение.</p><h2><a name="e" href="#e">Присваивание</a></h2><p>Обратим внимание, в таблице приоритетов также есть оператор присваивания <code>=</code>.</p><p>У него – один из самых низких приоритетов: <code>3</code>.</p><p>Именно поэтому, когда переменную чему-либо присваивают, например, <code>x = 2 * 2 + 1</code> сначала выполнится арифметика, а уже затем – произойдёт присваивание <code>=</code>.</p><code-example><script>`var x = 2 * 2 + 1;\n\n  alert( x ); // 5`</script><code-toolbar></code-toolbar></code-example><p><strong>Возможно присваивание по цепочке:</strong></p><code-example><script>`var a, b, c;\n\nMARKa = b = c = 2 + 2;\n\nalert( a ); // 4\nalert( b ); // 4\nalert( c ); // 4`</script><code-toolbar></code-toolbar></code-example><p>Такое присваивание работает справа-налево, то есть сначала вычислятся самое правое выражение <code>2+2</code>, присвоится в <code>c</code>, затем выполнится <code>b = c</code> и, наконец, <code>a = b</code>.</p><important-><h3>Оператор  <code>"="</code> возвращает значение</h3><p>Все операторы возвращают значение. Вызов  <code>x = выражение</code> не является исключением.</p><p>Он записывает выражение в  <code>x</code>, а затем возвращает его. Благодаря этому присваивание можно использовать как часть более сложного выражения:</p><code-example><script>`var a = 1;\nvar b = 2;\n\nMARKvar c = 3 - (a = b + 1);\n\nalert( a ); // 3\nalert( c ); // 0`</script><code-toolbar></code-toolbar></code-example></important-><h2><a name="f" href="#f">Взятие остатка %</a></h2><p>Оператор взятия остатка <code>%</code> интересен тем, что, несмотря на обозначение, никакого отношения к процентам не имеет.</p><p>Его результат <code>a % b</code> – это остаток от деления <code>a</code> на <code>b</code>.</p><p>Например:</p><code-example><script>`alert( 5 % 2 ); // 1, остаток от деления 5 на 2\nalert( 8 % 3 ); // 2, остаток от деления 8 на 3\nalert( 6 % 3 ); // 0, остаток от деления 6 на 3`</script><code-toolbar></code-toolbar></code-example><h2><a name="g" href="#g">Инкремент/декремент:  <code>++</code>,  <code>--</code></a></h2><p>Одной из наиболее частых операций в JavaScript, как и во многих других языках программирования, является увеличение или уменьшение переменной на единицу.</p><p>Для этого существуют даже специальные операторы:</p><ul><li>  <p><strong>Инкремент</strong>  <code>++</code> увеличивает на 1:</p>  <code-example>  <script>`var i = 2;\ni++; // более короткая запись для i = i + 1.\nalert(i); // 3`</script>  <code-toolbar></code-toolbar>  </code-example></li><li>  <p><strong>Декремент</strong>  <code>--</code> уменьшает на 1:</p>  <code-example>  <script>`var i = 2;\ni--; // более короткая запись для i = i - 1.\nalert(i); // 1`</script>  <code-toolbar></code-toolbar>  </code-example></li></ul><important-warn><h3>Важно:</h3><p>Инкремент/декремент можно применить только к переменной. Код  <code>5++</code> даст ошибку.</p></important-warn><p>Вызывать эти операторы можно не только после, но и перед переменной: <code>i++</code> (называется «постфиксная форма») или <code>++i</code> («префиксная форма»).</p><p>Обе эти формы записи делают одно и то же: увеличивают на <code>1</code>.</p><p>Тем не менее, между ними существует разница. Она видна только в том случае, когда мы хотим не только увеличить/уменьшить переменную, но и использовать результат в том же выражении.</p><p>Например:</p><code-example><script>`var i = 1;\nvar a = ++i; // (*)\n\nalert(a); // HIGH2LIGHT`</script><code-toolbar></code-toolbar></code-example><p>В строке <code>(*)</code> вызов <code>++i</code> увеличит переменную, а <em>затем</em> вернёт ее значение в <code>a</code>. Так что в <code>a</code> попадёт значение <code>i</code><em>после</em> увеличения.</p><p><strong>Постфиксная форма  <code>i++</code> отличается от префиксной  <code>++i</code> тем, что возвращает старое значение, бывшее до увеличения.</strong></p><p>В примере ниже в <code>a</code> попадёт старое значение <code>i</code>, равное <code>1</code>:</p><code-example><script>`var i = 1;\nvar a = i++; // (*)\n\nalert(a); // HIGH1LIGHT`</script><code-toolbar></code-toolbar></code-example><ul><li>  <p>Если результат оператора не используется, а нужно только увеличить/уменьшить переменную – без разницы, какую  форму использовать:</p>  <code-example>  <script>`var i = 0;\ni++;\n++i;\nalert( i ); // 2`</script>  <code-toolbar></code-toolbar>  </code-example></li><li>  <p>Если хочется тут же использовать результат, то нужна префиксная форма:</p>  <code-example>  <script>`var i = 0;\nalert( ++i ); // 1`</script>  <code-toolbar></code-toolbar>  </code-example></li><li>  <p>Если нужно увеличить, но нужно значение переменной  <em>до увеличения</em> – постфиксная форма:</p>  <code-example>  <script>`var i = 0;\nalert( i++ ); // 0`</script>  <code-toolbar></code-toolbar>  </code-example></li></ul><important-><h3>Инкремент/декремент можно использовать в любых выражениях</h3><p>При этом он имеет более высокий приоритет и выполняется раньше, чем арифметические операции:</p><code-example><script>`var i = 1;\nalert( 2 * ++i ); // 4`</script><code-toolbar></code-toolbar></code-example><code-example><script>`var i = 1;\nalert( 2 * i++ ); // 2,  выполнился раньше, но значение вернул старое\nalert( i ); // 2\nalert( 2 * i++ ); // 4\nalert( i ); // 3`</script><code-toolbar></code-toolbar></code-example><p>При этом, нужно с осторожностью использовать такую запись, потому что в более длинной строке при быстром «вертикальном»  чтении кода легко пропустить такой  <code>i++</code>, и будет неочевидно, что переменая увеличивается.</p><p>Три строки, по одному действию в каждой – длиннее, зато нагляднее:</p><code-example><script>`var i = 1;\nalert( 2 * i );\ni++;`</script><code-toolbar></code-toolbar></code-example></important-><h2><a name="h" href="#h">Побитовые операторы</a></h2><p>Побитовые операторы рассматривают аргументы как 32-разрядные целые числа и работают на уровне их внутреннего двоичного представления.</p><p>Эти операторы не являются чем-то специфичным для JavaScript, они поддерживаются в большинстве языков программирования.</p><p>Поддерживаются следующие побитовые операторы:</p><ul><li>AND(и) (  <code>&amp;</code> )</li><li>OR(или) (  <code>|</code> )</li><li>XOR(побитовое исключающее или) (  <code>^</code> )</li><li>NOT(не) (  <code>~</code> )</li><li>LEFT SHIFT(левый сдвиг) (  <code>&lt;&lt;</code> )</li><li>RIGHT SHIFT(правый сдвиг) (  <code>&gt;&gt;</code> )</li><li>ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) (  <code>&gt;&gt;&gt;</code> )</li></ul><p>Они используются редко, поэтому вынесены в отдельную главу <a data-load_page="17">Побитовые операторы</a>.</p><h2><a name="i" href="#i">Сокращённая арифметика с присваиванием</a></h2><p>Часто нужно применить оператор к переменной и сохранить результат в ней же, например:</p><code-example><script>`var n = 2;\nn = n + 5;\nn = n * 2;`</script></code-example><p>Эту запись можно укоротить при помощи совмещённых операторов, вот так:</p><code-example><script>`var n = 2;\nn += 5; // теперь n=7 (работает как n = n + 5)\nn *= 2; // теперь n=14 (работает как n = n * 2)\n\nalert( n ); // 14`</script><code-toolbar></code-toolbar></code-example><p>Так можно сделать для операторов <code>+,-,*,/,%</code> и бинарных <code>&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;,&amp;,|,^</code>.</p><p>Вызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполнится после большинства других операций:</p><code-example><script>`var n = 2;\nn *= 3 + 5;\n\nalert( n ); // 16  (n = 2 * 8)`</script><code-toolbar></code-toolbar></code-example><h2><a name="j" href="#j">Оператор запятая</a></h2><p>Один из самых необычных операторов – запятая <code>','</code>.</p><p>Его можно вызвать явным образом, например:</p><code-example><script>`MARKvar a = (5, 6);\n\nalert( a );`</script><code-toolbar></code-toolbar></code-example><p>Запятая позволяет перечислять выражения, разделяя их запятой <code>','</code>. Каждое из них – вычисляется и отбрасывается, за исключением последнего, которое возвращается.</p><p>Запятая – единственный оператор, приоритет которого ниже присваивания. В выражении <code>a = (5,6)</code> для явного задания приоритета использованы скобки, иначе оператор <code>'='</code> выполнился бы до запятой <code>','</code>, получилось бы <code>(a=5), 6</code>.</p><p>Зачем же нужен такой странный оператор, который отбрасывает значения всех перечисленных выражений, кроме последнего?</p><p>Обычно он используется в составе более сложных конструкций, чтобы сделать несколько действий в одной строке. Например:</p><code-example><script>`// три операции в одной строке\nfor (HIGHa = 1, b = 3, c = a * bLIGHT; a < 10; a++) {\n  ...\n}`</script></code-example><p>Такие трюки используются во многих JavaScript-фреймворках для укорачивания кода.</p><h2 id="tasks"><a href="#tasks">Задачи (2)</a></h2><task-content><h3>  <a name="k" href="#k">Инкремент, порядок срабатывания</a>  <task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Посмотрите, понятно ли вам, почему код ниже работает именно так?</p><code-example><script>`var a = 1, b = 1, c, d;\n\nc = ++a; alert(c); // 2\nd = b++; alert(d); // 1\n\nc = (2+ ++a); alert(c); // 5\nd = (2+ b++); alert(d); // 4\n\nalert(a); // 3\nalert(b); // 3`</script><code-toolbar></code-toolbar></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="" style="">разъяснение</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><b>Разъяснения</b><code-example><script>`var a = 1, b = 1, c, d;\n\n// префиксная форма сначала увеличивает a до 2, а потом возвращает\nc = ++a; alert(c); // 2\n\n// постфиксная форма увеличивает, но возвращает старое значение\nd = b++; alert(d); // 1\n\n// сначала увеличили a до 3, потом использовали в арифметике\nc = (2+ ++a); alert(c); // 5\n\n// увеличили b до 3, но в этом выражении оставили старое значение\nd = (2+ b++); alert(d); // 4\n\n// каждую переменную увеличили по 2 раза\nalert(a); // 3\nalert(b); // 3`</script><code-toolbar></code-toolbar></code-example></task-answer></task-answer-ext></task-content><task-content><h3>  <a name="l" href="#l">Результат присваивания</a>  <task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 3</span><p>Чему будет равен  <code>x</code> в примере ниже?</p><code-example><script>`var a = 2;\n\nvar x = 1 + (a *= 2);`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Ответ:  <code>x = 5</code>.</p><p>Оператор присваивания возвращает значение, которое будет записано в переменную, например:</p><code-example><script>`var a = 2;\nalert( a *= 2 ); // 4`</script><code-toolbar></code-toolbar></code-example><p>Отсюда  <code>x = 1 + 4 = 5</code>.</p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Шесть типов данных, typeof; Операторы сравнения и логические значения"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/operators", disqus_identifier = "operators", disqus_title = "u041e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u044b"</script></page-content></main>