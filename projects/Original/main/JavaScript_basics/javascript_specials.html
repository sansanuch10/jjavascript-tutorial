<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="7">Основы JavaScript</a></nav-up><h1>Всё вместе: особенности JavaScript</h1><p>В этой главе приводятся основные особенности JavaScript, на уровне базовых конструкций, типов, синтаксиса.</p><p>Она будет особенно полезна, если ранее вы программировали на другом языке, ну или как повторение важных моментов раздела.</p><p>Всё очень компактно, со ссылками на развёрнутые описания.</p><h2><a name="0" href="#0">Структура кода</a></h2><p>Операторы разделяются точкой с запятой:</p><code-example><script>`alert('Привет'); alert('Мир');`</script><code-toolbar></code-toolbar></code-example><p>Как правило, перевод строки тоже подразумевает точку с запятой. Так тоже будет работать:</p><code-example><script>`alert('Привет')\nalert('Мир')`</script><code-toolbar></code-toolbar></code-example><p>…Однако, иногда JavaScript не вставляет точку с запятой. Например:</p><code-example><script>`var a = 2\n+3\n\nalert(a); // 5`</script><code-toolbar></code-toolbar></code-example><p>Бывают случаи, когда это ведёт к ошибкам, которые достаточно трудно найти и исправить, например:</p><code-example><script>`alert('После этого сообщения будет ошибка')\n\n[1, 2].forEach(alert)`</script><code-toolbar></code-toolbar></code-example><p>Детали того, как работает код выше (массивы <code>[...]</code> и <code>forEach</code>) мы скоро изучим, здесь важно то, что при установке точки с запятой после <code>alert</code> он будет работать корректно.</p><p><strong>Поэтому в JavaScript рекомендуется точки с запятой ставить. Сейчас это, фактически, общепринятый стандарт.</strong></p><p>Поддерживаются однострочные комментарии <code>// ...</code> и многострочные <code>/* ... */</code>:</p><p>Подробнее: <a data-load_page="10">Структура кода</a>.</p><h2><a name="1" href="#1">Переменные и типы</a></h2><ul><li><p>Объявляются директивой <code>var</code>. Могут хранить любое значение:</p><code-example><script>`var x = 5;\nx = 'Петя';`</script></code-example></li><li><p>Есть 5 «примитивных» типов и объекты:</p><code-example><script>`x = 1;  // число\nx = 'Тест'; // строка, кавычки могут быть одинарные или двойные\nx = true; // булево значение true/false\nx = null; // спец. значение (само себе тип)\nx = undefined;  // спец. значение (само себе тип)`</script></code-example><p>Также есть специальные числовые значения <code>Infinity</code> (бесконечность) и <code>NaN</code>.</p><p>Значение <code>NaN</code> обозначает ошибку и является результатом числовой операции, если она некорректна.</p></li><li><p><strong>Значение <code>null</code> не является «ссылкой на нулевой адрес/объект» или чем-то подобным. Это просто специальное значение.</strong></p><p>Оно присваивается, если мы хотим указать, что значение переменной неизвестно.</p><p>Например:</p><code-example><script>`var age = null; // возраст неизвестен`</script></code-example></li><li><p><strong>Значение <code>undefined</code> означает «переменная не присвоена».</strong></p><p>Например:</p><code-example><script>`var x;\nalert( x ); // undefined`</script></code-example><p>Можно присвоить его и явным образом: <code>x = undefined</code>, но так делать не рекомендуется.</p><p>Про объекты мы поговорим в главе <a data-load_page="38">Объекты как ассоциативные массивы</a>, они в JavaScript сильно отличаются от большинства других языков.</p></li><li><p>В имени переменной могут быть использованы любые буквы или цифры, но цифра не может быть первой. Символы доллар <code>$</code> и подчёркивание <code>_</code> допускаются наравне с буквами.</p></li></ul><p>Подробнее: <a data-load_page="12">Переменные</a>, <a data-load_page="14">Шесть типов данных, typeof</a>.</p><h2><a name="2" href="#2">Строгий режим</a></h2><p>Для того, чтобы интерпретатор работал в режиме максимального соответствия современному стандарту, нужно начинать скрипт директивой <code>'use strict';</code></p><code-example><script>`'use strict';\n\n...`</script></code-example><p>Эта директива может также указываться в начале функций. При этом функция будет выполняться в режиме соответствия, а на внешний код такая директива не повлияет.</p><p>Одно из важных изменений в современном стандарте – все переменные нужно объявлять через <code>var</code>. Есть и другие, которые мы изучим позже, вместе с соответствующими возможностями языка.</p><h2><a name="3" href="#3">Взаимодействие с посетителем</a></h2><p>Простейшие функции для взаимодействия с посетителем в браузере:</p><dl><dt><a href="https://developer.mozilla.org/en/DOM/window.prompt">«prompt(вопрос[, по_умолчанию])»</a></dt><dd>Задать <code>вопрос</code> и возвратить введённую строку, либо <code>null</code>, если посетитель нажал «Отмена».</dd><dt><a href="https://developer.mozilla.org/en/DOM/window.confirm">«confirm(вопрос)»</a></dt><dd>Задать <code>вопрос</code> и предложить кнопки «Ок», «Отмена». Возвращает, соответственно,  <code>true/false</code>.</dd><dt><a href="https://developer.mozilla.org/en/DOM/window.alert">«alert(сообщение)»</a></dt><dd>Вывести сообщение на экран.</dd></dl><p>Все эти функции являются <em>модальными</em>, т.е. не позволяют посетителю взаимодействовать со страницей до ответа.</p><p>Например:</p><code-example><script>`var userName = prompt("Введите имя?", "Василий");\nvar isTeaWanted = confirm("Вы хотите чаю?");\n\nalert( "Посетитель:&nbsp" + userName );\nalert( "Чай:&nbsp" + isTeaWanted );`</script><code-toolbar></code-toolbar></code-example><p>Подробнее: <a data-load_page="18">Взаимодействие с пользователем: alert, prompt, confirm</a>.</p><h2><a name="4" href="#4">Особенности операторов</a></h2><ul><li><p><strong>Для сложения строк используется оператор <code>+</code>.</strong></p><p>Если хоть один аргумент – строка, то другой тоже приводится к строке:</p><code-example><script>`alert( 1 + 2 ); // 3, число\nalert( '1' + 2 ); // '12', строка\nalert( 1 + '2' ); // '12', строка`</script><code-toolbar></code-toolbar></code-example></li><li><p><strong>Сравнение <code>===</code> проверяет точное равенство, включая одинаковый тип.</strong> Это самый очевидный и надёжный способ сравнения.</p></li><li><p><strong>Остальные сравнения <code>== &lt; &lt;= &gt; &gt;=</code> осуществляют числовое приведение типа:</strong></p><code-example><script>`alert( 0 == false ); // true\nalert( true > 0 ); // true`</script><code-toolbar></code-toolbar></code-example><p>Исключение – сравнение двух строк, которое осуществляется лексикографически (см. далее).</p><p>Также: значения <code>null</code> и <code>undefined</code> при <code>==</code> равны друг другу и не равны ничему ещё. А при операторах больше/меньше происходит приведение <code>null</code> к <code>0</code>, а <code>undefined</code> к <code>NaN</code>.</p><p>Такое поведение может привести к неочевидным результатам, поэтому лучше всего использовать для сравнения с <code>null/undefined</code> оператор <code>===</code>. Оператор <code>==</code> тоже можно, если не хотите отличать <code>null</code> от <code>undefined</code>.</p><p>Например, забавное следствие этих правил для <code>null</code>:</p><code-example><script>`alert( null > 0 );  // false, т.к. null преобразовано к 0\nalert( null >= 0 ); // true, т.к. null преобразовано к 0\nalert( null == 0 ); // false, в стандарте явно указано, что null равен лишь undefined`</script><code-toolbar></code-toolbar></code-example><p>С точки зрения здравого смысла такое невозможно. Значение <code>null</code> не равно нулю и не больше, но при этом <code>null &gt;= 0</code> возвращает <code>true</code>!</p></li><li><p><strong>Сравнение строк – лексикографическое, символы сравниваются по своим unicode-кодам.</strong></p><p>Поэтому получается, что строчные буквы всегда больше, чем прописные:</p><code-example><script>`alert( 'а' > 'Я' ); // true`</script><code-toolbar></code-toolbar></code-example><p>Подробнее: <a data-load_page="15">Основные операторы</a>, <a data-load_page="16">Операторы сравнения и логические значения</a>.</p></li></ul><h2><a name="5" href="#5">Логические операторы</a></h2><p>В JavaScript есть логические операторы: И (обозначается <code>&amp;&amp;</code>), ИЛИ (обозначается <code>||</code>) и НЕ (обозначается <code>!</code>). Они интерпретируют любое значение как логическое.</p><p>Не стоит путать их с <a data-load_page="17">побитовыми операторами</a> И, ИЛИ, НЕ, которые тоже есть в JavaScript и работают с числами на уровне битов.</p><p>Как и в большинстве других языков, в логических операторах используется «короткий цикл» вычислений. Например, вычисление выражения <code>1 &amp;&amp; 0 &amp;&amp; 2</code> остановится после первого И <code>&amp;&amp;</code>, т.к. понятно что результат будет ложным (ноль интерпретируется как <code>false</code>).</p><p><strong>Результатом логического оператора служит последнее значение в коротком цикле вычислений.</strong></p><p>Можно сказать и по-другому: значения хоть и интерпретируются как логические, но то, которое в итоге определяет результат, возвращается без преобразования.</p><p>Например:</p><code-example><script>`alert( 0 && 1 ); // 0\nalert( 1 && 2 && 3 ); // 3\nalert( null || 1 || 2 ); // 1`</script><code-toolbar></code-toolbar></code-example><p>Подробнее: <a data-load_page="20">Логические операторы</a>.</p><h2><a name="6" href="#6">Циклы</a></h2><ul><li><p>Поддерживаются три вида циклов:</p><code-example><script>`// 1\nwhile (условие) {\n  ...\n}\n\n// 2\ndo {\n  ...\n} while (условие);\n\n// 3\nfor (var i = 0; i < 10; i++) {\n  ...\n}`</script></code-example></li><li><p>Переменную можно объявлять прямо в цикле, но видна она будет и за его пределами.</p></li><li><p>Поддерживаются директивы <code>break/continue</code> для выхода из цикла/перехода на следующую итерацию.</p><p>Для выхода одновременно из нескольких уровней цикла можно задать метку.</p><p>Синтаксис: «<code>имя_метки:</code>», ставится она только перед циклами и блоками, например:</p><code-example><script>`HIGHouterLIGHT:\nfor(;;) {\n ...\n  for(;;) {\n ...\n HIGHbreak outerLIGHT;\n  }\n}`</script></code-example><p>Переход на метку возможен только изнутри цикла, и только на внешний блок по отношению к данному циклу. В произвольное место программы перейти нельзя.</p></li></ul><p>Подробнее: <a data-load_page="22">Циклы while, for</a>.</p><h2><a name="7" href="#7">Конструкция switch</a></h2><p>При сравнениях в конструкции <code>switch</code> используется оператор <code>===</code>.</p><p>Например:</p><code-example><script>`var age = prompt('Ваш возраст', 18);\n\nswitch (age) {\n  case 18:\n    alert( 'Никогда не сработает' ); // результат prompt - строка, а не число\n\n  case '18': // вот так - сработает!\n    alert( 'Вам 18 лет!' );\n    break;\n\n  default:\n    alert( 'Любое значение, не совпавшее с case' );\n}`</script><code-toolbar></code-toolbar></code-example><p>Подробнее: <a data-load_page="23">Конструкция switch</a>.</p><h2><a name="8" href="#8">Функции</a></h2><p>Синтаксис функций в JavaScript:</p><code-example><script>`// function имя(список параметров) { тело }\nfunction sum(a, b) {\n  var result = a + b;\n\n  return result;\n}\n\n// использование:\nalert( sum(1, 2) ); // 3`</script><code-toolbar></code-toolbar></code-example><ul><li><p><code>sum</code> – имя функции, ограничения на имя функции – те же, что и на имя переменной.</p></li><li><p>Переменные, объявленные через <code>var</code> внутри функции, видны везде внутри этой функции, блоки <code>if</code>, <code>for</code> и т.п. на видимость не влияют.</p></li><li><p>Параметры копируются в локальные переменные <code>a</code>, <code>b</code>.</p></li><li><p>Функция без <code>return</code> считается возвращающей <code>undefined</code>. Вызов  <code>return</code> без значения также возвращает <code>undefined</code>:</p><code-example><script>`function f() { }\nalert( f() ); // undefined`</script><code-toolbar></code-toolbar></code-example></li></ul><p>Подробнее: <a data-load_page="24">Функции</a>.</p><h2><a name="9" href="#9">Function Declaration и Expression</a></h2><p>Функция в JavaScript является обычным значением.</p><p>Её можно создать в любом месте кода и присвоить в переменную, вот так:</p><code-example><script>`var sum = function(a, b) {\n  var result = a + b;\n\n  return result;\n}\n\nalert( sum(1, 2) ); // 3`</script><code-toolbar></code-toolbar></code-example><p>Такой синтаксис, при котором функция объявляется в контексте выражения (в данном случае, выражения присваивания), называется Function Expression, а обычный синтаксис, при котором функция объявляется в основном потоке кода – Function Declaration.</p><p>Функции, объявленные через Function Declaration, отличаются от Function Expression тем, что интерпретатор создаёт их при входе в область видимости (в начале выполнения скрипта), так что они работают до объявления.</p><p>Обычно это удобно, но может быть проблемой, если нужно объявить функцию в зависимости от условия. В этом случае, а также в других ситуациях, когда хочется создать функцию «здесь и сейчас», используют Function Expression.</p><p>Детали: <a data-load_page="25">Функциональные выражения</a>.</p><h2><a name="10" href="#10">Named Function Expression</a></h2><p>Если объявление функции является частью какого-либо выражения, например <code>var f = function...</code> или любого другого, то это Function Expression.</p><p>В этом случае функции можно присвоить «внутреннее» имя, указав его после <code>function</code>. Оно будет видно только внутри этой функции и позволяет обратиться к функции изнутри себя. Обычно это используется для рекурсивных вызовов.</p><p>Например, создадим функцию для вычисления факториала как Function Expression и дадим ей имя <code>me</code>:</p><code-example><script>`var factorial = function me(n) {\n  return (n == 1) ? n : n * me(n - 1);\n}\n\nalert( factorial(5) ); // 120\nMARKalert( me ); // ошибка, нет такой переменной`</script><code-toolbar></code-toolbar></code-example><p>Ограничение видимости для имени не работает в IE8-, но вызов с его помощью работает во всех браузерах.</p><p>Более развёрнуто: <a data-load_page="27">Именованные функциональные выражения</a>.</p><h2><a name="11" href="#11">Итого</a></h2><p>В этой главе мы повторили основные особенности JavaScript, знание которых необходимо для обхода большинства «граблей», да и просто для написания хорошего кода.</p><p>Это, конечно, лишь основы. Дальше вы узнаете много других особенностей и приёмов программирования на этом языке.</p><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Именованные функциональные выражения; Качество кода"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/javascript-specials", disqus_identifier = "javascript-specials", disqus_title = "\u0412\u0441\u0451 \u0432\u043c\u0435\u0441\u0442\u0435: \u043e\u0441\u043e\u0431\u0435\u043d\u043d\u043e\u0441\u0442\u0438 JavaScript";</script></page-content></main>