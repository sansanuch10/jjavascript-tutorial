<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="7">Основы JavaScript</a></nav-up><h1>Операторы сравнения и логические значения</h1><p>В этом разделе мы познакомимся с операторами сравнения и с логическими значениями, которые такие операторы возвращают.</p><p>Многие операторы сравнения знакомы нам из математики:</p><ul><li>Больше/меньше: <code>a &gt; b</code>, <code>a &lt; b</code>.</li><li>Больше/меньше или равно: <code>a &gt;= b</code>, <code>a &lt;= b</code>.</li><li> Равно <code>a == b</code>. Для сравнения используется два символа равенства <code>'='</code>. Один символ <code>a = b</code> означал бы присваивание. </li><li>«Не равно». В математике он пишется как <code>≠</code>, в JavaScript – знак равенства с восклицательным знаком перед ним <code>!=</code>.</li></ul><h2><a name="a" href="#a">Логические значения</a></h2><p>Как и другие операторы, сравнение возвращает значение. Это значение имеет <em>логический</em> тип.</p><p>Существует всего два логических значения:</p><ul><li><code>true</code> – имеет смысл «да», «верно», «истина».</li><li><code>false</code> – означает «нет», «неверно», «ложь».</li></ul><p>Например:</p><code-example><script>`alert( 2 > 1 ); // true, верно\nalert( 2 == 1 ); // false, неверно\nalert( 2 != 1 ); // true`</script><code-toolbar></code-toolbar></code-example><p>Логические значения можно использовать и напрямую, присваивать переменным, работать с ними как с любыми другими:</p><code-example><script>`var a = true; // присваивать явно\n\nvar b = 3 > 4; // или как результат сравнения\nalert( b ); // false\n\nalert( a == b ); // (true == false) неверно, выведет false`</script><code-toolbar></code-toolbar></code-example><h2><a name="b" href="#b">Сравнение строк</a></h2><p>Строки сравниваются побуквенно:</p><code-example><script>`alert( 'Б' > 'А' ); // true`</script><code-toolbar></code-toolbar></code-example><important-warn><h3>Осторожно, Unicode!</h3><p>Аналогом «алфавита» во внутреннем представлении строк служит кодировка, у каждого символа – свой номер (код). JavaScript использует кодировку <a href="http://ru.wikipedia.org/wiki/%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4">Unicode</a>.</p><p>При этом сравниваются <em>численные коды символов</em>. В частности, код у символа <code>Б</code> больше, чем у <code>А</code>, поэтому и результат сравнения такой.</p><p><strong>В кодировке Unicode обычно код у строчной буквы больше, чем у прописной.</strong></p><p>Поэтому регистр имеет значение:</p><code-example><script>`alert( 'а' > 'Я' ); // true, строчные буквы больше прописных`</script><code-toolbar></code-toolbar></code-example><p>Для корректного сравнения символы должны быть в одинаковом регистре.</p></important-warn><p>Если строка состоит из нескольких букв, то сравнение осуществляется как в телефонной книжке или в словаре. Сначала сравниваются первые буквы, потом вторые, и так далее, пока одна не будет больше другой.</p><p>Иными словами, больше – та строка, которая в телефонной книге была бы на большей странице.</p><p>Например:</p><ul><li><p>Если первая буква первой строки больше – значит первая строка больше, независимо от остальных символов:</p><code-example><script>`alert( 'Банан' > 'Аят' );`</script><code-toolbar></code-toolbar></code-example></li><li><p>Если одинаковы – сравнение идёт дальше. Здесь оно дойдёт до третьей буквы:</p><code-example><script>`alert( 'Вася' > 'Ваня' ); // true, т.к. 'с' > 'н'`</script><code-toolbar></code-toolbar></code-example></li><li><p>При этом любая буква больше отсутствия буквы:</p><code-example><script>`alert( 'Привет' > 'Прив' ); // true, так как 'е' больше чем 'ничего'.`</script><code-toolbar></code-toolbar></code-example></li></ul><p>Такое сравнение называется <em>лексикографическим</em>.</p><important-warn><h3><span>Важно:</span></h3><p>Обычно мы получаем значения от посетителя в виде строк. Например, <code>prompt</code> возвращает <em>строку</em>, которую ввел посетитель.</p><p>Числа, полученные таким образом, в виде строк сравнивать нельзя, результат будет неверен. Например:</p><code-example><script>`alert( "2" > "14" ); // true, неверно, ведь 2 не больше 14`</script><code-toolbar></code-toolbar></code-example><p>В примере выше <code>2</code> оказалось больше <code>14</code>, потому что строки сравниваются посимвольно, а первый символ <code>'2'</code> больше <code>'1'</code>.</p><p>Правильно было бы преобразовать их к числу явным образом. Например, поставив перед ними <code>+</code>:</p><code-example><script>`alert( +"2" > +"14" ); // false, теперь правильно`</script><code-toolbar></code-toolbar></code-example></important-warn><h2><a name="c" href="#c">Сравнение разных типов</a></h2><p>При сравнении значений разных типов, используется числовое преобразование. Оно применяется к обоим значениям.</p><p>Например:</p><code-example><script>`alert( '2' > 1 ); // true, сравнивается как 2 > 1\nalert( '01' == 1 ); // true, сравнивается как 1 == 1\nalert( false == 0 ); // true, false становится числом 0\nalert( true == 1 ); // true, так как true становится числом 1.`</script><code-toolbar></code-toolbar></code-example><p>Тема преобразований типов будет продолжена далее, в главе <a data-load_page="21">Преобразование типов для примитивов</a>.</p><h2><a name="d" href="#d">Строгое равенство</a></h2><p>В обычном операторе <code>==</code> есть «проблема» – он не может отличить <code>0</code> от <code>false</code>:</p><code-example><script>`alert( 0 == false ); // true`</script><code-toolbar></code-toolbar></code-example><p>Та же ситуация с пустой строкой:</p><code-example><script>`alert( '' == false ); // true`</script><code-toolbar></code-toolbar></code-example><p>Это естественное следствие того, что операнды разных типов преобразовались к числу. Пустая строка, как и <code>false</code>, при преобразовании к числу дают <code>0</code>.</p><p>Что же делать, если всё же нужно отличить <code>0</code> от <code>false</code>?</p><p><strong>Для проверки равенства без преобразования типов используются операторы строгого равенства <code>===</code> (тройное равно) и <code>!==</code>.</strong></p><p>Если тип разный, то они всегда возвращают <code>false</code>:</p><code-example><script>`alert( 0 === false ); // false, т.к. типы различны`</script><code-toolbar></code-toolbar></code-example><p>Строгое сравнение предпочтительно, если мы хотим быть уверены, что «сюрпризов» не будет.</p><h2><a name="e" href="#e">Сравнение с null и undefined</a></h2><p>Проблемы со специальными значениями возможны, когда к переменной применяется операция сравнения <code>&gt; &lt; &lt;= &gt;=</code>, а у неё может быть как численное значение, так и <code>null/undefined</code>.</p><p><strong>Интуитивно кажется, что <code>null/undefined</code> эквивалентны нулю, но это не так.</strong></p><p>Они ведут себя по-другому.</p><ol><li> Значения <code>null</code> и <code>undefined</code> равны <code>==</code> друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка. </li><li>При преобразовании в число <code>null</code> становится <code>0</code>, а <code>undefined</code> становится <code>NaN</code>.</li></ol><p>Посмотрим забавные следствия.</p><h3><a name="некорректный-результат-сравнения-null-с-0" href="#некорректный-результат-сравнения-null-с-0">Некорректный результат сравнения null с 0</a></h3><p>Сравним <code>null</code> с нулём:</p><code-example><script>`alert( null > 0 ); // false\nalert( null == 0 ); // false`</script><code-toolbar></code-toolbar></code-example><p>Итак, мы получили, что <code>null</code> не больше и не равен нулю. А теперь…</p><code-example><script>`alert(null >= 0); // true`</script><code-toolbar></code-toolbar></code-example><p>Как такое возможно? Если нечто <em>«больше или равно нулю»</em>, то резонно полагать, что оно либо <em>больше</em>, либо <em>равно</em>. Но здесь это не так.</p><p>Дело в том, что алгоритмы проверки равенства <code>==</code> и сравнения <code>&gt;= &gt; &lt; &lt;=</code> работают по-разному.</p><p>Сравнение честно приводит к числу, получается ноль. А при проверке равенства значения <code>null</code> и <code>undefined</code> обрабатываются особым образом: они равны друг другу, но не равны чему-то ещё.</p><p>В результате получается странная с точки зрения здравого смысла ситуация, которую мы видели в примере выше.</p><h3><a name="несравнимый-undefined" href="#несравнимый-undefined">Несравнимый undefined</a></h3><p>Значение <code>undefined</code> вообще нельзя сравнивать:</p><code-example><script>`alert( undefined > 0 ); // false (1)\nalert( undefined < 0 ); // false (2)\nalert( undefined == 0 ); // false (3)`</script><code-toolbar></code-toolbar></code-example><ul><li>Сравнения <code>(1)</code> и <code>(2)</code> дают <code>false</code> потому, что <code>undefined</code> при преобразовании к числу даёт <code>NaN</code>. А значение <code>NaN</code> по стандарту устроено так, что сравнения <code>==</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> и даже <code>===</code> с ним возвращают <code>false</code>.</li><li>Проверка равенства <code>(3)</code> даёт <code>false</code>, потому что в стандарте явно прописано, что <code>undefined</code> равно лишь <code>null</code> и ничему другому.</li></ul><p><strong>Вывод: любые сравнения с <code>undefined/null</code>, кроме точного <code>===</code>, следует делать с осторожностью.</strong></p><p>Желательно не использовать сравнения <code>&gt;= &gt; &lt; &lt;=</code> с ними, во избежание ошибок в коде.</p><h2><a name="f" href="#f">Итого</a></h2><ul><li>В JavaScript есть логические значения <code>true</code> (истина) и <code>false</code> (ложь). Операторы сравнения возвращают их.</li><li>Строки сравниваются побуквенно.</li><li>Значения разных типов приводятся к числу при сравнении, за исключением строгого равенства <code>===</code> (<code>!==</code>).</li><li>Значения <code>null</code> и <code>undefined</code> равны <code>==</code> друг другу и не равны ничему другому. В других сравнениях (с участием <code>&gt;</code>,<code>&lt;</code>) их лучше не использовать, так как они ведут себя не как <code>0</code>.</li></ul><p>Мы ещё вернёмся к теме сравнения позже, когда лучше изучим различные типы данных в JavaScript.</p><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Основные операторы; Побитовые операторы"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/comparison",disqus_identifier="comparison",disqus_title="\u041e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u044b \u0441\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f \u0438 \u043b\u043e\u0433\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f"</script></page-content></main>