<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="7">Основы JavaScript</a></nav-up><h1>Побитовые операторы</h1><p>Побитовые операторы интерпретируют операнды как последовательность из 32 битов (нулей и единиц). Они производят операции, используя двоичное представление числа, и возвращают новую последовательность из 32 бит (число) в качестве результата.</p><p>Эта глава требует дополнительных знаний в программировании и не очень важная, при первом чтении вы можете пропустить её и вернуться потом, когда захотите понять, как побитовые операторы работают.</p><h2><a name="a" href="#a">Формат 32-битного целого числа со знаком</a></h2><p>Побитовые операторы в JavaScript работают с 32-битными целыми числами в их двоичном представлении.</p><p>Это представление называется «32-битное целое со знаком, старшим битом слева и дополнением до двойки».</p><p>Разберём, как устроены числа внутри подробнее, это необходимо знать для битовых операций с ними.</p><ul><li><p>Что такое <a href="http://ru.wikipedia.org/wiki/%C4%E2%EE%E8%F7%ED%E0%FF_%F1%E8%F1%F2%E5%EC%E0_%F1%F7%E8%F1%EB%E5%ED%E8%FF">двоичная система счисления</a>, вам, надеюсь, уже известно. При разборе побитовых операций мы будем обсуждать именно двоичное представление чисел, из 32 бит.</p></li><li><p><em>Старший бит слева</em> – это научное название для самого обычного порядка записи цифр (от большего разряда к меньшему). При этом, если больший разряд отсутствует, то соответствующий бит равен нулю.</p><p>Примеры представления чисел в двоичной системе:</p><code-example><script>`a = 0;   // 00000000000000000000000000000000\na = 1;   // 00000000000000000000000000000001\na = 2;   // 00000000000000000000000000000010\na = 3;   // 00000000000000000000000000000011\na = 255; // 00000000000000000000000011111111`</script></code-example><p>Обратите внимание, каждое число состоит ровно из 32-битов.</p></li><li><p><em>Дополнение до двойки</em> – это название способа поддержки отрицательных чисел.</p><p><strong> Двоичный вид числа, обратного данному (например, <code>5</code> и <code>-5</code>) получается путём обращения всех битов с прибавлением 1. </strong></p><p>То есть, нули заменяются на единицы, единицы – на нули и к числу прибавляется <code>1</code>. Получается внутреннее представление того же числа, но со знаком минус.</p><p>Например, вот число <code>314</code>:</p><code-example><script>`00000000000000000000000100111010`</script></code-example><p>Чтобы получить <code>-314</code>, первый шаг – обратить биты числа: заменить <code>0</code> на <code>1</code>, а <code>1</code> на <code>0</code>:</p><code-example><script>`11111111111111111111111011000101`</script></code-example><p>Второй шаг – к полученному двоичному числу прибавить единицу, обычным двоичным сложением: <code>11111111111111111111111011000101 + 1 = 11111111111111111111111011000110</code>.</p><p>Итак, мы получили:</p><code-example><script>`-314 = 11111111111111111111111011000110`</script></code-example><p>Принцип дополнения до двойки делит все двоичные представления на два множества: если крайний-левый бит равен <code>0</code> – число положительное, если <code>1</code> – число отрицательное. Поэтому этот бит называется <i>знаковым битом</i>.</p></li></ul><h2><a name="b" href="#b">Список операторов</a></h2><p>В следующей таблице перечислены все побитовые операторы. Далее операторы разобраны более подробно.</p><table><tbody><tr><th>Оператор</th><th>Использование</th><th>Описание</th></tr><tr><td>Побитовое И (AND)</td><td style="white-space: nowrap"><code>a &amp; b</code></td><td>Ставит 1 на бит результата, для которого соответствующие биты операндов равны 1.</td></tr><tr><td>Побитовое ИЛИ (OR)</td><td style="white-space: nowrap"><code>a | b</code></td><td>Ставит 1 на бит результата, для которого хотя бы один из соответствующих битов операндов равен 1.</td></tr><tr><td>Побитовое исключающее ИЛИ (XOR)</td><td style="white-space: nowrap"><code>a ^ b</code></td><td>Ставит 1 на бит результата, для которого только один из соответствующих битов операндов равен 1 (но не оба).</td></tr><tr><td>Побитовое НЕ (NOT)</td><td style="white-space: nowrap"><code>~a</code></td><td>Заменяет каждый бит операнда на противоположный.</td></tr><tr><td>Левый сдвиг</td><td style="white-space: nowrap">`a &lt;&lt; b`</td><td><code>a</code> на   <code>b</code> битов влево, добавляя справа нули. </td></tr><tr><td>Правый сдвиг, переносящий знак</td><td style="white-space: nowrap">`a &gt;&gt; b`</td><td><code>a</code> на   <code>b</code> битов вправо, отбрасывая сдвигаемые биты. </td></tr><tr><td>Правый сдвиг с заполнением нулями</td><td style="white-space: nowrap;">`a &gt;&gt;&gt; b`</td><td><code>a</code> на   <code>b</code> битов вправо, отбрасывая сдвигаемые биты и добавляя нули слева. </td></tr></tbody></table><p>Побитовые операторы работают следующим образом:</p><ol><li> Операнды преобразуются в 32-битные целые числа, представленные последовательностью битов. Дробная часть, если она есть, отбрасывается. </li><li> Для бинарных операторов – каждый бит в первом операнде рассматривается вместе с соответствующим битом второго операнда: первый бит с первым, второй со вторым и т.п. Оператор применяется к каждой паре бит, давая соответствующий бит результата. </li><li>Получившаяся в результате последовательность бит интерпретируется как обычное число.</li></ol><p>Посмотрим, как работают операторы, на примерах.</p><important-><h3> Вспомогательные функции parseInt, toString </h3><p>Для удобной работы с примерами в этой статье, если вы захотите протестировать что-то в консоли, пригодятся две функции.</p><ul><li><code>parseInt("11000", 2)</code> – переводит строку с двоичной записью числа в число. </li><li><code>n.toString(2)</code> – получает для числа <code>n</code> запись в 2-ной системе в виде строки. </li></ul><p>Например:</p><code-example><script>`var access = parseInt("11000", 2); // получаем число из строки\n\nalert( access ); // 24, число с таким 2-ным представлением\n\nvar access2 = access.toString(2); // обратно двоичную строку из числа\n\nalert( access2 ); // 11000`</script><code-toolbar></code-toolbar></code-example><p>Без них перевод в двоичную систему и обратно был бы куда менее удобен. Более подробно они разбираются в главе <a data-load_page="36">Числа</a>.</p></important-><h2><a name="c" href="#c">&amp; (Побитовое И)</a></h2><p>Выполняет операцию И над каждой парой бит.</p><p>Результат <code>a &amp; b</code> равен единице только когда оба бита <code>a</code> и <code>b</code> равны единице.</p><p>Таблица истинности для <code>&amp;</code>:</p><table><tbody><tr><th><code>a</code></th><th><code>b</code></th><th><code>a &amp; b</code></th></tr><tr><td><code>0</code></td><td><code>0</code></td><td><code>0</code></td></tr><tr><td><code>0</code></td><td><code>1</code></td><td><code>0</code></td></tr><tr><td><code>1</code></td><td><code>0</code></td><td><code>0</code></td></tr><tr><td><code>1</code></td><td><code>1</code></td><td><code>1</code></td></tr></tbody></table><p>Пример:</p><code-example><script>`9 (по осн. 10)\n  = 00000000000000000000000000001001 (по осн. 2)\n14 (по осн. 10)\n  = 00000000000000000000000000001110 (по осн. 2)\n                   --------------------------------\n14 & 9 (по осн. 10)\n  = 00000000000000000000000000001000 (по осн. 2)\n  = 8 (по осн. 10)`</script></code-example><h2><a name="d" href="#d">| (Побитовое ИЛИ)</a></h2><p>Выполняет операцию ИЛИ над каждой парой бит. Результат <code>a | b</code> равен 1, если хотя бы один бит из <code>a,b</code> равен 1.</p><p>Таблица истинности для <code>|</code>:</p><table><tbody><tr><th><code>a</code></th><th><code>b</code></th><th><code>a | b</code></th></tr><tr><td><code>0</code></td><td><code>0</code></td><td><code>0</code></td></tr><tr><td><code>0</code></td><td><code>1</code></td><td><code>1</code></td></tr><tr><td><code>1</code></td><td><code>0</code></td><td><code>1</code></td></tr><tr><td><code>1</code></td><td><code>1</code></td><td><code>1</code></td></tr></tbody></table><p>Пример:</p><code-example><script>`9 (по осн. 10)\n  = 00000000000000000000000000001001 (по осн. 2)\n14 (по осн. 10)\n  = 00000000000000000000000000001110 (по осн. 2)\n                   --------------------------------\n14 | 9 (по осн. 10)\n  = 00000000000000000000000000001111 (по осн. 2)\n  = 15 (по осн. 10)`</script></code-example><h2><a name="e" href="#e">^ (Исключающее ИЛИ)</a></h2><p>Выполняет операцию «Исключающее ИЛИ» над каждой парой бит.</p><p><code>a</code> Исключающее ИЛИ <code>b</code> равно 1, если только <code>a=1</code> или только <code>b=1</code>, но не оба одновременно <code>a=b=1</code>.</p><p>Таблица истинности для исключающего ИЛИ:</p><table><tbody><tr><th><code>a</code></th><th><code>b</code></th><th><code>a ^ b</code></th></tr><tr><td><code>0</code></td><td><code>0</code></td><td><code>0</code></td></tr><tr><td><code>0</code></td><td><code>1</code></td><td><code>1</code></td></tr><tr><td><code>1</code></td><td><code>0</code></td><td><code>1</code></td></tr><tr><td><code>1</code></td><td><code>1</code></td><td><code>0</code></td></tr></tbody></table><p>Как видно, оно даёт 1, если ЛИБО слева <code>1</code>, ЛИБО справа <code>1</code>, но не одновременно. Поэтому его и называют «исключающее ИЛИ».</p><p>Пример:</p><code-example><script>`9 (по осн. 10)\n  = 00000000000000000000000000001001 (по осн. 2)\n14 (по осн. 10)\n  = 00000000000000000000000000001110 (по осн. 2)\n                   --------------------------------\n14 ^ 9 (по осн. 10)\n  = 00000000000000000000000000000111 (по осн. 2)\n  = 7 (по осн. 10)`</script></code-example><important-><h3>Исключающее ИЛИ в шифровании</h3><p>Исключающее или можно использовать для шифрования, так как эта операция полностью обратима. Двойное применение исключающего ИЛИ с тем же аргументом даёт исходное число.</p><p>Иначе говоря, верна формула: <code>a ^ b ^ b == a</code>.</p><p>Пускай Вася хочет передать Пете секретную информацию <code>data</code>. Эта информация заранее превращена в число, например строка интерпретируется как последовательность кодов символов.</p><p>Вася и Петя заранее договариваются о числовом ключе шифрования <code>key</code>.</p><p>Алгоритм:</p><ul><li> Вася берёт двоичное представление <code>data</code> и делает операцию <code>data ^ key</code>. При необходимости <code>data</code> бьётся на части, равные по длине <code>key</code>, чтобы можно было провести побитовое ИЛИ <code>^</code> для каждой части. В JavaScript оператор <code>^</code> работает с 32-битными целыми числами, так что <code>data</code> нужно разбить на последовательность таких чисел. </li><li> Результат <code>data ^ key</code> отправляется Пете, это шифровка. </li></ul><p>Например, пусть в <code>data</code> очередное число равно <code>9</code>, а ключ <code>key</code> равен <code>1220461917</code>.</p><code-example><script>`Данные: 9 в двоичном виде\n00000000000000000000000000001001\n\nКлюч: 1220461917 в двоичном виде\n01001000101111101100010101011101\n\nРезультат операции 9 ^ key:\n01001000101111101100010101010100\nРезультат в 10-ной системе (шифровка):\n1220461908`</script></code-example><ul><li> Петя, получив очередное число шифровки <code>1220461908</code>, применяет к нему такую же операцию <code>^ key</code>. </li><li> Результатом будет исходное число <code>data</code>. </li></ul><p>В нашем случае:</p><code-example><script>`Полученная шифровка в двоичной системе:\n9 ^ key = 1220461908\n01001000101111101100010101010100\n\nКлюч: 1220461917 в двоичном виде:\n01001000101111101100010101011101\n\nРезультат операции 1220461917 ^ key:\n00000000000000000000000000001001\nРезультат в 10-ной системе (исходное сообщение):\n9`</script></code-example><p>Конечно, такое шифрование поддаётся частотному анализу и другим методам дешифровки, поэтому современные алгоритмы используют операцию XOR <code>^</code> как одну из важных частей более сложной многоступенчатой схемы.</p></important-><h2><a name="f" href="#f">~ (Побитовое НЕ)</a></h2><p>Производит операцию НЕ над каждым битом, заменяя его на обратный ему.</p><p>Таблица истинности для НЕ:</p><table><tbody><tr><th><code>a</code></th><th><code>~a</code></th></tr><tr><td><code>0</code></td><td><code>1</code></td></tr><tr><td><code>1</code></td><td><code>0</code></td></tr></tbody></table><p>Пример:</p><code-example><script>`9 (по осн. 10)\n  = 00000000000000000000000000001001 (по осн. 2)\n               --------------------------------\n~9 (по осн. 10)\n  = 11111111111111111111111111110110 (по осн. 2)\n  = -10 (по осн. 10)`</script></code-example><p>Из-за внутреннего представления отрицательных чисел получается так, что <code>~n == -(n+1)</code>.</p><p>Например:</p><code-example><script>`alert( ~3 ); // -4\nalert( ~-1 ); // 0`</script><code-toolbar></code-toolbar></code-example><h3><a name="битовый-сдвиг-влево" href="#битовый-сдвиг-влево">&lt;&lt; (Битовый сдвиг влево)</a></h3><p>Операторы битового сдвига принимают два операнда. Первый – это число для сдвига, а второй – количество битов, которые нужно сдвинуть в первом операнде.</p><p>Оператор <code>&lt;&lt;</code> сдвигает первый операнд на указанное число битов влево. Лишние биты отбрасываются, справа добавляются нулевые биты.</p><p>Например, <code>9 &lt;&lt; 2</code> даст <code>36</code>:</p><code-example><script>`9 (по осн.10)\n  = 00000000000000000000000000001001 (по осн.2)\n                  --------------------------------\n9 << 2 (по осн.10)\n  = 00000000000000000000000000100100 (по осн.2)\n  = 36 (по осн.10)`</script></code-example><p>Операция <code>&lt;&lt; 2</code> сдвинула и отбросила два левых нулевых бита и добавила справа два новых нулевых.</p><important-><h3>Левый сдвиг почти равен умножению на 2</h3><p>Битовый сдвиг <code>&lt;&lt; N</code> обычно имеет тот же эффект, что и умножение на два <code>N</code> раз, например:</p><code-example><script>`alert( 3 << 1 ); // 6, умножение на 2\nalert( 3 << 2 ); // 12, умножение на 2 два раза\nalert( 3 << 3 ); // 24, умножение на 2 три раза`</script><code-toolbar></code-toolbar></code-example><p>Конечно, следует иметь в виду, что побитовые операторы работают только с 32-битными числами, поэтому верхний порог такого «умножения» ограничен:</p><code-example><script>`alert(10000000000 << 1); // -1474836480, отброшен крайний-левый бит\nalert(10000000000 * 2); // 20000000000, обычное умножение`</script><code-toolbar></code-toolbar></code-example></important-><h3><a name="правый-битовый-сдвиг-переносящий-знак" href="#правый-битовый-сдвиг-переносящий-знак">&gt;&gt; (Правый битовый сдвиг, переносящий знак)</a></h3><p>Этот оператор сдвигает биты вправо, отбрасывая лишние. При этом слева добавляется <em>копия</em> крайнего-левого бита.</p><p>Знак числа (представленный крайним-левым битом) при этом не меняется, так как новый крайний-левый бит имеет то же значение, что и исходном числе.</p><p>Поэтому он назван «переносящим знак».</p><p>Например, <code>9 &gt;&gt; 2</code> даст <code>2</code>:</p><code-example><script>`9 (по осн.10)\n  = 00000000000000000000000000001001 (по осн.2)\n                  --------------------------------\n9 >> 2 (по осн.10)\n  = 00000000000000000000000000000010 (по осн.2)\n  = 2 (по осн.10)`</script></code-example><p>Операция <code>&gt;&gt; 2</code> сдвинула вправо и отбросила два правых бита <code>01</code> и добавила слева две копии первого бита <code>00</code>.</p><p>Аналогично, <code>-9 &gt;&gt; 2</code> даст <code>-3</code>:</p><code-example><script>`-9 (по осн.10)\n  = 11111111111111111111111111110111 (по осн.2)\n                   --------------------------------\n-9 >> 2 (по осн.10)\n  = 11111111111111111111111111111101 (по осн.2) = -3 (по осн.10)`</script></code-example><p>Здесь операция <code>&gt;&gt; 2</code> сдвинула вправо и отбросила два правых бита <code>11</code> и добавила слева две копии первого бита <code>11</code>. , Знак числа сохранён, так как крайний-левый (знаковый) бит сохранил значение <code>1</code>.</p><important-><h3>Правый сдвиг почти равен целочисленному делению на 2</h3><p>Битовый сдвиг <code>&gt;&gt; N</code> обычно имеет тот же результат, что и целочисленное деление на два <code>N</code> раз:</p><code-example><script>`alert( 100 >> 1 ); // 50, деление на 2\nalert( 100 >> 2 ); // 25, деление на 2 два раза\nalert( 100 >> 3 ); // 12, деление на 2 три раза, целая часть от результата`</script><code-toolbar></code-toolbar></code-example></important-><h3><a class="main__anchor" name="правый-сдвиг-с-заполнением-нулями" href="#правый-сдвиг-с-заполнением-нулями">&gt;&gt;&gt; (Правый сдвиг с заполнением нулями)</a></h3><p>Этот оператор сдвигает биты первого операнда вправо. Лишние биты справа отбрасываются. Слева добавляются нулевые биты.</p><p>Знаковый бит становится равным 0, поэтому результат всегда положителен.</p><p><strong> Для неотрицательных чисел правый сдвиг с заполнением нулями <code>&gt;&gt;&gt;</code> и правый сдвиг с переносом знака <code>&gt;&gt;</code> дадут одинаковый результат, т.к в обоих случаях слева добавятся нули. </strong></p><p>Для отрицательных чисел – результат работы разный. Например, <code>-9 &gt;&gt;&gt; 2</code> даст <code>1073741821</code>, в отличие от <code>-9 &gt;&gt; 2</code> (дает <code>-3</code>):</p><code-example><script>`-9 (по осн.10)\n  = 11111111111111111111111111110111 (по осн.2)\n                    --------------------------------\n-9 >>> 2 (по осн.10)\n  = 00111111111111111111111111111101 (по осн.2)\n  = 1073741821 (по осн.10)`</script></code-example><h2><a name="g" href="#g">Применение побитовых операторов</a></h2><p>Побитовые операторы используются редко, но всё же используются.</p><p>Случаи применения побитовых операторов, которые мы здесь разберём, составляют большинство всех использований в JavaScript.</p><important-warn><h3>Осторожно, приоритеты!</h3><p>В JavaScript побитовые операторы <code>^</code>, <code>&amp;</code>, <code>|</code> выполняются после сравнений <code>==</code>.</p><p>Например, в сравнении <code>a == b^0</code> будет сначала выполнено сравнение <code>a == b</code>, а потом уже операция <code>^0</code>, как будто стоят скобки <code>(a == b)^0</code>.</p><p>Обычно это не то, чего мы хотим. Чтобы гарантировать желаемый порядок, нужно ставить скобки: <code>a == (b^0)</code>.</p></important-warn><h3><a name="маска" href="#маска">Маска</a></h3><p>Для этого примера представим, что наш скрипт работает с пользователями.</p><p>У них могут быть различные роли в проекте:</p><ul><li><code>Гость</code></li><li><code>Редактор</code></li><li><code>Админ</code></li></ul><p>Каждой роли соответствует ряд доступов к статьям и функционалу сайта.</p><p>Например, <code>Гость</code> может лишь просматривать статьи сайта, а <code>Редактор</code> – ещё и редактировать их, и тому подобное.</p><p>Что-то в таком духе:</p><table><thead><tr><th>Пользователь</th><th>Просмотр статей</th><th>Изменение статей</th><th>Просмотр товаров</th><th>Изменение товаров</th><th>Управление правами</th></tr></thead><tbody><tr><td>Гость</td><td>Да</td><td>Нет</td><td>Да</td><td>Нет</td><td>Нет</td></tr><tr><td>Редактор</td><td>Да</td><td>Да</td><td>Да</td><td>Да</td><td>Нет</td></tr><tr><td>Админ</td><td>Да</td><td>Да</td><td>Да</td><td>Да</td><td>Да</td></tr></tbody></table><p>Если вместо «Да» поставить <code>1</code>, а вместо «Нет» – <code>0</code>, то каждый набор доступов описывается числом:</p><table><thead><tr><th>Пользователь</th><th>Просмотр статей</th><th>Изменение статей</th><th>Просмотр товаров</th><th>Изменение товаров</th><th>Управление правами</th><th>В 10-ной системе</th></tr></thead><tbody><tr><td>Гость</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td> = 20</td></tr><tr><td>Редактор</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td> = 30</td></tr><tr><td>Админ</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td> = 31</td></tr></tbody></table><p>В последней колонке находится десятичное число, которое получится, если прочитать строку доступов в двоичном виде.</p><p>Например, доступ гостя <code>10100 = 20</code>.</p><p>Такая интерпретация доступов позволяет «упаковать» много информации в одно число. Это экономит память, а кроме этого – это удобно, поскольку в дополнение к экономии – по такому значению очень легко проверить, имеет ли посетитель заданную <em>комбинацию доступов</em>!</p><p>Для этого посмотрим, как в 2-ной системе представляется каждый доступ в отдельности.</p><ul><li> Доступ, соответствующий только управлению правами: <code>00001 (=1)</code> (все нули кроме <code>1</code> на позиции, соответствующей этому доступу). </li><li> Доступ, соответствующий только изменению товаров: <code>00010 (=2)</code>. </li><li> Доступ, соответствующий только просмотру товаров: <code>00100 (=4)</code>. </li><li> Доступ, соответствующий только изменению статей: <code>01000 (=8)</code>. </li><li> Доступ, соответствующий только просмотру статей: <code>10000 (=16)</code>. </li></ul><p>Доступ одновременно на просмотр и изменение статей – это двоичное число с <code>1</code> на соответствующих позициях, то есть <code>access = 11000</code>.</p><p>Как правило, доступы задаются в виде констант:</p><code-example><script>`var ACCESS_ADMIN = 1;         // 00001\nvar ACCESS_GOODS_EDIT = 2;    // 00010\nvar ACCESS_GOODS_VIEW = 4;    // 00100\nvar ACCESS_ARTICLE_EDIT = 8;  // 01000\nvar ACCESS_ARTICLE_VIEW = 16; // 10000`</script></code-example><p>Из этих констант получить нужную комбинацию доступов можно при помощи операции <code>|</code>.</p><code-example><script>`var guest = ACCESS_ARTICLE_VIEW | ACCESS_GOODS_VIEW; // 10100\nvar editor = guest | ACCESS_ARTICLE_EDIT | ACCESS_GOODS_EDIT; // 11110\nvar admin = editor | ACCESS_ADMIN; // 11111`</script></code-example><p>Теперь, чтобы понять, есть ли в доступе <code>editor</code> нужный доступ, например управление правами – достаточно применить к нему побитовый оператор И ( <code>&amp;</code>) с соответствующей константой.</p><p>Ненулевой результат будет означать, что доступ есть:</p><code-example><script>`alert(editor & ACCESS_ADMIN); // 0, доступа нет\nalert(editor & ACCESS_ARTICLE_EDIT); // 8, доступ есть`</script></code-example><p>Такая проверка работает, потому что оператор И ставит <code>1</code> на те позиции результата, на которых в обоих операндах стоит <code>1</code>.</p><p><strong>Можно проверить один из нескольких доступов.</strong></p><p>Например, проверим, есть ли права на просмотр ИЛИ изменение товаров. Соответствующие права задаются битом <code>1</code> на втором и третьем месте с конца, что даёт число <code>00110</code> (= <code>6</code> в 10-ной системе).</p><code-example><script>`var check = ACCESS_GOODS_VIEW | ACCESS_GOODS_EDIT; // 6, 00110\n\nalert( admin & check ); // не 0, значит есть доступ к просмотру ИЛИ изменению`</script></code-example><p><em>Битовой маской</em> называют как раз комбинацию двоичных значений ( <code>check</code> в примере выше), которая используется для проверки и выборки единиц на нужных позициях.</p><p>Маски могут быть весьма удобны.</p><p>В частности, их используют в функциях, чтобы одним параметром передать несколько «флагов», т.е. однобитных значений.</p><p>Пример вызова функции с маской:</p><code-example><script>`// найти пользователей с правами на изменение товаров или администраторов\nfindUsers(ACCESS_GOODS_EDIT | ACCESS_ADMIN);`</script></code-example><p>Это довольно-таки коротко и элегантно, но, вместе с тем, применение масок налагает определённые ограничения. В частности, побитовые операторы в JavaScript работают только с 32-битными числами, а значит, к примеру, 33 доступа уже в число не упакуешь. Да и работа с двоичной системой счисления – как ни крути, менее удобна, чем с десятичной или с обычными логическими значениями <code>true/false</code>.</p><p>Поэтому основная сфера применения масок – это быстрые вычисления, экономия памяти, низкоуровневые операции, связанные с рисованием из JavaScript (3d-графика), интеграция с некоторыми функциями ОС (для серверного JavaScript), и другие ситуации, когда уже существуют функции, требующие битовую маску.</p><h3><a name="округление" href="#округление">Округление</a></h3><p>Так как битовые операции отбрасывают десятичную часть, то их можно использовать для округления. Достаточно взять любую операцию, которая не меняет значение числа.</p><p>Например, двойное НЕ ( <code>~</code>):</p><code-example><script>`alert( ~~12.345 ); // 12`</script><code-toolbar></code-toolbar></code-example><p>Подойдёт и Исключающее ИЛИ ( <code>^</code>) с нулём:</p><code-example><script>`alert( 12.345 ^ 0 ); // 12`</script><code-toolbar></code-toolbar></code-example><p>Последнее даже более удобно, поскольку отлично читается:</p><code-example><script>`alert(12.3 * 14.5 ^ 0); // (=178) "12.3 умножить на 14.5 и округлить"`</script><code-toolbar></code-toolbar></code-example><p>У побитовых операторов достаточно низкий приоритет, он меньше чем у остальной арифметики:</p><code-example><script>`alert( 1.1 + 1.2 ^ 0 ); // 2, сложение выполнится раньше округления`</script><code-toolbar></code-toolbar></code-example><h3><a name="проверка-на-1" href="#проверка-на-1">Проверка на −1</a></h3><p><a href="#signed-format">Внутренний формат</a> 32-битных чисел устроен так, что для смены знака нужно все биты заменить на противоположные («обратить») и прибавить <code>1</code>.</p><p>Обращение битов – это побитовое НЕ ( <code>~</code>). То есть, при таком формате представления числа <code>-n = ~n + 1</code>. Или, если перенести единицу: <code>~n = -(n+1)</code>.</p><p>Как видно из последнего равенства, <code>~n == 0</code> только если <code>n == -1</code>. Поэтому можно легко проверить равенство <code>n == -1</code>:</p><code-example><script>`var n = 5;\n\nif (~n) { // сработает, т.к. ~n = -(5+1) = -6\n  alert( "n не -1" ); // выведет!\n}`</script><code-toolbar></code-toolbar></code-example><code-example><script>`var n = -1;\n\nif (~n) { // не сработает, т.к. ~n = -(-1+1) = 0\n  alert( "...ничего не выведет..." );\n}`</script><code-toolbar></code-toolbar></code-example><p>Проверка на <code>-1</code> пригождается, например, при поиске символа в строке. Вызов <code>str.indexOf("подстрока")</code> возвращает позицию подстроки в <code>str</code>, или <code>-1</code> если не нашёл.</p><code-example><script>`var str = "Проверка";\n\nif (~str.indexOf("верка")) { // Сочетание "if (~...indexOf)" читается как "если найдено"\n  alert( "найдено!" );\n}`</script><code-toolbar></code-toolbar></code-example><h3><a name="умножение-и-деление-на-степени-2" href="#умножение-и-деление-на-степени-2">Умножение и деление на степени 2</a></h3><p>Оператор <code>a &lt;&lt; b</code>, сдвигая биты, по сути умножает <code>a</code> на <code>2</code> в степени <code>b</code>.</p><p>Например:</p><code-example><script>`alert( 1 << 2 ); // 1*(2*2) = 4\nalert( 1 << 3 ); // 1*(2*2*2) = 8\nalert( 3 << 3 ); // 3*(2*2*2) = 24`</script><code-toolbar></code-toolbar></code-example><p>При этом следует иметь в виду, что максимальный верхний порог такого умножения меньше, чем обычно, так как побитовый оператор манипулирует 32-битными целыми, в то время как обычные операторы работают с числами длиной 64 бита.</p><p>Оператор сдвига в другую сторону <code>a &gt;&gt; b</code>, производит обратную операцию – целочисленное деление <code>a</code> на <code>2<sup>b</sup></code>.</p><code-example><script>`alert( 8 >> 2 ); // 2 = 8/4, убрали 2 нуля в двоичном представлении\nalert( 11 >> 2 ); // 2, целочисленное деление (менее значимые биты просто отброшены)`</script><code-toolbar></code-toolbar></code-example><h2><a name="h" href="#h">Итого</a></h2><ul><li> Бинарные побитовые операторы: <code>&amp; | ^ &lt;&lt; &gt;&gt; &gt;&gt;&gt;</code>. </li><li> Унарный побитовый оператор один: <code>~</code>. </li></ul><p>Как правило, битовое представление числа используется для:</p><ul><li> Округления числа: <code>(12.34^0) = 12</code>. </li><li> Проверки на равенство <code>-1</code>: <code>if (~n) { n не -1 }</code>. </li><li> Упаковки нескольких битововых значений («флагов») в одно значение. Это экономит память и позволяет проверять наличие комбинации флагов одним оператором <code>&amp;</code>. </li><li>Других ситуаций, когда нужны битовые маски.</li></ul><h2 id="tasks"><a href="#tasks">Задачи (4)</a></h2><task-content><h3><a name="i" href="#i">Побитовый оператор и значение</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Почему побитовые операции в примерах ниже не меняют число? Что они делают внутри?</p><code-example><script>`alert( 123 ^ 0 ); // 123\nalert( 0 ^ 123 ); // 123\nalert( ~~123 ); // 123`</script><code-toolbar></code-toolbar></code-example><button-answer data-toggle_answer="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><ol><li><p>Операция   <code>a^b</code> ставит бит результата в   <code>1</code>, если на соответствующей битовой позиции в   <code>a</code> или   <code>b</code> (но не одновременно) стоит   <code>1</code>.</p><p>Так как в   <code>0</code> везде стоят нули, то биты берутся в точности как во втором аргументе.</p></li><li><p>Первое побитовое НЕ   <code>~</code> превращает   <code>0</code> в   <code>1</code>, а   <code>1</code> в   <code>0</code>. А второе НЕ превращает ещё раз, в итоге получается как было.</p></li></ol></task-answer></task-content><task-content><h3><a name="j" href="#j">Проверка, целое ли число</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Напишите функцию <code>isInteger(num)</code>, которая возвращает <code>true</code>, если <code>num</code> – целое число, иначе <code>false</code>.</p><code-example><script>`alert( isInteger(1) ); // true\nalert( isInteger(1.5) ); // false\nalert( isInteger(-0.5) ); // false`</script><code-toolbar></code-toolbar></code-example><button-answer data-toggle_answer="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Один из вариантов такой функции:</p><code-example><script>`function isInteger(num) {\n  return (num ^ 0) === num;\n}\n\nalert( isInteger(1) ); // true\nalert( isInteger(1.5) ); // false\nalert( isInteger(-0.5) ); // false`</script><code-toolbar></code-toolbar></code-example><p>Обратите внимание: <code>num^0</code> – в скобках! Это потому, что приоритет операции <code>^</code> очень низкий. Если не поставить скобку, то <code>===</code> сработает раньше. Получится <code>num ^ (0 === num)</code>, а это уже совсем другое дело.</p></task-answer></task-content><task-content><h3><a name="k" href="#k">Симметричны ли операции ^, |, &amp;?</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Верно ли, что для любых <code>a</code> и <code>b</code> выполняются равенства ниже?</p><ul><li><code>(a ^ b) == (b ^ a)</code></li><li><code>(a &amp; b) == (b &amp; a)</code></li><li><code>(a | b) == (b | a)</code></li></ul><p>Иными словами, при перемене мест – всегда ли результат остаётся тем же?</p><button-answer data-toggle_answer="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Операция над числами, в конечном итоге, сводится к битам.</p><p>Посмотрим, можно ли поменять местами биты слева и справа.</p><p>Например, таблица истинности для <code>^</code>:</p><table><thead><tr><th><code>a</code></th><th><code>b</code></th><th>результат</th></tr></thead><tbody><tr><td><code>0</code></td><td><code>0</code></td><td><code>0</code></td></tr><tr><td><code>0</code></td><td><code>1</code></td><td><code>1</code></td></tr><tr><td><code>1</code></td><td><code>0</code></td><td><code>1</code></td></tr><tr><td><code>1</code></td><td><code>1</code></td><td><code>0</code></td></tr></tbody></table><p>Случаи <code>0^0</code> и <code>1^1</code> заведомо не изменятся при перемене мест, поэтому нас не интересуют. А вот <code>0^1</code> и <code>1^0</code> эквивалентны и равны <code>1</code>.</p><p>Аналогично можно увидеть, что и другие операторы симметричны.</p><p>Ответ: <strong>да</strong>.</p></task-answer></task-content><task-content><h3><a name="l" href="#l">Почему результат разный?</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Почему результат второго <code>alert'а</code> такой странный?</p><code-example><script>`alert( 123456789 ^ 0 ); // 123456789\nalert( 12345678912345 ^ 0 ); // 1942903641`</script><code-toolbar></code-toolbar></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Всё дело в том, что побитовые операции преобразуют число в 32-битное целое.</p><p>Обычно число в JavaScript имеет 64-битный формат с плавающей точкой. При этом часть битов ( <code>52</code>) отведены под цифры, часть ( <code>11</code>) отведены под хранение номера позиции, на которой стоит десятичная точка, и один бит – знак числа.</p><p>Это означает, что максимальное целое число, которое можно хранить, занимает <code>52</code> бита.</p><p>Число <code>12345678912345</code> в двоичном виде: <code>10110011101001110011110011100101101101011001</code> (44 цифры).</p><p>Побитовый оператор <code>^</code> преобразует его в 32-битное путём отбрасывания десятичной точки и «лишних» старших цифр. При этом, так как число большое и старшие биты здесь ненулевые, то, естественно, оно изменится.</p><p>Вот ещё пример:</p><code-example><script>`// в двоичном виде 1000000000000000000000000000000 (31 цифры)\nalert( Math.pow(2, 30) ); // 1073741824\nalert( Math.pow(2, 30) ^ 0 ); // 1073741824, всё ок, длины хватает\n\n// в двоичном виде 100000000000000000000000000000000 (33 цифры)\nalert( Math.pow(2, 32) ); // 4294967296\nalert( Math.pow(2, 32) ^ 0 ); // 0, отброшены старшие цифры, остались нули\n\n// пограничный случай\n// в двоичном виде 10000000000000000000000000000000 (32 цифры)\nalert( Math.pow(2, 31) ); // 2147483648\nalert( Math.pow(2, 31) ^ 0 ); // -2147483648, ничего не отброшено,\n// но первый бит 1 теперь стоит в начале числа и является знаковым`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Операторы сравнения и логические значения; Взаимодействие с пользователем: alert, prompt, confirm"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/bitwise-operators", disqus_identifier = "/bitwise-operators", disqus_title = "\u041f\u043e\u0431\u0438\u0442\u043e\u0432\u044b\u0435 \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u044b";</script></page-content></main>