<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="7">Основы JavaScript</a></nav-up><h1>Именованные функциональные выражения</h1><p>Специально для работы с рекурсией в JavaScript существует особое расширение функциональных выражений, которое называется «Named Function Expression» (сокращённо NFE) или, по-русски, <em>«именованное функциональное выражение»</em>.</p><h2><a name="0" href="#0">Named Function Expression</a></h2><p>Обычное функциональное выражение:</p><code-example><script>`var f = function(...) { /* тело функции */ };`</script></code-example><p>Именованное с именем <code>sayHi</code>:</p><code-example><script>`var f = function HIGHsayHiLIGHT(...) { /* тело функции */ };`</script></code-example><p>Что же это за имя, которое идёт в дополнение к <code>f</code>, и зачем оно?</p><p>Имя функционального выражения (<code>sayHi</code>) имеет особый смысл. Оно доступно <em>только изнутри</em> самой функции (<code>f</code>).</p><p>Это ограничение видимости входит в стандарт JavaScript и поддерживается всеми браузерами, кроме IE8-.</p><p>Например:</p><code-example><script>`var f = function sayHi(name) {\n  alert( sayHi ); // изнутри функции - видно (выведет код функции)\n};\n\nalert( sayHi ); // снаружи - не видно (ошибка: undefined variable 'sayHi')`</script><code-toolbar></code-toolbar></code-example><p>Кроме того, имя NFE нельзя перезаписать:</p><code-example><script>`var test = function sayHi(name) {\nMARK  sayHi = 'тест'; // попытка перезаписи\n  alert( sayHi ); // function... (перезапись не удалась)\n};\n\ntest();`</script><code-toolbar></code-toolbar></code-example><p>В режиме <code>use strict</code> код выше выдал бы ошибку.</p><p>Как правило, имя NFE используется для единственной цели – позволить изнутри функции вызвать саму себя.</p><h2><a name="1" href="#1">Пример использования</a></h2><p>NFE используется в первую очередь в тех ситуациях, когда функцию нужно передавать в другое место кода или перемещать из одной переменной в другую.</p><p><strong>Внутреннее имя позволяет функции надёжно обращаться к самой себе, где бы она ни находилась.</strong></p><p>Вспомним, к примеру, функцию-факториал из задачи <a data-load_page="26-2">Вычислить факториал</a>:</p><code-example><script>`function f(n) {\n  return n ? n * f(n - 1) : 1;\n};\n\nalert( f(5) ); // 120`</script><code-toolbar></code-toolbar></code-example><p>Попробуем перенести её в другую переменную <code>g</code>:</p><code-example><script>`function f(n) {\n  return n ? n * f(n - 1) : 1;\n};\n\nMARKvar g = f;\nMARKf = null;\n\nalert( g(5) ); // запуск функции с новым именем - ошибка при выполнении!`</script><code-toolbar></code-toolbar></code-example><p>Ошибка возникла потому что функция из своего кода обращается к своему старому имени <code>f</code>. А этой функции уже нет, <code>f = null</code>.</p><p>Для того, чтобы функция всегда надёжно работала, объявим её как Named Function Expression:</p><code-example><script>`var f = function HIGHfactorialLIGHT(n) {\n  return n ? n*HIGHfactorialLIGHT(n-1) : 1;\n};\n\nvar g = f;  // скопировали ссылку на функцию-факториал в g\nf = null;\n\nMARKalert( g(5) ); // 120, работает!`</script><code-toolbar></code-toolbar></code-example><important-warn><h3>В браузере IE8- создаются две функции</h3><p>Как мы говорили выше, в браузере IE до 9 версии имя NFE видно везде, что является ошибкой с точки зрения стандарта.</p><p>…Но на самом деле ситуация ещё забавнее. Старый IE создаёт в таких случаях целых две функции: одна записывается в переменную <code>f</code>, а вторая – в переменную <code>factorial</code>.</p><p>Например:</p><code-example><script>`var f = function factorial(n) { /*...*/ };\n\n// в IE8- false\n// в остальных браузерах ошибка, т.к. имя factorial не видно\nalert( f === factorial );`</script><code-toolbar></code-toolbar></code-example><p>Все остальные браузеры полностью поддерживают именованные функциональные выражения.</p></important-warn><important-><h3>Устаревшее специальное значение <code>arguments.callee</code></h3><p>Если вы давно работаете с JavaScript, то, возможно, знаете, что раньше для этой цели также служило специальное значение <code>arguments.callee</code>.</p><p>Если это название вам ни о чём не говорит – всё в порядке, читайте дальше, мы обязательно обсудим его <a data-load_page="44#2">в отдельной главе</a>.</p><p>Если же вы в курсе, то стоит иметь в виду, что оно официально исключено из современного стандарта. А NFE – это наше настоящее.</p></important-><h2><a name="2" href="#2">Итого</a></h2><p>Если функция задана как Function Expression, ей можно дать имя.</p><p>Оно будет доступно только внутри функции (кроме IE8-).</p><p>Это имя предназначено для надёжного рекурсивного вызова функции, даже если она записана в другую переменную.</p><p>Обратим внимание, что с Function Declaration так поступить нельзя. Такое «специальное» внутреннее имя функции задаётся только в синтаксисе Function Expression.</p><h2 id="tasks"><a href="#3" name="3">Задачи</a></h2><task-content><h3><a href="#7" name="7">Проверка на NFE</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Каков будет результат выполнения кода?</p><code-example><script>`function g() { return 1; }\n\nalert(g);`</script></code-example><p>А такого? Будет ли разница, если да – почему?</p><code-example><script>`(function g() { return 1; });\n\nalert(g);`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p><strong>Первый код выведет <code>function ...</code>, второй – ошибку во всех браузерах, кроме IE8-.</strong></p><code-example><script>`// обычное объявление функции (Function Declaration)\nfunction g() { return 1; };\n\nalert(g); // функция`</script><code-toolbar></code-toolbar></code-example><p>Во втором коде скобки есть, значит функция внутри является не <code>Function Declaration</code>, а частью выражения, то есть <code>Named Function Expression</code>. Его имя видно только внутри, снаружи переменная <code>g</code> не определена.</p><code-example><script>`// Named Function Expression!\n(function g() { return 1; });\n\nalert(g);  // Ошибка!`</script><code-toolbar></code-toolbar></code-example><p>Все браузеры, кроме IE8-, поддерживают это ограничение видимости и выведут ошибку, <code>"undefined variable"</code>.</p></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Рекурсия, стек; Всё вместе: особенности JavaScript"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/named-function-expression", disqus_identifier = "named-function-expression", disqus_title = "\u0418\u043c\u0435\u043d\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u044b\u0435 \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u044f";</script></page-content></main>