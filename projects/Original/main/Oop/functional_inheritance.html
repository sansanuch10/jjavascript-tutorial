<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="69">ООП в функциональном стиле</a></nav-up><h1>Функциональное наследование</h1><p>Наследование – это создание новых «классов» на основе существующих.</p><p>В JavaScript его можно реализовать несколькими путями, один из которых – с использованием наложения конструкторов, мы рассмотрим в этой главе.</p><h2><a name="0" href="#0">Зачем наследование?</a></h2><p>Ранее мы обсуждали различные реализации кофеварки. Продолжим эту тему далее.</p><p>Хватит ли нам только кофеварки для удобной жизни? Вряд ли… Скорее всего, ещё понадобятся как минимум холодильник, микроволновка, а возможно и другие <em>машины</em>.</p><p>В реальной жизни у этих <em>машин</em> есть базовые правила пользования. Например, большая кнопка <i class="fa fa-power-off"></i> – включение, шнур с розеткой нужно воткнуть в питание и т.п.</p><p>Можно сказать, что «у всех машин есть общие свойства, а конкретные машины могут их дополнять».</p><p>Именно поэтому, увидев новую технику, мы уже можем что-то с ней сделать, даже не читая инструкцию.</p><p>Механизм наследования позволяет определить базовый класс <code>Машина</code>, в нём описать то, что свойственно всем машинам, а затем на его основе построить другие, более конкретные: <code>Кофеварка</code>, <code>Холодильник</code> и т.п.</p><important-><h3>В веб-разработке всё так же</h3><p>В веб-разработке нам могут понадобиться классы <code>Меню</code>, <code>Табы</code>, <code>Диалог</code> и другие компоненты интерфейса. В них всех обычно есть что-то общее.</p><p>Можно выделить такой общий функционал в класс <code>Компонент</code> и наследовать их от него, чтобы не дублировать код.</p></important-><h2><a name="1" href="#1">Наследование от Machine</a></h2><p>Базовый класс «машина» <code>Machine</code> будет реализовывать общего вида методы «включить» <code>enable()</code> и «выключить» <code>disable()</code>:</p><code-example><script>`function Machine() {\n  var enabled = false;\n\n  this.enable = function() {\n    enabled = true;\n  };\n\n  this.disable = function() {\n    enabled = false;\n  };\n}`</script></code-example><p>Унаследуем от него кофеварку. При этом она получит эти методы автоматически:</p><code-example><script>`function CoffeeMachine(power) {\nMARK  Machine.call(this); // отнаследовать\n\n  var waterAmount = 0;\n\n  this.setWaterAmount = function(amount) {\n    waterAmount = amount;\n  };\n\n}\n\nvar coffeeMachine = new CoffeeMachine(10000);\n\nMARKcoffeeMachine.enable();\nMARKcoffeeMachine.setWaterAmount(100);\nMARKcoffeeMachine.disable();`</script></code-example><p>Наследование реализовано вызовом <code>Machine.call(this)</code> в начале конструктора <code>CoffeeMachine</code>.</p><p>Он вызывает функцию <code>Machine</code>, передавая ей в качестве контекста <code>this</code> текущий объект. <code>Machine</code>, в процессе выполнения, записывает в <code>this</code> различные полезные свойства и методы, в нашем случае <code>this.enable</code> и <code>this.disable</code>.</p><p>Далее конструктор <code>CoffeeMachine</code> продолжает выполнение и может добавить свои свойства и методы.</p><p>В результате мы получаем объект <code>coffeeMachine</code>, который включает в себя методы из <code>Machine</code> и <code>CoffeeMachine</code>.</p><h2><a name="2" href="#2">Защищённые свойства</a></h2><p>В коде выше есть одна проблема.</p><p><strong>Наследник не имеет доступа к приватным свойствам родителя.</strong></p><p>Иначе говоря, если кофеварка захочет обратиться к <code>enabled</code>, то её ждёт разочарование:</p><code-example><script>`function Machine() {\n  var enabled = false;\n\n  this.enable = function() {\n    enabled = true;\n  };\n\n  this.disable = function() {\n    enabled = false;\n  };\n}\n\nfunction CoffeeMachine(power) {\n  Machine.call(this);\n\n  this.enable();\n\nMARK  // ошибка, переменная не определена!\nMARK  alert( enabled );\n}\n\nvar coffeeMachine = new CoffeeMachine(10000);`</script><code-toolbar></code-toolbar></code-example><p>Это естественно, ведь <code>enabled</code> – локальная переменная функции <code>Machine</code>. Она находится в другой области видимости.</p><p><strong>Чтобы наследник имел доступ к свойству, оно должно быть записано в <code>this</code>.</strong></p><p>При этом, чтобы обозначить, что свойство является внутренним, его имя начинают с подчёркивания <code>_</code>.</p><code-example><script>`function Machine() {\nMARK  this._enabled = false; // вместо var enabled\n\n  this.enable = function() {\n    this._enabled = true;\n  };\n\n  this.disable = function() {\n    this._enabled = false;\n  };\n}\n\nfunction CoffeeMachine(power) {\n  Machine.call(this);\n\n  this.enable();\n\nMARK  alert( this._enabled ); // true\n}\n\nvar coffeeMachine = new CoffeeMachine(10000);`</script><code-toolbar></code-toolbar></code-example><p>Подчёркивание в начале свойства – общепринятый знак, что свойство является внутренним, предназначенным лишь для доступа из самого объекта и его наследников. Такие свойства называют <em>защищёнными</em>.</p><p>Технически, залезть в него из внешнего кода, конечно, возможно, но приличный программист так делать не будет.</p><h2><a name="3" href="#3">Перенос свойства в защищённые</a></h2><p>У <code>CoffeeMachine</code> есть приватное свойство <code>power</code>. Сейчас мы его тоже сделаем защищённым и перенесём в <code>Machine</code>, поскольку «мощность» свойственна всем машинам, а не только кофеварке.</p><code-example><script>`function Machine(power) {\nMARK  this._power = power; // (1)\n\n  this._enabled = false;\n\n  this.enable = function() {\n    this._enabled = true;\n  };\n\n  this.disable = function() {\n    this._enabled = false;\n  };\n}\n\nfunction CoffeeMachine(power) {\nMARK  Machine.apply(this, arguments); // (2)\n\n  alert( this._enabled ); // false\n  alert( this._power ); // 10000\n}\n\nvar coffeeMachine = new CoffeeMachine(10000);`</script><code-toolbar></code-toolbar></code-example><p>Теперь все машины <code>Machine</code> имеют мощность <code>power</code>. Обратим внимание, что мы из параметра конструктора сразу скопировали её в объект в строке <code>(1)</code>. Иначе она была бы недоступна из наследников.</p><p>В строке <code>(2)</code> мы теперь вызываем не просто <code>Machine.call(this)</code>, а расширенный вариант: <code>Machine.apply(this, arguments)</code>, который вызывает <code>Machine</code> в текущем контексте вместе с передачей текущих аргументов.</p><p>Можно было бы использовать и более простой вызов <code>Machine.call(this, power)</code>, но использование <code>apply</code> гарантирует передачу всех аргументов, вдруг их количество увеличится – не надо будет переписывать.</p><h2><a name="4" href="#4">Переопределение методов</a></h2><p>Итак, мы получили класс <code>CoffeeMachine</code>, который наследует от <code>Machine</code>.</p><p>Аналогичным образом мы можем унаследовать от <code>Machine</code> холодильник <code>Fridge</code>, микроволновку <code>MicroOven</code> и другие классы, которые разделяют общий «машинный» функционал, то есть имеют мощность и их можно включать/выключать.</p><p>Для этого достаточно вызвать <code>Machine</code> в текущем контексте, а затем добавить свои методы.</p><code-example><script>`// Fridge может добавить и свои аргументы,\n// которые в Machine не будут использованы\nfunction Fridge(power, temperature) {\n  Machine.apply(this, arguments);\n\n  // ...\n}`</script></code-example><p>Бывает так, что реализация конкретного метода машины в наследнике имеет свои особенности.</p><p>Можно, конечно, объявить в <code>CoffeeMachine</code> свой <code>enable</code>:</p><code-example><script>`function CoffeeMachine(power, capacity) {\n  Machine.apply(this, arguments);\n\n  // переопределить this.enable\n  this.enable = function() {\n    /* enable для кофеварки */\n  };\n}`</script></code-example><p>…Однако, как правило, мы хотим не заменить, а <em>расширить</em> метод родителя, добавить к нему что-то. Например, сделать так, чтобы при включении кофеварка тут же запускалась.</p><p>Для этого метод родителя предварительно копируют в переменную, и затем вызывают внутри нового <code>enable</code> – там, где считают нужным:</p><code-example><script>`function CoffeeMachine(power) {\n  Machine.apply(this, arguments);\n\n  var parentEnable = this.enable; // (1)\n  this.enable = function() { // (2)\n      parentEnable.call(this); // (3)\n      this.run(); // (4)\n    }\n\n  ...\n}`</script></code-example><p><strong>Общая схема переопределения метода (по строкам выделенного фрагмента кода):</strong></p><ol><li>Копируем доставшийся от родителя метод <code>this.enable</code> в переменную, например <code>parentEnable</code>.</li><li>Заменяем <code>this.enable</code> на свою функцию…</li><li>…Которая по-прежнему реализует старый функционал через вызов <code>parentEnable</code>.</li><li>…И в дополнение к нему делает что-то своё, например запускает приготовление кофе.</li></ol><p>Обратим внимание на строку <code>(3)</code>.</p><p>В ней родительский метод вызывается так: <code>parentEnable.call(this)</code>. Если бы вызов был таким: <code>parentEnable()</code>, то ему бы не передался текущий <code>this</code> и возникла бы ошибка.</p><p>Технически, можно сделать возможность вызывать его и как <code>parentEnable()</code>, но тогда надо гарантировать, что контекст будет правильным, например привязать его при помощи <code>bind</code> или при объявлении, в родителе, вообще не использовать <code>this</code>, а получать контекст через замыкание, вот так:</p><code-example><script>`function Machine(power) {\n  this._enabled = false;\n\nMARK  var self = this;\n\n  this.enable = function() {\nMARK    // используем внешнюю переменную вместо this\nMARK    self._enabled = true;\n  };\n\n  this.disable = function() {\n    self._enabled = false;\n  };\n\n}\n\nfunction CoffeeMachine(power) {\n  Machine.apply(this, arguments);\n\n  var waterAmount = 0;\n\n  this.setWaterAmount = function(amount) {\n    waterAmount = amount;\n  };\n\nMARK  var parentEnable = this.enable;\nMARK  this.enable = function() {\nMARK      parentEnable(); // теперь можно вызывать как угодно, this не важен\nMARK      this.run();\nMARK    }\n\n  function onReady() {\n    alert( 'Кофе готово!' );\n  }\n\n  this.run = function() {\n    setTimeout(onReady, 1000);\n  };\n\n}\n\nvar coffeeMachine = new CoffeeMachine(10000);\ncoffeeMachine.setWaterAmount(50);\ncoffeeMachine.enable();`</script><code-toolbar></code-toolbar></code-example><p>В коде выше родительский метод <code>parentEnable = this.enable</code> успешно продолжает работать даже при вызове без контекста. А всё потому, что использует <code>self</code> внутри.</p><h2><a name="5" href="#5">Итого</a></h2><p>Организация наследования, которая описана в этой главе, называется «функциональным паттерном наследования».</p><p>Её общая схема (кратко):</p><ol><li><p>Объявляется конструктор родителя <code>Machine</code>. В нём могут быть приватные (private), публичные (public) и защищённые (protected) свойства:</p><code-example><script>`function Machine(params) {\n  // локальные переменные и функции доступны только внутри Machine\n  var privateProperty;\n\n  // публичные доступны снаружи\n  this.publicProperty = ...;\n\n  // защищённые доступны внутри Machine и для потомков\n  // мы договариваемся не трогать их снаружи\n  this._protectedProperty = ...\n}\n\nvar machine = new Machine(...)\nmachine.public();`</script></code-example></li><li><p>Для наследования конструктор потомка вызывает родителя в своём контексте через <code>apply</code>. После чего может добавить свои переменные и методы:</p><code-example><script>`function CoffeeMachine(params) {\n  // универсальный вызов с передачей любых аргументов\nMARK  Machine.apply(this, arguments);\n\n  this.coffeePublicProperty = ...\n}\n\nvar coffeeMachine = new CoffeeMachine(...);\ncoffeeMachine.publicProperty();\ncoffeeMachine.coffeePublicProperty();`</script></code-example></li><li><p>В <code>CoffeeMachine</code> свойства, полученные от родителя, можно перезаписать своими. Но обычно требуется не заменить, а расширить метод родителя. Для этого он предварительно копируется в переменную:</p><code-example><script>`function CoffeeMachine(params) {\n  Machine.apply(this, arguments);\n\nMARK  var parentProtected = this._protectedProperty;\nMARK  this._protectedProperty = function(args) {\nMARK parentProtected.apply(this, args); // (*)\nMARK // ...\nMARK  };\n}`</script></code-example><p>Строку <code>(*)</code> можно упростить до <code>parentProtected(args)</code>, если метод родителя не использует <code>this</code>, а, например, привязан к <code>var self = this</code>:</p><code-example><script>`function Machine(params) {\n  var self = this;\n\n  this._protected = function() {\n self.property = "value";\n  };\n}`</script></code-example></li></ol><p>Надо сказать, что способ наследования, описанный в этой главе, используется нечасто.</p><p>В следующих главах мы будем изучать прототипный подход, который обладает рядом преимуществ.</p><p>Но знать и понимать его необходимо, поскольку во многих существующих библиотеках классы написаны в функциональном стиле, и расширять/наследовать от них можно только так.</p><h2 id="tasks"><a href="#6" name="6">Задачи (5)</a></h2><task-content><h3><a href="#9" name="9">Запускать только при включённой кофеварке</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>В коде <code>CoffeeMachine</code> сделайте так, чтобы метод <code>run</code> выводил ошибку, если кофеварка выключена.</p><p>В итоге должен работать такой код:</p><code-example><script>`var coffeeMachine = new CoffeeMachine(10000);\ncoffeeMachine.run(); // ошибка, кофеварка выключена!`</script></code-example><p>А вот так – всё в порядке:</p><code-example><script>`var coffeeMachine = new CoffeeMachine(10000);\ncoffeeMachine.enable();\ncoffeeMachine.run(); // ...Кофе готов!`</script></code-example><p><a href="http://plnkr.co/edit/I3ppEzOa301kBZlEoVIy?p=preview" target="_blank" data-plunk-id="I3ppEzOa301kBZlEoVIy">Открыть песочницу для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Изменения в методе <code>run</code>:</p><code-example><script>`this.run = function() {\nMARK  if (!this._enabled) {\nMARK    throw new Error("Кофеварка выключена");\nMARK  }\n\n  setTimeout(onReady, 1000);\n};`</script></code-example><p><a href="http://plnkr.co/edit/qzY9waq3Vf5q8z4lZwKV?p=preview" target="_blank" data-plunk-id="qzY9waq3Vf5q8z4lZwKV">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#10" name="10">Останавливать кофеварку при выключении</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Когда кофеварку выключают – текущая варка кофе должна останавливаться.</p><p>Например, следующий код кофе не сварит:</p><code-example><script>`var coffeeMachine = new CoffeeMachine(10000);\ncoffeeMachine.enable();\ncoffeeMachine.run();\ncoffeeMachine.disable(); // остановит работу, ничего не выведет`</script></code-example><p>Реализуйте это на основе решения <a href="#9">предыдущей задачи</a>.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p><a href="http://plnkr.co/edit/UZvvsiseprV7LWOv0GXM?p=preview" target="_blank" data-plunk-id="UZvvsiseprV7LWOv0GXM">Открыть решение в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#11" name="11">Унаследуйте холодильник</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>Создайте класс для холодильника <code>Fridge(power)</code>, наследующий от <code>Machine</code>, с приватным свойством <code>food</code> и методами <code>addFood(...)</code>, <code>getFood()</code>:</p><ul><li>Приватное свойство <code>food</code> хранит массив еды.</li><li>Публичный метод <code>addFood(item)</code> добавляет в массив <code>food</code> новую еду, доступен вызов с несколькими аргументами <code>addFood(item1, item2...)</code> для добавления нескольких элементов сразу.</li><li>Если холодильник выключен, то добавить еду нельзя, будет ошибка.</li><li>Максимальное количество еды ограничено <code>power/100</code>, где <code>power</code> – мощность холодильника, указывается в конструкторе. При попытке добавить больше – будет ошибка</li><li>Публичный метод <code>getFood()</code> возвращает еду в виде массива, добавление или удаление элементов из которого не должно влиять на свойство <code>food</code> холодильника.</li></ul><p>Код для проверки:</p><code-example><script>`var fridge = new Fridge(200);\nfridge.addFood("котлета"); // ошибка, холодильник выключен`</script></code-example><p>Ещё код для проверки:</p><code-example><script>`// создать холодильник мощностью 500 (не более 5 еды)\nvar fridge = new Fridge(500);\nfridge.enable();\nfridge.addFood("котлета");\nfridge.addFood("сок", "зелень");\nfridge.addFood("варенье", "пирог", "торт"); // ошибка, слишком много еды`</script></code-example><p>Код использования холодильника без ошибок:</p><code-example><script>`var fridge = new Fridge(500);\nfridge.enable();\nfridge.addFood("котлета");\nfridge.addFood("сок", "варенье");\n\nvar fridgeFood = fridge.getFood();\nalert( fridgeFood ); // котлета, сок, варенье\n\n// добавление элементов не влияет на еду в холодильнике\nfridgeFood.push("вилка", "ложка");\n\nalert( fridge.getFood() ); // внутри по-прежнему: котлета, сок, варенье`</script></code-example><p>Исходный код класса <code>Machine</code>, от которого нужно наследовать:</p><code-example><script>`function Machine(power) {\n  this._power = power;\n  this._enabled = false;\n\n  var self = this;\n\n  this.enable = function() {\n    self._enabled = true;\n  };\n\n  this.disable = function() {\n    self._enabled = false;\n  };\n}`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Решение:</p><code-example><script>`function Fridge(power) {\n  // унаследовать\n  Machine.apply(this, arguments);\n\n  var food = []; // приватное свойство food\n\n  this.addFood = function() {\n    if (!this._enabled) {\n      throw new Error("Холодильник выключен");\n    }\n    if (food.length + arguments.length > this._power / 100) {\n      throw new Error("Нельзя добавить, не хватает мощности");\n    }\n    for (var i = 0; i < arguments.length; i++) {\n      food.push(arguments[i]); // добавить всё из arguments\n    }\n  };\n\n  this.getFood = function() {\n    // копируем еду в новый массив, чтобы манипуляции с ним не меняли food\n    return food.slice();\n  };\n\n}`</script></code-example></task-answer></task-content><task-content><h3><a href="#12" name="12">Добавьте методы в холодильник</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Добавьте в холодильник методы:</p><ul><li>Публичный метод <code>filterFood(func)</code>, который возвращает всю еду, для которой <code>func(item) == true</code></li><li>Публичный метод <code>removeFood(item)</code>, который удаляет еду <code>item</code> из холодильника.</li></ul><p>Код для проверки:</p><code-example><script>`var fridge = new Fridge(500);\nfridge.enable();\nfridge.addFood({\n  title: "котлета",\n  calories: 100\n});\nfridge.addFood({\n  title: "сок",\n  calories: 30\n});\nfridge.addFood({\n  title: "зелень",\n  calories: 10\n});\nfridge.addFood({\n  title: "варенье",\n  calories: 150\n});\n\nfridge.removeFood("нет такой еды"); // без эффекта\nalert( fridge.getFood().length ); // 4\n\nvar dietItems = fridge.filterFood(function(item) {\n  return item.calories < 50;\n});\n\ndietItems.forEach(function(item) {\n  alert( item.title ); // сок, зелень\n  fridge.removeFood(item);\n});\n\nalert( fridge.getFood().length ); // 2`</script></code-example><p>В качестве исходного кода используйте решение <a data-load_page="73-3">предыдущей задачи</a>.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`function Machine(power) {\n  this._power = power;\n  this._enabled = false;\n\n  var self = this;\n\n  this.enable = function() {\n    self._enabled = true;\n  };\n\n  this.disable = function() {\n    self._enabled = false;\n  };\n}\n\nfunction Fridge(power) {\n  // унаследовать\n  Machine.apply(this, arguments);\n\n  var food = []; // приватное свойство food\n\n  this.addFood = function() {\n    if (!this._enabled) {\n      throw new Error("Холодильник выключен");\n    }\n    if (food.length + arguments.length >= this._power / 100) {\n      throw new Error("Нельзя добавить, не хватает мощности");\n    }\n    for (var i = 0; i < arguments.length; i++) {\n      food.push(arguments[i]); // добавить всё из arguments\n    }\n\n  };\n\n  this.getFood = function() {\n    // копируем еду в новый массив, чтобы манипуляции с ним не меняли food\n    return food.slice();\n  };\n\nMARK  this.filterFood = function(filter) {\nMARK    return food.filter(filter);\nMARK  };\nMARK&nbsp\nMARK  this.removeFood = function(item) {\nMARK    var idx = food.indexOf(item);\nMARK    if (idx != -1) food.splice(idx, 1);\nMARK  };\n}\n\nvar fridge = new Fridge(500);\nfridge.enable();\nfridge.addFood({\n  title: "котлета",\n  calories: 100\n});\nfridge.addFood({\n  title: "сок",\n  calories: 30\n});\nfridge.addFood({\n  title: "зелень",\n  calories: 10\n});\nfridge.addFood({\n  title: "варенье",\n  calories: 150\n});\n\nvar dietItems = fridge.filterFood(function(item) {\n  return item.calories < 50;\n});\n\nfridge.removeFood("нет такой еды"); // без эффекта\nalert( fridge.getFood().length ); // 4\n\ndietItems.forEach(function(item) {\n  alert( item.title ); // сок, зелень\n  fridge.removeFood(item);\n});\n\nalert( fridge.getFood().length ); // 2`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#13" name="13">Переопределите disable</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Переопределите метод <code>disable</code> холодильника, чтобы при наличии в нём еды он выдавал ошибку.</p><p>Код для проверки:</p><code-example><script>`var fridge = new Fridge(500);\nfridge.enable();\nfridge.addFood("кус-кус");\nfridge.disable(); // ошибка, в холодильнике есть еда`</script></code-example><p>В качестве исходного кода используйте решение <a data-load_page="73-4">предыдущей задачи</a>.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`function Machine(power) {\n  this._power = power;\n  this._enabled = false;\n\n  var self = this;\n\n  this.enable = function() {\n    self._enabled = true;\n  };\n\n  this.disable = function() {\n    self._enabled = false;\n  };\n}\n\nfunction Fridge(power) {\n  Machine.apply(this, arguments);\n\n  var food = []; // приватное свойство food\n\n  this.addFood = function() {\n    if (!this._enabled) {\n      throw new Error("Холодильник выключен");\n    }\n    if (food.length + arguments.length >= this._power / 100) {\n      throw new Error("Нельзя добавить, не хватает мощности");\n    }\n    for (var i = 0; i < arguments.length; i++) {\n      food.push(arguments[i]); // добавить всё из arguments\n    }\n\n  };\n\n  this.getFood = function() {\n    // копируем еду в новый массив, чтобы манипуляции с ним не меняли food\n    return food.slice();\n  };\n\n  this.filterFood = function(filter) {\n    return food.filter(filter);\n  };\n\n  this.removeFood = function(item) {\n    var idx = food.indexOf(item);\n    if (idx != -1) food.splice(idx, 1);\n  };\n\nMARK  var parentDisable = this.disable;\nMARK  this.disable = function() {\nMARK    if (food.length) {\nMARK      throw new Error("Нельзя выключить: внутри еда");\nMARK    }\nMARK    parentDisable();\nMARK  };\n}\n\nvar fridge = new Fridge(500);\nfridge.enable();\nfridge.addFood("кус-кус");\nfridge.disable(); // ошибка, в холодильнике есть еда`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Геттеры и сеттеры; ООП в прототипном стиле"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/functional-inheritance", disqus_identifier = "functional-inheritance", disqus_title = "\u0424\u0443\u043d\u043a\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u043e\u0435 \u043d\u0430\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u043d\u0438\u0435";</script></page-content></main>