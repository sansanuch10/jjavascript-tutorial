<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="69">ООП в функциональном стиле</a></nav-up><h1>Внутренний и внешний интерфейс</h1><p>Один из важнейших принципов ООП – отделение внутреннего интерфейса от внешнего.</p><p>Это – обязательная практика в разработке чего угодно сложнее hello world.</p><p>Чтобы это понять, отвлечемся от разработки и переведем взгляд на объекты реального мира.</p><p>Как правило, устройства, с которыми мы имеем дело, весьма сложны. Но <em>разделение интерфейса на внешний и внутренний</em> позволяет использовать их без малейших проблем.</p><h2><a name="0" href="#0">Пример из жизни</a></h2><p>Например, кофеварка. Простая снаружи: кнопка, индикатор, отверстия,… И, конечно, результат – кофе :)</p><figure><img src="coffee.jpg" style="max-width:240px" width="100%" <="" div=""></figure><p>Но внутри… (картинка из пособия по ремонту)</p><figure><img src="coffee-inside.jpg" style="max-width:239px" width="100%"></figure><p>Масса деталей. Но мы можем пользоваться ей, совершенно не зная об этом.</p><p>Кофеварки – довольно-таки надежны, не правда ли? Можно пользоваться годами, и только когда что-то пойдет не так – придется нести к мастеру.</p><p>Секрет надежности и простоты кофеварки – в том, что все детали отлажены и <em>спрятаны</em> внутри.</p><p>Если снять с кофеварки защитный кожух, то использование её будет более сложным (куда нажимать?) и опасным (током ударить может).</p><p>Как мы увидим, объекты очень схожи с кофеварками.</p><p>Только для того, чтобы прятать внутренние детали, используется не кожух, а специальные средства языка и соглашения.</p><h2><a name="1" href="#1">Внутренний и внешний интерфейс</a></h2><p>В программировании мы будем разделять методы и свойства объекта на две группы:</p><ul><li><em>Внутренний интерфейс</em> – это свойства и методы, доступ к которым может быть осуществлен только из других методов объекта, их также называют «приватными» (есть и другие термины, встретим их далее).</li><li><em>Внешний интерфейс</em> – это свойства и методы, доступные снаружи объекта, их называют «публичными».</li></ul><p>Если продолжить аналогию с кофеваркой – то, что спрятано внутри кофеварки: трубка кипятильника, нагревательный элемент, тепловой предохранитель и так далее – это её внутренний интерфейс.</p><p>Внутренний интерфейс используется для обеспечения работоспособности объекта, его детали используют друг друга. Например, трубка кипятильника подключена к нагревательному элементу.</p><p>Но снаружи кофеварка закрыта специальным кожухом, чтобы никто к ним не подобрался. Детали скрыты и недоступны. Виден лишь внешний интерфейс.</p><p>Получив объект, всё, что нужно для пользования им – это знать внешний интерфейс. О внутреннем же знать вообще не обязательно.</p><p>Это были общие слова по теории программирования.</p><p>Далее мы реализуем кофеварку на JavaScript с приватными и публичными свойствами. В кофеварке много деталей, мы конечно, не будем моделировать каждый винтик, а сосредоточимся на основных приёмах разработки.</p><h2><a name="2" href="#2">Шаг 1: публичное и приватное свойство</a></h2><p>Конструктор кофеварок будет называться <code>CoffeeMachine</code>.</p><code-example><script>`function CoffeeMachine(power) {\n  this.waterAmount = 0; // количество воды в кофеварке\n\n  alert( 'Создана кофеварка мощностью:&nbsp' + power + ' ватт' );\n}\n\n// создать кофеварку\nvar coffeeMachine = new CoffeeMachine(100);\n\n// залить воды\ncoffeeMachine.waterAmount = 200;`</script><code-toolbar></code-toolbar></code-example><p><strong>Локальные переменные, включая параметры конструктора, можно считать приватными свойствами.</strong></p><p>В примере выше это <code>power</code> – мощность кофеварки, которая указывается при создании и далее будет использована для расчёта времени кипячения.</p><p>К локальным переменным конструктора нельзя обратиться снаружи, но они доступны внутри самого конструктора.</p><p><strong>Свойства, записанные в <code>this</code>, можно считать публичными.</strong></p><p>Здесь свойство <code>waterAmount</code> записано в объект, а значит – доступно для модификации снаружи. Можно доливать и выливать воду в любом количестве.</p><important-><h3>Вопрос терминологии</h3><p>Далее мы будем называть <code>power</code> как «локальной переменной», так и «приватным свойством» объекта.</p><p>Это, смотря, с какой стороны посмотреть.</p><p>Термины «приватное свойство/метод», «публичное свойство/метод» относятся к общей теории ООП. А их конкретная реализация в языке программирования может быть различной.</p><p>Здесь ООП-принцип «приватного свойства» реализован через локальные переменные, поэтому и «локальная переменная» и «приватное свойство» – правильные термины, в зависимости от того, с какой точки зрения взглянуть – кода или архитектуры ООП.</p></important-><h2><a name="3" href="#3">Шаг 2: публичный и приватный методы</a></h2><p>Добавим публичный метод <code>run</code>, запускающий кофеварку, а также вспомогательные внутренние методы <code>getBoilTime</code> и <code>onReady</code>:</p><code-example><script>`function CoffeeMachine(power) {\n\n  this.waterAmount = 0;\n\nMARK  // расчёт времени для кипячения\nMARK  function getBoilTime() {\nMARK    return 1000; // точная формула расчета будет позже\nMARK  }\nMARK&nbsp\nMARK  // что делать по окончании процесса\nMARK  function onReady() {\nMARK    alert( 'Кофе готов!' );\nMARK  }\nMARK&nbsp\nMARK  this.run = function() {\nMARK    // setTimeout - встроенная функция,\nMARK    // она запустит onReady через getBoilTime() миллисекунд\nMARK    setTimeout(onReady, getBoilTime());\nMARK  };\n}\n\nvar coffeeMachine = new CoffeeMachine(100);\ncoffeeMachine.waterAmount = 200;\n\ncoffeeMachine.run();`</script><code-toolbar></code-toolbar></code-example><p>Приватные методы, такие как <code>onReady</code>, <code>getBoilTime</code> могут быть объявлены как вложенные функции.</p><p>В результате естественным образом получается, что доступ к ним (через замыкание) имеют только другие функции, объявленные в том же конструкторе.</p><h2><a name="4" href="#4">Шаг 3: константа</a></h2><p>Для расчёта времени на кипячение воды используется формула <code>c*m*ΔT / power</code>, где:</p><ul><li><code>c</code> – коэффициент теплоёмкости воды, физическая константа равная <code>4200</code>.</li><li><code>m</code> – масса воды, которую нужно нагреть.</li><li><code>ΔT</code> – температура, на которую нужно подогреть, будем считать, что изначально вода – комнатной температуры 20°С, то есть до 100° нужно греть на <code>ΔT=80</code>.</li><li><code>power</code> – мощность.</li></ul><p>Используем её в более реалистичном варианте <code>getBoilTime()</code>, включающем использование приватных свойств и константу:</p><code-example><script>`"use strict"\n\nfunction CoffeeMachine(power) {\n\n  this.waterAmount = 0;\n\nMARK  // физическая константа - удельная теплоёмкость воды для getBoilTime\nMARK  var WATER_HEAT_CAPACITY = 4200;\nMARK&nbsp\nMARK  // расчёт времени для кипячения\nMARK  function getBoilTime() {\nMARK    return this.waterAmount * WATER_HEAT_CAPACITY * 80 / power; // ошибка!\nMARK  }\n\n  // что делать по окончании процесса\n  function onReady() {\n    alert( 'Кофе готов!' );\n  }\n\n  this.run = function() {\n    setTimeout(onReady, getBoilTime());\n  };\n\n}\n\nvar coffeeMachine = new CoffeeMachine(1000);\ncoffeeMachine.waterAmount = 200;\n\ncoffeeMachine.run();`</script><code-toolbar></code-toolbar></code-example><p>Удельная теплоёмкость <code>WATER_HEAT_CAPACITY</code> выделена большими буквами, так как это константа.</p><p>Внимание, при запуске кода выше в методе <code>getBoilTime</code> будет ошибка. Как вы думаете, почему?</p><h2><a name="5" href="#5">Шаг 4: доступ к объекту из внутреннего метода</a></h2><p>Внутренний метод вызывается так: <code>getBoilTime()</code>. А чему при этом равен <code>this</code>?… Как вы наверняка помните, в современном стандарте он будет <code>undefined</code> (в старом – <code>window</code>), из-за этого при чтении <code>this.waterAmount</code> возникнет ошибка!</p><p>Её можно решить, если вызвать <code>getBoilTime</code> с явным указанием контекста: <code>getBoilTime.call(this)</code>:</p><code-example><script>`function CoffeeMachine(power) {\n  this.waterAmount = 0;\n  var WATER_HEAT_CAPACITY = 4200;\n\n  function getBoilTime() {\n    return this.waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n  }\n\n  function onReady() {\n    alert( 'Кофе готов!' );\n  }\n\n  this.run = function() {\nMARK    setTimeout(onReady, getBoilTime.call(this));\n  };\n\n}\n\n// создаю кофеварку, мощностью 100000W чтобы кипятила быстро\nvar coffeeMachine = new CoffeeMachine(100000);\ncoffeeMachine.waterAmount = 200;\n\ncoffeeMachine.run();`</script><code-toolbar></code-toolbar></code-example><p>Такой подход будет работать, но он не очень-то удобен. Ведь получается, что теперь везде, где мы хотим вызвать <code>getBoilTime</code>, нужно явно указывать контекст, т.е. писать <code>getBoilTime.call(this)</code>.</p><p>К счастью существуют более элегантные решения.</p><h3><a name="10" href="#10">Привязка через bind</a></h3><p>Можно при объявлении привязать <code>getBoilTime</code> к объекту через <code>bind</code>, тогда вопрос контекста отпадёт сам собой:</p><code-example><script>`function CoffeeMachine(power) {\n  this.waterAmount = 0;\n\n  var WATER_HEAT_CAPACITY = 4200;\n\nMARK  var getBoilTime = function() {\nMARK    return this.waterAmount * WATER_HEAT_CAPACITY * 80 / power;\nMARK  }.bind(this);\n\n  function onReady() {\n    alert( 'Кофе готов!' );\n  }\n\n  this.run = function() {\nMARK    setTimeout(onReady, getBoilTime());\n  };\n\n}\n\nvar coffeeMachine = new CoffeeMachine(100000);\ncoffeeMachine.waterAmount = 200;\n\ncoffeeMachine.run();`</script><code-toolbar></code-toolbar></code-example><p>Это решение будет работать, теперь функцию можно просто вызывать без <code>call</code>. Но объявление функции стало менее красивым.</p><h3><a name="11" href="#11">Сохранение this в замыкании</a></h3><p>Пожалуй, самый удобный и часто применяемый путь решения состоит в том, чтобы предварительно скопировать <code>this</code> во вспомогательную переменную и обращаться из внутренних функций уже к ней.</p><p>Вот так:</p><code-example><script>`function CoffeeMachine(power) {\n  this.waterAmount = 0;\n\n  var WATER_HEAT_CAPACITY = 4200;\n\nMARK  var self = this;\nMARK&nbsp\nMARK  function getBoilTime() {\nMARK      return self.waterAmount * WATER_HEAT_CAPACITY * 80 / power;\nMARK    }\n\n  function onReady() {\n    alert( 'Кофе готов!' );\n  }\n\n  this.run = function() {\n    setTimeout(onReady, getBoilTime());\n  };\n\n}\n\nvar coffeeMachine = new CoffeeMachine(100000);\ncoffeeMachine.waterAmount = 200;\n\ncoffeeMachine.run();`</script><code-toolbar></code-toolbar></code-example><p>Теперь <code>getBoilTime</code> получает <code>self</code> из замыкания.</p><p><strong>Конечно, чтобы это работало, мы не должны изменять <code>self</code>, а все приватные методы, которые хотят иметь доступ к текущему объекту, должны использовать внутри себя <code>self</code> вместо <code>this</code>.</strong></p><p>Вместо <code>self</code> можно использовать любое другое имя переменной, например <code>var me = this</code>.</p><h2><a name="6" href="#6">Итого</a></h2><p>Итак, мы сделали кофеварку с публичными и приватными методами и заставили их корректно работать.</p><p>В терминологии ООП отделение и защита внутреннего интерфейса называется <a href="http://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F_%28%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%29">инкапсуляция</a>.</p><p>Кратко перечислим бонусы, которые она даёт:</p><dl><dt>Защита пользователей от выстрела себе в ногу</dt><dd><p>Представьте, команда разработчиков пользуется кофеваркой. Кофеварка создана фирмой «Лучшие Кофеварки» и, в общем, работает хорошо, но с неё сняли защитный кожух и, таким образом, внутренний интерфейс стал доступен.</p><p>Все разработчики цивилизованны – и пользуются кофеваркой как обычно. Но хитрый Вася решил, что он самый умный, и подкрутил кое-что внутри кофеварки, чтобы кофе заваривался покрепче. Вася не знал, что те изменения, которые он произвёл, приведут к тому, что кофеварка испортится через два дня.</p><p>Виноват, разумеется, не только Вася, но и тот, кто снял защитный кожух с кофеварки, и тем самым позволил Васе проводить манипуляции.</p><p>В программировании – то же самое. Если пользователь объекта будет менять то, что не рассчитано на изменение снаружи – последствия могут быть непредсказуемыми.</p></dd><dt>Удобство в поддержке</dt><dd><p>Ситуация в программировании сложнее, чем с кофеваркой, т.к. кофеварку один раз купили и всё, а программа может улучшаться и дорабатываться.</p><p><strong>При наличии чётко выделенного внешнего интерфейса, разработчик может свободно менять внутренние свойства и методы, без оглядки на коллег.</strong></p><p>Гораздо легче разрабатывать, если знаешь, что ряд методов (все внутренние) можно переименовывать, менять их параметры, и вообще, переписать как угодно, так как внешний код к ним абсолютно точно не обращается.</p><p>Ближайшая аналогия в реальной жизни – это когда выходит «новая версия» кофеварки, которая работает гораздо лучше. Разработчик мог переделать всё внутри, но пользоваться ей по-прежнему просто, так как внешний интерфейс сохранён.</p></dd><dt>Управление сложностью</dt><dd><p>Люди обожают пользоваться вещами, которые просты с виду. А что внутри – дело десятое.</p><p>Программисты здесь не исключение.</p><p><strong>Всегда удобно, когда детали реализации скрыты, и доступен простой, понятно документированный внешний интерфейс.</strong></p></dd></dl><h2 id="tasks"><a href="#7" name="7">Задачи (1)</a></h2><task-content><h3><a href="#12" name="12">Добавить метод и свойство кофеварке</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Улучшите готовый код кофеварки, который дан ниже: добавьте в кофеварку <em>публичный</em> метод <code>stop()</code>, который будет останавливать кипячение (через <code>clearTimeout</code>).</p><code-example><script>`function CoffeeMachine(power) {\n  this.waterAmount = 0;\n\n  var WATER_HEAT_CAPACITY = 4200;\n\n  var self = this;\n\n  function getBoilTime() {\n    return self.waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n  }\n\n  function onReady() {\n    alert( 'Кофе готово!' );\n  }\n\n  this.run = function() {\n    setTimeout(onReady, getBoilTime());\n  };\n\n}`</script><code-toolbar></code-toolbar></code-example><p>Вот такой код должен ничего не выводить:</p><code-example><script>`var coffeeMachine = new CoffeeMachine(50000);\ncoffeeMachine.waterAmount = 200;\n\ncoffeeMachine.run();\ncoffeeMachine.stop(); // кофе приготовлен не будет`</script></code-example><p>P.S. Текущую температуру воды вычислять и хранить не требуется.</p><p>P.P.S. При решении вам, скорее всего, понадобится добавить <em>приватное</em> свойство <code>timerId</code>, которое будет хранить текущий таймер.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Кофеварка с новым методом:</p><code-example><script>`function CoffeeMachine(power) {\n  this.waterAmount = 0;\n\n  var WATER_HEAT_CAPACITY = 4200;\nMARK  var timerId;\n  var self = this;\n\n  function getBoilTime() {\n    return self.waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n  }\n\n  function onReady() {\n    alert( 'Кофе готово!' );\n  }\n\n  this.run = function() {\nMARK    timerId = setTimeout(onReady, getBoilTime());\n  };\n\nMARK  this.stop = function() {\nMARK    clearTimeout(timerId)\nMARK  };\n}\n\nvar coffeeMachine = new CoffeeMachine(50000);\ncoffeeMachine.waterAmount = 200;\n\ncoffeeMachine.run();\ncoffeeMachine.stop(); // кофе приготовлен не будет`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Введение; Геттеры и сеттеры"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/internal-external-interface",disqus_identifier="internal-external-interface",disqus_title="\u0412\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u0438\u0439 \u0438 \u0432\u043d\u0435\u0448\u043d\u0438\u0439 \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441";</script></page-content></main>