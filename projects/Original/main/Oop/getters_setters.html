<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="69">ООП в функциональном стиле</a></nav-up><h1>Геттеры и сеттеры</h1><p>Для <em>управляемого</em> доступа к состоянию объекта используют специальные функции, так называемые «геттеры» и «сеттеры».</p><h2><a name="0" href="#0">Геттер и сеттер для воды</a></h2><p>На текущий момент количество воды в кофеварке является публичным свойством <code>waterAmount</code>:</p><code-example><script>`function CoffeeMachine(power) {\n  // количество воды в кофеварке\n  this.waterAmount = 0;\n\n  ...\n}`</script><code-toolbar></code-toolbar></code-example><p>Это немного опасно. Ведь в это свойство можно записать произвольное количество воды, хоть весь мировой океан.</p><code-example><script>`// не помещается в кофеварку!\vcoffeeMachine.waterAmount = 1000000;`</script></code-example><p>Это ещё ничего, гораздо хуже, что можно наоборот – вылить больше, чем есть:</p><code-example><script>`// и не волнует, было ли там столько воды вообще!\ncoffeeMachine.waterAmount -= 1000000;`</script></code-example><p>Так происходит потому, что свойство полностью доступно снаружи.</p><p>Чтобы не было таких казусов, нам нужно ограничить контроль над свойством со стороны внешнего кода.</p><p><strong>Для лучшего контроля над свойством его делают приватным, а запись значения осуществляется через специальный метод, который называют <em>«сеттер»</em> (setter method).</strong></p><p>Типичное название для сеттера – <code>setСвойство</code>, например, в случае с кофеваркой таким сеттером будет метод <code>setWaterAmount</code>:</p><code-example><script>`function CoffeeMachine(power, capacity) { // capacity - ёмкость кофеварки\n  var waterAmount = 0;\n\n  var WATER_HEAT_CAPACITY = 4200;\n\n  function getTimeToBoil() {\n    return waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n  }\n\nMARK  // "умная" установка свойства\nMARK  this.setWaterAmount = function(amount) {\nMARK    if (amount < 0) {\nMARK      throw new Error("Значение должно быть положительным");\nMARK    }\nMARK    if (amount > capacity) {\nMARK      throw new Error("Нельзя залить воды больше, чем&nbsp" + capacity);\nMARK    }\nMARK&nbsp\nMARK    waterAmount = amount;\nMARK  };\n\n  function onReady() {\n    alert( 'Кофе готов!' );\n  }\n\n  this.run = function() {\n    setTimeout(onReady, getTimeToBoil());\n  };\n\n}\n\nvar coffeeMachine = new CoffeeMachine(1000, 500);\ncoffeeMachine.setWaterAmount(600); // упс, ошибка!`</script><code-toolbar></code-toolbar></code-example><p>Теперь <code>waterAmount</code> – внутреннее свойство, его можно записать (через сеттер), но, увы, нельзя прочитать.</p><p><strong>Для того, чтобы дать возможность внешнему коду узнать его значение, создадим специальную функцию – «геттер» (getter method).</strong></p><p>Геттеры обычно имеют название вида <code>getСвойство</code>, в данном случае <code>getWaterAmount</code>:</p><code-example><script>`function CoffeeMachine(power, capacity) {\n  //...\n  this.setWaterAmount = function(amount) {\n    if (amount < 0) {\n      throw new Error("Значение должно быть положительным");\n    }\n    if (amount > capacity) {\n      throw new Error("Нельзя залить воды больше, чем&nbsp" + capacity);\n    }\n\n    waterAmount = amount;\n  };\n\nMARK  this.getWaterAmount = function() {\nMARK    return waterAmount;\nMARK  };\n}\n\nvar coffeeMachine = new CoffeeMachine(1000, 500);\ncoffeeMachine.setWaterAmount(450);\nalert( coffeeMachine.getWaterAmount() ); // 450`</script><code-toolbar></code-toolbar></code-example><h2><a name="1" href="#1">Единый геттер-сеттер</a></h2><p>Для большего удобства иногда делают единый метод, который называется так же, как свойство и отвечает <em>и за запись, и за чтение</em>.</p><p>При вызове без параметров такой метод возвращает свойство, а при передаче параметра – назначает его.</p><p>Выглядит это так:</p><code-example><script>`function CoffeeMachine(power, capacity) {\n  var waterAmount = 0;\n\nMARK  this.waterAmount = function(amount) {\n    // вызов без параметра, значит режим геттера, возвращаем свойство\n    if (!arguments.length) return waterAmount;\n\n    // иначе режим сеттера\n    if (amount < 0) {\n      throw new Error("Значение должно быть положительным");\n    }\n    if (amount > capacity) {\n      throw new Error("Нельзя залить воды больше, чем&nbsp" + capacity);\n    }\n\n    waterAmount = amount;\n  };\n\n}\n\nvar coffeeMachine = new CoffeeMachine(1000, 500);\n\n// пример использования\nMARKcoffeeMachine.waterAmount(450);\nJMARKalert( coffeeMachine.waterAmount() ); // 450`</script><code-toolbar></code-toolbar></code-example><p>Единый геттер-сеттер используется реже, чем две отдельные функции, но в некоторых JavaScript-библиотеках, например <a href="http://jquery.com">jQuery</a> и <a href="http://d3js.org">D3</a>, подобный подход принят на уровне концепта.</p><h2><a name="2" href="#2">Итого</a></h2><ul><li>Для большего контроля над присвоением и чтением значения вместо свойства делают «функцию-геттер» и «функцию-сеттер», геттер возвращает значение, сеттер – устанавливает.</li><li>Если свойство предназначено только для чтения, то может быть только геттер, только для записи – только сеттер.</li><li>В качестве альтернативы к паре геттер/сеттер применяют единую функцию, которая без аргументов ведёт себя как геттер, а с аргументом – как сеттер.</li></ul><p>Также можно организовать геттеры/сеттеры для свойства, не меняя структуры кода, через <a data-load_page="58">дескрипторы свойств</a>.</p><h2 id="tasks"><a href="#3" name="3">Задачи (5)</a></h2><task-content><h3><a href="#6" name="6">Написать объект с геттерами и сеттерами</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>Напишите конструктор <code>User</code> для создания объектов:</p><ul><li>С приватными свойствами имя <code>firstName</code> и фамилия <code>surname</code>.</li><li>С сеттерами для этих свойств.</li><li>С геттером <code>getFullName()</code>, который возвращает полное имя.</li></ul><p>Должен работать так:</p><code-example><script>`function User() {\n  /* ваш код */\n}\n\nvar user = new User();\nuser.setFirstName("Петя");\nuser.setSurname("Иванов");\n\nalert( user.getFullName() ); // Петя Иванов`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Решение:</p><code-example><script>`function User() {\n\n  var firstName, surname;\n\n  this.setFirstName = function(newFirstName) {\n    firstName = newFirstName;\n  };\n\n  this.setSurname = function(newSurname) {\n    surname = newSurname;\n  };\n\n  this.getFullName = function() {\n    return firstName + ' ' + surname;\n  }\n}\n\nvar user = new User();\nuser.setFirstName("Петя");\nuser.setSurname("Иванов");\n\nalert( user.getFullName() ); // Петя Иванов`</script><code-toolbar></code-toolbar></code-example><p>Обратим внимание, что для «геттера» <code>getFullName</code> нет соответствующего свойства объекта, он конструирует ответ «на лету». Это нормально. Одна из целей существования геттеров/сеттеров – как раз и есть изоляция внутренних свойств объекта, чтобы можно было их как угодно менять, генерировать «на лету», а внешний интерфейс оставался тем же.</p></task-answer></task-content><task-content><h3><a href="#7" name="7">Добавить геттер для power</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Добавьте кофеварке геттер для приватного свойства <code>power</code>, чтобы внешний код мог узнать мощность кофеварки.</p><p>Исходный код:</p><code-example><script>`function CoffeeMachine(power, capacity) {\n  //...\n  this.setWaterAmount = function(amount) {\n    if (amount < 0) {\n      throw new Error("Значение должно быть положительным");\n    }\n    if (amount > capacity) {\n      throw new Error("Нельзя залить воды больше, чем&nbsp" + capacity);\n    }\n\n    waterAmount = amount;\n  };\n\n  this.getWaterAmount = function() {\n    return waterAmount;\n  };\n\n}`</script></code-example><p>Обратим внимание, что ситуация, когда у свойства <code>power</code> есть геттер, но нет сеттера – вполне обычна.</p><p>Здесь это означает, что мощность <code>power</code> можно указать лишь при создании кофеварки и в дальнейшем её можно прочитать, но нельзя изменить.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer style=""><close- title="закрыть" data-close_answer=""></close-><code-example><script>`function CoffeeMachine(power, capacity) {\n  //...\n  this.setWaterAmount = function(amount) {\n    if (amount < 0) {\n      throw new Error("Значение должно быть положительным");\n    }\n    if (amount > capacity) {\n      throw new Error("Нельзя залить воды больше, чем&nbsp" + capacity);\n    }\n\n    waterAmount = amount;\n  };\n\n  this.getWaterAmount = function() {\n    return waterAmount;\n  };\n\nMARK  this.getPower = function() {\nMARK    return power;\nMARK  };\n}`</script></code-example></task-answer></task-content><task-content><h3><a href="#8" name="8">Добавить публичный метод кофеварке</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Добавьте кофеварке публичный метод <code>addWater(amount)</code>, который будет добавлять воду.</p><p>При этом, конечно же, должны происходить все необходимые проверки – на положительность и превышение ёмкости.</p><p>Исходный код:</p><code-example><script>`function CoffeeMachine(power, capacity) {\n  var waterAmount = 0;\n\n  var WATER_HEAT_CAPACITY = 4200;\n\n  function getTimeToBoil() {\n    return waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n  }\n\n  this.setWaterAmount = function(amount) {\n    if (amount < 0) {\n      throw new Error("Значение должно быть положительным");\n    }\n    if (amount > capacity) {\n      throw new Error("Нельзя залить больше, чем&nbsp" + capacity);\n    }\n\n    waterAmount = amount;\n  };\n\n  function onReady() {\n    alert( 'Кофе готов!' );\n  }\n\n  this.run = function() {\n    setTimeout(onReady, getTimeToBoil());\n  };\n\n}`</script></code-example><p>Вот такой код должен приводить к ошибке:</p><code-example><script>`var coffeeMachine = new CoffeeMachine(100000, 400);\ncoffeeMachine.addWater(200);\ncoffeeMachine.addWater(100);\ncoffeeMachine.addWater(300); // Нельзя залить больше, чем 400\ncoffeeMachine.run();`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>В решении ниже <code>addWater</code> будет просто вызывать <code>setWaterAmount</code>.</p><code-example><script>`function CoffeeMachine(power, capacity) {\n  var waterAmount = 0;\n\n  var WATER_HEAT_CAPACITY = 4200;\n\n  function getTimeToBoil() {\n    return waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n  }\n\n  this.setWaterAmount = function(amount) {\n    if (amount < 0) {\n      throw new Error("Значение должно быть положительным");\n    }\n    if (amount > capacity) {\n      throw new Error("Нельзя залить больше, чем&nbsp" + capacity);\n    }\n\n    waterAmount = amount;\n  };\n\nMARK  this.addWater = function(amount) {\nMARK    this.setWaterAmount(waterAmount + amount);\nMARK  };\n\n  function onReady() {\n    alert( 'Кофе готов!' );\n  }\n\n  this.run = function() {\n    setTimeout(onReady, getTimeToBoil());\n  };\n\n}\n\nvar coffeeMachine = new CoffeeMachine(100000, 400);\ncoffeeMachine.addWater(200);\ncoffeeMachine.addWater(100);\ncoffeeMachine.addWater(300); // Нельзя залить больше..\ncoffeeMachine.run();`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#9" name="9">Создать сеттер для onReady</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Обычно когда кофе готов, мы хотим что-то сделать, например выпить его.</p><p>Сейчас при готовности срабатывает функция <code>onReady</code>, но она жёстко задана в коде:</p><code-example><script>`function CoffeeMachine(power, capacity) {\n  var waterAmount = 0;\n\n  var WATER_HEAT_CAPACITY = 4200;\n\n  function getTimeToBoil() {\n    return waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n  }\n\n  this.setWaterAmount = function(amount) {\n    // ... проверки пропущены для краткости\n    waterAmount = amount;\n  };\n\n  this.getWaterAmount = function(amount) {\n    return waterAmount;\n  };\n\nMARK  function onReady() {\nMARK      alert( 'Кофе готов!' );\nMARK    }\n\n  this.run = function() {\n    setTimeout(onReady, getTimeToBoil());\n  };\n\n}`</script></code-example><p>Создайте сеттер <code>setOnReady</code>, чтобы код снаружи мог назначить свой <code>onReady</code>, вот так:</p><code-example><script>`var coffeeMachine = new CoffeeMachine(20000, 500);\ncoffeeMachine.setWaterAmount(150);\n\nMARKcoffeeMachine.setOnReady(function() {\nMARK  var amount = coffeeMachine.getWaterAmount();\nMARK  alert( 'Готов кофе:&nbsp' + amount + 'мл' ); // Кофе готов: 150 мл\nMARK});\n\ncoffeeMachine.run();`</script></code-example><p>P.S. Значение <code>onReady</code> по умолчанию должно быть таким же, как и раньше.</p><p>P.P.S. Постарайтесь сделать так, чтобы <code>setOnReady</code> можно было вызвать не только до, но и <em>после</em> запуска кофеварки, то есть чтобы функцию <code>onReady</code> можно было изменить в любой момент до её срабатывания.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`function CoffeeMachine(power, capacity) {\n  var waterAmount = 0;\n\n  var WATER_HEAT_CAPACITY = 4200;\n\n  function getTimeToBoil() {\n    return waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n  }\n\n  this.setWaterAmount = function(amount) {\n    // ... проверки пропущены для краткости\n    waterAmount = amount;\n  };\n\n  this.getWaterAmount = function(amount) {\n    return waterAmount;\n  };\n\n  function onReady() {\n    alert( 'Кофе готов!' );\n  }\n\nMARK  this.setOnReady = function(newOnReady) {\nMARK    onReady = newOnReady;\nMARK  };\n\n  this.run = function() {\nMARK    setTimeout(function() {\nMARK      onReady();\nMARK    }, getTimeToBoil());\n  };\n\n}\n\nvar coffeeMachine = new CoffeeMachine(20000, 500);\ncoffeeMachine.setWaterAmount(150);\n\ncoffeeMachine.run();\n\nMARKcoffeeMachine.setOnReady(function() {\nMARK  var amount = coffeeMachine.getWaterAmount();\nMARK  alert( 'Готов кофе:&nbsp' + amount + 'мл' ); // Готов кофе: 150 мл\nMARK});`</script><code-toolbar></code-toolbar></code-example><p>Обратите внимание на два момента в решении:</p><ol><li><p>В сеттере   <code>setOnReady</code> параметр называется   <code>newOnReady</code>. Мы не можем назвать его   <code>onReady</code>, так как тогда изнутри сеттера мы никак не доберёмся до внешнего (старого значения):</p><code-example>   <script>`// нерабочий вариант\nthis.setOnReady = function(onReady) {\n  onReady = onReady; // ??? внешняя переменная onReady недоступна\n};`</script></code-example></li><li><p>Чтобы   <code>setOnReady</code> можно было вызывать в любое время, в   <code>setTimeout</code> передаётся не   <code>onReady</code>, а анонимная функция   <code>function() { onReady() }</code>, которая возьмёт текущий (установленный последним)   <code>onReady</code> из замыкания.</p></li></ol></task-answer></task-content><task-content><h3><a href="#10" name="10">Добавить метод isRunning</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Из внешнего кода мы хотели бы иметь возможность понять – запущена кофеварка или нет.</p><p>Для этого добавьте кофеварке публичный метод <code>isRunning()</code>, который будет возвращать <code>true</code>, если она запущена и <code>false</code>, если нет.</p><p>Нужно, чтобы такой код работал:</p><code-example><script>`var coffeeMachine = new CoffeeMachine(20000, 500);\ncoffeeMachine.setWaterAmount(100);\n\nalert( 'До:&nbsp' + coffeeMachine.isRunning() ); // До: false\n\ncoffeeMachine.run();\nalert( 'В процессе:&nbsp' + coffeeMachine.isRunning() ); // В процессе: true\n\ncoffeeMachine.setOnReady(function() {\n  alert( "После:&nbsp" + coffeeMachine.isRunning() ); // После: false\n});`</script></code-example><p>Исходный код возьмите из решения <a data-load_page="72-4">предыдущей задачи</a>.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Код решения модифицирует функцию <code>run</code> и добавляет приватный идентификатор таймера <code>timerId</code>, по наличию которого мы судим о состоянии кофеварки:</p><code-example><script>`function CoffeeMachine(power, capacity) {\n  var waterAmount = 0;\n\nMARK  var timerId;\nMARK&nbsp\nMARK  this.isRunning = function() {\nMARK    return !!timerId;\nMARK  };\n\n  var WATER_HEAT_CAPACITY = 4200;\n\n  function getTimeToBoil() {\n    return waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n  }\n\n  this.setWaterAmount = function(amount) {\n    // ... проверки пропущены для краткости\n    waterAmount = amount;\n  };\n\n  this.getWaterAmount = function(amount) {\n    return waterAmount;\n  };\n\n  function onReady() {\n    alert( 'Кофе готов!' );\n  }\n\n  this.setOnReady = function(newOnReady) {\n    onReady = newOnReady;\n  };\n\n  this.run = function() {\nMARK    timerId = setTimeout(function() {\nMARK      timerId = null;\nMARK      onReady();\nMARK    }, getTimeToBoil());\nMARK  };\n\n}\n\nvar coffeeMachine = new CoffeeMachine(20000, 500);\ncoffeeMachine.setWaterAmount(100);\n\nalert( 'До:&nbsp' + coffeeMachine.isRunning() ); // До: false\n\ncoffeeMachine.run();\nalert( 'В процессе:&nbsp' + coffeeMachine.isRunning() ); // В процессе: true\n\ncoffeeMachine.setOnReady(function() {\n  alert( "После:&nbsp" + coffeeMachine.isRunning() ); // После: false\n});`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Внутренний и внешний интерфейс; Функциональное наследование"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/getters-setters", disqus_identifier = "getters-setters", disqus_title = "\u0413\u0435\u0442\u0442\u0435\u0440\u044b \u0438 \u0441\u0435\u0442\u0442\u0435\u0440\u044b";</script></page-content></main>