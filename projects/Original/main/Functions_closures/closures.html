<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="46">Замыкания, область видимости</a></nav-up><h1>Замыкания, функции изнутри</h1><p>В этой главе мы продолжим рассматривать, как работают переменные, и, как следствие, познакомимся с замыканиями. От глобального объекта мы переходим к работе внутри функций.</p><h2><a name="0" href="#0">Лексическое окружение</a></h2><p>Все переменные внутри функции – это свойства специального внутреннего объекта <code>LexicalEnvironment</code>, который создаётся при её запуске.</p><p>Мы будем называть этот объект «лексическое окружение» или просто «объект переменных».</p><p>При запуске функция создает объект <code>LexicalEnvironment</code>, записывает туда аргументы, функции и переменные. Процесс инициализации выполняется в том же порядке, что и для глобального объекта, который, вообще говоря, является частным случаем лексического окружения.</p><p>В отличие от <code>window</code>, объект <code>LexicalEnvironment</code> является внутренним, он скрыт от прямого доступа.</p><h3><a name="9" href="#9">Пример</a></h3><p>Посмотрим пример, чтобы лучше понимать, как это работает:</p><code-example><script>`function sayHi(name) {\n  var phrase = \"Привет,&nbsp\" + name;\n  alert( phrase );\n}\n\nsayHi('Вася');`</script></code-example><p>При вызове функции:</p><ol><li><p>До выполнения первой строчки её кода, на стадии инициализации, интерпретатор создает пустой объект <code>LexicalEnvironment</code> и заполняет его.</p><p>В данном случае туда попадает аргумент <code>name</code> и единственная переменная <code>phrase</code>:</p><code-example><script>`function sayHi(name) {\nMARK  // LexicalEnvironment = { name: 'Вася', phrase: undefined }\n  var phrase = \"Привет,&nbsp\" + name;\n  alert( phrase );\n}\n\nsayHi('Вася');`</script></code-example></li><li><p>Функция выполняется.</p><p>Во время выполнения происходит присвоение локальной переменной <code>phrase</code>, то есть, другими словами, присвоение свойству <code>LexicalEnvironment.phrase</code> нового значения:</p><code-example><script>`function sayHi(name) {\n  // LexicalEnvironment = { name: 'Вася', phrase: undefined }\n  var phrase = \"Привет,&nbsp\" + name;\n\nMARK  // LexicalEnvironment = { name: 'Вася', phrase: 'Привет, Вася'}\n  alert( phrase );\n}\n\nsayHi('Вася');`</script></code-example></li><li><p>В конце выполнения функции объект с переменными обычно выбрасывается и память очищается. В примерах выше так и происходит. Через некоторое время мы рассмотрим более сложные ситуации, при которых объект с переменными сохраняется и после завершения функции.</p></li></ol><important-><h3>Тонкости спецификации</h3><p>Если почитать спецификацию ECMA-262, то мы увидим, что речь идёт о двух объектах: <code>VariableEnvironment</code> и <code>LexicalEnvironment</code>.</p><p>Но там же замечено, что в реализациях эти два объекта могут быть объединены. Так что мы избегаем лишних деталей и используем везде термин <code>LexicalEnvironment</code>, это достаточно точно позволяет описать происходящее.</p><p>Более формальное описание находится в спецификации ECMA-262, секции 10.2-10.5 и 13.</p></important-><h2><a name="1" href="#1">Доступ ко внешним переменным</a></h2><p>Из функции мы можем обратиться не только к локальной переменной, но и к внешней:</p><code-example><script>`var userName = "Вася";\n\nfunction sayHi() {\n  alert( userName ); // "Вася"\n}`</script></code-example><p><strong>Интерпретатор, при доступе к переменной, сначала пытается найти переменную в текущем <code>LexicalEnvironment</code>, а затем, если её нет – ищет во внешнем объекте переменных. В данном случае им является <code>window</code>.</strong></p><p>Такой порядок поиска возможен благодаря тому, что ссылка на внешний объект переменных хранится в специальном внутреннем свойстве функции, которое называется <code>[[Scope]]</code>. Это свойство закрыто от прямого доступа, но знание о нём очень важно для понимания того, как работает JavaScript.</p><p><strong>При создании функция получает скрытое свойство <code>[[Scope]]</code>, которое ссылается на лексическое окружение, в котором она была создана.</strong></p><p>В примере выше таким окружением является <code>window</code>, так что создаётся свойство:</p><code-example><script>`sayHi.[[Scope]] = window`</script></code-example><p>Это свойство никогда не меняется. Оно всюду следует за функцией, привязывая её, таким образом, к месту своего рождения.</p><p>При запуске функции её объект переменных <code>LexicalEnvironment</code> получает ссылку на «внешнее лексическое окружение» со значением из <code>[[Scope]]</code>.</p><p>Если переменная не найдена в функции – она будет искаться снаружи.</p><p>Именно благодаря этой механике в примере выше <code>alert(userName)</code> выводит внешнюю переменную. На уровне кода это выглядит как поиск во внешней области видимости, вне функции.</p><p>Если обобщить:</p><ul><li>Каждая функция при создании получает ссылку <code>[[Scope]]</code> на объект с переменными, в контексте которого была создана.</li><li>При запуске функции создаётся новый объект с переменными <code>LexicalEnvironment</code>. Он получает ссылку на внешний объект переменных из <code>[[Scope]]</code>.</li><li>При поиске переменных он осуществляется сначала в текущем объекте переменных, а потом – по этой ссылке.</li></ul><p>Выглядит настолько просто, что непонятно – зачем вообще говорить об этом <code>[[Scope]]</code>, об объектах переменных. Сказали бы: «Функция читает переменные снаружи» – и всё. Но знание этих деталей позволит нам легко объяснить и понять более сложные ситуации, с которыми мы столкнёмся далее.</p><h2><a name="2" href="#2">Всегда текущее значение</a></h2><p>Значение переменной из внешней области берётся всегда текущее. Оно может быть уже не то, что было на момент создания функции.</p><p>Например, в коде ниже функция <code>sayHi</code> берёт <code>phrase</code> из внешней области:</p><code-example><script>`var phrase = 'Привет';\n\nfunction sayHi(name) {\n  alert(phrase + ',&nbsp' + name);\n}\n\nMARKsayHi('Вася');  // Привет, Вася (*)\n\nphrase = 'Пока';\n\nMARKsayHi('Вася'); // Пока, Вася (**)`</script><code-toolbar></code-toolbar></code-example><p>На момент первого запуска <code>(*)</code>, переменная <code>phrase</code> имела значение <code>'Привет'</code>, а ко второму <code>(**)</code> изменила его на <code>'Пока'</code>.</p><p>Это естественно, ведь для доступа к внешней переменной функция по ссылке <code>[[Scope]]</code> обращается во внешний объект переменных и берёт то значение, которое там есть на момент обращения.</p><h2><a name="3" href="#3">Вложенные функции</a></h2><p>Внутри функции можно объявлять не только локальные переменные, но и другие функции.</p><p>К примеру, вложенная функция может помочь лучше организовать код:</p><code-example><script>`function sayHiBye(firstName, lastName) {\n\n  alert( "Привет,&nbsp" + getFullName() );\n  alert( "Пока,&nbsp" + getFullName() );\n\nMARK  function getFullName() {\nMARK    return firstName + "&nbsp" + lastName;\nMARK  }\n\n}\n\nsayHiBye("Вася", "Пупкин"); // Привет, Вася Пупкин ; Пока, Вася Пупкин`</script><code-toolbar></code-toolbar></code-example><p>Здесь, для удобства, создана вспомогательная функция <code>getFullName()</code>.</p><p>Вложенные функции получают <code>[[Scope]]</code> так же, как и глобальные. В нашем случае:</p><code-example><script>`getFullName.[[Scope]] = объект переменных текущего запуска sayHiBye`</script></code-example><p>Благодаря этому <code>getFullName()</code> получает снаружи <code>firstName</code> и <code>lastName</code>.</p><p>Заметим, что если переменная не найдена во внешнем объекте переменных, то она ищется в ещё более внешнем (через <code>[[Scope]]</code> внешней функции), то есть, такой пример тоже будет работать:</p><code-example><script>`var phrase = 'Привет';\n\nfunction say() {\n\n  function go() {\n    alert( phrase ); // найдёт переменную снаружи\n  }\n\n  go();\n}\n\nsay();`</script><code-toolbar></code-toolbar></code-example><h2><a name="4" href="#4">Возврат функции</a></h2><p>Рассмотрим более «продвинутый» вариант, при котором внутри одной функции создаётся другая и возвращается в качестве результата.</p><p>В разработке интерфейсов это совершенно стандартный приём, функция затем может назначаться как обработчик действий посетителя.</p><p>Здесь мы будем создавать функцию-счётчик, которая считает свои вызовы и возвращает их текущее число.</p><p>В примере ниже <code>makeCounter</code> создает такую функцию:</p><code-example><script>`function makeCounter() {\nMARK  var currentCount = 1;\n\n  return function() { // (**)\n    return currentCount++;\n  };\n}\n\nvar counter = makeCounter(); // (*)\n\n// каждый вызов увеличивает счётчик и возвращает результат\nalert( counter() ); // 1\nalert( counter() ); // 2\nalert( counter() ); // 3\n\n// создать другой счётчик, он будет независим от первого\nvar counter2 = makeCounter();\nalert( counter2() ); // 1`</script><code-toolbar></code-toolbar></code-example><p>Как видно, мы получили два независимых счётчика <code>counter</code> и <code>counter2</code>, каждый из которых незаметным снаружи образом сохраняет текущее количество вызовов.</p><p>Где? Конечно, во внешней переменной <code>currentCount</code>, которая у каждого счётчика своя.</p><p>Если подробнее описать происходящее:</p><ol><li><p>В строке <code>(*)</code> запускается <code>makeCounter()</code>. При этом создаётся <code>LexicalEnvironment</code> для переменных текущего вызова. В функции есть одна переменная <code>var currentCount</code>, которая станет свойством этого объекта. Она изначально инициализуется в <code>undefined</code>, затем, в процессе выполнения, получит значение <code>1</code>:</p><code-example><script>`function makeCounter() {\nMARK  // LexicalEnvironment = { currentCount: undefined }\n\n  var currentCount = 1;\n\nMARK  // LexicalEnvironment = { currentCount: 1 }\n\n  return function() { // [[Scope]] -> LexicalEnvironment (**)\n return currentCount++;\n  };\n}\n\nvar counter = makeCounter(); // (*)`</script></code-example></li><li><p>В процессе выполнения <code>makeCounter()</code> создаёт функцию в строке <code>(**)</code>. При создании эта функция получает внутреннее свойство <code>[[Scope]]</code> со ссылкой на текущий <code>LexicalEnvironment</code>.</p></li><li><p>Далее вызов <code>makeCounter()</code> завершается и функция <code>(**)</code> возвращается и сохраняется во внешней переменной <code>counter</code><code>(*)</code>.</p></li></ol><p>На этом создание «счётчика» завершено.</p><p>Итоговым значением, записанным в переменную <code>counter</code>, является функция:</p><code-example><script>`function() { // [[Scope]] -> {currentCount: 1}\n  return currentCount++;\n};`</script></code-example><p>Возвращённая из <code>makeCounter()</code> функция <code>counter</code> помнит (через <code>[[Scope]]</code>) о том, в каком окружении была создана.</p><p>Это и используется для хранения текущего значения счётчика.</p><p>Далее, когда-нибудь, функция <code>counter</code> будет вызвана. Мы не знаем, когда это произойдёт. Может быть, прямо сейчас, но, вообще говоря, совсем не факт.</p><p>Эта функция состоит из одной строки: <code>return currentCount++</code>, ни переменных ни параметров в ней нет, поэтому её собственный объект переменных, для краткости назовём его <code>LE</code> – будет пуст.</p><p>Однако, у неё есть свойство <code>[[Scope]]</code>, которое указывает на внешнее окружение. Чтобы увеличить и вернуть <code>currentCount</code>, интерпретатор ищет в текущем объекте переменных <code>LE</code>, не находит, затем идёт во внешний объект, там находит, изменяет и возвращает новое значение:</p><code-example><script>`function makeCounter() {\n  var currentCount = 1;\n\n  return function() {\n    return currentCount++;\n  };\n}\n\nvar counter = makeCounter(); // [[Scope]] -> {currentCount: 1}\n\nalert( counter() ); // 1, [[Scope]] -> {currentCount: 1}\nalert( counter() ); // 2, [[Scope]] -> {currentCount: 2}\nalert( counter() ); // 3, [[Scope]] -> {currentCount: 3}`</script><code-toolbar></code-toolbar></code-example><p><strong>Переменную во внешней области видимости можно не только читать, но и изменять.</strong></p><p>В примере выше было создано несколько счётчиков. Все они взаимно независимы:</p><code-example><script>`var counter = makeCounter();\n\nvar counter2 = makeCounter();\n\nalert( counter() ); // 1\nalert( counter() ); // 2\nalert( counter() ); // 3\n\nalert( counter2() ); // 1, HIGHсчётчики независимыLIGHT`</script></code-example><p>Они независимы, потому что при каждом запуске <code>makeCounter</code> создаётся свой объект переменных <code>LexicalEnvironment</code>, со своим свойством <code>currentCount</code>, на который новый счётчик получит ссылку <code>[[Scope]]</code>.</p><h2><a name="5" href="#5">Свойства функции</a></h2><p>Функция в JavaScript является объектом, поэтому можно присваивать свойства прямо к ней, вот так:</p><code-example><script>`function f() {}\n\nf.test = 5;\nalert( f.test );`</script><code-toolbar></code-toolbar></code-example><p>Свойства функции не стоит путать с переменными и параметрами. Они совершенно никак не связаны. Переменные доступны только внутри функции, они создаются в процессе её выполнения. Это – использование функции «как функции».</p><p>А свойство у функции – доступно отовсюду и всегда. Это – использование функции «как объекта».</p><p>Если хочется привязать значение к функции, то можно им воспользоваться вместо внешних переменных.</p><p>В качестве демонстрации, перепишем пример со счётчиком:</p><code-example><script>`function makeCounter() {\nMARK  function counter() {\nMARK    return counter.currentCount++;\nMARK  };\nMARK  counter.currentCount = 1;\n\n  return counter;\n}\n\nvar counter = makeCounter();\nalert( counter() ); // 1\nalert( counter() ); // 2`</script><code-toolbar></code-toolbar></code-example><p>При запуске пример работает также.</p><p>Принципиальная разница – во внутренней механике и в том, что свойство функции, в отличие от переменной из замыкания – общедоступно, к нему имеет доступ любой, у кого есть объект функции.</p><p>Например, можно взять и поменять счётчик из внешнего кода:</p><code-example><script>`var counter = makeCounter();\nalert( counter() ); // 1\n\nMARKcounter.currentCount = 5;\n\nalert( counter() ); // 5`</script></code-example><important-><h3>Статические переменные</h3><p>Иногда свойства, привязанные к функции, называют «статическими переменными».</p><p>В некоторых языках программирования можно объявлять переменную, которая сохраняет значение между вызовами функции. В JavaScript ближайший аналог – такое вот свойство функции.</p></important-><h2><a name="6" href="#6">Итого: замыкания</a></h2><p><a href="http://en.wikipedia.org/wiki/Closure_(computer_science)">Замыкание</a> – это функция вместе со всеми внешними переменными, которые ей доступны.</p><p>Таково стандартное определение, которое есть в Wikipedia и большинстве серьёзных источников по программированию. То есть, замыкание – это функция + внешние переменные.</p><p>Тем не менее, в JavaScript есть небольшая терминологическая особенность.</p><p><strong>Обычно, говоря «замыкание функции», подразумевают не саму эту функцию, а именно внешние переменные.</strong></p><p>Иногда говорят «переменная берётся из замыкания». Это означает – из внешнего объекта переменных.</p><important-><h3>Что это такое – «понимать замыкания?»</h3><p>Иногда говорят «Вася молодец, понимает замыкания!». Что это такое – «понимать замыкания», какой смысл обычно вкладывают в эти слова?</p><p>«Понимать замыкания» в JavaScript означает понимать следующие вещи:</p><ol><li>Все переменные и параметры функций являются свойствами объекта переменных <code>LexicalEnvironment</code>. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – <code>window</code>.</li><li>При создании функция получает системное свойство <code>[[Scope]]</code>, которое ссылается на <code>LexicalEnvironment</code>, в котором она была создана.</li><li>При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних <code>LexicalEnvironment</code> с места своего «рождения».</li></ol><p>В следующих главах мы углубим это понимание дополнительными примерами, а также рассмотрим, что происходит с памятью.</p></important-><h2 id="tasks"><a href="#7" name="7">Задачи (6)</a></h2><task-content><h3><a href="#13" name="13">Что выведет say в начале кода?</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Что будет, если вызов <code>say('Вася');</code> стоит в самом-самом начале, в первой строке кода?</p><code-example><script>`MARKsay('Вася'); // Что выведет? Не будет ли ошибки?\n\nvar phrase = 'Привет';\n\nfunction say(name) {\n  alert( name + \",&nbsp\" + phrase );\n}`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Ошибки не будет, выведет <code>"Вася, undefined"</code>.</p><code-example><script>`MARKsay('Вася'); // Что выведет? Не будет ли ошибки?\n\nvar phrase = 'Привет';\n\nfunction say(name) {\n  alert( name + \",&nbsp\" + phrase );\n}`</script><code-toolbar></code-toolbar></code-example><p>Переменная как таковая существует, вот только на момент запуска функции она равна <code>undefined</code>.</p></task-answer></task-content><task-content><h3><a href="#14" name="14">В какую переменную будет присвоено значение?</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Каков будет результат выполнения этого кода?</p><code-example><script>`var value = 0;\n\nfunction f() {\n  if (1) {\n    value = true;\n  } else {\n    var value = false;\n  }\n\n  alert( value );\n}\n\nf();`</script></code-example><p>Изменится ли внешняя переменная <code>value</code> ?</p><p>P.S. Какими будут ответы, если из строки <code>var value = false</code> убрать <code>var</code>?</p><button-answer data-toggle_answer="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p><strong>Результатом будет <code>true</code></strong>, т.к. <code>var</code> обработается и переменная будет создана до выполнения кода.</p><p>Соответственно, присвоение <code>value=true</code> сработает на локальной переменной, и <code>alert</code> выведет <code>true</code>.</p><p><strong>Внешняя переменная не изменится.</strong></p><p>P.S. Если <code>var</code> нет, то в функции переменная не будет найдена. Интерпретатор обратится за ней в <code>window</code> и изменит её там.</p><p><strong>Так что без <code>var</code> результат будет также <code>true</code>, но внешняя переменная изменится.</strong></p></task-answer></task-content><task-content><h3><a href="#15" name="15">var window</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Каков будет результат выполнения этого кода? Почему?</p><code-example><script>`function test() {\n\n  alert( window );\n\n  var window = 5;\n\n  alert( window );\n}\n\ntest();`</script></code-example><button-answer data-toggle_answer="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Результатом будет <code>undefined</code>, затем <code>5</code>.</p><code-example><script>`function test() {\n\n  alert( window );\n\  var window = 5;\n\n  alert( window );\n}\n\ntest();`</script><code-toolbar></code-toolbar></code-example><p>Такой результат получился потому, что <code>window</code> – это глобальная переменная, но ничто не мешает объявить такую же локальную.</p><p>Директива <code>var window</code> обработается до начала выполнения кода функции и будет создана локальная переменная, т.е. свойство <code>LexicalEnvironment.window</code>:</p><code-example><script>`LexicalEnvironment = {\n  window: undefined\n}`</script></code-example><p>Когда выполнение кода начнется и сработает <code>alert</code>, он выведет уже локальную переменную, которая на тот момент равна <code>undefined</code>.</p><p>Затем сработает присваивание, и второй <code>alert</code> выведет уже <code>5</code>.</p></task-answer></task-content><task-content><h3><a href="#16" name="16">Вызов "на месте"</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>Каков будет результат выполнения кода? Почему?</p><code-example><script>`var a = 5\n\n(function() {\n  alert(a)\n})()`</script></code-example><p>P.S. <em>Подумайте хорошо! Здесь все ошибаются!</em>P.P.S. <em>Внимание, здесь подводный камень! Ок, вы предупреждены.</em></p><button-answer data-toggle_answer="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Результат – <strong>ошибка</strong>. Попробуйте:</p><code-example><script>`var a = 5\n\n(function() {\n  alert(a)\n})()`</script><code-toolbar></code-toolbar></code-example><p>Дело в том, что после <code>var a = 5</code> нет точки с запятой.</p><p>JavaScript воспринимает этот код как если бы перевода строки не было:</p><code-example><script>`var a = 5(function() {\n  alert(a)\n})()`</script><code-toolbar></code-toolbar></code-example><p>То есть, он пытается вызвать <em>функцию</em><code>5</code>, что и приводит к ошибке.</p><p>Если точку с запятой поставить, все будет хорошо:</p><code-example><script>`var a = 5;\n\n(function() {\n  alert(a)\n})()`</script><code-toolbar></code-toolbar></code-example><p>Это один из наиболее частых и опасных подводных камней, приводящих к ошибкам тех, кто <em>не</em> ставит точки с запятой.</p></task-answer></task-content><task-content><h3><a href="#17" name="17">Перекрытие переменной</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>Если во внутренней функции есть своя переменная с именем <code>currentCount</code> – можно ли в ней получить <code>currentCount</code> из внешней функции?</p><code-example><script>`function makeCounter() {\n  var currentCount = 1;\n\n  return function() {\n    var currentCount;\n    // можно ли здесь вывести currentCount из внешней функции (равный 1)?\n  };\n}`</script></code-example><button-answer data-toggle_answer="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Нет, нельзя.</p><p>Локальная переменная полностью перекрывает внешнюю.</p></task-answer></task-content><task-content><h3><a href="#18" name="18">Глобальный счётчик</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Что выведут эти вызовы, если переменная <code>currentCount</code> находится вне <code>makeCounter</code>?</p><code-example><script>`var currentCount = 1;\n\nfunction makeCounter() {\n  return function() {\n    return currentCount++;\n  };\n}\n\nvar counter = makeCounter();\nvar counter2 = makeCounter();\n\nMARKalert( counter() ); // ?\nMARKalert( counter() ); // ?\n\nMARKalert( counter2() ); // ?\nMARKalert( counter2() ); // ?`</script></code-example><button-answer data-toggle_answer="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Выведут <strong>1,2,3,4.</strong></p><p>Здесь внутренняя функция будет искать – и находить <code>currentCount</code> каждый раз в самом внешнем объекте переменных: глобальном объекте <code>window</code>.</p><p>В результате все счётчики будут разделять единое, глобальное текущее значение.</p><code-example><script>`var currentCount = 1;\n\nfunction makeCounter() {\n  return function() {\n    return currentCount++;\n  };\n}\n\nvar counter = makeCounter();\nvar counter2 = makeCounter();\n\nMARKalert( counter() ); // 1\nMARKalert( counter() ); // 2\n\nMARKalert( counter2() ); // 3\nMARKalert( counter2() ); // 4`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="Глобальный объект; [[Scope]] для new Function"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/closures",disqus_identifier="closures",disqus_title="\u0417\u0430\u043c\u044b\u043a\u0430\u043d\u0438\u044f, \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0438\u0437\u043d\u0443\u0442\u0440\u0438";</script></page-content></main>