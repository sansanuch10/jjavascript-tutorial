<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="46">Замыкания, область видимости</a></nav-up><h1>[[Scope]] для new Function</h1><h2><a name="0" href="#0">Присвоение [[Scope]] для new Function</a></h2><p>Есть одно исключение из общего правила присвоения <code>[[Scope]]</code>, которое мы рассматривали в предыдущей главе.</p><p>При создании функции с использованием  <code>new Function</code>, её свойство <code>[[Scope]]</code> ссылается не на текущий <code>LexicalEnvironment</code>, а на <code>window</code>.</p><h2><a name="1" href="#1">Пример</a></h2><p>Следующий пример демонстрирует как функция, созданная <code>new Function</code>, игнорирует внешнюю переменную <code>a</code> и выводит глобальную вместо неё:</p><code-example><script>`var a = 1;\n\nfunction getFunc() {\n  var a = 2;\n\nMARK  var func = new Function('', 'alert(a)');\n\n  return func;\n}\n\ngetFunc()(); // HIGH1LIGHT, из window`</script><code-toolbar></code-toolbar></code-example><p>Сравним с обычным поведением:</p><code-example><script>`var a = 1;\n\nfunction getFunc() {\n  var a = 2;\n\nMARK  var func = function() { alert(a); };\n\n  return func;\n}\n\ngetFunc()(); // HIGH2LIGHT, из LexicalEnvironment функции getFunc`</script><code-toolbar></code-toolbar></code-example><h2><a name="2" href="#2">Почему так сделано?</a></h2><important-warn><h3>Продвинутые знания</h3><p>Содержимое этой секции содержит продвинутую информацию теоретического характера, которая прямо сейчас не обязательна для дальнейшего изучения JavaScript.</p></important-warn><p>Эта особенность <code>new Function</code>, хоть и выглядит странно, на самом деле весьма полезна.</p><p>Представьте себе, что нам действительно нужно создать функцию из строки кода. Текст кода этой функции неизвестен на момент написания скрипта (иначе зачем <code>new Function</code>), но станет известен позже, например получен с сервера или из других источников данных.</p><p>Предположим, что этому коду надо будет взаимодействовать с внешними переменными основного скрипта.</p><p>Но проблема в том, что JavaScript при выкладывании на «боевой сервер» предварительно сжимается минификатором – специальной программой, которая уменьшает размер кода, убирая из него лишние комментарии, пробелы, что очень важно – переименовывает локальные переменные на более короткие.</p><p>То есть, если внутри функции есть <code>var userName</code>, то минификатор заменит её на <code>var a</code> (или другую букву, чтобы не было конфликта), предполагая, что так как переменная видна только внутри функции, то этого всё равно никто не заметит, а код станет короче. И обычно проблем нет.</p><p>…Но если бы <code>new Function</code> могла обращаться к внешним переменным, то при попытке доступа к <code>userName</code> в сжатом коде была бы ошибка, так как минификатор переименовал её.</p><p><strong>Получается, что даже если бы мы захотели использовать локальные переменные в <code>new Function</code>, то после сжатия были бы проблемы, так как минификатор переименовывает локальные переменные.</strong></p><p>Описанная особенность <code>new Function</code> просто-таки спасает нас от ошибок.</p><p>Ну а если внутри функции, создаваемой через <code>new Function</code>, всё же нужно использовать какие-то данные – без проблем, нужно всего лишь предусмотреть соответствующие параметры и передавать их явным образом, например так:</p><code-example><script>`MARKvar sum = new Function('a, b', ' return a + b; ');\n\nvar a = 1, b = 2;\n\nMARKalert( sum(a, b) ); // 3`</script><code-toolbar></code-toolbar></code-example><h2><a name="3" href="#3">Итого</a></h2><ul><li>Функции, создаваемые через <code>new Function</code>, имеют значением <code>[[Scope]]</code> не внешний объект переменных, а <code>window</code>.</li><li>Следствие – такие функции не могут использовать замыкание. Но это хорошо, так как бережёт от ошибок проектирования, да и при сжатии JavaScript проблем не будет. Если же внешние переменные реально нужны – их можно передать в качестве параметров.</li></ul><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Замыкания, функции изнутри; Локальные переменные для объекта"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/scope-new-function", disqus_identifier = "scope-new-function", disqus_title = "[[Scope]] \u0434\u043b\u044f new Function";</script></page-content></main>