<main> <page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="46">Замыкания, область видимости</a></nav-up><h1>Локальные переменные для объекта</h1><p>Замыкания можно использовать сотнями способов. Иногда люди сами не замечают, что использовали замыкания – настолько это просто и естественно.</p><p>В этой главе мы рассмотрим дополнительные примеры использования замыканий и задачи на эту тему.</p><h2><a name="0" href="#0">Счётчик-объект</a></h2><p>Ранее мы сделали счётчик.</p><p>Напомню, как он выглядел:</p><code-example><script>`function makeCounter() {\n  var currentCount = 1;\n\n  return function() {\n    return currentCount++;\n  };\n}\n\nvar counter = makeCounter();\n\n// каждый вызов возвращает результат, увеличивая счётчик\nalert( counter() ); // 1\nalert( counter() ); // 2\nalert( counter() ); // 3`</script><code-toolbar></code-toolbar></code-example><p>Счётчик получился вполне рабочий, но вот только возможностей ему не хватает. Хорошо бы, чтобы можно было сбрасывать значение счётчика или начинать отсчёт с другого значения вместо <code>1</code> или… Да много чего можно захотеть от простого счётчика и, тем более, в более сложных проектах.</p><p><strong>Чтобы добавить счётчику возможностей – перейдём с функции на полноценный объект:</strong></p><code-example><script>`function makeCounter() {\n  var currentCount = 1;\n\n  return { // возвратим объект вместо функции\n    getNext: function() {\n      return currentCount++;\n    },\n\n    set: function(value) {\n      currentCount = value;\n    },\n\n    reset: function() {\n      currentCount = 1;\n    }\n  };\n}\n\nvar counter = makeCounter();\n\nalert( counter.getNext() ); // 1\nalert( counter.getNext() ); // 2\n\ncounter.set(5);\nalert( counter.getNext() ); // 5`</script><code-toolbar></code-toolbar></code-example><p>Теперь функция <code>makeCounter</code> возвращает не одну функцию, а объект с несколькими методами:</p><ul><li><code>getNext()</code> – получить следующее значение, то, что раньше делал вызов <code>counter()</code>.</li><li><code>set(value)</code> – поставить значение.</li><li><code>reset()</code> – обнулить счётчик.</li></ul><p>Все они получают ссылку <code>[[Scope]]</code> на текущий (внешний) объект переменных. Поэтому вызов любого из этих методов будет получать или модифицировать одно и то же внешнее значение <code>currentCount</code>.</p><h2><a name="1" href="#1">Объект счётчика + функция</a></h2><p>Изначально, счётчик делался функцией во многом ради красивого вызова: <code>counter()</code>, который увеличивал значение и возвращал результат.</p><p>К сожалению, при переходе на объект короткий вызов пропал, вместо него теперь <code>counter.getNext()</code>. Но он ведь был таким простым и удобным…</p><p>Поэтому давайте вернём его!</p><code-example><script>`function makeCounter() {\n  var currentCount = 1;\n\nMARK  // возвращаемся к функции\nMARK  function counter() {\nMARK    return currentCount++;\nMARK  }\n\n  // ...и добавляем ей методы!\n  counter.set = function(value) {\n    currentCount = value;\n  };\n\n  counter.reset = function() {\n    currentCount = 1;\n  };\n\n  return counter;\n}\n\nvar counter = makeCounter();\n\nMARKalert( counter() ); // 1\nMARKalert( counter() ); // 2\nMARK&nbsp\nMARKcounter.set(5);\nMARKalert( counter() ); // 5`</script><code-toolbar></code-toolbar></code-example><p>Красиво, не правда ли? Получился полноценный объект, который можно вдобавок ещё и вызывать.</p><p>Этот трюк часто используется при разработке JavaScript-библиотек. Например, популярная библиотека <a href="http://jquery.com">jQuery</a> предоставляет глобальную переменную с именем <a href="http://api.jquery.com/jQuery/">jQuery</a> (доступна также под коротким именем <code>$</code>), которая с одной стороны является функцией и может вызываться как <code>jQuery(...)</code>, а с другой – у неё есть различные методы, например <code>jQuery.type(123)</code> возвращает тип аргумента.</p><p>Далее вы найдёте различные задачи на понимание замыканий. Рекомендуется их сделать самостоятельно.</p><h2 id="tasks"><a href="#2" name="2">Задачи (6)</a></h2><task-content><h3><a href="#4" name="4">Сумма через замыкание</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span><p>Напишите функцию <code>sum</code>, которая работает так: <code>sum(a)(b) = a+b</code>.</p><p>Да, именно так, через двойные скобки (это не опечатка). Например:</p><code-example><script>`sum(1)(2) = 3\Nsum(5)(-1) = 4`</script></code-example><button-answer data-toggle_answer="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Чтобы вторые скобки в вызове работали – первые должны возвращать функцию.</p><p>Эта функция должна знать про <code>a</code> и уметь прибавлять <code>a</code> к <code>b</code>. Вот так:</p><code-example><script>`function sum(a) {\n\n  return function(b) {\n    return a + b; // возьмет a из внешнего LexicalEnvironment\n  };\n\n}\n\nalert( sum(1)(2) );\nalert( sum(5)(-1) );`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#5" name="5">Функция - строковый буфер</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>В некоторых языках программирования существует объект «строковый буфер», который аккумулирует внутри себя значения. Его функционал состоит из двух возможностей:</p><ol><li>Добавить значение в буфер.</li><li>Получить текущее содержимое.</li></ol><p><strong>Задача – реализовать строковый буфер на функциях в JavaScript, со следующим синтаксисом:</strong></p><ul><li>Создание объекта: <code>var buffer = makeBuffer();</code>.</li><li>Вызов <code>makeBuffer</code> должен возвращать такую функцию <code>buffer</code>, которая при вызове <code>buffer(value)</code> добавляет значение в некоторое внутреннее хранилище, а при вызове без аргументов <code>buffer()</code> – возвращает его.</li></ul><p>Вот пример работы:</p><code-example><script>`function makeBuffer() { /* ваш код */ }\n\nvar buffer = makeBuffer();\n\n// добавить значения к буферу\nbuffer('Замыкания');\nbuffer(' Использовать');\nbuffer(' Нужно!');\n\n// получить текущее значение\nalert( buffer() ); // Замыкания Использовать Нужно!`</script></code-example><p>Буфер должен преобразовывать все данные к строковому типу:</p><code-example><script>`var buffer = makeBuffer();\nbuffer(0);\nbuffer(1);\nbuffer(0);\n\nalert( buffer() ); // '010'`</script></code-example><p>Решение не должно использовать глобальные переменные.</p><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    // ...Ваш код...\n\n  <\/script>\n  <script>\n    var buffer;\n    beforeEach(function() {\n      buffer = makeBuffer();\n    });\n\n    it("возвращает пустую строку по умолчанию", function() {\n      assert.strictEqual(buffer(), "");\n    });\n\n    it("добавляет аргументы в буффер", function() {\n      buffer('Замыкания');\n      buffer(' Использовать');\n      buffer(' Нужно!');\n      assert.equal(buffer(), 'Замыкания Использовать Нужно!');\n    });\n\n    it("приводит всё к строке", function() {\n      buffer(null);\n      buffer(false);\n      assert.equal(buffer(), "nullfalse");\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="task_2" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="task_2">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Текущее значение текста удобно хранить в замыкании, в локальной переменной <code>makeBuffer</code>:</p><code-example><script>`function makeBuffer() {\n  var text = '';\n\n  return function(piece) {\n    if (arguments.length == 0) { // вызов без аргументов\n      return text;\n    }\n    text += piece;\n  };\n};\n\nvar buffer = makeBuffer();\n\n// добавить значения к буферу\nbuffer('Замыкания');\nbuffer(' Использовать');\nbuffer(' Нужно!');\nalert( buffer() ); // 'Замыкания Использовать Нужно!'\n\nvar buffer2 = makeBuffer();\nbuffer2(0);\nbuffer2(1);\nbuffer2(0);\n\nalert( buffer2() ); // '010'`</script><code-toolbar></code-toolbar></code-example><p>Начальное значение <code>text = ''</code> – пустая строка. Поэтому операция <code>text += piece</code> прибавляет <code>piece</code> к строке, автоматически преобразуя его к строковому типу, как и требовалось в условии.</p><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    function makeBuffer() {\n      var text = '';\n    \n      return function(piece) {\n        if (arguments.length == 0) { // вызов без аргументов\n          return text;\n        }\n        text += piece;\n      };\n    };\n\n  <\/script>\n  <script>\n    var buffer;\n    beforeEach(function() {\n      buffer = makeBuffer();\n    });\n\n    it("возвращает пустую строку по умолчанию", function() {\n      assert.strictEqual(buffer(), "");\n    });\n\n    it("добавляет аргументы в буффер", function() {\n      buffer('Замыкания');\n      buffer(' Использовать');\n      buffer(' Нужно!');\n      assert.equal(buffer(), 'Замыкания Использовать Нужно!');\n    });\n\n    it("приводит всё к строке", function() {\n      buffer(null);\n      buffer(false);\n      assert.equal(buffer(), "nullfalse");\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="answer_2" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="answer_2">Открыть решение с тестами в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#6" name="6">Строковый буфер с очисткой</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Добавьте буферу из решения задачи <a href="/task/stringbuffer">Функция - строковый буфер</a> метод <code>buffer.clear()</code>, который будет очищать текущее содержимое буфера:</p><code-example><script>`function makeBuffer() {\n  ...ваш код...\n}\n\nvar buffer = makeBuffer();\n\nbuffer("Тест");\nbuffer(" тебя не съест ");\nalert( buffer() ); // Тест тебя не съест\n\nMARKbuffer.clear();\n\nalert( buffer() ); // ""`</script></code-example><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    // ...Ваш код...\n\n  <\/script>\n  <script>\n    var buffer;\n\n    beforeEach(function() {\n      buffer = makeBuffer();\n    });\n\n    it("возвращает пустую строку по умолчанию", function() {\n      assert.strictEqual(buffer(), "");\n    });\n\n    it("добавляет аргументы в буффер", function() {\n      buffer('Замыкания');\n      buffer(' Использовать');\n      buffer(' Нужно!');\n      assert.equal(buffer(), 'Замыкания Использовать Нужно!');\n    });\n\n    it("приводит всё к строке", function() {\n      buffer(null);\n      buffer(false);\n      assert.equal(buffer(), "nullfalse");\n    });\n\n    it("очищает буфер вызовом clear", function() {\n      buffer("test");\n      buffer.clear();\n      buffer("первый");\n      buffer("второй");\n      assert.equal(buffer(), "первыйвторой");\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="task_3" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="task_3">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`function makeBuffer() {\n  var text = \'\';\n\n  function buffer(piece) {\n    if (arguments.length == 0) { // вызов без аргументов\n      return text;\n    }\n    text += piece;\n  };\n\n  buffer.clear = function() {\n    text = "";\n  }\n\n  return buffer;\n};\n\nvar buffer = makeBuffer();\n\nbuffer("Тест");\nbuffer(" тебя не съест ");\nalert( buffer() ); // Тест тебя не съест\n\nMARKbuffer.clear();\n\nalert( buffer() ); // ""`</script><code-toolbar></code-toolbar></code-example><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    function makeBuffer() {\n      var text = '';\n    \n      function buffer(piece) {\n        if (arguments.length == 0) { // вызов без аргументов\n          return text;\n        }\n        text += piece;\n      };\n    \n      buffer.clear = function() {\n        text = "";\n      }\n    \n      return buffer;\n    };\n\n  <\/script>\n  <script>\n    var buffer;\n\n    beforeEach(function() {\n      buffer = makeBuffer();\n    });\n\n    it("возвращает пустую строку по умолчанию", function() {\n      assert.strictEqual(buffer(), "");\n    });\n\n    it("добавляет аргументы в буффер", function() {\n      buffer('Замыкания');\n      buffer(' Использовать');\n      buffer(' Нужно!');\n      assert.equal(buffer(), 'Замыкания Использовать Нужно!');\n    });\n\n    it("приводит всё к строке", function() {\n      buffer(null);\n      buffer(false);\n      assert.equal(buffer(), "nullfalse");\n    });\n\n    it("очищает буфер вызовом clear", function() {\n      buffer("test");\n      buffer.clear();\n      buffer("первый");\n      buffer("второй");\n      assert.equal(buffer(), "первыйвторой");\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="answer_3" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="answer_3">Открыть решение с тестами в песочнице.</a></p></task-answer></task-content><task-content><h3><a href="#7" name="7">Сортировка</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>У нас есть массив объектов:</p><code-example><script>`var users = [{\n  name: "Вася",\n  surname: \'Иванов\',\n  age: 20\n}, {\n  name: "Петя",\n  surname: \'Чапаев\',\n  age: 25\n}, {\n  name: "Маша",\n  surname: \'Медведева\',\n  age: 18\n}];`</script></code-example><p>Обычно сортировка по нужному полю происходит так:</p><code-example><script>`// по полю name (Вася, Маша, Петя)\nusers.sort(function(a, b) {\n  return a.name > b.name ? 1 : -1;\n});\n\n// по полю age  (Маша, Вася, Петя)\nusers.sort(function(a, b) {\n  return a.age > b.age ? 1 : -1;\n});`</script></code-example><p>Мы хотели бы упростить синтаксис до одной строки, вот так:</p><code-example><script>`users.sort(byField('name'));\nusers.forEach(function(user) {\n  alert( user.name );\n}); // Вася, Маша, Петя\n\nusers.sort(byField('age'));\nusers.forEach(function(user) {\n  alert( user.name );\n}); // Маша, Вася, Петя`</script></code-example><p>То есть, вместо того, чтобы каждый раз писать в <code>sort</code><code>function...</code> – будем использовать <code>byField(...)</code></p><p>Напишите функцию <code>byField(field)</code>, которую можно использовать в <code>sort</code> для сравнения объектов по полю <code>field</code>, чтобы пример выше заработал.</p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><code-example><script>`var users = [{\n  name: \"Вася\",\n  surname: 'Иванов',\n  age: 20\n}, {\n  name: \"Петя\",\n  surname: 'Чапаев',\n  age: 25\n}, {\n  name: \"Маша\",\n  surname: 'Медведева',\n  age: 18\n}];\n\nMARKfunction byField(field) {\nMARK    return function(a, b) {\nMARK      return a[field] > b[field] ? 1 : -1;\nMARK    }\nMARK  }\n\nusers.sort(byField('name'));\nusers.forEach(function(user) {\n  alert( user.name );\n});\n\nusers.sort(byField('age'));\nusers.forEach(function(user) {\n  alert( user.name );\n});`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#8" name="8">Фильтрация через функцию</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><ol><li>Создайте функцию <code>filter(arr, func)</code>, которая получает массив <code>arr</code> и возвращает новый, в который входят только те элементы <code>arr</code>, для которых <code>func</code> возвращает <code>true</code>.</li><li>Создайте набор «готовых фильтров»: <code>inBetween(a,b)</code> – «между a,b», <code>inArray([...])</code> – "в массиве <code>[...]</code>".Использование должно быть таким:</li></ol><ul><li><code>filter(arr, inBetween(3,6))</code> – выберет только числа от 3 до 6,</li><li><code>filter(arr, inArray([1,2,3]))</code> – выберет только элементы, совпадающие с одним из значений массива.</li></ul><p>Пример, как это должно работать:</p><code-example><script>`/* .. ваш код для filter, inBetween, inArray */\nvar arr = [1, 2, 3, 4, 5, 6, 7];\n\nalert(filter(arr, function(a) {\n  return a % 2 == 0\n})); // 2,4,6\n\nalert( filter(arr, inBetween(3, 6)) ); // 3,4,5,6\n\nalert( filter(arr, inArray([1, 2, 10])) ); // 1,2`</script></code-example><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    function filter(arr, func) {\n      // ...ваш код...\n    }\n    \n    function inBetween(a, b) {\n      // ...ваш код...\n    }\n    \n    function inArray(arr) {\n      // ...ваш код...\n    }\n\n  <\/script>\n  <script>\n    var arr;\n\n    before(function() {\n      arr = [1, 2, 3, 4, 5, 6, 7];\n    });\n\n    describe("inArray", function() {\n      var checkInArr;\n\n      before(function() {\n        checkInArr = inArray(arr);\n      });\n\n      it("возвращает фильтр для значений в массиве", function() {\n        assert.isTrue(checkInArr(5));\n        assert.isFalse(checkInArr(0));\n      });\n    });\n\n\n    describe("inBetween", function() {\n      var checkBetween36;\n\n      before(function() {\n        checkBetween36 = inBetween(3, 6);\n      });\n\n      it("возвращает фильтрa для значений в промежутке", function() {\n        assert.isTrue(checkBetween36(5));\n        assert.isFalse(checkBetween36(0));\n      });\n    });\n\n\n    describe("filter", function() {\n\n      it("фильтрует через func", function() {\n        assert.deepEqual(filter(arr, function(a) {\n          return a % 2 == 0;\n        }), [2, 4, 6]);\n      });\n\n      it("не модифицирует исходный массив", function() {\n        filter(arr, function(a) {\n          return a % 2 == 0;\n        });\n        assert.deepEqual(arr, [1, 2, 3, 4, 5, 6, 7]);\n      });\n\n      it("поддерживает фильтр inBetween", function() {\n        assert.deepEqual(filter(arr, inBetween(3, 6)), [3, 4, 5, 6]);\n      });\n\n      it("поддерживает фильтр inArray", function() {\n        assert.deepEqual(filter(arr, inArray([1, 2, 3])), [1, 2, 3]);\n      });\n\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="task_5" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="task_5">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="" style="">Функция фильтрации</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Функция фильтрации</h4><code-example><script>`function filter(arr, func) {\n  var result = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    var val = arr[i];\n    if (func(val)) {\n      result.push(val);\n    }\n  }\n\n  return result;\n}\n\nvar arr = [1, 2, 3, 4, 5, 6, 7];\n\nalert(filter(arr, function(a) {\n  return a % 2 == 0;\n})); // 2, 4, 6`</script><code-toolbar></code-toolbar></code-example></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Фильтр inBetween</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Фильтр inBetween</h4><code-example><script>`function filter(arr, func) {\n  var result = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    var val = arr[i];\n    if (func(val)) {\n      result.push(val);\n    }\n  }\n\n  return result;\n}\n\nMARKfunction inBetween(a, b) {\nMARK    return function(x) {\nMARK      return x >= a && x <= b;\nMARK    };\nMARK  }\n\nvar arr = [1, 2, 3, 4, 5, 6, 7];\nalert( filter(arr, inBetween(3, 6)) ); // 3,4,5,6`</script><code-toolbar></code-toolbar></code-example></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Фильтр inArray</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Фильтр inArray</h4><code-example><script>`function filter(arr, func) {\n  var result = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    var val = arr[i];\n    if (func(val)) {\n      result.push(val);\n    }\n  }\n\n  return result;\n}\n\nMARKfunction inArray(arr) {\nMARK    return function(x) {\nMARK      return arr.indexOf(x) != -1;\nMARK    };\nMARK  }\n\nvar arr = [1, 2, 3, 4, 5, 6, 7];\nalert( filter(arr, inArray([1, 2, 10])) ); // 1,2`</script><code-toolbar></code-toolbar></code-example><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    function filter(arr, func) {\n      var result = [];\n    \n      for (var i = 0; i < arr.length; i++) {\n        var val = arr[i];\n        if (func(val)) {\n          result.push(val);\n        }\n      }\n    \n      return result;\n    }\n    \n    function inArray(arr) {\n      return function(x) {\n        return arr.indexOf(x) != -1;\n      };\n    }\n    \n    function inBetween(a, b) {\n      return function(x) {\n        return x >= a && x <= b;\n      };\n    }\n\n  <\/script>\n  <script>\n    var arr;\n\n    before(function() {\n      arr = [1, 2, 3, 4, 5, 6, 7];\n    });\n\n    describe("inArray", function() {\n      var checkInArr;\n\n      before(function() {\n        checkInArr = inArray(arr);\n      });\n\n      it("возвращает фильтр для значений в массиве", function() {\n        assert.isTrue(checkInArr(5));\n        assert.isFalse(checkInArr(0));\n      });\n    });\n\n\n    describe("inBetween", function() {\n      var checkBetween36;\n\n      before(function() {\n        checkBetween36 = inBetween(3, 6);\n      });\n\n      it("возвращает фильтрa для значений в промежутке", function() {\n        assert.isTrue(checkBetween36(5));\n        assert.isFalse(checkBetween36(0));\n      });\n    });\n\n\n    describe("filter", function() {\n\n      it("фильтрует через func", function() {\n        assert.deepEqual(filter(arr, function(a) {\n          return a % 2 == 0;\n        }), [2, 4, 6]);\n      });\n\n      it("не модифицирует исходный массив", function() {\n        filter(arr, function(a) {\n          return a % 2 == 0;\n        });\n        assert.deepEqual(arr, [1, 2, 3, 4, 5, 6, 7]);\n      });\n\n      it("поддерживает фильтр inBetween", function() {\n        assert.deepEqual(filter(arr, inBetween(3, 6)), [3, 4, 5, 6]);\n      });\n\n      it("поддерживает фильтр inArray", function() {\n        assert.deepEqual(filter(arr, inArray([1, 2, 3])), [1, 2, 3]);\n      });\n\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="answer_5" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="answer_5">Открыть решение с тестами в песочнице.</a></p></task-answer></task-answer-ext></task-content><task-content><h3><a href="#9" name="9">Армия функций</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Следующий код создает массив функций-стрелков <code>shooters</code>. По замыслу, каждый стрелок должен выводить свой номер:</p><code-example><script>`function makeArmy() {\n\n  var shooters = [];\n\n  for (var i = 0; i < 10; i++) {\n    var shooter = function() { // функция-стрелок\n      alert( i ); // выводит свой номер\n    };\n    shooters.push(shooter);\n  }\n\n  return shooters;\n}\n\nvar army = makeArmy();\n\narmy[0](); // стрелок выводит 10, а должен 0\narmy[5](); // стрелок выводит 10...\n// .. все стрелки выводят 10 вместо 0,1,2...9`</script><code-toolbar></code-toolbar></code-example><p>Почему все стрелки́ выводят одно и то же? Поправьте код, чтобы стрелки работали как задумано. Предложите несколько вариантов исправления.</p><code-example style="display:none"><script>`<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script src="` + window.location.toString().split('#')[0] + `sinon.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n\n<body>\n\n  <script>\n\n    function makeArmy() {    \n      var shooters = [];    \n      for (var i = 0; i < 10; i++) {\n        var shooter = function() { // функция-стрелок\n          alert(i); // выводит свой номер\n        };\n        shooters.push(shooter);\n      }    \n      return shooters;\n    }\n\n  <\/script>\n  <script>\n    var army;\n    before(function() {\n      army = makeArmy();\n      window.alert = sinon.stub(window, "alert");\n    });\n\n    it("army[0] выводит 0", function() {\n      army[0]();\n      assert(alert.calledWith(0));\n    });\n\n\n    it("army[5] функция выводит 5", function() {\n      army[5]();\n      assert(alert.calledWith(5));\n    });\n\n    after(function() {\n      window.alert.restore();\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n\n</html>`</script><code-toolbar-><a id="task_6" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="task_6">Открыть песочницу с тестами для задачи.</a></p><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer-ext><button-answer-ext data-toggle_answer_ext="" style="">Что происходит в этом коде</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Что происходит в этом коде</h4><p>Функция <code>makeArmy</code> делает следующее:</p><ol><li><p>Создаёт пустой массив <code>shooters</code>:</p><code-example><script>`var shooters = [];`</script></code-example></li><li><p>В цикле заполняет массив элементами через <code>shooters.push</code>.При этом каждый элемент массива – это функция, так что в итоге после цикла массив будет таким:</p><code-example><script>`shooters = [\n  function () { alert(i); },\n  function () { alert(i); },\n  function () { alert(i); },\n  function () { alert(i); },\n  function () { alert(i); },\n  function () { alert(i); },\n  function () { alert(i); },\n  function () { alert(i); },\n  function () { alert(i); },\n  function () { alert(i); }\n];`</script></code-example><p>Этот массив возвращается из функции.</p></li><li><p>Вызов <code>army[5]()</code> – это получение элемента массива (им будет функция), и тут же – её запуск.</p></li></ol></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Почему ошибка</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Почему ошибка</h4><p>Вначале разберемся, почему все стрелки выводят одно и то же значение.</p><p>В функциях-стрелках <code>shooter</code> отсутствует переменная <code>i</code>. Когда такая функция вызывается, то <code>i</code> она берет из внешнего <code>LexicalEnvironment</code>.</p><p>Чему же будет равно это значение <code>i</code>?</p><p>К моменту вызова <code>army[0]()</code>, функция <code>makeArmy</code> уже закончила работу. Цикл завершился, последнее значение было <code>i=10</code>.</p><p>В результате все функции <code>shooter</code> получают из внешнего лексического окружения это, одно и то же, последнее, значение <code>i=10</code>.</p><p>Попробуйте исправить проблему самостоятельно.</p></task-answer><button-answer-ext data-toggle_answer_ext="" style="">Исправление (3 варианта)</button-answer-ext><task-answer><close- title="закрыть" data-close_answer=""></close-><h4>Исправление (3 варианта)</h4><p>Есть несколько способов исправить ситуацию.</p><ol><li><p><strong>Первый способ исправить код – это привязать значение непосредственно к функции-стрелку:</strong></p><code-example><script>`function makeArmy() {\n\n  var shooters = [];\n\n  for (var i = 0; i < 10; i++) {\n\nMARK var shooter = function me() {\nMARK alert( me.i );\nMARK };\nMARK shooter.i = i;\n\n shooters.push(shooter);\n  }\n\n  return shooters;\n}\n\nvar army = makeArmy();\n\narmy[0](); // 0\narmy[1](); // 1`</script><code-toolbar></code-toolbar></code-example><p>В этом случае каждая функция хранит в себе свой собственный номер.</p><p>Кстати, обратите внимание на использование Named Function Expression, вот в этом участке:</p><code-example><script>`...\nvar shooter = function me() {\n  alert( me.i );\n};\n...`</script></code-example><p>Если убрать имя <code>me</code> и оставить обращение через <code>shooter</code>, то работать не будет:</p><code-example><script>`for (var i = 0; i < 10; i++) {\n  var shooter = function() {\nMARK alert( shooter.i ); // вывести свой номер (не работает!)\nMARK // потому что откуда функция возьмёт переменную shooter?\nMARK // ..правильно, из внешнего объекта, а там она одна на всех\n  };\n  shooter.i = i;\n  shooters.push(shooter);\n}`</script></code-example><p>Вызов <code>alert(shooter.i)</code> при вызове будет искать переменную <code>shooter</code>, а эта переменная меняет значение по ходу цикла, и к моменту вызова она равна последней функции, созданной в цикле.</p><p>Если использовать Named Function Expression, то имя жёстко привязывается к конкретной функции, и поэтому в коде выше <code>me.i</code> возвращает правильный <code>i</code>.</p></li><li><p><strong>Другое, более продвинутое решение – использовать дополнительную функцию для того, чтобы «поймать» текущее значение <code>i</code></strong>:</p><code-example><script>`function makeArmy() {\n\n  var shooters = [];\n\n  for (var i = 0; i < 10; i++) {\n\nMARK var shooter = (function(x) {\nMARK&nbsp\nMARK return function() {\nMARK alert( x );\nMARK };\nMARK&nbsp\nMARK })(i);\n\n shooters.push(shooter);\n  }\n\n  return shooters;\n}\n\nvar army = makeArmy();\n\narmy[0](); // 0\narmy[1](); // 1`</script><code-toolbar></code-toolbar></code-example><p>Посмотрим выделенный фрагмент более внимательно, чтобы понять, что происходит:</p><code-example><script>`var shooter = (function(x) {\n  return function() {\n alert( x );\n  };\n})(i);`</script></code-example><p>Функция <code>shooter</code> создана как результат вызова промежуточного функционального выражения <code>function(x)</code>, которое объявляется – и тут же выполняется, получая <code>x = i</code>.</p><p>Так как <code>function(x)</code> тут же завершается, то значение <code>x</code> больше не меняется. Оно и будет использовано в возвращаемой функции-стрелке.</p><p>Для красоты можно изменить название переменной <code>x</code> на <code>i</code>, суть происходящего при этом не изменится:</p><code-example><script>`var shooter = (function(i) {\n  return function() {\n alert( i );\n  };\n})(i);`</script></code-example><p><strong>Кстати, обратите внимание – скобки вокруг <code>function(i)</code> не нужны</strong>, можно и так:</p><code-example><script>`var shooter = function(i) { // HIGHбез скобок вокруг function(i)LIGHT\n  return function() {\n alert( i );\n  };\n}(i);`</script></code-example><p>Скобки добавлены в код для лучшей читаемости, чтобы человек, который просматривает его, не подумал, что <code>var shooter = function</code>, а понял что это вызов «на месте», и присваивается его результат.</p></li><li><p><strong>Еще один забавный способ – обернуть весь цикл во временную функцию</strong>:</p><code-example><script>`function makeArmy() {\n\n  var shooters = [];\n\nMARK  for (var i = 0; i < 10; i++)(function(i) {\nMARK&nbsp\nMARK var shooter = function() {\nMARK alert( i );\nMARK };\nMARK&nbsp\nMARK shooters.push(shooter);\nMARK&nbsp\nMARK  })(i);\n\n  return shooters;\n}\n\nvar army = makeArmy();\n\narmy[0](); // 0\narmy[1](); // 1`</script><code-toolbar></code-toolbar></code-example><p>Вызов <code>(function(i) { ... })</code> обернут в скобки, чтобы интерпретатор понял, что это <code>Function Expression</code>.</p><p>Плюс этого способа – в большей читаемости. Фактически, мы не меняем создание <code>shooter</code>, а просто обертываем итерацию в функцию.</p></li></ol><code-example style="display:none;"><script>`<!DOCTYPE html>\n<html>\n<head>\n  <meta charset="utf-8">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"><\/script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"><\/script>\n  <script src="` + window.location.toString().split('#')[0] + `sinon.js"><\/script>\n  <script>var assert = chai.assert; mocha.setup("bdd");<\/script>\n</head>\n<body>\n  <script>\n    function makeArmy() {    \n      var shooters = [];\n      for (var i = 0; i < 10; i++) {\n        var shooter = (function(x) {\n          return function() {\n            alert(x);\n          };\n        })(i);\n        shooters.push(shooter);\n      }\n      return shooters;\n    }\n  <\/script>\n  <script>\n    var army;\n    before(function() {\n      army = makeArmy();\n      window.alert = sinon.stub(window, "alert");\n    });\n    it("army[0] выводит 0", function() {\n      army[0]();\n      assert(alert.calledWith(0));\n    });\n    it("army[5] функция выводит 5", function() {\n      army[5]();\n      assert(alert.calledWith(5));\n    });\n    after(function() {\n      window.alert.restore();\n    });\n  <\/script>\n  <div id="mocha"></div>\n  <script>mocha.run();<\/script>\n</body>\n</html>`</script><code-toolbar-><a id="answer_6" data-code_edit=""></a></code-toolbar-></code-example><p><a data-click="answer_6">Открыть решение с тестами в песочнице.</a></p></task-answer></task-answer-ext></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>! function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||screen.width<1024||"bannerBottomDisabled" in localStorage||(localStorage.bannerBottomShownCount||(localStorage.bannerBottomShownCount=1),document.querySelector(".banner-bottom").style.display="block")}();</script><nav-book data-tooltips="[[Scope]] для new Function; Модули через замыкания"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url="https:\/\/learn.javascript.ru\/closures-usage",disqus_identifier="closures-usage",disqus_title="\u041b\u043e\u043a\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u0434\u043b\u044f \u043e\u0431\u044a\u0435\u043a\u0442\u0430";</script></page-content></main>