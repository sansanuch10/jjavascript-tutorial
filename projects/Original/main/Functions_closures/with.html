<main><page-content><nav-up><home- data-load_page="0" hover-style=""></home-><arrow-next></arrow-next><a data-load_page="1">Язык JavaScript</a><arrow-next></arrow-next><a data-load_page="46">Замыкания, область видимости</a></nav-up><h1>Устаревшая конструкция "with"</h1><p>Конструкция <code>with</code> позволяет использовать в качестве области видимости для переменных произвольный объект.</p><p>В современном JavaScript от этой конструкции отказались. С <code>use strict</code> она не работает, но её ещё можно найти в старом коде, так что стоит познакомиться с ней, чтобы если что – понимать, о чём речь.</p><p>Синтаксис:</p><code-example><script>`with(obj) {\n  ...код...n}`</script></code-example><p>Любое обращение к переменной внутри <code>with</code> сначала ищет её среди свойств <code>obj</code>, а только потом – вне <code>with</code>.</p><h2><a name="0" href="#0">Пример</a></h2><p>В примере ниже переменная будет взята не из глобальной области, а из <code>obj</code>:</p><code-example><script>`var a = 5;\n\nvar obj = {\n  a: 10\n};\n\nMARKwith(obj) {\nMARK    alert( a ); // 10, из obj\nMARK  }`</script><code-toolbar></code-toolbar></code-example><p>Попробуем получить переменную, которой в <code>obj</code> нет:</p><code-example><script>`var b = 1;\n\nvar obj = {\n  a: 10\n};\n\nMARKwith(obj) {\nMARK    alert( b ); // 1, из window\nMARK  }`</script><code-toolbar></code-toolbar></code-example><p>Здесь интерпретатор сначала проверяет наличие <code>obj.b</code>, не находит и идет вне <code>with</code>.</p><p>Особенно забавно выглядит применение вложенных <code>with</code>:</p><code-example><script>`var obj = {\n  weight: 10,\n  size: {\n    width: 5,\n    height: 7\n  }\n};\n\nwith(obj) {\n  with(size) { // size будет взят из obj\nMARK    alert( width * height / weight ); // width,height из size, weight из obj\n  }\n}`</script><code-toolbar></code-toolbar></code-example><p>Свойства из разных объектов используются как обычные переменные… Магия! Порядок поиска переменных в выделенном коде: <code>size =&gt; obj =&gt; window</code>.</p><h2><a name="1" href="#1">Изменения переменной</a></h2><p>При использовании <code>with</code>, как и во вложенных функциях – переменная изменяется в той области, где была найдена.</p><p>Например:</p><code-example><script>`var obj = {\n  a: 10\n}\n\nMARKwith(obj) {\nMARK    a = 20;\nMARK  }\nMARKalert( obj.a ); // 20, переменная была изменена в объекте`</script><code-toolbar></code-toolbar></code-example><h2><a name="2" href="#2">Почему отказались от with?</a></h2><p>Есть несколько причин.</p><ol><li><p>В современном стандарте <code>JavaScript</code> отказались от <code>with</code>, потому что конструкция <code>with</code> подвержена ошибкам и непрозрачна.</p><p>Проблемы возникают в том случае, когда в <code>with(obj)</code> присваивается переменная, которая по замыслу должна быть в свойствах <code>obj</code>, но ее там нет.</p><p>Например:</p><code-example><script>`var obj = {\n  weight: 10\n};\n\with(obj) {\n  weight = 20; // (1)\n  size = 35; // (2)\n}\n\nalert( obj.size );\nalert( window.size );`</script><code-toolbar></code-toolbar></code-example><p>В строке <code>(2)</code> присваивается свойство, отсутствующее в <code>obj</code>. В результате интерпретатор, не найдя его, создает новую глобальную переменную <code>window.size</code>.</p><p>Такие ошибки редки, но очень сложны в отладке, особенно если <code>size</code> изменилась не в <code>window</code>, а где-нибудь во внешнем <code>LexicalEnvironment</code>.</p></li><li><p>Еще одна причина – алгоритмы сжатия JavaScript не любят <code>with</code>. Перед выкладкой на сервер JavaScript сжимают. Для этого есть много инструментов, например <a href="http://code.google.com/intl/ru-RU/closure/compiler/">Closure Compiler</a> и <a href="https://github.com/mishoo/UglifyJS">UglifyJS</a>. Обычно они переименовывают локальные переменные в более короткие имена, но не свойства объектов. С конструкцией <code>with</code> до запуска кода непонятно – откуда будет взята переменная. Поэтому выходит, что, на всякий случай (если это свойство), лучше её не переименовывать. Таким образом, качество сжатия кода страдает.</p></li><li><p>Ну и, наконец, производительность – усложнение поиска переменной из-за <code>with</code> влечет дополнительные накладные расходы.</p><p>Современные движки применяют много внутренних оптимизаций, ряд которых не может быть применен к коду, в котором есть <code>with</code>.</p><p>Вот, к примеру, запустите этот код в современном браузере. Производительность функции <code>fast</code> существенно отличается <code>slow</code> с пустым(!) <code>with</code>. И дело тут именно в <code>with</code>, т.к. наличие этой конструкции препятствует оптимизации.</p><code-example><script>`var i = 0;\n\nfunction fast() {\n  i++;\n}\n\nfunction slow() {\n  with(i) {}\n  i++;\n}\n\nvar time = performance.now();\nwhile (i < 1000000) fast();\nalert( "Без with:&nbsp" + (performance.now() - time) );\n\nvar time = performance.now();\ni = 0;\nwhile (i < 1000000) slow();\nalert( "С with:&nbsp" + (performance.now() - time) );`</script><code-toolbar></code-toolbar></code-example></li></ol><h3><a name="6" href="#6">Замена with</a></h3><p>Вместо <code>with</code> рекомендуется использовать временную переменную, например:</p><code-example><script>`/* вместо\nwith(elem.style) {\n  top = '10px';\n  left = '20px';\n}\n*/\n\nvar s = elem.style;\n\ns.top = '10px';\ns.left = '0';`</script></code-example><p>Это не так элегантно, но убирает лишний уровень вложенности и абсолютно точно понятно, что будет происходить и куда присвоятся свойства.</p><h2><a name="3" href="#3">Итого</a></h2><ul><li>Конструкция <code>with(obj) { ... }</code> использует <code>obj</code> как дополнительную область видимости. Все переменные, к которым идет обращение внутри блока, сначала ищутся в <code>obj</code>.</li><li>Конструкция <code>with</code> устарела и не рекомендуется по ряду причин. Избегайте её.</li></ul><h2 id="tasks"><a href="#4" name="4">Задачи (2)</a></h2><task-content><h3><a href="#7" name="7">With + функция</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Какая из функций будет вызвана?</p><code-example><script>`function f() {\n  alert(1)\n}\n\nvar obj = {\n  f: function() {\n    alert(2)\n  }\n};\n\nwith(obj) {\n  f();\n}`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Вторая (<code>2</code>), т.к. при обращении к любой переменной внутри <code>with</code> – она ищется прежде всего в объекте.</p><p>Соответственно, будет выведено <code>2</code>:</p><code-example><script>`function f() {\n  alert(1)\n}\n\nvar obj = {\n  f: function() {\n    alert(2)\n  }\n};\n\nwith(obj) {\n  f();\n}`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><task-content><h3><a href="#8" name="8">With + переменные</a><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open><task-open hover-style="" data-show_task="" title="Открыть задачу"></task-open></h3><span title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span><p>Что выведет этот код?</p><code-example><script>`var a = 1;\n\nvar obj = {\n  b: 2\n};\n\nwith(obj) {\n  var b;\n  alert( a + b );\n}`</script></code-example><button-answer data-toggle_answer="" style="">решение</button-answer><task-answer><close- title="закрыть" data-close_answer=""></close-><p>Выведет <code>3</code>.</p><p><strong>Конструкция <code>with</code> не создаёт области видимости,</strong> её создают только функции. Поэтому объявление <code>var b</code> внутри конструкции работает также, как если бы оно было вне её.</p><p>Код в задаче эквивалентен такому:</p><code-example><script>`var a = 1;\nMARKvar b;\n\nvar obj = {\n  b: 2\n}\n\nwith(obj) {\n  alert( a + b );\n}`</script><code-toolbar></code-toolbar></code-example></task-answer></task-content><banner-bottom class="banner-bottom" style="display: block;"></banner-bottom><script>!function () { /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 1024 || "bannerBottomDisabled" in localStorage || (localStorage.bannerBottomShownCount || (localStorage.bannerBottomShownCount = 1), document.querySelector(".banner-bottom").style.display = "block") }();</script><nav-book data-tooltips="Управление памятью в JavaScript; Методы объектов и контекст вызова"></nav-book><share-map><share-></share-><map-button hover-style="" data-load_page="l"></map-button></share-map><comments- id="comments"></comments-><div id="disqus_thread"></div><script>disqus_url = "https:\/\/learn.javascript.ru\/with", disqus_identifier = "with", disqus_title = "\u0423\u0441\u0442\u0430\u0440\u0435\u0432\u0448\u0430\u044f \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u044f \"with\"";</script></page-content></main>